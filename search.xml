<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CS61B学习笔记(十五)-Rd12-哈希表</title>
      <link href="/2024/02/28/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-15-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd12-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2024/02/28/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-15-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd12-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="目前的问题"><a href="#目前的问题" class="headerlink" title="目前的问题"></a>目前的问题</h1><p>到目前为止，我们已经了解了一些数据结构，以便有效地搜索数据结构中是否存在项目。我们研究了二叉搜索树，然后使用 2-3 棵树使它们平衡。</p><p>然而，这些结构存在一些限制（是的，甚至是 2-3 棵树）</p><ol><li><p>他们要求项目具有可比性。您如何决定新项目在 BST 中的位置？你必须回答“你比根小还是大”的问题？对于某些对象来说，这个问题可能没有意义。</p></li><li><p>它们给出的复杂度为 <code>Θ(logN)</code> 。这个好吗？绝对地。但也许我们可以做得更好。</p></li></ol><h2 id="第一次尝试：-DataIndexedIntegerSet"><a href="#第一次尝试：-DataIndexedIntegerSet" class="headerlink" title="第一次尝试： DataIndexedIntegerSet"></a>第一次尝试： <code>DataIndexedIntegerSet</code></h2><p>目前，我们只尝试改进上面的问题#2（将复杂性从 <code>Θ(logN)</code> 提高到 <code>Θ(1)</code> 。我们不会担心问题#1（可比性）事实上，我们只会考虑存储和搜索 <code>int</code> 。</p><p>这里有一个想法：让我们创建一个类型为 <code>boolean</code> 且大小为 20 亿的 ArrayList。让一切默认为假。</p><ul><li><code>add(int x)</code> 方法只是将 ArrayList 中的 <code>x</code> 位置设置为 true。这需要 Θ(1)Θ(1) 时间。</li><li><code>contains(int x)</code> 方法只是返回 ArrayList 中的 <code>x</code> 位置是 <code>true</code> 还是 <code>false</code> 。这也需要 <code>Θ(1) </code>时间！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataIndexedIntegerSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] present;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataIndexedIntegerSet</span><span class="params">()</span> &#123;</span><br><span class="line">        present = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2000000000</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        present[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> present[i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/02/28/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-15-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd12-%E5%93%88%E5%B8%8C%E8%A1%A8/image-20240228174821879.png" alt="image-20240228174821879"></p><p>这种方法有哪些<strong>潜在问题</strong>？</p><ul><li>极其浪费。如果我们假设 <code>boolean</code> 需要 1 个字节来存储，则上面的每个 <code>new DataIndexedIntegerSet()</code> 需要 <code>2GB</code> 空间。此外，用户只能插入少量项目……</li><li>如果有人想插入 <code>String</code> 我们该怎么办？</li></ul><h1 id="解决单词插入问题"><a href="#解决单词插入问题" class="headerlink" title="解决单词插入问题"></a>解决单词插入问题</h1><p>我们的 <code>DataIndexedIntegerSet</code> 只允许使用整数，但现在我们想要将 <code>String</code> <code>&quot;cat&quot;</code> 插入其中。我们将可以插入字符串的数据结构称为 <code>DataIntexedEnglishWordSet</code> 这是一个疯狂的想法：让我们给每个字符串一个数字。也许“cat”可以是 <code>1</code> ，“dog”可以是 <code>2</code> ，“turtle”可以是 <code>3</code> 。</p><p>（这样做的方式是——如果有人想在我们的数据结构中添加一只“猫”，我们会“算出”“猫”的数字是 1，然后将 <code>present[1]</code> 设置为是 <code>true</code> 。如果有人想问我们“cat”是否在我们的数据结构中，我们会“找出”“cat”是 1，并检查 <code>present[1]</code> 是否为 true .)</p><p>但如果有人试图插入“potatocactus”这个词，我们就不知道该怎么办了。我们需要制定一个通用策略，以便给定一个字符串，我们可以找出它的数字表示形式。</p><h2 id="策略-1：使用第一个字母。"><a href="#策略-1：使用第一个字母。" class="headerlink" title="策略 1：使用第一个字母。"></a>策略 1：使用第一个字母。</h2><p>一个简单的想法是仅使用任何给定字符串的第一个字符将其转换为其数字表示形式。所以“cat”-&gt;“c”-&gt; 3。“Dog”-&gt;“d”-&gt; 4。而且，“drum”-&gt;“d”-&gt; 4。</p><p>如果有人想在我们的 <code>DataIntexedEnglishWordSet</code> 中插入“dog”和“drum”怎么办？所有的赌注都落空了，我们不知道该怎么做。</p><p>请注意，当两个不同的输入（“dog”和“drum”）映射到同一整数时，我们称之为<strong>碰撞</strong>。我们还不知道如何处理碰撞，所以让我们想办法避免它们。</p><h2 id="策略-2：避免碰撞"><a href="#策略-2：避免碰撞" class="headerlink" title="策略 2：避免碰撞"></a>策略 2：避免碰撞</h2><p>我们知道英语小写字母中有26个独特的字符，我们可以先将其编号：a &#x3D; 1, b &#x3D; 2, …, z &#x3D; 26，我们可以将单词每个字母进行加权。</p><ul><li><img src="/2024/02/28/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-15-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd12-%E5%93%88%E5%B8%8C%E8%A1%A8/image-20240228172338363.png" alt="image-20240228172338363"></li></ul><p><strong>这种表示形式为每个包含小写字母的英语单词提供了一个唯一的整数，就像使用基数 10 为每个数字提供了唯一的表示形式一样。我们保证不会发生碰撞。</strong></p><h2 id="我们的数据结构-DataIndexedEnglishWordSet"><a href="#我们的数据结构-DataIndexedEnglishWordSet" class="headerlink" title="我们的数据结构 DataIndexedEnglishWordSet"></a>我们的数据结构 <code>DataIndexedEnglishWordSet</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataIndexedEnglishWordSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] present;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataIndexedEnglishWordSet</span><span class="params">()</span> &#123;</span><br><span class="line">        present = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2000000000</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        present[englishToInt(s)] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        resent present[englishToInt(s)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用辅助方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">letterNum</span><span class="params">(String s, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">/** Converts ith character of String to a letter number.</span></span><br><span class="line"><span class="comment">    * e.g. &#x27;a&#x27; -&gt; 1, &#x27;b&#x27; -&gt; 2, &#x27;z&#x27; -&gt; 26 */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ithChar</span> <span class="operator">=</span> s.charAt(i)</span><br><span class="line">    <span class="keyword">if</span> ((ithChar &lt; <span class="string">&#x27;a&#x27;</span>) || (ithChar &gt; <span class="string">&#x27;z&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ithChar - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">englishToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">intRep</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0l</span> i &lt; s.length(); i += <span class="number">1</span>) &#123;</span><br><span class="line">        intRep = intRep * <span class="number">26</span>;</span><br><span class="line">        intRep += letterNum(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intRep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="目前进度"><a href="#目前进度" class="headerlink" title="目前进度"></a>目前进度</h2><ul><li>我们的方法仍然非常浪费内存。我们还没有解决这个问题！</li><li>只局限于整数和英语小写字母</li><li>比 Θ(log<em>N</em>) 更好。现在我们已经对整数和单个英语单词进行了此操作。</li><li>无法存储<code>2pac</code>这样的字符串</li></ul><h1 id="在单个英文单词之外插入-String"><a href="#在单个英文单词之外插入-String" class="headerlink" title="在单个英文单词之外插入 String"></a>在单个英文单词之外插入 <code>String</code></h1><p>有一种称为 ASCII 的字符格式，每个字符都有一个整数。在这里，我们看到最大值（即我们需要使用的基数&#x2F;乘数）是 126。让我们这样做。与 <code>DataIndexedEnglishWordSet</code> 相同，但只是使用基础 <code>126</code> 。</p><p><img src="/2024/02/28/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-15-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd12-%E5%93%88%E5%B8%8C%E8%A1%A8/image-20240228174935269.png" alt="image-20240228174935269"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static int asciiToInt(String s) &#123;</span><br><span class="line">    int intRep = 0;</span><br><span class="line">    for (int i = 0; i &lt; s.length(); i += 1) &#123;           </span><br><span class="line">        intRep = intRep * 126;</span><br><span class="line">        intRep = intRep + s.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return intRep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加对中文的支持怎么样？最大可能的表示形式是 40959，因此我们需要使用它作为基础。这是一个例子：</p><p><img src="/2024/02/28/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-15-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd12-%E5%93%88%E5%B8%8C%E8%A1%A8/image-20240228175013247.png" alt="image-20240228175013247"></p><p>所以…为了存储一个 3 个字符的中文单词，我们需要一个大小大于 39 万亿（带 T）的数组！这已经失控了……所以让我们探讨一下我们能做什么。</p><h1 id="处理整数溢出和哈希码"><a href="#处理整数溢出和哈希码" class="headerlink" title="处理整数溢出和哈希码"></a>处理整数溢出和哈希码</h1><p>Java 中整数的最大可能值为 2,147,483,647。最小值为-2,147,483,648。</p><p>如果你尝试取最大值并加 1，你会得到最小值！</p><p>因此，即使只使用 ASCII 字符（记住，以 126 为基数），我们也会遇到问题。</p><p>对于<em>omens</em><del>126</del>&#x3D;28,196,917,171 .<code>asciiToInt(omens)</code> 返回 <code>-1,867,853,901</code>.</p><p>由于溢出， <code>melt banana</code> 和 <code>subterresetrial anticosmetic</code> 实际上根据 <code>asciiToInt</code> 具有相同的表示。因此，如果我们添加 <code>melt banana</code> 然后尝试询问 <code>contains(subterrestrial anticosmetic)</code> ，我们会得到 <code>true</code> 。</p><h2 id="不可避免的事实。"><a href="#不可避免的事实。" class="headerlink" title="不可避免的事实。"></a>不可避免的事实。</h2><p>从最小到最大可能的整数，Java 中总共有 4,294,967,296 个整数。然而，Java 中可以创建的对象总数远不止于此，因此冲突是不可避免的。抵抗是徒劳的。我们必须弄清楚如何正面处理碰撞，而不是试图解决它。</p><blockquote><p>（如果您不相信在 Java 中可以创建超过 40 亿个对象，只需考虑一下：“一”、“二”、…、“五万亿”——每个都是一个唯一的字符串。 ）</p></blockquote><p><strong>我们必须处理碰撞。</strong></p><h2 id="哈希码"><a href="#哈希码" class="headerlink" title="哈希码"></a>哈希码</h2><p>在计算机科学中，获取一个对象并将其转换为某个整数称为“计算该对象的哈希码”。例如，“meltbanana”的哈希码是839099497。</p><blockquote><p><a href="https://mathworld.wolfram.com/HashFunction.html">哈希函数——来自 Wolfram MathWorld — Hash Function – from Wolfram MathWorld</a></p></blockquote><p>我们研究了如何计算字符串的哈希码。对于其他对象，我们执行以下两件事之一：</p><ul><li>Java中的每个对象都有一个默认的 <code>.hashcode()</code> 方法，我们可以使用它。 Java 通过计算 <code>Object</code> 在内存中的位置（计算机内存的每个部分都有一个地址！）来计算此值，并使用该内存地址执行类似于我们对 <code>String</code> s。该方法为每个 Java 对象提供唯一的哈希码。</li><li>有时，我们编写自己的 <code>hashcode</code> 方法。例如，给定一个 <code>Dog</code> ，我们可以使用它的 <code>name</code> 、 <code>age</code> 和 <code>breed</code> 的组合来生成 <code>hashcode</code></li></ul><h2 id="哈希码的属性"><a href="#哈希码的属性" class="headerlink" title="哈希码的属性"></a>哈希码的属性</h2><p>哈希码具有三个必要的属性，这意味着哈希码必须具有以下属性才能有效：</p><ol><li>它必须是一个整数</li><li>如果我们在一个对象上运行 <code>.hashCode()</code> 两次，它应该返回相同的数字</li><li>被视为 <code>.equal()</code> 的两个对象必须具有相同的哈希码。</li></ol><p>然而，并非所有哈希码都是一样的。如果你希望你的哈希码被认为是一个好的哈希码，它应该：</p><ol><li>均匀分配物品</li></ol><p><strong>请注意，此时，我们知道如何向数据结构添加任意对象，而不仅仅是字符串。</strong></p><h2 id="未决问题"><a href="#未决问题" class="headerlink" title="未决问题"></a>未决问题</h2><ul><li>空间：我们还没有弄清楚如何使用更少的空间。</li><li>处理碰撞：我们已经确定需要处理碰撞，但我们还没有真正处理它们。</li></ul><h1 id="处理碰撞"><a href="#处理碰撞" class="headerlink" title="处理碰撞"></a>处理碰撞</h1><p>最重要的想法是稍微改变我们的数组，使其不只包含项目，而是包含项目的 LinkedList（或任何其他列表）。所以…</p><p>数组中的所有内容原本都是空的。<br>如果我们得到一个新项目，它的哈希码是 $h$：</p><ul><li>如果索引 $h$ 目前没有任何内容，我们将为索引 $h$ 创建一个新的 <code>LinkedList</code> ，将其放置在那里，然后将新项目添加到新创建的 <code>LinkedList</code></li><li>如果索引 $h$ 处已经有一些东西，那么那里已经有一个 <code>LinkedList</code> 。我们只需将新项目添加到 <code>LinkedList</code> 中即可。<strong>注意：我们的数据结构不允许有任何重复的项&#x2F;键。因此，我们必须首先检查我们要插入的项是否已经在此 LinkedList 中。如果是的话，我们什么也不做！这也意味着我们将插入到链表的末尾，因为无论如何我们都需要检查所有元素。</strong></li></ul><h2 id="具体工作流程"><a href="#具体工作流程" class="headerlink" title="具体工作流程"></a>具体工作流程</h2><ul><li><p><code>add</code> 项目</p><ul><li><p>获取项目的哈希码（即索引）。</p></li><li><p>如果索引没有项目，则创建新列表，并将项目放置在那里。</p></li><li><p>如果索引已经有一个列表，请检查列表以查看项目是否已在其中。如果没有，请将项目添加到列表中。</p></li></ul></li><li><p><code>contains</code>项目</p><ul><li>获取项目的哈希码（即索引）。</li><li>如果索引为空，则返回 <code>false</code> 。</li><li>否则，检查列表中该索引处的所有项目，如果该项目存在，则返回 <code>true</code> 。</li></ul></li></ul><h2 id="运行时复杂性"><a href="#运行时复杂性" class="headerlink" title="运行时复杂性"></a>运行时复杂性</h2><p>由于我们需要通过哈希码（即索引）查看 LinkedList 中的所有项目。所以<code>contains</code>的复杂度是Θ(<em>Q</em>)</p><p>因为我们必须检查以确保该项目尚未位于链接列表中，所以<code>add</code>的复杂度是Θ(<em>Q</em>)</p><h2 id="解决空间"><a href="#解决空间" class="headerlink" title="解决空间"></a>解决空间</h2><p>让我们创建一个大小为 100 的 ArrayList。我们不要更改 <code>hashcode</code> 函数的行为方式（让它返回一个疯狂的大整数。）但是在获得 <code>hashcode</code> 后，我们将对其取模 100 以获得我们想要的 0…990…99 范围内的索引。</p><p><img src="/2024/02/28/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-15-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd12-%E5%93%88%E5%B8%8C%E8%A1%A8/image-20240228175450133.png" alt="image-20240228175450133"></p><h2 id="目前进度-1"><a href="#目前进度-1" class="headerlink" title="目前进度"></a>目前进度</h2><ul><li>空间：已解决。</li><li>处理碰撞：完成！</li><li>运行时复杂度？我们之前在 Θ(�)Θ(<em>Q</em>) 处为 <code>add</code> 和 <code>contains</code> 丢失了一些，然后在 <code>解决空间</code> 部分，我们意识到我们丢失了更多，因为我们的 LinkedList 可能会更大（因此 <code>Q</code> 会更大。）</li></ul><h1 id="我们最终的数据结构：-HashTable"><a href="#我们最终的数据结构：-HashTable" class="headerlink" title="我们最终的数据结构： HashTable"></a>我们最终的数据结构： <code>HashTable</code></h1><p>我们现在创建的称为 <code>HashTable</code> 。</p><ul><li>输入由哈希函数 ( <code>hashcode</code> ) 转换为整数。然后，使用模运算符将它们转换为有效索引。然后，它们被添加到该索引处（使用 LinkedList 处理冲突）。</li><li><code>contains</code> 通过找出有效索引并在相应的 LinkedList 中查找该项目以类似的方式工作。</li></ul><h2 id="处理运行时间"><a href="#处理运行时间" class="headerlink" title="处理运行时间"></a>处理运行时间</h2><p>唯一需要解决的问题是运行时间问题。如果我们有 100 个项目，并且 ArrayList 的大小为 5，那么</p><ul><li>在最好的情况下，所有项目都会均匀地发送到不同的索引。也就是说，我们有 5 个 linkedList，每个 linkedList 包含 20 个项目。</li><li>在最坏的情况下，所有项目都会发送到同一个索引！也就是说，我们只有 1 个 LinkedList，但它包含全部 100 个项目。</li></ul><p>有两种方法可以尝试解决此问题：</p><ul><li>动态增长我们的哈希表。</li><li>改进我们的哈希码</li></ul><h3 id="动态增长哈希表"><a href="#动态增长哈希表" class="headerlink" title="动态增长哈希表"></a>动态增长哈希表</h3><p>假设我们有 <em>M</em> 个桶（索引）和 <em>N</em> 个项。我们说我们的<strong>装载因子</strong>是 <em>N</em>&#x2F;<em>M</em>。</p><p>（注意，<strong>装载因子</strong>等同于我们上面的<strong>最佳</strong>情况运行时间。）</p><p>所以…我们有动机保持我们的装载因子低（毕竟，这是我们可能实现的最佳运行时间！）。</p><p>注意，如果我们保持 <em>M</em>（桶的数量）固定，而 <em>N</em> 不断增加，装载因子会不断增加。</p><p>策略？每隔一段时间，将 <em>M</em> 加倍。我们这样做的方式如下：</p><ul><li>创建一个具有 2<em>M</em> 个桶的新哈希表。</li><li>遍历旧哈希表中的所有项，逐个将它们添加到这个新哈希表中。<ul><li>我们需要再次逐个添加元素，因为由于数组的大小变化，模数也会变化，因此该项可能属于新哈希表中的不同桶而不是旧哈希表中的桶。</li></ul></li></ul><p>我们通过设置<strong>装载因子阈值</strong>来执行此操作。一旦装载因子大于此阈值，我们就会调整大小。</p><p>看一下下面的例子。”helmet” 的哈希码是 13。在第一个哈希表中，它被发送到桶 13%4&#x3D;1。在第二个哈希表中，它被发送到桶 13%8&#x3D;5。<strong>请注意，调整哈希表的大小也有助于打乱哈希表中的项</strong>！ </p><p><img src="/2024/02/28/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-15-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd12-%E5%93%88%E5%B8%8C%E8%A1%A8/image-20240228175534697.png" alt="image-20240228175534697"></p><p>在这一点上，<em>假设项目均匀分布</em>，所有列表大约都会是 <em>N</em>&#x2F;<em>M</em> 个项目长，导致 Θ(<em>N</em>&#x2F;<em>M</em>) 运行时间。请记住，<em>N</em>&#x2F;<em>M</em> 只允许在一个常数<strong>装载因子阈值</strong>下，因此， Θ(<em>N</em>&#x2F;<em>M</em>)&#x3D;Θ(1)。</p><p>还要注意，调整大小需要 Θ(<em>N</em>) 时间。为什么？因为我们需要将 <em>N</em> 个项目添加到哈希表中，并且每次添加都需要 Θ(1) 时间。</p><p>一个小细节：当进行调整大小时，我们实际上不需要检查项是否已经存在于链表中（因为我们知道没有重复项），因此我们可以确保将每个项都在 Θ(1) 时间内添加到链表的前面。（回想一下，通常情况下，我们必须搜索链表以确保项不在那里…但是当调整大小时，我们可以跳过该步骤。）</p><p>当然，我们需要重新审视假设项目均匀分布的假设。如果项目不均匀分布，我们的运行时间将是 Θ(<em>N</em>)，因为可能会存在一个大小为 <em>N</em> 的单个链表。</p><h3 id="假设物品均匀分布？"><a href="#假设物品均匀分布？" class="headerlink" title="假设物品均匀分布？"></a>假设物品均匀分布？</h3><p>如果我们有好的哈希码（即为不同项目提供相当随机的值的哈希码），项目将均匀分布。）一般来说，这样做是……嗯……很难。</p><p>一些通用的好的经验法则：</p><ul><li>使用与我们之前开发的策略类似的“基本”策略。</li><li>使用一个小质数的“基数”。<ul><li>Base 126 实际上并不是很好，因为使用 Base 126 意味着以相同的最后 32 个字符结尾的任何字符串都具有相同的哈希码。</li><li>发生这种情况是因为溢出。</li><li>使用素数有助于避免溢出问题（即由于溢出而导致的冲突）。</li><li>为什么是小素数？因为它更容易计算。</li></ul></li></ul><h1 id="哈希表的普及"><a href="#哈希表的普及" class="headerlink" title="哈希表的普及"></a>哈希表的普及</h1><p>哈希表是集合和映射的最流行实现。</p><ul><li>在实践中性能出色。 </li><li>不需要项可比较。 </li><li>实现通常相对简单。 </li><li>Python 字典实际上就是哈希表。</li></ul><p>在 Java 中，它们以 java.util.HashMap 和 java.util.HashSet 实现</p><ul><li>HashMap 如何知道如何计算每个对象的哈希码？ <ul><li>好消息是：不是“implements Hashable”。 </li><li>相反，在 Java 中，所有对象必须实现一个 .hashCode() 方法。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(十四)-Rd11-树</title>
      <link href="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
      <url>/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>Reading: <a href="https://joshhug.gitbooks.io/hug61b/content/chap11/">11. 平衡树 ·拥抱61B — 11. Balanced Trees · Hug61B (gitbooks.io)</a></p><p>当我们随机插入 BST 时，平均深度和高度预计为<code>Θ(*logN*)</code> .</p><p>但是，我们并不总是能够以随机顺序插入 BST。如果我们的数据是实时的呢？然后，我们将被迫按照数据到达我们的顺序进行插入。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209082942966.png" alt="image-20240209082942966"></p><p>下面我们将了解一棵始终保持平衡的树！</p><h1 id="B-trees-2-3-trees-2-3-4-trees"><a href="#B-trees-2-3-trees-2-3-4-trees" class="headerlink" title="B-trees &#x2F; 2-3 trees &#x2F; 2-3-4 trees"></a>B-trees &#x2F; 2-3 trees &#x2F; 2-3-4 trees</h1><p><a href="https://docs.google.com/presentation/d/1zhQDvbcDZ9RJgJl0bmqwFFlHP8ExbDFo36Q9ZWH9EgU/edit#slide=id.g4fe50d0bd7_0_381">cs61b 2019 lec17 ds3 2-3 trees, 2-3-4 trees - Google 幻灯片</a></p><p>BST 的问题在于我们总是插入叶节点。这就是导致高度增加的原因。</p><p>当我们开始插入节点时，我们可能会破坏平衡结构。所以，让我们想出一种方法，在添加新节点时保持树的平衡！</p><p><strong>疯狂的想法</strong>：我们永远不要添加叶子节点！当我们插入时，让我们只添加到当前的叶节点。这样，高度永远不会增加。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209074328974.png" alt="image-20240209074328974"></p><p>但是，您能看到这种插入方案的潜在问题吗？如果我们搜索 19，那么我们将向下遍历到包含它的节点，我们仍然必须像查看数组一样查看该节点才能到达 19 元素。这将导致 <em>N</em>  的运行时！</p><p><strong>解决方案</strong>：设置单个节点中元素数量的限制。比方说 4.如果我们需要在节点已经有 4 个元素的情况下向节点添加一个新元素，我们会将节点分成两半。通过向上凸起左中间的节点。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209074359730.png" alt="image-20240209074359730"></p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209074429994.png" alt="image-20240209074429994"></p><p>通过在中间拆分节点，我们保持了完美的平衡！这些树被称为 B 树或 2-3-4&#x2F;2-3 树。2-3-4 和 2-3 是指每个节点可以拥有的子节点数。因此，一棵 2-3-4 棵树可以有 2、3 或 4 个孩子，而一棵 2-3 棵树可以有 2 或 3 个孩子。这意味着当 2-3-4 棵树有 3 个节点时，它们会拆分节点，并且需要再添加一个节点。2-3 棵树在有 2 个节点后分裂，需要再添加一个。</p><h2 id="Insertion-Process-插入过程"><a href="#Insertion-Process-插入过程" class="headerlink" title="Insertion Process 插入过程"></a>Insertion Process 插入过程</h2><p>The process of adding a node to a 2-3-4 tree is:<br>将节点添加到 2-3-4 树的过程是：</p><ol><li>我们仍然总是插入到叶子节点中，所以拿你要插入的节点，用它沿着树向下遍历，根据要插入的节点是大于还是小于每个节点中的项目来左右移动。</li><li>将节点添加到叶节点后，如果新节点有 4 个节点，则弹出左侧中间的节点并相应地重新排列子节点。</li><li>如果这导致父节点有 4 个节点，则再次弹出左中间节点，相应地重新排列子节点。</li><li>重复此过程，直到父节点可以容纳或您到达根节点。</li></ol><h2 id="B树不变量"><a href="#B树不变量" class="headerlink" title="B树不变量"></a>B树不变量</h2><p>练习 11.3.1：按此顺序将 1-7 插入到 B 树中。树的高度是多少？我们可以改变插入的顺序，以便降低高度吗？这里有一个 <a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html/">很酷的 B 树可视化工具</a> 可能会有所帮助！</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209074745016.png" alt="image-20240209074745016"></p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209074805752.png" alt="image-20240209074805752"></p><blockquote><p>根据您插入节点的顺序，B 树的高度可能会发生变化。然而，这棵树将永远是浓密的。</p><p>高度为1的B-Tree需要先添加2-6，最后添加1和7实现。</p></blockquote><p>B 树具有以下有用的不变量：</p><ul><li>所有叶子与源的距离必须相同。</li><li>包含 <em>k</em> 项的非叶节点必须具有<em>k</em>+1 的子节点。</li></ul><p>同时，这些不变量导致树总是浓密的。</p><h2 id="B-Tree运行时分析"><a href="#B-Tree运行时分析" class="headerlink" title="B-Tree运行时分析"></a>B-Tree运行时分析</h2><p>在 B 树中搜索的最坏情况是，如果每个节点中都有最大数量的元素，我们必须一直遍历到底部。我们将用于 L 表示每个节点中的元素数量。这意味着需要探索节点（因为最大高度是 log<em>N</em> 由于灌木丛不变），并且在每个节点上，我们需要探索 <em>L</em>log<em>N</em> 元素。总的来说，我们需要运行 <em>L</em>log<em>N</em> 操作。但是，我们知道 <em>L</em> 是一个常数，因此我们的总运行时间是 O*(log*N) 。</p><h2 id="B-Tree-删除-（Extra）"><a href="#B-Tree-删除-（Extra）" class="headerlink" title="B-Tree 删除 （Extra）"></a>B-Tree 删除 （Extra）</h2><p>如果您好奇，请看 <a href="https://docs.google.com/presentation/d/1zhQDvbcDZ9RJgJl0bmqwFFlHP8ExbDFo36Q9ZWH9EgU/edit#slide=id.g508ece10b0_1_1305">these extra slides</a> 。我们不会在这里讨论它们。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>BST 有最佳情况高度 Θ(log<em>N</em>) 和最坏情况高度 Θ(<em>N</em>) 。</p><ul><li>大O与最坏的情况不是一回事！</li></ul><p>B 树是对二叉搜索树的修改，可避免 Θ(<em>N</em>) 最坏的情况。</p><ul><li>节点可以包含从1 到 <em>L</em>个 项目。</li><li>包含的工作原理几乎与普通 BST 完全相同。</li><li>通过向现有叶节点添加项目来添加工作。<ul><li>如果节点太满，它们就会分裂。</li></ul></li><li>由此产生的树具有完美的平衡。操作的运行时为: O*(log<em>N</em>) 。</li><li>没有讨论删除。如果您好奇，请参阅其他幻灯片。</li><li>没有讨论过拆分是如何工作的 <em>L</em>&gt;3 （参见其他类）。</li><li>B 树更复杂，但它们可以有效地处理任何插入顺序。</li></ul><blockquote><p>目前问题:</p><ul><li>分裂的实现过于复杂</li><li>删除的操作必须保证包含 <em>k</em> 项的非叶节点必须具有<em>k</em>+1 的子节点，因此删除会变得更加困难，可能需要添加额外的节点。</li></ul></blockquote><h1 id="旋转树"><a href="#旋转树" class="headerlink" title="旋转树"></a>旋转树</h1><p><a href="https://docs.google.com/presentation/d/1S27xlCPX0Up8WAHZPBqmbcrcKo4FNbyG6eTHamOxzgA/edit#slide=id.g7582c86fb_0984">cs61b 2020 lec18 ds4 balanced search trees - Google 幻灯片</a></p><p><a href="https://docs.google.com/presentation/d/1pfkQENfIBwiThGGFVO5xvlVp7XAUONI2BwBqYxib0A4/edit#slide=id.g465b5392c_00">rotation balancing demo - Google 幻灯片</a></p><h2 id="BST-结构"><a href="#BST-结构" class="headerlink" title="BST 结构"></a>BST 结构</h2><p>对于任何 BST，有多种方式可以构建它以保持 BST 不变性。在第 11.1 章中，我们讨论了如何以不同顺序插入元素将导致不同的 BST。以下 BST 都包含元素 1、2 和 3，但结构各异。</p><p>然而，插入并不是产生相同 BST 不同结构的唯一方法。我们可以通过一种称为<strong>旋转</strong>的过程改变已经放置节点的树。</p><h2 id="树的旋转"><a href="#树的旋转" class="headerlink" title="树的旋转"></a>树的旋转</h2><p>旋转的形式定义为：</p><ul><li><code>rotateLeft(G)</code>: 令 x 为 G 的右子节点。将 G 设为 x 的新左子节点。</li><li><code>rotateRight(G)</code>: 令 x 为 G 的左子节点。将 G 设为 x 的新右子节点。</li></ul><p>在接下来的几段文字中，我们将慢慢揭示这个过程。下面是对节点 G 进行左旋转时所发生的情况的图形描述。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209081017071.png" alt="image-20240209081017071"></p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209081034821.png" alt="image-20240209081034821"></p><p>G 的右子节点 P 与 G 合并，带着它的子节点一起。然后 P 将其左子节点传递给 G，并且 G 向左下移动成为 P 的左子节点。您可以看到树的结构以及级别数量发生了变化。我们也可以在非根节点上旋转。我们只需暂时断开节点与父节点的连接，旋转节点处的子树，然后重新连接新的根。</p><p>以下是 <code>rotateRight</code> 和 <code>rotateLeft</code> 的实现，由 <a href="https://algs4.cs.princeton.edu/33balanced/RedBlackBST.java.html">普林斯顿文档</a> 提供，为简单起见省略了一些代码行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">rotateRight</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    <span class="comment">// assert (h != null) &amp;&amp; isRed(h.left);</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> h.left;</span><br><span class="line">    h.left = x.right;</span><br><span class="line">    x.right = h;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make a right-leaning link lean to the left</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">rotateLeft</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    <span class="comment">// assert (h != null) &amp;&amp; isRed(h.right);</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> h.right;</span><br><span class="line">    h.right = x.left;</span><br><span class="line">    x.left = h;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过旋转，我们实际上可以完全平衡一棵树。在这些幻灯片中查看演示：<a href="https://docs.google.com/presentation/d/1pfkQENfIBwiThGGFVO5xvlVp7XAUONI2BwBqYxib0A4/edit#slide=id.g465b5392c_00">点击这里</a></p><p>在下一章中，我们将学习一种特定的树数据结构，通过使用旋转保持平衡。</p><h1 id="黑白树"><a href="#黑白树" class="headerlink" title="黑白树"></a>黑白树</h1><p><a href="https://docs.google.com/presentation/d/1S27xlCPX0Up8WAHZPBqmbcrcKo4FNbyG6eTHamOxzgA/edit#slide=id.g4694c9844_01030">cs61b 2020 lec18 ds4 balanced search trees - Google 幻灯片</a></p><p>在前一节中，我们说我们真的很喜欢 2-3 树，因为它们始终保持平衡，但我们也不喜欢它们，因为它们很难实现。但为什么不两者兼得呢？为什么不创建一棵使用 BST 实现的树，但在结构上与 2-3 树相同，因此保持平衡？（请注意，在本章中，我们将专注于 2-3 树，而不是 2-3-4 树）</p><h2 id="红黑树的介绍"><a href="#红黑树的介绍" class="headerlink" title="红黑树的介绍"></a>红黑树的介绍</h2><p>我们将通过查看 2-3 树来创建这棵树，并问自己我们可以进行什么样的修改来将其转换为 BST。</p><p>对于仅具有 2 个子节点（具有 2 个子节点的节点）的 2-3 树，我们已经有了一个 BST，因此我们不需要进行任何修改！</p><p>然而，当我们遇到 3 个节点时会发生什么呢？</p><p>我们可以创建一个“粘合”节点，该节点不包含任何信息，只用于显示其 2 个子节点实际上是一个节点的一部分。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209081406566.png" alt="image-20240209081406566"></p><p>然而，这是一个非常不优雅的解决方案，因为我们占用了更多的空间，并且代码会变得丑陋。因此，我们不使用粘合节点，而是使用粘合链接！</p><p>我们任意选择将左侧元素设为右侧元素的子节点。这导致了左倾树。我们通过将其标记为<strong>红色</strong>来显示链接为<strong>粘合链接</strong>。正常的链接是黑色的。由于这一点，我们将这些结构称为左倾红黑树（LLRB）。我们将在 61B 中使用左倾树。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209081418640.png" alt="image-20240209081418640"></p><p>左倾红黑树与 2-3 树具有一一对应的关系。每个 2-3 树都有与之关联的唯一 LLRB 红黑树。至于 2-3-4 树，它们与标准红黑树保持对应关系。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209081433983.png" alt="image-20240209081433983"></p><h2 id="LLRB-的属性"><a href="#LLRB-的属性" class="headerlink" title="LLRB 的属性"></a>LLRB 的属性</h2><p>LLRB(<strong>Left-Leaning Red Black Binary Search Tree</strong>)左倾黑白搜索树</p><p>以下是 LLRB 的属性：</p><ul><li>与 2-3 树具有一一对应的关系。</li><li>没有节点有 2 条红色链接。</li><li>没有红色右链接。</li><li>从根到叶的每条路径具有相同数量的黑色链接（因为 2-3 树到每个叶子的链接数相同）。</li><li>高度不超过相应 2-3 树的高度的 2 倍 + 1。</li></ul><blockquote><p>注意，当我们对应到2-3树的时候需要考虑2-3树的两个不变量:</p><ul><li>所有叶子与源的距离必须相同。</li><li>包含 <em>k</em> 项的非叶节点必须具有<em>k</em>+1 的子节点。</li></ul></blockquote><h2 id="LLRB-的插入"><a href="#LLRB-的插入" class="headerlink" title="LLRB 的插入"></a>LLRB 的插入</h2><p>我们可以通过向 2-3 树插入并使用上述方案转换来随时插入到 LLRB 树。但是，这与我们最初创建 LLRB 的目的相违背，即避免复杂的 2-3 树代码！相反，我们将像对待普通 BST 一样插入到 LLRB 中。然而，这可能会破坏它与 2-3 树的一一映射，因此我们将使用旋转将树调整回正确的结构。</p><p>在插入 LLRB 时，我们需要解决的不同任务如下。</p><p><strong>任务 1：插入颜色：</strong>因为在 2-3 树中，我们总是通过向叶节点添加来插入，所以我们添加的链接的颜色应始终为红色。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209081859814.png" alt="image-20240209081859814"></p><p><strong>任务 2：右侧插入：</strong> 回想一下，我们使用左倾红黑树，这意味着我们<strong>永远不能有右侧的红色链接</strong>。如果我们在右侧插入，我们将需要使用旋转来维护 LLRB 不变式。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209081919590.png" alt="image-20240209081919590"></p><p>但是，如果我们在右侧插入时有一个红色链接，且左子节点也是红色链接，则出于在任务 3 中将会更清楚的目的，我们将暂时允许它。</p><p><strong>任务 3：左侧双重插入：</strong> 如果存在 2 个连续的左链接，则我们有一个非法的 4 节点。首先，我们将旋转以创建在任务 2 中看到的相同树。然后，在这两种情况下，我们将翻转所有接触 S 的边的颜色。这相当于在 2-3 树中推动中间节点上升。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209081940480.png" alt="image-20240209081940480"></p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209082031744.png" alt="image-20240209082031744"></p><p>您可能需要经过一系列旋转才能完成转换。过程是：在 LLRB 树不满足与 2-3 树的一一对应或破坏 LLRB 不变式时，执行任务 1、2 或 3，具体取决于树的条件，直到您获得合法的 LLRB。</p><p><strong>任务4：分离临时的4节点</strong></p><p>如果存在具有两个红色子节点的任何节点，反转颜色。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209082102708.png" alt="image-20240209082102708"></p><p>以下是所有操作的摘要：</p><ul><li>插入时：使用红色链接。</li><li>如果存在右倾的“3 节点”，我们有一个左倾违例<ul><li>旋转适当的节点向左以修复。</li></ul></li><li>如果有两个连续的左链接，我们有一个不正确的 4 节点违例！<ul><li>旋转适当的节点向右以修复。</li></ul></li><li>如果存在具有两个红色子节点的任何节点，我们有一个临时的 4 节点。<ul><li>颜色翻转节点以模拟拆分操作。</li></ul></li></ul><h2 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h2><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209082331745.png" alt="image-20240209082331745"></p><p>由于左倾红黑树与 2-3 树具有一一对应的关系，并且始终保持在其 2-3 树的 2 倍高度之内，操作的运行时将花费<code> logN</code> 时间。</p><p>以下是插入 LLRB 的抽象代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">put</span><span class="params">(Node h, Key key, Value val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, val, RED); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(h.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)      &#123; h.left  = put(h.left,  key, val); &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123; h.right = put(h.right, key, val); &#125;</span><br><span class="line">    <span class="keyword">else</span>              &#123; h.val   = val;                    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left))      &#123; h = rotateLeft(h);  &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.left.left)) &#123; h = rotateRight(h); &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.right))     &#123; flipColors(h);      &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>二叉搜索树很简单，但易受不平衡的影响，导致糟糕的运行时。</li><li>2-3 树（B 树）是平衡的，但实现起来痛苦，而且相对较慢。</li><li>LLRB 的插入简单易行（但删除困难）。</li><li>通过与 2-3 树保持数学双射来工作。</li><li>Java 的 <a href="%5BTreeMap%5D(https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/999dbd4192d0f819cb5224f26e9e7fa75ca6f289/src/java.base/share/classes/java/util/TreeMap.java)">TreeMap</a> 是一棵红黑树（但不是左倾的）。</li><li>LLRB 与 2-3 树保持一致，标准红黑树与 2-3-4 树保持一致。</li><li>允许在任一侧使用粘合链接（请参阅<a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red-Black Tree</a>）。</li><li>实现更复杂，但速度明显更快。</li></ul><blockquote><p>删除过于复杂，暂不讨论</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B项目笔记(四)-Lab7-二叉查找树</title>
      <link href="/2024/02/07/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-4-CS61b%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab7-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
      <url>/2024/02/07/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-4-CS61b%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab7-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://sp21.datastructur.es/materials/lab/lab7/lab7">Lab 7: BSTMap | CS 61B Spring 2021 (datastructur.es)</a></p><p><img src="/2024/02/07/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-4-CS61b%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab7-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/image-20240207100309645.png" alt="image-20240207100309645"></p><p>创建一个 BSTMap 类，它使用 BST（二叉搜索树）作为其核心数据结构来实现 Map61B 接口。您必须在名为 <code>BSTMap.java</code> 的文件中执行此操作。您的实现需要实现 Map61B 中给出的所有方法，但 <code>remove</code> 、 <code>iterator</code> 和 <code>keySet</code> 除外。对于这些方法，您应该抛出一个 <code>UnsupportedOperationException</code> </p><p>在创建 <code>BSTMap</code> 类并实现 Map61B 的所有方法之前，您的代码不会编译。您可以一次实现一个方法，方法是编写所有必需方法的方法签名，但为实现抛出 <code>UnsupportedOperationExceptions</code> ，直到您真正开始编写它们。</p><p>您的 <code>BSTMap</code> 还应该添加一个附加方法 <code>printInOrder()</code> （Map61B 接口中未给出），该方法按 Key 递增的顺序打印出 BSTMap。我们不会测试此方法的结果，但您会发现这对测试您的实现很有帮助！</p><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ul><li>Lecture 16 <a href="https://docs.google.com/presentation/d/1Bl-PTBfa5sp1vM1l0OSMpK_0JFQ-MT6je4O26-9ffpg/edit#slide=id.g50738e5fde_0_0">slides</a>. 讲座 16 幻灯片。</li><li>BST 代码来自我们的课程资源页面的<a href="http://www-inst.eecs.berkeley.edu/~cs61b/fa14/book2/data-structures.pdf">Data Structures Into Java</a> 第 109 和 111 页。</li><li>来自我们<a href="https://algs4.cs.princeton.edu/32bst/BST.java.html">our optional textbook</a>.的 BST 代码。</li><li><code>ULLMap.java</code> （已提供），一个基于 Map61B 实现的工作<strong>无序链接列表。</strong></li></ul><h1 id="BSTMap"><a href="#BSTMap" class="headerlink" title="BSTMap"></a>BSTMap</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bstmap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSTMap</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt; <span class="keyword">implements</span> <span class="title class_">Map61B</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;             <span class="comment">// root of BST</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> K key;           <span class="comment">// sorted by key</span></span><br><span class="line">        <span class="keyword">private</span> V val;         <span class="comment">// associated data</span></span><br><span class="line">        <span class="keyword">private</span> Node left, right;  <span class="comment">// left and right subtrees</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> size;          <span class="comment">// number of nodes in subtree</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V val, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.size = size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes an empty symbol table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTMap</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        root.size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        clear(root);</span></span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private Node clear(Node node) &#123;</span></span><br><span class="line"><span class="comment">//        if (node == null) &#123;</span></span><br><span class="line"><span class="comment">//            return null;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if (node.left != null) &#123;</span></span><br><span class="line"><span class="comment">//            node.left = clear(node.left);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if (node.right != null) &#123;</span></span><br><span class="line"><span class="comment">//            node.right = clear(node.right);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return null;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to contains() is null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> conainsKey(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">conainsKey</span><span class="params">(Node n, K key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(n.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> conainsKey(n.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> conainsKey(n.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> V <span class="title function_">get</span><span class="params">(Node n, K key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to contains() is null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(n.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> get(n.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> get(n.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">(Node x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to contains() is null&quot;</span>);</span><br><span class="line">        root = put(root, key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">put</span><span class="params">(Node node, K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.right = put(node.right, key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.left = put(node.left, key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.val = value;</span><br><span class="line">        &#125;</span><br><span class="line">        node.size = <span class="number">1</span> + size(node.right) + size(node.left);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printInOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to contains() is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to contains() is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to contains() is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to contains() is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to contains() is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private class MapIterator implements Iterator&lt;K&gt; &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        /**</span></span><br><span class="line"><span class="comment">//         * Returns &#123;@code true&#125; if the iteration has more elements.</span></span><br><span class="line"><span class="comment">//         * (In other words, returns &#123;@code true&#125; if &#123;@link #next&#125; would</span></span><br><span class="line"><span class="comment">//         * return an element rather than throwing an exception.)</span></span><br><span class="line"><span class="comment">//         *</span></span><br><span class="line"><span class="comment">//         * @return &#123;@code true&#125; if the iteration has more elements</span></span><br><span class="line"><span class="comment">//         */</span></span><br><span class="line"><span class="comment">//        int size = size();</span></span><br><span class="line"><span class="comment">//        MapIterator() &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        @Override</span></span><br><span class="line"><span class="comment">//        public boolean hasNext() &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        /**</span></span><br><span class="line"><span class="comment">//         * Returns the next element in the iteration.</span></span><br><span class="line"><span class="comment">//         *</span></span><br><span class="line"><span class="comment">//         * @return the next element in the iteration</span></span><br><span class="line"><span class="comment">//         */</span></span><br><span class="line"><span class="comment">//        @Override</span></span><br><span class="line"><span class="comment">//        public K next() &#123;</span></span><br><span class="line"><span class="comment">//            return null;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="ULLMap"><a href="#ULLMap" class="headerlink" title="ULLMap"></a>ULLMap</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bstmap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** A data structure that uses a linked list to store pairs of keys and values.</span></span><br><span class="line"><span class="comment"> *  Any key must appear at most once in the dictionary, but values may appear multiple</span></span><br><span class="line"><span class="comment"> *  times. Key operations are get(key), put(key, value), and contains(key) methods. The value</span></span><br><span class="line"><span class="comment"> *  associated to a key is the value in the last call to put with that key. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ULLMap</span>&lt;K, V&gt;  <span class="keyword">implements</span> <span class="title class_">Map61B</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns the value corresponding to KEY or null if no such value exists. */</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">lookup</span> <span class="operator">=</span> list.get(key);</span><br><span class="line">        <span class="keyword">if</span> (lookup == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lookup.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes all of the mappings from this map. */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        list = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts the key-value pair of KEY and VALUE into this dictionary,</span></span><br><span class="line"><span class="comment">     *  replacing the previous value associated to KEY, if any. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Entry</span> <span class="variable">lookup</span> <span class="operator">=</span> list.get(key);</span><br><span class="line">            <span class="keyword">if</span> (lookup == <span class="literal">null</span>) &#123;</span><br><span class="line">                list = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, val, list);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lookup.val = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, val, list);</span><br><span class="line">            size = size + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns true if and only if this dictionary contains KEY as the</span></span><br><span class="line"><span class="comment">     *  key of some key-value pair. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(key) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ULLMapIter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Keys and values are stored in a linked list of Entry objects.</span></span><br><span class="line"><span class="comment">     *  This variable stores the first pair in this linked list. */</span></span><br><span class="line">    <span class="keyword">private</span> Entry list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Represents one node in the linked list that stores the key-value pairs</span></span><br><span class="line"><span class="comment">     *  in the dictionary. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Stores KEY as the key in this key-value pair, VAL as the value, and</span></span><br><span class="line"><span class="comment">         *  NEXT as the next node in the linked list. */</span></span><br><span class="line">        Entry(K k, V v, Entry n) &#123;</span><br><span class="line">            key = k;</span><br><span class="line">            val = v;</span><br><span class="line">            next = n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Returns the Entry in this linked list of key-value pairs whose key</span></span><br><span class="line"><span class="comment">         *  is equal to KEY, or null if no such Entry exists. */</span></span><br><span class="line">        Entry <span class="title function_">get</span><span class="params">(K k)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k != <span class="literal">null</span> &amp;&amp; k.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> next.get(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Stores the key of the key-value pair of this node in the list. */</span></span><br><span class="line">        K key;</span><br><span class="line">        <span class="comment">/** Stores the value of the key-value pair of this node in the list. */</span></span><br><span class="line">        V val;</span><br><span class="line">        <span class="comment">/** Stores the next Entry in the linked list. */</span></span><br><span class="line">        Entry next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** An iterator that iterates over the keys of the dictionary. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ULLMapIter</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;K&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Create a new ULLMapIter by setting cur to the first node in the</span></span><br><span class="line"><span class="comment">         *  linked list that stores the key-value pairs. */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ULLMapIter</span><span class="params">()</span> &#123;</span><br><span class="line">            cur = list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cur != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> K <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">ret</span> <span class="operator">=</span> cur.key;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Stores the current key-value pair. */</span></span><br><span class="line">        <span class="keyword">private</span> Entry cur;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Map61B接口"><a href="#Map61B接口" class="headerlink" title="Map61B接口"></a>Map61B接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bstmap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Your implementation BSTMap should implement this interface. To do so,</span></span><br><span class="line"><span class="comment"> * append &quot;implements Map61B&lt;K,V&gt;&quot; to the end of your &quot;public class...&quot;</span></span><br><span class="line"><span class="comment"> * declaration, though you can use other formal type parameters if you&#x27;d like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map61B</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;K&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes all of the mappings from this map. */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns true if this map contains a mapping for the specified key. */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(K key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns the value to which the specified key is mapped, or null if this</span></span><br><span class="line"><span class="comment">     * map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(K key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns the number of key-value mappings in this map. */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Associates the specified value with the specified key in this map. */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns a Set view of the keys contained in this map. Not required for Lab 7.</span></span><br><span class="line"><span class="comment">     * If you don&#x27;t implement this, throw an UnsupportedOperationException. */</span></span><br><span class="line">    Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Removes the mapping for the specified key from this map if present.</span></span><br><span class="line"><span class="comment">     * Not required for Lab 7. If you don&#x27;t implement this, throw an</span></span><br><span class="line"><span class="comment">     * UnsupportedOperationException. */</span></span><br><span class="line">    V <span class="title function_">remove</span><span class="params">(K key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Removes the entry for the specified key only if it is currently mapped to</span></span><br><span class="line"><span class="comment">     * the specified value. Not required for Lab 7. If you don&#x27;t implement this,</span></span><br><span class="line"><span class="comment">     * throw an UnsupportedOperationException.*/</span></span><br><span class="line">    V <span class="title function_">remove</span><span class="params">(K key, V value)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(十三)-Rd10-ADP、树</title>
      <link href="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/"/>
      <url>/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>Slides:<a href="https://docs.google.com/presentation/d/1Bl-PTBfa5sp1vM1l0OSMpK_0JFQ-MT6je4O26-9ffpg/edit#slide=id.g50738e5fde_0_6">cs61b 2020 lec16 ds2 adts, sets, maps, binary search trees - Google 幻灯片</a></p><p>Reading:<a href="https://joshhug.gitbooks.io/hug61b/content/chap10/chap102.html">10.2 Trees · Hug61B (gitbooks.io)</a></p><h1 id="ADTs"><a href="#ADTs" class="headerlink" title="ADTs"></a>ADTs</h1><iframe frameborder="0" allowfullscreen src="https://www.youtube.com/embed/aFOSePlOExw" style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; font-size: inherit; border: none; top: 0px; left: 0px; width: 770px; height: 458.125px;"></iframe><p>抽象数据类型（ADT）仅通过其操作进行定义，而不是通过其实现。</p><blockquote><p>这意味着ADT定义了一组操作或行为，而不涉及具体的实现细节。</p></blockquote><p>例如，在proj1a中，我们开发了一个<code>ArrayDeque</code>和一个<code>LinkedListDeque</code>，它们具有<strong>相同的方法</strong>，但这些方法的编写方式非常不同。在这种情况下，我们说<code>ArrayDeque</code>和<code>LinkedListDeque</code>是Deque ADT的<em>实现</em>。从这个描述中，我们可以看出ADT和接口在某种程度上是相关的。</p><blockquote><p>ADT强调的是数据和操作的抽象描述，而接口强调的是行为和操作的规范定义。</p></blockquote><p>在概念上，Deque是一个接口，<code>ArrayDeque</code>和<code>LinkedListDeque</code>是其实现。在代码中，为了表达这种关系，我们让<code>ArrayDeque</code>和<code>LinkedListDeque</code>类从Deque接口继承。</p><p>一些常用的ADT包括：</p><ul><li><p>栈(Stack)：支持后进先出检索元素的结构</p><ul><li><code>push(int x)</code>: 将x放在栈顶</li><li><code>int pop()</code>: 取出栈顶元素</li></ul></li><li><p>列表(List)</p><p>: 一组有序的元素</p><ul><li><code>add(int i)</code>: 添加一个元素</li><li><code>int get(int i)</code>: 获取索引为i的元素</li></ul></li><li><p>集合(Set)</p><p>: 一组无序的唯一元素（不重复）</p><ul><li><code>add(int i)</code>: 添加一个元素</li><li><code>contains(int i)</code>: 返回集合中是否包含该值的布尔值</li></ul></li><li><p>映射(Map)</p><p>: 一组键&#x2F;值对</p><ul><li><code>put(K key, V value)</code>: 将一个键值对放入映射</li><li><code>V get(K key)</code>: 获取与键对应的值</li></ul></li></ul><p><strong>加粗的ADT是一个名为<code>Collections</code>的更大的总体接口的子接口</strong></p><p>下面我们展示接口和类之间的关系。接口为白色，类为蓝色。</p><p>ADT使我们能够以高效而优雅的方式利用面向对象编程。您在proj1b中看到了我们如何交换<code>OffByOne</code>和<code>OffByN</code>比较器，因为它们都实现了相同的接口！同样，您可以交替使用ArrayDeque或LinkedListArrayDeque，因为它们都是Deque ADT的一部分。</p><p>在接下来的章节中，我们将致力于定义一些更多的ADT并列举它们的不同实现。</p><h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>现在我们要学习可能是有史以来最重要的数据结构之一。</p><iframe width="475" height="292" src="https://www.youtube.com/embed/AcRKQOe0zYg" title="[ADTs, Sets, Maps, BSTs, Video 2] - Inventing the BST" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>链表很棒，但是查找项需要很长时间，即使列表是排序的！如果项目在列表的末尾怎么办？那将花费线性时间！看一下下面的链表，并让自己相信这是真的。</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095104937.png" alt="image-20240207095104937"></p><blockquote><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095200910.png" alt="image-20240207095200910"></p><p><a href="https://en.wikipedia.org/wiki/Skip_list">跳过列表 - 维基百科 — Skip list - Wikipedia</a></p></blockquote><p>我们知道，对于数组，我们可以使用二分查找来更快地找到元素。具体地说，时间复杂度是<code>log(*n*)</code>。关于二分查找的简短解释，请查看此<a href="https://www.geeksforgeeks.org/binary-search/">链接</a>。</p><p>TL;DR：在二分查找中，我们知道列表是排序的，因此我们可以利用这一信息来缩小搜索范围。首先，我们查看中间元素。如果它大于我们要查找的元素，则向左查找。如果它小于我们要查找的元素，则向右查找。然后，我们查看各自一半的中间元素，并重复此过程，直到找到我们要查找的元素（或因为列表不包含它而找不到）。</p><p>但是，我们如何在链表中运行二分查找呢？我们需要遍历到中间位置才能检查那里的元素，这本身就需要线性时间！</p><p>我们可以实现一种优化，即具有对中间节点的引用。这样，我们可以在常数时间内到达中间位置。然后，如果我们翻转节点的指针，这样就可以遍历到左右两半，从而将运行时间减半！</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095039828.png" alt="image-20240207095039828"></p><p>但是，我们可以做得更好。我们可以通过像下面这样在每个递归半部分的中间添加指针来进一步优化。</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095020256.png" alt="image-20240207095020256"></p><p>现在，如果你垂直拉伸这个结构，你会看到一棵树！</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095026028.png" alt="image-20240207095026028"></p><p>这棵具体的树称为<strong>二叉树</strong>，因为每个交叉点分为两个。</p><h3 id="树的属性"><a href="#树的属性" class="headerlink" title="树的属性"></a>树的属性</h3><p>让我们更加正式地定义树数据结构。</p><iframe width="770" height="458" src="https://www.youtube.com/embed/slOxliXDV-s" title="[ADTs, Sets, Maps, BSTs, Video 3] - BST Definitions" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>树由以下组成：</p><ul><li>节点</li><li>将这些节点连接起来的边。<ul><li><strong>约束</strong>：任何两个节点之间只有一条路径。</li></ul></li></ul><p>在某些树中，我们选择一个<strong>根</strong>节点，这是一个没有父节点的节点。</p><p>树还有<strong>叶子节点</strong>，它们是没有子节点的节点。</p><p>下面的结构是有效的树：<img src="https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-02-28%20at%209.25.43%20AM.png" alt="img"></p><p><strong>练习 10.2.1：</strong>你能想出一个非有效的树的例子吗？</p><p>将这与我们之前提出的原始树结构联系起来，我们现在可以对已有的约束引入新的约束。这创建了更具体的树类型，其中两个示例是二叉树和二叉搜索树。</p><ul><li><strong>二叉树</strong>：除了上述要求外，还满足二进制属性约束。即每个节点只有0、1或2个子节点。</li><li><strong>二叉搜索树</strong>：除了所有上述要求外，还具有以下属性：对于树中的每个节点X：<ul><li>左子树中的每个键都小于X的键。</li><li>右子树中的每个键都大于X的键。<strong>记住这个属性！！</strong>我们在本模块和61B的整个持续时间中将引用它很多次。</li></ul></li></ul><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095307884.png" alt="image-20240207095307884"></p><blockquote><p>满足对称性和传递性</p></blockquote><p>这是我们在本模块中将使用的BST类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">BST</span>&lt;Key&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Key key;</span><br><span class="line">    <span class="keyword">private</span> BST left;</span><br><span class="line">    <span class="keyword">private</span> BST right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BST</span><span class="params">(Key key, BST left, BST Right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BST</span><span class="params">(Key key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树操作"><a href="#二叉搜索树操作" class="headerlink" title="二叉搜索树操作"></a>二叉搜索树操作</h2><iframe width="770" height="458" src="https://www.youtube.com/embed/PLyDf3_J7Cc" title="[ADTs, Sets, Maps, BSTs, Video 4] - BST Search" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>要搜索某个元素，我们使用二分查找，这在很大程度上是由于前一节中描述的BST属性的便利！</p><p>我们知道BST被构造得使得节点的右侧所有元素都大于节点，并且左侧所有元素都小于节点。基于此，我们可以从根节点开始，将其与我们正在查找的元素X进行比较。如果X大于根，则我们转向根的右子节点。如果X小于根，则我们转向根的左子节点。我们递归地重复这个过程，直到我们找到项目或者我们到达一个叶子节点，在这种情况下，树不包含该项目。</p><p><strong>练习 10.2.2：</strong>尝试自己编写此方法。这是方法头：<code>static BST find(BST T, Key key)</code>。它应返回以与键参数匹配的键根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> BST <span class="title function_">find</span><span class="params">(BST T, Key sk)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (T == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (sk.equals(T.key))</span><br><span class="line">      <span class="keyword">return</span> T;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (sk ≺ T.key)</span><br><span class="line">      <span class="keyword">return</span> find(T.left, sk);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> find(T.right, sk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们的树相对“茂密”，那么find操作将在log(�)log(<em>n</em>)时间内运行，因为树的高度是logn，这相当快！</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><iframe width="770" height="458" src="https://www.youtube.com/embed/otDvoMb8UqE" title="[ADTs, Sets, Maps, BSTs, Video 5] - BST Insert" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>我们<strong>总是</strong>在叶子节点插入！</p><p>首先，我们在树中搜索节点。如果我们找到它，则不做任何操作。如果我们找不到它，则我们已经在叶子节点上。此时，我们只需将新元素添加到叶子的左侧或右侧，保持BST属性不变。</p><p><strong>练习 10.2.3：</strong>尝试自己编写此方法。这是方法头：<code>static BST insert(BST T, Key ik)</code>。它应返回插入了正确位置的新节点的完整BST。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BST <span class="title function_">insert</span><span class="params">(BST T, Key ik)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (T == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BST</span>(ik);</span><br><span class="line">  <span class="keyword">if</span> (ik ≺ T.key)</span><br><span class="line">    T.left = insert(T.left, ik);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ik ≻ T.key)</span><br><span class="line">    T.right = insert(T.right, ik);</span><br><span class="line">  <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习 10.2.4：</strong>想出一种插入顺序，会导致树的高度不同。尝试找到树高度的两种极端情况。提示：您的第一个插入将决定随后插入的行为。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><iframe width="770" height="458" src="https://www.youtube.com/embed/vPzB6svl4rc" title="[ADTs, Sets, Maps, BSTs, Video 6] - BST Deletion" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>从二叉树中删除节点稍微复杂一些，因为每当我们删除时，我们都需要确保重构树并仍然保持其BST属性。</p><p>让我们将此问题分为三个类别：</p><ul><li>我们尝试删除的节点没有子节点</li><li>有一个子节点</li><li>有两个子节点</li></ul><h4 id="没有子节点"><a href="#没有子节点" class="headerlink" title="没有子节点"></a>没有子节点</h4><p>如果节点没有子节点，则它是一个叶子，我们可以只删除其父节点指针，节点最终会被<a href="https://stackoverflow.com/questions/3798424/what-is-the-garbage-collector-in-java">垃圾回收器</a>清除。</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095555283.png" alt="image-20240207095555283"></p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095604465.png" alt="image-20240207095604465"></p><h4 id="一个子节点"><a href="#一个子节点" class="headerlink" title="一个子节点"></a>一个子节点</h4><p>如果节点只有一个子节点，我们知道该子节点与节点的父节点保持BST属性，因为该属性对右和左子树是递归的。因此，我们只需重新分配父节点的子节点指针到节点的子节点，节点最终将被垃圾回收。</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095614371.png" alt="image-20240207095614371"></p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095632829.png" alt="image-20240207095632829"></p><h4 id="两个子节点"><a href="#两个子节点" class="headerlink" title="两个子节点"></a>两个子节点</h4><p>如果节点有两个子节点，则该过程变得稍微复杂，因为我们不能简单地将一个子节点指定为新根。这可能会破坏BST属性。</p><p>相反，我们选择一个新节点来替换删除的节点。</p><p>我们知道新节点必须：</p><ul><li>大于左子树中的所有内容。</li><li>小于右子树中的所有内容。</li></ul><p>在下面的树中，我们展示了哪些节点将满足这些要求，假设我们要删除<code>dog</code>节点。</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095730453.png" alt="image-20240207095730453"></p><p>要找到这些节点，您可以选择左子树中的最右节点或右子树中的最左节点。</p><p>然后，我们用<code>cat</code>或<code>elf</code>替换<code>dog</code>节点，然后删除旧的<code>cat</code>或<code>elf</code>节点。</p><p>这称为<strong>Hibbard删除</strong>，在删除中保持了BST属性。</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095803817.png" alt="image-20240207095803817"></p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095812382.png" alt="image-20240207095812382"></p><blockquote><p>若将树重新拉直，k左右两边将会是g和m，我们只需要将其中一个替换掉k，那么就能实现删除的同时保持树的特性！</p></blockquote><h2 id="作为集合和映射的BST"><a href="#作为集合和映射的BST" class="headerlink" title="作为集合和映射的BST"></a>作为集合和映射的BST</h2><iframe width="770" height="458" src="https://www.youtube.com/embed/sL2p1slgUMg" title="[ADTs, Sets, Maps, BSTs, Video 7] - Sets vs Maps, Summary, Tips for Lab" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>我们可以使用BST来实现<code>Set</code> ADT！但是它更好，因为在<code>ArraySet</code>中，我们需要在最坏的情况下<code>O*(*n*)</code>时间来运行<code>contains</code>，因为我们需要搜索整个集合。但是，如果我们使用BST，我们可以将此运行时间减少到log(<em>n</em>)&#96;，因为BST属性使我们能够使用二分查找！</p><p>我们还可以通过使每个BST节点保存<code>(key,value)</code>对而不是单个值来将二叉树转换为映射。我们将比较每个元素的键以确定在树中的位置。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>抽象数据类型（ADTs）是根据操作而不是实现来定义的。</p><p>几种有用的ADT：</p><ul><li>不相交集、映射、集合、列表。</li><li>Java提供了映射、集合、列表接口，以及几种实现。</li></ul><p>我们已经看到了实现Set（或Map）的两种方法：</p><ul><li>ArraySet：在最坏的情况下，需要<code>Θ(*N*)</code>的操作。</li><li>BST：如果树是平衡的，则需要Θ(log<em>N</em>)&#96;的操作。</li></ul><p>BST实现：</p><ul><li>搜索和插入都很简单（但插入有点棘手）。</li><li>删除更具挑战性。典型的方法是“Hibbard删除”。</li></ul><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095946155.png" alt="image-20240207095946155"></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(十二)-Rd8.9-不相交集</title>
      <link href="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/"/>
      <url>/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>slide:<a href="https://docs.google.com/presentation/d/1I9Jzt95GvxRqwGMzN7DSEIREKhMZ0qEUzPyWLl6CU5g/edit#slide=id.g5347e2c8f_210">cs61b 2020 lec14 ds1 disjoint sets - Google 幻灯片</a></p><p>Reading:<a href="https://joshhug.gitbooks.io/hug61b/content/chap9/chap91.html">9.1 Introduction · Hug61B (gitbooks.io)</a></p><p>code:<a href="https://algs4.cs.princeton.edu/15uf/">Case Study: Union-Find (princeton.edu)</a></p><h1 id="Disjoint-Sets简介"><a href="#Disjoint-Sets简介" class="headerlink" title="Disjoint Sets简介"></a>Disjoint Sets简介</h1><p>如果两个集合没有共同元素，则称它们为<em>不相交集合</em>。一个不相交集合（或者称为并查集）数据结构用于追踪固定数量的元素，这些元素被划分为多个<em>不相交集合</em>。该数据结构具有两个操作：</p><ol><li><code>connect(x, y)</code>: 连接 <code>x</code> 和 <code>y</code>。也称为 <code>union</code>。</li><li><code>isConnected(x, y)</code>: 如果 <code>x</code> 和 <code>y</code> 连接（即属于同一集合），则返回true。</li></ol><p>不相交集合数据结构有一定数量的元素，每个元素最初都位于自己的子集中。通过对某些元素 <code>x</code> 和 <code>y</code> 调用 <code>connect(x, y)</code>，我们可以将子集合并在一起。</p><p>例如，假设我们有四个元素，我们将它们称为 A、B、C、D。初始时，每个元素都在自己的集合中：</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/intro1_resized.png" alt="img"></p><p>调用 <code>connect(A, B)</code> 后：</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/intro2_resized.png" alt="img"></p><p>请注意，子集 A 和 B 被合并。让我们来检查一些 <code>isConnected</code> 调用的输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CodeisConnected(A, B) -&gt; <span class="literal">true</span></span><br><span class="line"><span class="title function_">isConnected</span><span class="params">(A, C)</span> -&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>调用 <code>connect(A, D)</code> 后：</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/intro3_resized.png" alt="img"></p><p>我们找到了 A 所属的集合，并将其与 D 所属的集合合并，形成了一个大的 A、B、D 集合。C 保持不变。 <code>isConnected(A, D) -&gt; true</code> <code>isConnected(A, C) -&gt; false</code></p><p>有了这个直观理解，让我们正式定义一下我们的不相交集合接口是什么样子的。作为提醒，一个 <strong>接口</strong> 确定了一个数据结构应该具有的行为（但不包括实现方法）。现在，我们只处理非负整数集合。这并不是一个限制，因为在实际应用中，我们可以为我们想要表示的任何内容分配整数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line">    <span class="comment">/** 连接两个项目 P 和 Q */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 检查两个项目是否连接 */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了学习如何实现一个迷人的数据结构之外，这一章还将是一个了解数据结构实现如何演变的机会。我们将讨论四个不相交集合设计的迭代过程：<em>Quick Find → Quick Union → Weighted Quick Union (WQU) → WQU with Path Compression</em>。<strong>我们将看到设计决策如何极大地影响渐近运行时间和代码复杂度。</strong></p><h1 id="快速查找Quick-Find"><a href="#快速查找Quick-Find" class="headerlink" title="快速查找Quick Find"></a>快速查找Quick Find</h1><iframe width="770" height="458" src="https://www.youtube.com/embed/W6Dckcv8PIo" title="[Disjoint Sets, Video 2] - Quick Find" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>现在我们来解决如何实现我们的 <code>DisjointSets</code> 接口所需的行为。我们的挑战是跟踪集合成员关系。</p><h2 id="集合列表"><a href="#集合列表" class="headerlink" title="集合列表"></a>集合列表</h2><p>直观地，我们可能首先考虑将不相交集合表示为一个集合列表，例如 <code>List&lt;Set&lt;Integer&gt;&gt;</code>。</p><p>例如，如果我们有 N&#x3D;6 个元素，并且还没有连接任何元素，我们的集合列表看起来像：<code>[&#123;0&#125;, &#123;1&#125;, &#123;2&#125;, &#123;3&#125;, &#123;4&#125;, &#123;5&#125;, &#123;6&#125;]</code>。看起来不错。然而，考虑如何完成像 <code>connect(5, 6)</code> 这样的操作。我们将不得不遍历多达 <code>N</code> 个集合来找到5，以及多达 <code>N</code> 个集合来找到6。我们的运行时间变为 <code>O(N)</code>。而且，如果你试图实现这个，代码会非常复杂。</p><blockquote><p>要记住的教训是 <strong>初始设计决策决定了我们的代码复杂度和运行时间。</strong></p></blockquote><h2 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a>快速查找</h2><p>让我们考虑另一种方法，使用一个 <em>整数数组</em>。</p><ul><li>数组的<strong>索引</strong>表示我们集合的元素。</li><li>索引处的<strong>值</strong>是它所属的集合编号。</li></ul><p>例如，我们将 <code>&#123;0, 1, 2, 4&#125;, &#123;3, 5&#125;, &#123;6&#125;</code> 表示为：</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/9.2.1-1707267489271-11.png" alt="img"></p><p>数组索引（0…6）是元素。<code>id[i]</code> 处的值是它所属的集合。<em>具体的集合编号并不重要，只要同一集合中的所有元素共享相同的id。</em></p><h3 id="connect-x-y"><a href="#connect-x-y" class="headerlink" title="connect(x, y)"></a><code>connect(x, y)</code></h3><p>让我们看看连接操作如何工作。当前，<code>id[2] = 4</code> 和 <code>id[3] = 5</code>。调用 <code>connect(2, 3)</code> 后，所有id为4和5的元素应该具有相同的id。现在暂时将它们全部赋值为5：</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/9.2.2-1707267498002-14.png" alt="img"></p><h3 id="isConnected-x-y"><a href="#isConnected-x-y" class="headerlink" title="isConnected(x, y)"></a><code>isConnected(x, y)</code></h3><p>要检查 <code>isConnected(x, y)</code>，我们只需检查 <code>id[x] == id[y]</code>。请注意，这是一个常数时间操作！</p><p>我们将此实现称为 “快速查找”，因为查找元素是否相连需要常数时间。</p><h3 id="总结和代码"><a href="#总结和代码" class="headerlink" title="总结和代码"></a>总结和代码</h3><table><thead><tr><th>实现方式</th><th>构造函数</th><th><code>connect</code></th><th><code>isConnected</code></th></tr></thead><tbody><tr><td>集合列表</td><td>Θ(N)[1]</td><td>O(N)</td><td>O(N)</td></tr><tr><td>快速查找</td><td>Θ(N)</td><td>Θ(N)</td><td>Θ(1)</td></tr></tbody></table><p>N &#x3D; 不相交集合数据结构中的元素数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickFindDS</span> <span class="keyword">implements</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Θ(N) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuickFindDS</span><span class="params">(<span class="type">int</span> N)</span>&#123;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 需要遍历数组 =&gt; Θ(N) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> id[p];</span><br><span class="line">        <span class="type">int</span> <span class="variable">qid</span> <span class="operator">=</span> id[q];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; id.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (id[i] == pid)&#123;</span><br><span class="line">                id[i] = qid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Θ(1) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (id[p] == id[q]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速合并Quick-Union"><a href="#快速合并Quick-Union" class="headerlink" title="快速合并Quick Union"></a>快速合并Quick Union</h1><iframe width="770" height="458" src="https://www.youtube.com/embed/RY7UCusguGg" title="[Disjoint Sets, Video 3] - Quick Union" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>假设我们优先考虑使 <code>connect</code> 操作快速。我们仍然将使用数组来表示我们的集合。但是，与其使用一个id，我们将每个项目分配给其父项的索引。如果一个项目没有父项，那么它就是一个 ‘根’，我们为其分配一个负值。</p><p>这种方法使我们可以将我们的每个集合想象成一棵树。例如，我们将 <code>&#123;0, 1, 2, 4&#125;, &#123;3, 5&#125;, &#123;6&#125;</code> 表示为：</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/9.3.1-1707267897651-23.png" alt="img"></p><p>请注意，我们使用<strong>只有一个数组</strong>来表示集合。我们自己将其视为树。</p><p>对于快速合并，我们定义一个辅助函数 <code>find(int item)</code>，它返回项目所在树的根。例如，对于上面的集合，<code>find(4) == 0</code>，<code>find(1) == 0</code>，<code>find(5) == 3</code> 等。每个元素都有一个唯一的根。</p><h2 id="connect-x-y-1"><a href="#connect-x-y-1" class="headerlink" title="connect(x, y)"></a><code>connect(x, y)</code></h2><p>要连接两个项目，我们找到每个项目所属的集合（它们各自树的根），并将其中一个作为另一个的子项。例如：</p><p><code>connect(5, 2)</code>：</p><ol><li><code>find(5)</code> -&gt; 3</li><li><code>find(2)</code> -&gt; 0</li><li>设置 <code>find(5)</code> 的值为 <code>find(2)</code>，也就是 <code>parent[3] = 0</code></li></ol><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/9.3.2-1707267923567-26.png" alt="img"></p><p>请注意，元素3现在指向元素0，将两棵树&#x2F;集合合并为一棵树。</p><p>在最佳情况下，如果 <code>x</code> 和 <code>y</code> 都是它们树的根，那么 <code>connect(x, y)</code> 就会简单地使 <code>x</code> 指向 <code>y</code>，这是一个 Θ(1) 的操作！（因此称为快速合并）</p><h2 id="isConnected-x-y-1"><a href="#isConnected-x-y-1" class="headerlink" title="isConnected(x, y)"></a><code>isConnected(x, y)</code></h2><p>如果两个元素属于同一个集合，那么它们将在同一棵树中。因此，它们将具有相同的根。因此对于 <code>isConnected(x, y)</code>，我们只需检查 <code>find(x) == find(y)</code>。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>快速合并存在潜在的性能问题：树可能变得非常长。在这种情况下，找到一个项目的根 (<code>find(item)</code>) 就变得非常昂贵。考虑下面的树：</p><p>[图3]</p><p>在最坏的情况下，我们必须遍历所有项目才能到达根，这是一个 Θ(N) 的运行时间。由于我们必须对 <code>connect</code> 和 <code>isConnected</code> 都调用 <code>find</code>，所以它们的运行时间都由 O(N) 上限约束。</p><h3 id="总结和代码-1"><a href="#总结和代码-1" class="headerlink" title="总结和代码"></a>总结和代码</h3><table><thead><tr><th>实现方式</th><th>构造函数</th><th><code>connect</code></th><th><code>isConnected</code></th></tr></thead><tbody><tr><td>快速合并</td><td>Θ(N)</td><td>O(N)</td><td>O(N)</td></tr><tr><td>快速查找</td><td>Θ(N)</td><td>Θ(N)</td><td>Θ(1)</td></tr><tr><td>快速合并</td><td>Θ(N)</td><td>O(N)</td><td>O(N)</td></tr></tbody></table><p>N &#x3D; 不相交集合数据结构中的元素数量</p><p>从运行时间表中，快速合并似乎比快速查找更差！但请注意，O(N) 是一个 <strong>上限</strong>。当我们的树是平衡的时候，<code>connect</code> 和 <code>isConnected</code> 都表现得相当好。在下一节中，我们将看到如何 <em>保证</em> 它们的性能良好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickUnionDS</span> <span class="keyword">implements</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuickUnionDS</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[p] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> j= find(q);</span><br><span class="line">        parent[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="加权快速联合Weighted-Quick-Uion-WQU"><a href="#加权快速联合Weighted-Quick-Uion-WQU" class="headerlink" title="加权快速联合Weighted Quick Uion(WQU)"></a>加权快速联合Weighted Quick Uion(WQU)</h1><p>Quick Union 的改进依赖于一个关键的见解：每当我们调用 <code>find</code> 时，我们都必须爬到树的根部。因此，树越短，速度就越快！</p><p><strong>新规则</strong>：每当我们调用 <code>connect</code> 时，我们总是将<strong>较小树的根</strong>链接到<strong>较大树</strong>。</p><p>遵循此规则将为您的树提供最大高度 <code>logN</code> ，其中 N 是不相交集中的元素数量。这如何影响 <code>connect</code> 和 <code>isConnected</code> 的运行时？</p><iframe frameborder="0" allowfullscreen src="https://www.youtube.com/embed/xc9s9wdaSdU" style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; font-size: inherit; border: none; top: 0px; left: 0px; width: 770px; height: 458.125px;"></iframe><p>让我们通过一个例子来说明这样做的好处。考虑连接下面两组 T1 和 T2：</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/9.4.1.png" alt="img"></p><p>我们有两种连接它们的选项：</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/9.4.2.png" alt="img"> 第一个选项我们将 T1 链接到 T2。在第二个中，我们将 T2 链接到 T1。</p><p><strong>第二个选项更可取</strong>，因为它的高度只有 2，而不是 3。根据我们的新规则，我们也会选择第二个选项，因为 T2 小于 T1（尺寸为 3 与 6）。</p><p>我们根据树中的项目数量来确定更小&#x2F;更大。因此，当连接两棵树时，我们需要知道它们的大小（或重量）。我们可以通过用 <code>-(size of tree)</code> 替换 <code>-1</code> 来将此信息存储在树的根中。您将在<a href="https://sp19.datastructur.es/materials/lab/lab6/lab6">Lab 6</a>中实现这一点。</p><h2 id="最大高度：Log-N"><a href="#最大高度：Log-N" class="headerlink" title="最大高度：Log N"></a>最大高度：Log N</h2><p>遵循上述规则可确保任何树的最大高度为 θ(log N)。 N 是不相交集中的元素数量。<strong>通过扩展， <code>connect</code> 和 <code>isConnected</code> 的运行时间以 O(log N) 为界。</strong></p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/image-20240207091146331.png" alt="image-20240207091146331"></p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/image-20240207091744666.png" alt="image-20240207091744666"></p><p>您可能想知道为什么我们不根据高度而不是重量来链接树木。事实证明，这实现起来更复杂，并且给了我们相同的 θ(log N) 高度限制。</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/image-20240207091815565.png" alt="image-20240207091815565"></p><h2 id="总结和代码-2"><a href="#总结和代码-2" class="headerlink" title="总结和代码"></a>总结和代码</h2><table><thead><tr><th>Implementation</th><th>Constructor</th><th><code>connect</code></th><th><code>isConnected</code></th></tr></thead><tbody><tr><td>QuickUnion</td><td>Θ(N)</td><td>O(N)</td><td>O(N)</td></tr><tr><td>QuickFind</td><td>Θ(N)</td><td>Θ(N)</td><td>Θ(1)</td></tr><tr><td>QuickUnion</td><td>Θ(N)</td><td>O(N)</td><td>O(N)</td></tr><tr><td>Weighted Quick Union</td><td>Θ(N)</td><td>O(log N)</td><td>O(log N)</td></tr></tbody></table><p>N &#x3D; number of elements in our DisjointSets data structure</p><p>代码:<a href="https://sp19.datastructur.es/materials/lab/lab6/lab6">Lab 6</a>中实现 or <a href="https://algs4.cs.princeton.edu/15uf/WeightedQuickUnionUF.java.html">WeightedQuickUnionUF.java (princeton.edu)</a></p><h1 id="带路径压缩的加权快速联合WQU-with-Path-Compression"><a href="#带路径压缩的加权快速联合WQU-with-Path-Compression" class="headerlink" title="带路径压缩的加权快速联合WQU with Path Compression"></a>带路径压缩的加权快速联合WQU with Path Compression</h1><iframe width="770" height="458" src="https://www.youtube.com/embed/DZKzDebT4gU" title="[Disjoint Sets, Video 5] - Weighted Quick Union with Path Compression and Summary" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>每当我们调用 <code>find(x)</code> 时，我们都必须遍历从 <code>x</code> 到 root 的路径。因此，在此过程中，我们可以将我们访问的所有项目连接到它们的根，而无需额外的渐近成本。</p><p>将沿途的所有项目连接到根将有助于每次调用 <code>find</code> 时使我们的树更短。</p><p>回想一下， <code>connect(x, y)</code> 和 <code>isConnected(x, y)</code> 总是调用 <code>find(x)</code> 和 <code>find(y)</code> 。因此，在足够多地调用 <code>connect</code> 或 <code>isConnected</code> 之后，基本上所有元素都将直接指向它们的根。</p><p>通过扩展， <code>connect</code> 和 <code>isConnected</code> 的平均运行时间从长远来看几乎保持不变！这称为摊销运行时间（来自摊销分析，第 8.4 章）。</p><p>更具体地说，对于 N 个元素上的 M 次操作，具有路径压缩的 WQU 为 <code>O(N + M (lg* N))</code>。 <code>lg* </code>是迭代对数，对于任何现实世界的输入都小于 5。</p><blockquote><p><code>lg*</code>:</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/image-20240207091913787.png" alt="image-20240207091913787"></p></blockquote><h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p>N：不相交集中的元素数量</p><table><thead><tr><th>执行</th><th><code>isConnected</code></th><th><code>connect</code></th></tr></thead><tbody><tr><td>快速查找</td><td>Θ(N)</td><td>Θ(1)</td></tr><tr><td>快联</td><td>O(N)</td><td>O(N)</td></tr><tr><td>加权快速联合 (WQU)</td><td>O(log N)</td><td>O(log N)</td></tr><tr><td>带路径压缩的 WQU</td><td>O(α(N))*</td><td>O(α(N))*</td></tr></tbody></table><p>*长期表现稳定。</p><p>代码:<a href="https://algs4.cs.princeton.edu/15uf/WeightedQuickUnionPathCompressionUF.java.html">WeightedQuickUnionPathCompressionUF.java (princeton.edu)</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/image-20240207091954317.png" alt="image-20240207091954317"></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(十一)-Rd8.1-封装、API、ADT</title>
      <link href="/2024/02/02/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-11-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-1/"/>
      <url>/2024/02/02/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-11-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-1/</url>
      
        <content type="html"><![CDATA[<h1 id="高效编程"><a href="#高效编程" class="headerlink" title="高效编程"></a>高效编程</h1><p>效率有两种形式：</p><p>1.） 编程成本。</p><ul><li>开发您的程序需要多长时间？</li><li>读取、修改和维护代码的难易程度如何？</li></ul><p>2.） 执行成本（从下周开始）。</p><ul><li>您的程序需要多少时间才能执行？</li><li>您的程序需要多少内存？</li></ul><p>61B 中讨论了一些有用的 Java 特性：</p><ul><li>包（Packages）<ul><li>优点：组织，使事物成为包私有。</li><li>缺点：过于具体。</li></ul></li><li>静态类型检查（Static type checking）。<ul><li>优点：早期检查错误，更像是一篇故事。</li><li>缺点：不够灵活，（强制转换等）</li></ul></li><li>继承（Inheritance）<ul><li>优点：代码重用。</li><li>缺点： “Is a”，，调试路径变得烦人，不能实例化，要实现接口的每个方法。</li></ul></li></ul><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>首先，我们将定义一些术语：</p><ul><li><p><strong>模块</strong>：一组方法，作为整体一起执行某个任务或一组相关任务。 </p></li><li><p><strong>封装的</strong>：如果模块的实现完全隐藏，只能通过文档化的接口访问，则称其为封装的。</p></li></ul><h1 id="API（应用程序编程接口）"><a href="#API（应用程序编程接口）" class="headerlink" title="API（应用程序编程接口）"></a>API（应用程序编程接口）</h1><p>ADT（抽象数据结构）的API是构造函数和方法列表以及每个方法的简短描述。</p><p>API由语法和语义规范组成。</p><ul><li>编译器验证是否符合语法。 <ul><li>也就是说，API中指定的一切都存在。</li></ul></li><li>测试有助于验证语义是否正确。 <ul><li>也就是说，一切都按照应该的方式工作。 </li><li>语义规范通常用英语编写（可能包括使用示例）。数学上精确的形式规范在某种程度上可能存在，但并不普遍。</li></ul></li></ul><h1 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h1><p>ADT（抽象数据结构）是根据其行为而不是实现定义的高级类型。</p><p>即）Proj1中的Deque是一个具有特定行为（<code>addFirst</code>、<code>addLast</code>等）的ADT。但是，我们实际使用的数据结构是<code>ArrayDeque</code>和<code>LinkedListDeque</code>。</p><p>有些ADT实际上是其他ADT的特殊情况。例如，栈和队列只是具有更具体行为的列表。</p><p>练习 8.1.1 使用链表作为其底层数据结构编写一个栈类。您只需要实现一个函数：push(Item x)。确保该类是通用的，其中“Item”是泛型类型！</p><p>可能会以几种不同的方式编写它。让我们看看三种流行的解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtensionStack</span>&lt;Item&gt; <span class="keyword">extends</span> <span class="title class_">LinkedList</span>&lt;Item&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Item x)</span> &#123;</span><br><span class="line">        add(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个解决方案使用扩展(<em>extension</em>)。它简单地从<code>LinkedList&lt;Item&gt;</code>中借用方法并将其用作自己的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelegationStack</span>&lt;Item&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Item&gt; L = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Item&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Item x)</span> &#123;</span><br><span class="line">        L.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法使用委托(<em>Delegation</em>)。它创建一个LinkedList对象并调用其方法以实现目标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackAdapter</span>&lt;Item&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> List L;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StackAdapter</span><span class="params">(List&lt;Item&gt; worker)</span> &#123;</span><br><span class="line">        L = worker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Item x)</span> &#123;</span><br><span class="line">        L.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法类似于前一种方法，除了它可以使用实现List接口的任何类（如<code>LinkedList</code>、<code>ArrayList</code>等）。</p><p><strong>警告</strong>：注意“is-a”和“has-a”关系之间的区别。</p><ul><li><p>猫有一个爪子</p></li><li><p>猫是一种猫科动物</p></li></ul><p>在本节的前面，定义了委托是通过传入一个类来完成的，而扩展是通过继承（只是因为一开始可能不容易注意到）。</p><p><strong>委托vs扩展</strong>：现在看起来，委托和扩展似乎可以互换使用；然而，在使用它们时必须记住一些重要的区别。</p><p>扩展倾向于在知道父类中发生什么的情况下使用。换句话说，你知道方法是如何实现的。此外，通过扩展，基本上是在说你正在扩展的类的行为与执行扩展的类的行为相似。另一方面，委托是当你不想将当前类视为从中提取方法的类的版本时使用的。</p><p>视图：视图是现有对象的替代表示。视图本质上限制了用户对底层对象的访问。然而，通过视图进行的更改将影响实际对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 创建一个ArrayList。 */</span></span><br><span class="line">List&lt;String&gt; L = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/** 添加一些项目。 */</span></span><br><span class="line">L.add(<span class="string">&quot;at&quot;</span>); L.add(<span class="string">&quot;ax&quot;</span>); …</span><br></pre></td></tr></table></figure><p>假设你只想要一个索引为1到4的列表。然后，您可以使用<code>sublist</code>方法通过以下方式进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** subList me up fam. */</span></span><br><span class="line">List&lt;String&gt; SL = l.subList(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">/** Mutate that thing. */</span></span><br><span class="line">SL.set(<span class="number">0</span>, “jug”);</span><br></pre></td></tr></table></figure><p>现在，这有什么用呢？嗯，假设我们只想反转列表的一部分。例如，在下图中，我们希望反转上图中的<code>ax ban bat</code>。</p><p><img src="/2024/02/02/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-11-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-1/reverse_list1.png" alt="reverse"></p><p>最直观的方法是创建一个接受列表对象和应该被反转的索引的方法。但是，这可能有点繁琐，因为我们添加了一些多余的逻辑。</p><p>为了避免这样做，我们可以只创建一个通用的反转函数，该函数接受一个列表并反转该列表。由于视图改变了它表示的底层对象，我们可以像前面一样创建一个子列表，然后反转子列表。最终结果实际上会改变实际列表而不是副本。</p><p><img src="/2024/02/02/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-11-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-1/reverse_list2.png" alt="img"></p><p>这一切都很好。然而，它会导致一个问题。您声称您可以提供一个列表对象，当操作该列表对象时，可以影响原始列表对象-这有点奇怪。思考一下“如何返回一个实际的List但仍然对另一个List产生影响？”可能有点令人困惑。好吧，答案是访问方法。</p><p>首先要注意的是，<code>sublist</code>方法返回一个List类型。此外，有一个称为<code>Sublist</code>的定义类，它扩展了<code>AbstractList</code>。由于<code>Abstract List</code>实现了List接口，它和<code>Sublist</code>都是<code>List</code>类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Item&gt; <span class="title function_">sublist</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">    Return <span class="keyword">new</span> <span class="title class_">this</span>.Sublist(start,end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的首要之处是<code>subList</code>返回一个<code>List</code>类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Private <span class="keyword">class</span> <span class="title class_">Sublist</span> <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;Item&gt;&#123;</span><br><span class="line">    Private <span class="type">int</span> start end;</span><br><span class="line">    Sublist(inst start, <span class="type">int</span> end)&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，<code>sublist</code>函数返回一个<code>List</code>是因为<code>SubList</code>类扩展了<code>AbstractList</code>。由于<code>AbstractList</code>实现了<code>List</code>接口，它和<code>Sublist</code>都是List类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Item <span class="title function_">get</span><span class="params">(<span class="type">int</span> k)</span>&#123;<span class="keyword">return</span> AbstractList.<span class="built_in">this</span>.get(start+k);&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, Item x)</span>&#123;AbstractList.<span class="built_in">this</span>.add(start+k, x); end+=<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这两个方法是在 <code>Sublist</code> 类中定义的。</p><p>在给定的上下文中，<code>Sublist</code> 类被设计为一个视图，它提供了对原始列表的部分元素的访问和操作。<code>Sublist</code> 不是通过复制数据来创建一个独立的列表，而是通过引用原始列表的一部分来创建视图。这样的设计可以节省内存，并且在需要修改原始列表的情况下，视图的操作会直接影响原始列表。</p><p>具体来说，<code>get</code> 方法通过调用外部类 <code>AbstractList</code> 的 <code>get</code> 方法获取原始列表中的元素。这是因为 <code>Sublist</code> 类没有自己的数据存储，而是依赖于外部类提供的数据。类似地，<code>add</code> 方法也是通过调用外部类 <code>AbstractList</code> 的 <code>add</code> 方法，将元素添加到原始列表的指定位置，并且 <code>end</code> 计数也通过修改外部类的字段来更新。</p><p>这种依赖关系的设计有几个优点：</p><ol><li><strong>节省内存：</strong> 不需要为子列表复制一份原始列表的数据，而是直接引用原始列表的部分数据。</li><li><strong>动态更新：</strong> 由于视图是对原始数据的引用，对视图的修改会直接影响原始数据。这样的动态性使得修改子列表时可以实时反映在原始列表中，无需执行额外的同步操作。</li></ol><p>总体而言，这种依赖关系的设计使得 <code>Sublist</code> 能够提供高效的视图功能，同时节省内存并保持数据的一致性。</p></blockquote><p>应该注意的一点是，从我们的子列表中获取第k个项与从具有偏移量等于我们的起始索引的原始列表中获取第k个项是相同的。因为我们使用的是外部类（最父级的类）的get方法，我们改变了我们的原始列表。</p><p>类似地，向我们的子列表添加元素与在起始索引的子列表中添加元素相同。因为我们使用的是子列表的get方法，我们改变了我们的原始列表。</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ul><li>API很难设计；然而，拥有一种一致的设计理念可以使您的代码更清晰，更容易处理。 </li><li>继承经常被频繁使用，但它存在问题，应该谨慎使用，只有在对类的属性（既被扩展又进行扩展的类）有把握的情况下才使用。</li></ul><h2 id="三种实现方式："><a href="#三种实现方式：" class="headerlink" title="三种实现方式："></a><strong>三种实现方式：</strong></h2><ul><li><strong>使用扩展（Extension）：</strong> 通过继承现有类的方式实现，比如使用<code>extends</code>关键字。文章给出了一个使用扩展的例子，即创建一个扩展了<code>LinkedList</code>的<code>ExtensionStack</code>类，它简单地借用了<code>LinkedList</code>的方法并将其作为自己的方法使用。</li><li><strong>使用委托（Delegation）：</strong> 通过创建一个新的类，在其中包含一个实例化的现有类，并调用其方法来实现目标。文章给出了一个使用委托的例子，即创建一个<code>DelegationStack</code>类，它包含一个<code>LinkedList</code>对象，通过调用其方法来实现堆栈的目标。</li><li><strong>使用视图（Views）：</strong> 视图是对现有对象的替代表示，通过视图可以限制用户对底层对象的访问。视图的更改会影响实际对象。这一概念在后文有具体的例子。</li></ul><h2 id="关于视图的讨论："><a href="#关于视图的讨论：" class="headerlink" title="关于视图的讨论："></a><strong>关于视图的讨论：</strong></h2><ul><li><strong>视图的概念：</strong> 视图是现有对象的替代表示，通过它可以限制用户对底层对象的访问。尽管视图可以限制访问，但通过视图进行的更改会直接影响实际对象。</li><li><strong>使用sublist方法创建视图：</strong> 通过示例说明了使用<code>sublist</code>方法创建视图。例如，创建一个ArrayList <code>L</code>，然后使用<code>sublist</code>方法获取索引1到4的部分视图（<code>SL</code>）。这样，对<code>SL</code>的更改将直接影响原始列表 <code>L</code>。</li><li><strong>通过视图修改原始列表：</strong> 通过视图，可以在不创建额外逻辑的情况下修改原始列表的部分内容。文章以一个具体的例子说明了如何通过创建视图，并在视图上进行修改，来实现对原始列表的修改。</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li><strong>扩展（Extension）：</strong><ul><li><strong>使用场景：</strong> 当你想要在已有类的基础上构建一个新的类，并且新类是已有类的扩展，具有类似的行为，可以考虑使用扩展。</li><li><strong>优势：</strong> 可以继承现有类的方法，使代码重用更为简单。</li></ul></li><li><strong>委托（Delegation）：</strong><ul><li><strong>使用场景：</strong> 当你想要在新的类中使用现有类的功能，但不是扩展它，而是将这些功能委托给其他类实现，可以考虑使用委托。</li><li><strong>优势：</strong> 更灵活，允许更动态地改变委托对象，避免了继承链的一些问题。</li></ul></li><li><strong>视图（Views）：</strong><ul><li><strong>使用场景：</strong> 当你需要对现有对象的一部分进行操作，并且希望对这部分的修改能够直接影响到原始对象时，可以考虑使用视图。</li><li><strong>优势：</strong> 节省内存，避免了不必要的数据复制，同时提供对原始数据的动态操作。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(十)-Rd6-迭代器，equal方法，异常处理</title>
      <link href="/2024/02/02/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd6/"/>
      <url>/2024/02/02/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd6/</url>
      
        <content type="html"><![CDATA[<p><a href="https://joshhug.gitbooks.io/hug61b/content/chap6/chap61.html">6.1 Lists, Sets, and ArraySet · Hug61B (gitbooks.io)</a></p><p>在本节中，我们将学习如何使用 Java 的内置 <code>List</code> 和 <code>Set</code> 数据结构，以及构建我们自己的 <code>ArraySet</code> </p><h1 id="Java中的Lists"><a href="#Java中的Lists" class="headerlink" title="Java中的Lists"></a>Java中的Lists</h1><p>我们从头开始构建了一个列表，但 Java 提供了一个内置 <code>List</code> 接口和几个实现，例如 <code>ArrayList</code> .请记住，由于 <code>List</code> 是一个接口，我们无法对其进行设置！我们必须确定它的一个实现。</p><p>为了访问它，我们可以使用类、接口的全名（“规范名称”）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.List&lt;Integer&gt; L = <span class="keyword">new</span> <span class="title class_">java</span>.util.ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>但是，这有点冗长。以类似于我们导入的方式，我们可以导入 <code>JUnit</code> java 库：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; L = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        L.add(<span class="number">5</span>);</span><br><span class="line">        L.add(<span class="number">10</span>);</span><br><span class="line">        System.out.println(L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="集合-Sets"><a href="#集合-Sets" class="headerlink" title="集合(Sets)"></a>集合(Sets)</h1><p>集合是唯一元素的集合 - 每个元素只能有一个副本，也无序。</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>Java 具有 <code>Set</code> 接口和实现，例如 <code>HashSet</code> .如果您不想使用全名，请记住导入它们！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">s.add(<span class="string">&quot;Tokyo&quot;</span>);</span><br><span class="line">s.add(<span class="string">&quot;Lagos&quot;</span>);</span><br><span class="line">System.out.println(S.contains(<span class="string">&quot;Tokyo&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>在 python 中，我们只需调用 <code>set()</code> .为了检查， <code>contains</code> 我们不使用方法，而是使用关键字 <code>in</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>()</span><br><span class="line">s.add(<span class="string">&quot;Tokyo&quot;</span>)</span><br><span class="line">s.add(<span class="string">&quot;Lagos&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Tokyo&quot;</span> <span class="keyword">in</span> s) // <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="ArraySet"><a href="#ArraySet" class="headerlink" title="ArraySet"></a>ArraySet</h2><p>我们的目标是用以下方法制作我们自己的集合 <code>ArraySet</code> ：</p><ul><li><code>add(value)</code>: add the value to the set if not already present<br><code>add(value)</code> ：将值添加到集合中（如果尚不存在）</li><li><code>contains(value)</code>: check to see if ArraySet contains the key<br><code>contains(value)</code> ：检查 ArraySet 是否包含键</li><li><code>size()</code>: return number of values<br><code>size()</code> ：返回值的数量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraySet</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">// the next item to be added will be at position size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArraySet</span><span class="params">()</span> &#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns true if this map contains a mapping for the specified key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i += <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (items[i].equals(x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Associates the specified value with the specified key in this map. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (contains(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        items[size] = x;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns the number of key-value mappings in this map. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h1><p>我们在 <code>ArraySet</code> 上一节中的实现有一个小错误。当我们添加<code>null</code>到  ArraySet 时，我们得到一个 NullPointerException。</p><p>问题出在我们检查 <code>contains</code> <code>items[i].equals(x)</code> 的方法上。如果 <code>items[i]</code>值为 null，则我们调用 <code>null.equals(x)</code> -&gt; NullPointerException。</p><p>在 Java 中，异常是对象，我们使用以下格式抛出异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new ExceptionObject(parameter1, ...)</span><br></pre></td></tr></table></figure><p>当用户尝试将 null 添加到我们的 <code>ArraySet</code> .我们将抛出一个接受一个 <code>IllegalArgumentException</code> 参数（一条 <code>String</code> 消息）。</p><p>我们更新 <code>add</code> 的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">   Throws an IllegalArgumentException if the key is null. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;can&#x27;t add null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (contains(x)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    items[size] = x;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论哪种方式，我们都会得到一个异常 - 为什么这样更好？</p><ol><li>我们可以控制我们的代码：我们有意识地决定在什么时候停止我们的程序流</li><li>对于使用我们代码的用户来说，更有用的异常类型和有用的错误消息</li></ol><p>但是，如果程序根本不崩溃会更好。在这种情况下，我们可以做不同的事情。以下是一些：</p><p><strong>方法 1</strong>：如果数组被传递到数组中，则不要将其添加到 <code>null</code> 数组中 <code>add</code> </p><p><strong>方法 2</strong>：更改 <code>contains</code> 方法以考虑情况 if <code>items[i] == null</code> .</p><p>无论您做出什么决定，重要的是用户知道会发生什么。这就是为什么文档（例如关于您的方法的评论）非常重要的原因。</p><h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>我们可以在 Java 的 <code>HashSet</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">s.add(<span class="string">&quot;Tokyo&quot;</span>);</span><br><span class="line">s.add(<span class="string">&quot;Lagos&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String city : s) &#123;</span><br><span class="line">    System.out.println(city);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果我们尝试对我们的 <code>ArraySet</code> 做同样的事情，我们会得到一个错误。我们如何启用此功能？</p><h2 id="增强的-For-循环"><a href="#增强的-For-循环" class="headerlink" title="增强的 For 循环"></a>增强的 For 循环</h2><p>让我们首先了解当我们使用增强的 for 循环时会发生什么。我们可以将增强的 for 循环“翻译”成一种丑陋的手动方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (String city : s) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码翻译为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line">Iterator&lt;String&gt; seer = s.iterator();</span><br><span class="line"><span class="keyword">while</span> (seer.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> seer.next();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的关键是一个称为迭代器的对象。</p><p>在我们的示例中，在 List.java 中，我们可以定义一个 <code>iterator()</code> 返回迭代器对象的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>现在，我们可以使用该对象遍历列表中的所有条目：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; friends = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">...</span><br><span class="line">Iterator&lt;Integer&gt; seer = friends.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (seer.hasNext()) &#123;</span><br><span class="line">System.out.println(seer.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码的行为与上面的 foreach 循环版本相同。</p><p>我们的迭代器方法中有三种关键方法：</p><ul><li><p>首先，我们得到一个新的迭代器对象，其中包含 <code>Iterator&lt;Integer&gt; seer = friends.iterator();</code></p></li><li><p>接下来，我们使用 while 循环遍历列表。我们检查是否还有剩余的项目，如果还有看不见的项目，则返回 <code>seer.hasNext()</code> true，如果所有项目都已处理，则返回 false。</p></li><li><p>最后， <code>seer.next()</code> 一次做两件事。它返回列表的下一个元素，在这里我们将其打印出来。它还将迭代器<strong>前进一项</strong>。这样，迭代器将只检查每个项目一次。</p></li></ul><h2 id="实现迭代器"><a href="#实现迭代器" class="headerlink" title="实现迭代器"></a>实现迭代器</h2><p>让我们首先考虑编译器需要了解什么才能成功编译以下迭代器示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; friends = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">Iterator&lt;Integer&gt; seer = friends.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(seer.hasNext()) &#123;</span><br><span class="line">    System.out.println(seer.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以查看调用相关方法的每个对象的静态类型。 <code>friends</code> 是一个列表，在它 <code>iterator()</code> 上面被调用，所以我们必须问：</p><ul><li>Does the List interface have an iterator() method?<br>List 接口有 iterator（） 方法吗？</li></ul><p><code>seer</code> 是一个迭代器，在它 <code>hasNext()</code> 上面 <code>next()</code> 被调用，所以我们必须问：</p><ul><li>Does the Iterator interface have next&#x2F;hasNext() methods?<br>迭代器接口是否有 next&#x2F;hasNext（） 方法？</li></ul><p>那么我们如何实现这些要求呢？</p><p>List 接口扩展了 Iterable 接口，继承了抽象的 iterator（） 方法。（实际上，List 扩展了扩展 Iterable 的 Collection，但以这种方式开始代码思考更容易。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;T&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，编译器检查迭代器是否具有 <code>hasNext()</code> 和 <code>next()</code> 。Iterator 接口显式指定以下抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将向 ArrayMap 类添加迭代键。首先，我们编写一个名为 ArraySetIterator 的新类，它<strong>嵌套在</strong> ArraySet 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArraySetIterator</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ArraySetIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> wizPos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArraySetIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        wizPos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> wizPos &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">returnItem</span> <span class="operator">=</span> items[wizPos];</span><br><span class="line">        wizPos += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> returnItem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>若需要用增强For循环，就需要告诉编译器你有一个迭代器，那如何告诉编译器呢？答案是继承Iterable</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraySet</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; </span><br></pre></td></tr></table></figure><h1 id="Object方法"><a href="#Object方法" class="headerlink" title="Object方法"></a><code>Object</code>方法</h1><p>所有类都继承自总体 Object 类。继承的方法如下：</p><ul><li><code>String toString()</code></li><li><code>boolean equals(Object obj)</code></li><li><code>Class &lt;?&gt; getClass()</code></li><li><code>int hashCode()</code></li><li><code>protected Objectclone()</code></li><li><code>protected void finalize()</code></li><li><code>void notify()</code></li><li><code>void notifyAll()</code></li><li><code>void wait()</code></li><li><code>void wait(long timeout)</code></li><li><code>void wait(long timeout, int nanos)</code></li></ul><p>在本章中，我们将重点介绍前两个。我们将利用继承来覆盖类中的这两个方法，以按照我们希望它们的方式运行。</p><h2 id="toString（）"><a href="#toString（）" class="headerlink" title="toString（）"></a>toString（）</h2><p>该 <code>toString()</code> 方法提供对象的字符串表示形式。该 <code>System.out.println()</code> 函数在传递给它的任何对象上隐式调用此方法，并打印返回的字符串。当你运行 <code>System.out.println(dog)</code> 时，它实际上是这样做的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> dog.toString()</span><br><span class="line">System.out.println(s)</span><br></pre></td></tr></table></figure><p>默认 <code>Object</code> 类的<code>toString()</code> 方法打印对象在内存中的位置。这是一个十六进制字符串。像 Arraylist 和 java 数组这样的类有自己的方法重写版本 <code>toString()</code> 。这就是为什么当你使用 Arraylist 并为其编写测试时，错误总是会以这样的格式（1、2、3、4）返回列表，而不是返回内存位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">returnString</span> <span class="operator">=</span> <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i += <span class="number">1</span>) &#123;</span><br><span class="line">        returnString += keys[i];</span><br><span class="line">        returnString += <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    returnString += <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> returnString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个方法很不好，因为每次<code>+=</code>都是在创建一个新的String对象</p><p>为了解决这个问题，Java 有一个名为 <code>StringBuilder</code> .它会创建一个可变的字符串对象，因此您可以继续追加到同一个字符串对象，而不是每次都创建一个新对象。</p></blockquote><p>重写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">returnSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">            returnSB.append(items[i].toString());</span><br><span class="line">            returnSB.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        returnSB.append(items[size - <span class="number">1</span>]);</span><br><span class="line">        returnSB.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> returnSB.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><p><code>equals()</code> 并在 <code>==</code> Java 中具有不同的行为。 <code>==</code> 检查两个对象在内存中是否实际上是同一个对象。记住，按值传递！ <code>==</code> 检查两个盒子是否装有相同的东西。对于基元，这意味着检查值是否相等。对于对象，这意味着检查地址&#x2F;指针是否相等。</p><p>假设我们有这个 <code>Doge</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Doge</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Doge</span><span class="params">(<span class="type">int</span> age, String name)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">Doge</span> <span class="variable">fido</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Doge</span>(<span class="number">5</span>, <span class="string">&quot;Fido&quot;</span>);</span><br><span class="line">      <span class="type">Doge</span> <span class="variable">doggo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Doge</span>(<span class="number">6</span>, <span class="string">&quot;Doggo&quot;</span>);</span><br><span class="line">      <span class="type">Doge</span> <span class="variable">fidoTwin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Doge</span>(<span class="number">5</span>, <span class="string">&quot;Fido&quot;</span>);</span><br><span class="line">      <span class="type">Doge</span> <span class="variable">fidoRealTwin</span> <span class="operator">=</span> fido;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们将此代码插入 java 可视化工具，我们将在下面所示的指针图中看到该框。</p><p><img src="/2024/02/02/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd6/image-20240202181822175.png" alt="image-20240202181822175"></p><p>练习 6.4.2：如果我们运行以下命令，java 将返回什么？</p><ul><li><code>x == y</code></li><li><code>x == z</code></li><li><code>fido == doggo</code></li><li><code>fido == fidoTwin</code></li><li><code>fido = fidoRealTwin</code></li></ul><p><strong>答案</strong></p><ul><li><code>True</code></li><li><code>False</code></li><li><code>False</code></li><li><code>False</code></li><li><code>True</code></li></ul><p><code>fido</code> 并且 <code>fidoTwin</code> 不被考虑 <code>==</code> ，因为它们指向不同的对象。然而，这是非常愚蠢的，因为它们的所有属性都是相同的。您可以看到如何在 <code>==</code> Java 测试中导致一些问题。当我们为 ArrayList 编写测试并想要检查 expected 是否与函数返回的内容相同时，我们会将 expected 创建为新的 arraylist。如果我们 <code>==</code> 在测试中使用，它总是会返回 false。这就是 <code>equals(Object o)</code> 目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object other)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == other) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (other.getClass() != <span class="built_in">this</span>.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArraySet&lt;T&gt; o = (ArraySet&lt;T&gt;) other;</span><br><span class="line">        <span class="keyword">if</span> (o.size() != <span class="built_in">this</span>.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (T item : <span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!o.contains(item)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Java 中的等式规则：重写 <code>.equals()</code> 方法时，有时可能比看起来更棘手。实现方法 <code>.equals()</code> 时要遵守的几条规则如下：</p><p>1.） <code>equals</code> 必须是等价关系</p><ul><li><strong>反身</strong>： <code>x.equals(x)</code> 是真的</li><li><strong>对称</strong>： <code>x.equals(y)</code> 当且仅当 <code>y.equals(x)</code></li><li><code>x.equals(z)</code><br><strong>及物</strong>： <code>x.equals(y)</code> 和 <code>y.equals(z)</code> 暗示 <code>x.equals(z)</code></li></ul><p>2.） 它必须接受一个 Object 参数，以便覆盖原始 <code>.equals()</code> 方法</p><p>3.） 它必须一致 如果 <code>x.equals(y)</code> ，那么只要 <code>x</code> 和 <code>y</code> 保持不变： <code>x</code> 必须继续相等 <code>y</code></p><p>4.) It is never true for null <code>x.equals(null)</code> must be false<br>4.）  null永远不会为真， <code>x.equals(null)</code> 必须是假的</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(九)-Rd4.3-子类多态性与HoFs的关系</title>
      <link href="/2024/01/30/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-3/"/>
      <url>/2024/01/30/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-3/</url>
      
        <content type="html"><![CDATA[<p>幻灯片:<a href="https://docs.google.com/presentation/d/13SVUU8oeTch0ex42hBQLGTZ4XAaMKDJmuXMqegEoVqM/edit#slide=id.g4eef494c27_45_245">cs61b 2021 lec10 inheritance3 - Google 幻灯片</a></p><p>Reading:<a href="https://joshhug.gitbooks.io/hug61b/content/chap4/chap43.html">4.3 Subtype Polymorphism vs. HOFs · Hug61B (gitbooks.io)</a></p><h1 id="子类多态性"><a href="#子类多态性" class="headerlink" title="子类多态性"></a>子类多态性</h1><p>多态性的核心是“多种形式”。在 Java 中，多态性是指对象可以具有多种形式或类型。在面向对象编程中，多态性涉及如何将一个对象视为其自身类的实例、其超类的实例、其超类的超类的实例等。</p><p>考虑一个静态类型为<code>deque</code>的变量deque。调用<code>dequeue .addFirst()</code> 将在执行时确定，这取决于调用 <code>addFirst</code> 时<code>deque</code>的运行时类型或动态类型。正如我们在上一章中看到的，Java使用动态方法选择来选择调用哪个方法。</p><blockquote><ol><li><strong>运行时类型（Runtime Type）：</strong> 运行时类型指的是在程序执行过程中，某个变量或对象的实际类型。这是由程序在运行时动态决定的。在一些面向对象的语言中，对象可能被声明为某个类型，但在运行时可能会被赋予该类型的子类型。因此，运行时类型是程序实际处理的对象类型，而不仅仅是在代码中声明的类型。如基类。</li><li><strong>动态类型（Dynamic Type）：</strong> 动态类型是指变量或对象在运行时的类型。与静态类型相对应，动态类型意味着类型信息是在运行时确定的，而不是在编译时。在一些动态语言中，变量可以在运行时引用不同的类型，因此变量的动态类型是可以变化的。</li></ol></blockquote><p>假设我们想编写一个 python 程序，该程序打印两个对象中较大的一个的字符串表示形式。有两种方法可以做到这一点。</p><ol><li>显式 HoF 方法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_larger</span>(<span class="params">x, y, compare, stringify</span>):</span><br><span class="line">    <span class="keyword">if</span> compare(x, y):</span><br><span class="line">        <span class="keyword">return</span> stringify(x)</span><br><span class="line">    <span class="keyword">return</span> stringify(y)</span><br></pre></td></tr></table></figure><ol start="2"><li>子类多态性方法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_larger</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">if</span> x.largerThan(y):</span><br><span class="line">        <span class="keyword">return</span> x.<span class="built_in">str</span>()</span><br><span class="line">    <span class="keyword">return</span> y.<span class="built_in">str</span>()</span><br></pre></td></tr></table></figure><p>使用显式高阶函数方法，您有一种常用的方法来打印出两个对象中较大的一个。相反，在子类多态性方法中，对象本身做出选择。所调用 <code>largerFunction</code> 的取决于 x 和 y 的实际含义。</p><h2 id="Max-函数"><a href="#Max-函数" class="headerlink" title="Max 函数"></a>Max 函数</h2><p>假设我们想编写一个 <code>max</code> 函数，该函数接受任何数组（无论类型如何）并返回数组中的最大项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">max</span><span class="params">(Object[] items)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (items[i] &gt; items[maxDex]) &#123;</span><br><span class="line">            maxDex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> items[maxDex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Dog[] dogs = &#123;<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Elyse&quot;</span>, <span class="number">3</span>), <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Sture&quot;</span>, <span class="number">9</span>), <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Benjamin&quot;</span>, <span class="number">15</span>)&#125;;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">maxDog</span> <span class="operator">=</span> (Dog) max(dogs);</span><br><span class="line">    maxDog.bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一处很明显的错误:<code>items[i] &gt; items[maxDex]</code>，这会导致编译错误的原因是，此行假定 <code>&gt;</code> 运算符使用任意 Object 类型，而实际上并非如此。</p><p>相反，我们可以在 Dog 类中定义一个函数，并放弃编写一个 <code>maxDog</code> 可以接受任意类型的数组的“一个真正的最大函数”。我们可以这样定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Dog <span class="title function_">maxDog</span><span class="params">(Dog[] dogs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dogs == <span class="literal">null</span> || dogs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">maxDog</span> <span class="operator">=</span> dogs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (Dog d : dogs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d.size &gt; maxDog.size) &#123;</span><br><span class="line">            maxDog = d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这在目前是可行的，但如果我们放弃制作广义 <code>max</code> 函数的梦想，让 Dog 类定义自己的 <code>max</code> 函数，那么我们将不得不对稍后定义的任何类做同样的事情。我们需要编写一个函数、一个函数、一个 <code>maxCat</code> <code>maxPenguin</code> <code>maxWhale</code> 函数等，导致不必要的重复工作和大量冗余代码。</p><p>导致这种情况的根本问题是 <strong>Objects 不能与 <code>&gt;</code> 进行比较</strong>。这是有道理的，因为 Java 怎么知道它是否应该使用对象的 String 表示、大小或其他度量来进行比较？在 Python 或 C++ 中， <code>&gt;</code> 运算符的工作方式可以重新定义，以便在应用于不同类型时以不同的方式工作。不幸的是，Java 没有这个功能。相反，我们求助于<strong>接口继承</strong>来帮助我们。</p><p>我们可以创建一个接口来保证任何实现类（如 Dog）都包含一个比较方法，我们称之为 <code>compareTo</code> 。</p><p><img src="/2024/01/30/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-3/dog_comparable.png" alt="img"></p><p>让我们编写我们的接口。我们指定一种方法<code>compareTo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OurComparable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将这样定义它的行为：</p><ul><li>如果 <code>this</code> &lt; o，则返回负数。</li><li>如果 <code>this</code> 等于 o，则返回 0。</li><li>如果 <code>this</code> &gt; o，则返回正数。</li></ul><p>现在我们已经创建了 <code>OurComparable</code> 接口，我们可以要求 Dog 类实现该 <code>compareTo</code> 方法。首先，我们将 Dog 的类头更改为  <code>implements OurComparable</code> ，然后根据上面定义的行为编写 <code>compareTo</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">OurComparable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String n, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        size = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; says: bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">uddaDog</span> <span class="operator">=</span> (Dog) o;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size - uddaDog.size;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>请注意，由于 <code>compareTo</code> 接受任何任意对象 o，因此我们必须将输入转换为 Dog 才能使用 <code>size</code> 实例变量进行比较。</strong></p></blockquote><p>现在，我们可以将我们在练习 4.3.1 中定义的 <code>max</code> 函数推广为，而不是接受任何任意的对象数组，而是接受 <code>OurComparable</code> 对象 - 我们肯定知道所有对象都实现了该 <code>compareTo</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> OurComparable <span class="title function_">max</span><span class="params">(OurComparable[] items)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> items[i].compareTo(items[maxDex]);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            maxDex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> items[maxDex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们的函数可以接受任何 <code>OurComparable</code> 类型对象的数组， <code>max</code> 并返回数组中的最大对象。</p><p>使用继承，我们能够推广我们的最大化函数。这种方法有什么好处？</p><ul><li>不需要每个类中的求最大代码（即不需要 <code>Dog.maxDog(Dog[])</code> 函数</li><li>我们有代码可以优雅地对多种类型（大多数）进行操作</li></ul><h2 id="Comparables"><a href="#Comparables" class="headerlink" title="Comparables"></a>Comparables</h2><p>我们刚刚构建的 <code>OurComparable</code> 接口可以工作，但并不完美。以下是它的一些问题：</p><ul><li>对象间尴尬的类型转换</li><li>我们编写了它。<ul><li>没有现有类继承 OurComparable （例如 String 等）</li><li>没有现有类使用 OurComparable（例如，没有使用 OurCompare 的内置 max 函数）</li></ul></li></ul><p>解决方案是什么？我们将利用一个名为 <code>Comparable</code> . <code>Comparable</code> 已经由 Java 定义，并被无数库使用。</p><p><code>Comparable</code> 看起来与我们制作的 OurComparable 接口非常相似，但有一个主要区别。你能发现它吗？</p><p><img src="/2024/01/30/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-3/comparable_interface.png" alt="img"></p><p>请注意， <code>Comparable&lt;T&gt;</code> 这意味着它采用泛型类型。这将帮助我们避免将对象转换为特定类型！现在，我们将重写 Dog 类以实现 Comparable 接口，确保将泛型类型 <code>T</code> 更新为 Dog：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Dog&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Dog uddaDog)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size - uddaDog.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在剩下的就是将 Maximizer 类中的每个 OurComparable 实例更改为 Comparable。看着最大的狗说吠叫：</p><p>我们现在使用真正的内置接口，而不是使用我们个人创建的接口 <code>OurComparable</code> 。 <code>Comparable</code> 因此，我们可以利用所有已经存在的库并使用 <code>Comparable</code> .</p><p><img src="/2024/01/30/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-3/comparable.png" alt="img"></p><h2 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h2><p>我们刚刚了解了可比较的接口，它为每只狗嵌入了将自己与另一只狗进行比较的能力。现在，我们将介绍一个看起来非常相似的新接口，称为 <code>Comparator</code> .</p><p>让我们从定义一些术语开始。</p><ul><li>自然顺序 - 用于指特定类 <code>compareTo</code> 的方法中隐含的顺序。</li></ul><p>例如，如前所述，狗的自然排序是根据大小的值定义的。如果我们想以不同于狗的自然顺序的方式对狗进行排序，例如按它们名字的字母顺序排序，该怎么办？</p><p>Java 实现这一点的方式是使用 <code>Comparator</code>。由于 <code>Comparator</code> 是一个对象，我们将使用 <code>Comparator</code> 的方法是通过在 <code>Dog</code> 类内部编写一个实现 <code>Comparator</code> 接口的嵌套类。</p><p>但首先，这个接口里面有什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这表明 <code>Comparator</code> 接口要求任何实现类实现该 <code>compare</code> 方法。的规则 <code>compare</code> 就像： <code>compareTo</code></p><ul><li>如果 o1 &lt; o2，则返回负数。</li><li>如果 o1 等于 o2，则返回 0。</li><li>如果 o1 &gt; o2，则返回正数。</li></ul><p>让我们给 Dog 一个 NameComparator。为此，我们可以简单地遵循 <code>String</code> 已经定义 <code>compareTo</code> 的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Dog&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Dog uddaDog)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size - uddaDog.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NameComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Dog&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Dog a, Dog b)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.name.compareTo(b.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Dog&gt; <span class="title function_">getNameComparator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NameComparator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>请注意，我们已将 NameComparator 声明为静态类。这是一个细微的差异，但我们这样做是因为我们不需要实例化 Dog 来获取 NameComparator。让我们看看这个比较器是如何工作的。</p></blockquote><p>正如你所看到的，我们可以像这样检索我们的 NameComparator：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Dog&gt; nc = Dog.getNameComparator();</span><br></pre></td></tr></table></figure><p>总而言之，我们有一个 Dog 类，它有一个私有的 NameComparator 类和一个返回 NameComparator 的方法，我们可以用它来按名称的字母顺序比较狗。</p><p>让我们看看继承层次结构中的一切是如何工作的——我们有一个内置于 Java 的比较器接口，我们可以实现它来在 Dog 中定义我们自己的比较器（ <code>NameComparator</code> 、 <code>SizeComparator</code> 等）。</p><p><img src="/2024/01/30/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-3/comparator.png" alt="img"></p><p>总而言之，Java 中的接口为我们提供了进行回调的能力。有时，一个函数需要另一个可能尚未编写的函数的帮助（例如 <code>max</code> needs <code>compareTo</code> ）。回调函数是帮助函数（在方案中为 <code>compareTo</code> ）。在某些语言中，这是使用显式函数传递来实现的;在 Java 中，我们将所需的函数包装在一个接口中。</p><p>一个可比者说，“我想将自己与另一个对象进行比较”。它嵌入在对象本身中，它定义了类型的<strong>自然顺序</strong>。另一方面，比较器更像是将两个对象相互比较的第三方机器。由于只有一种方法 <code>compareTo</code> 的空间，如果我们想要多种方法进行比较，我们必须求助于比较器。</p><blockquote><p>即<code>a.max(b)</code>和max(a, b)的区别</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>接口为我们提供了进行回调的能力：</p><ul><li>有时候，一个函数需要另一个可能尚未编写的函数的帮助。 例如：<code>max</code> 需要 <code>compareTo</code>。 这种帮助函数有时被称为“回调”。 </li><li>一些编程语言使用显式的函数传递来处理这种情况。 </li><li>在Java中，我们通过将所需的函数包装在接口中来实现这一点（例如，<code>Arrays.sort</code> 需要在比较器接口中定义的 <code>compare</code>）。 </li><li><code>Arrays.sort</code> 在需要进行比较时会“回调”相应的函数。 类似于在需要信息时将你的号码提供给别人。</li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li><strong>Comparables（可比较的）：</strong><ul><li>可比较的对象通常实现<code>Comparable</code>接口，该接口定义了<code>compareTo</code>方法，规定了对象的自然顺序。</li><li>自然顺序是对象的默认排序方式。</li><li>在子类中实现<code>compareTo</code>方法，以便对象可以在不同场景中进行比较，例如在排序中使用。</li></ul></li><li><strong>Comparators（比较器）：</strong><ul><li>比较器是实现了<code>Comparator</code>接口的对象，该接口定义了<code>compare</code>方法，允许两个对象进行自定义的比较。</li><li>比较器允许在不修改对象类本身的情况下定义多种比较方式。</li><li>在需要多种比较方式时，可以创建不同的比较器类，例如<code>NameComparator</code>和<code>SizeComparator</code>。</li></ul></li><li><strong>子类多态性：</strong><ul><li>多态性涉及对象在程序执行过程中可以具有多种形式或类型的概念。</li><li>在Java中，多态性表现为对象可以被视为其自身类的实例、其超类的实例等。</li><li>子类多态性通过继承和接口实现，使得代码更加灵活，允许处理不同类型的对象。</li></ul></li><li><strong>接口和回调函数：</strong><ul><li>接口提供了进行回调的能力，允许一个函数在需要时调用另一个可能尚未编写的函数。</li><li>在Java中，回调函数通常通过将函数包装在接口中实现，例如<code>compareTo</code>方法在<code>OurComparable</code>接口中定义。</li><li>使用接口和比较器，可以实现多种比较方式，使得对象在排序等场景中更加灵活。</li></ul></li></ol><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><ol><li><strong>Comparables 和 Comparators：</strong><ul><li><code>Comparables</code> 和 <code>Comparators</code> 都是用于进行对象比较的机制，但它们的使用场景和实现方式略有不同。</li><li><code>Comparables</code> 用于定义对象的自然顺序，要求对象自身实现 <code>Comparable</code> 接口，并重写 <code>compareTo</code> 方法来规定比较规则。</li><li><code>Comparators</code> 用于实现自定义的比较逻辑，可以为同一类对象定义多个不同的比较方式，而无需修改对象类本身。比较器实现 <code>Comparator</code> 接口，并重写 <code>compare</code> 方法。</li></ul></li><li><strong>子类多态性和接口的关系：</strong><ul><li>子类多态性涉及对象在程序执行过程中可以具有多种形式或类型的概念。在文章中，子类多态性通过继承和接口实现，使得对象可以具有不同的形式。</li><li>接口在这里起到了关键作用。例如，<code>OurComparable</code> 接口定义了 <code>compareTo</code> 方法，通过让类实现这个接口，可以在不同类型的类之间实现相似的比较行为，实现多态性。</li></ul></li><li><strong>使用 Comparables 和 Comparators 实现灵活性：</strong><ul><li>通过使用 <code>Comparables</code> 接口，对象可以定义它们的自然顺序，使得它们可以参与排序等操作。</li><li>使用 <code>Comparators</code> 接口，可以实现多种比较方式，而不必修改对象的类。这提供了灵活性，允许在不同的上下文中使用不同的比较规则。</li></ul></li></ol><p>总体而言，Comparables 和 Comparators 提供了不同层次的比较机制，使得代码更加灵活，同时子类多态性通过接口的实现使得对象可以以多种形式存在。这些概念相互协作，为Java中的对象比较和多态性提供了强大的工具。</p><h2 id="对抽象的意义"><a href="#对抽象的意义" class="headerlink" title="对抽象的意义"></a>对抽象的意义</h2><ol><li><strong>抽象接口提高通用性：</strong><ul><li>接口（比如 <code>Comparable</code> 和 <code>Comparator</code>）提供了抽象的规范，定义了在不同类之间进行比较的通用方式。</li><li>这种抽象性使得可以编写通用的算法和方法，而无需关心具体类的实现细节，从而提高了代码的通用性。</li></ul></li><li><strong>多态性提高扩展性：</strong><ul><li>使用 <code>Comparables</code> 和 <code>Comparators</code> 的多态性，代码可以处理不同类型的对象，并根据实际情况选择适当的比较方式。</li><li>新的类可以轻松地实现相应的接口或比较器，而不需要修改现有的代码，从而提高了代码的扩展性。</li></ul></li><li><strong>减少耦合度：</strong><ul><li>通过接口和多态性，实现了对象之间的松散耦合。例如，一个算法可能仅关心对象是否可比较，而不关心对象的具体类型。</li><li>这种减少耦合度的设计使得代码更加灵活，减少了对具体实现的依赖，提高了系统的可维护性。</li></ul></li><li><strong>支持算法的通用性：</strong><ul><li>通过接口和抽象的比较机制，可以编写通用的排序、搜索等算法，这些算法可以在不同类型的对象上工作，只要它们实现了相应的接口或比较器。</li><li>这种通用性使得可以更容易地共享和重用算法，同时减少了代码冗余。</li></ul></li><li><strong>更好的代码组织和可读性：</strong><ul><li>使用抽象接口和多态性，可以更清晰地组织代码，将通用的比较逻辑与具体类的实现分离。</li><li>这提高了代码的可读性，使得代码更易于理解和维护。</li></ul></li></ol><p>总体而言，通过在面向对象的设计中引入抽象接口和多态性，可以使代码更加灵活、通用和可扩展。这种实现对于处理不同类型的对象、支持通用算法以及减少代码耦合度都具有重要的意义。</p><h2 id="思维流程"><a href="#思维流程" class="headerlink" title="思维流程"></a>思维流程</h2><ol><li><p>我们希望编写一个 <code>max</code> 函数，该函数接受任何数组（无论类型如何）并返回数组中的最大项。因为目前我们只有<code>Dog</code>类，所以我们在<code>Dog</code>类中编写了一个<code>MaxDog</code>的方法。</p></li><li><p>虽然这样子可以实现我们的目的，但是有个问题，当我们有其他类想要比较时，这个<code>Max</code>函数没有办法比较，导致这种情况的根本问题是 <strong>Objects 不能与 <code>&gt;</code> 进行比较</strong>。于是我们想创建一个接口来保证任何实现类（如 Dog）都包含一个比较方法，我们称之为 <code>compareTo</code> 。</p></li><li><p>于是我们创建了一个OurComparable接口，里面规定了compareTo方法。我们在Dog类中实现后，把max方法修改成了这样</p></li><li><p><img src="/2024/01/30/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-3/image-20240130034614544.png" alt="image-20240130034614544"></p></li><li><p>但是这样子又有些问题:没有现有类继承 OurComparable, 没有现有类使用 OurComparable。解决方案是什么？我们将利用一个名为 <code>Comparable</code> . <code>Comparable</code> 已经由 Java 定义，并被无数库使用。</p></li><li><p>如前所述，狗的自然排序是根据大小的值定义的。如果我们想以不同于狗的自然顺序的方式对狗进行排序，例如按它们名字的字母顺序排序，该怎么办？</p></li><li><p>Java 实现这一点的方式是使用 <code>Comparator</code>。由于 <code>Comparator</code> 是一个对象，我们将使用 <code>Comparator</code> 的方法是通过在 <code>Dog</code> 类内部编写一个实现 <code>Comparator</code> 接口的嵌套类。</p></li><li><pre><code class="java">import java.util.Comparator;public class Dog implements Comparable&lt;Dog&gt; &#123;    ...    public int compareTo(Dog uddaDog) &#123;        return this.size - uddaDog.size;    &#125;    private static class NameComparator implements Comparator&lt;Dog&gt; &#123;        public int compare(Dog a, Dog b) &#123;            return a.name.compareTo(b.name);        &#125;    &#125;    public static Comparator&lt;Dog&gt; getNameComparator() &#123;        return new NameComparator();    &#125;&#125;</code></pre></li><li><p>这样子就能实现自定义排序</p></li><li><p><img src="/2024/01/30/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-3/image-20240130032414722.png" alt="image-20240130032414722"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(八)-Rd4.2-Extends.Casting,HigherOrderFunction</title>
      <link href="/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-2/"/>
      <url>/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-2/</url>
      
        <content type="html"><![CDATA[<p>幻灯片:<a href="https://docs.google.com/presentation/d/1zsr4-MHM5STYr_b0l-lZ8ABqAPzyIU3P31qWKP2M3m4/edit#slide=id.g109ce79706_0_385">cs61b 2021 lec9 inheritance2 - Google 幻灯片</a></p><p>Reading:<a href="https://joshhug.gitbooks.io/hug61b/content/chap4/chap42.html">4.2 Extends, Casting, Higher Order Functions · Hug61B (gitbooks.io)</a></p><h1 id="Extends关键字"><a href="#Extends关键字" class="headerlink" title="Extends关键字"></a>Extends关键字</h1><p>现在，您已经了解了如何使用 <code>implements</code> 关键字来定义与接口的层次结构关系。如果我们想定义类之间的层次结构关系怎么办？</p><ul><li><code>implements</code> 关键字：定义类与接口的层次结构关系</li><li><code>extends</code>关键字：定义类之间的层次结构关系</li></ul><p>通过使用 <code>extends</code> 关键字，子类继承父类的所有成员。 “成员”包括：</p><ul><li>所有实例变量和静态变量</li><li>所有方法</li><li>所有嵌套类</li></ul><p>请注意，构造函数不是继承的，子类不能直接访问私有成员。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 请注意，当有人调用 removeLast SLList 时，它会丢弃该值 - 再也看不到了。但是，如果那些被移除的价值观离开并开始对我们进行大规模的反抗呢？在这种情况下，我们需要记住那些被删除的（或者更确切地说是有缺陷的&gt;:(）值是什么，以便我们可以追踪它们并在以后终止它们。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">我们创建了一个新类 VengefulSLList，它记住了所有被 removeLast 放逐的元素。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VengefulSLList</span>&lt;Item&gt; <span class="keyword">extends</span> <span class="title class_">SLList</span>&lt;Item&gt; &#123;</span><br><span class="line">    SLList&lt;Item&gt; deletedItems;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VengefulSLList</span><span class="params">()</span> &#123;</span><br><span class="line">        deletedItems = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Item&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Item</span> <span class="variable">x</span> <span class="operator">=</span> <span class="built_in">super</span>.removeLast();</span><br><span class="line">        deletedItems.addLast(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Prints deleted items. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLostItems</span><span class="params">()</span> &#123;</span><br><span class="line">        deletedItems.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="surper"><a href="#surper" class="headerlink" title="surper()"></a>surper()</h2><p>我们继承过来的不包含构造函数，虽然构造函数不是继承的，但 Java 要求所有构造函数都必须<strong>从调用其超类的构造函数之一开始</strong>。当我们调用子类的构造函数的时候，会隐形地调用基类的构造函数，也可以在构造函数中加入<code>surper()</code>语句来显性调用基类的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">VengefulSLList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();<span class="comment">//或者删掉</span></span><br><span class="line">    deletedItems = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Item&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样子看起来surper()好像没有存在的必要</p></blockquote><p>但是如果我们需要调用带参数的构造函数，如果纯隐形调用基类的构造函数的话，我们的传入的参数并没有什么用，于是我们需要将参数传入<code>surper()</code>中，即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">VengefulSLList</span><span class="params">(Item x)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(x);</span><br><span class="line">    deletedItems = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Item&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象类-The-Object-Class"><a href="#对象类-The-Object-Class" class="headerlink" title="对象类(The Object Class)"></a>对象类(The Object Class)</h2><p>Java 中的每个类都是 Object 类或 <code>extends</code> Object 类的后代。即使类中没有显式类，它们仍然隐式 <code>extends</code> 扩展 Object 类。</p><p><img src="/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-2/image-20240130003225738.png" alt="image-20240130003225738"></p><blockquote><p>虚线表示隐式继承</p></blockquote><p>Documentation for Object class: <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html">Object (Java SE 9 &amp; JDK 9 ) (oracle.com)</a></p><h1 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装(Encapsulation)"></a>封装(Encapsulation)</h1><p>封装是面向对象编程的基本原则之一，也是我们作为程序员用来抵抗我们最大的敌人：复杂性的方法之一。管理复杂性是我们在编写大型程序时必须面对的主要挑战之一。</p><p>我们可以用来对抗复杂性的一些工具包括分层抽象（抽象障碍！）和称为“为变革而设计”的概念。这围绕着这样一种想法，即程序应该被构建成模块化的、可互换的部分，这些部分可以在不破坏系统的情况下进行交换。此外，在管理大型系统时，隐藏其他人不需要的信息是另一种基本方法。</p><p>封装的根源在于这种向外部隐藏信息的概念。观察它的一种方法是了解封装如何类似于人类细胞。细胞的内部可能非常复杂，由染色体、线粒体、核糖体等组成，但它被完全封装在一个模块中——抽象出内部的复杂性。</p><p><img src="/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-2/cell_encapsulated.png" alt="img"></p><p>在计算机科学术语中，模块可以定义为一组方法，这些方法作为一个整体协同工作以执行一项任务或一组相关任务。这可能类似于表示列表的类。现在，如果一个模块的实现细节在内部被隐藏，并且与它交互的唯一方法是通过一个记录的接口，那么该模块就被称为封装。</p><p>以 <code>ArrayDeque</code> 类为例。外部世界能够 <code>ArrayDeque</code> 通过其定义的方法（如 <code>addLast</code> 和 ）利用和 <code>removeLast</code> 与之交互。但是，他们不需要了解数据结构如何实现的复杂细节，以便能够有效地使用它。</p><h2 id="抽象障碍-Abstraction-Barriers"><a href="#抽象障碍-Abstraction-Barriers" class="headerlink" title="抽象障碍(Abstraction Barriers)"></a>抽象障碍(Abstraction Barriers)</h2><p>理想情况下，用户应该无法观察他们正在使用的数据结构的内部工作原理。幸运的是，Java 使实施抽象壁垒变得容易。在 Java 中使用关键字 <code>private</code> ，几乎不可能查看对象内部 - 确保底层复杂性不会暴露给外界。</p><h2 id="继承如何破坏封装"><a href="#继承如何破坏封装" class="headerlink" title="继承如何破坏封装"></a>继承如何破坏封装</h2><p>假设我们在 Dog 类中有以下两种方法。我们本可以实现 <code>bark</code> 并 <code>barkMany</code> 像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;bark&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">barkMany</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">        bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，我们可以这样实现它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">    barkMany(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">barkMany</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从用户的角度来看，这些实现中的任何一个的功能都是完全相同的。但是，如果我们要定义一个 <code>Dog</code> called <code>VerboseDog</code> 的子类，并按如下方式覆盖其方法，则观察其 <code>barkMany</code> 效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">barkMany</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;As a dog, I say: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">        bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所看到的，使用第一个实现，输出是 <code>As a dog, I say: bark bark bark</code>，而使用第二个实现，程序陷入无限循环。对 <code>bark()</code> 的调用将调用 ，它调用 <code>barkMany(1)</code> <code>bark()</code> ，无限多次重复该过程。</p><h1 id="类型检查和铸造"><a href="#类型检查和铸造" class="headerlink" title="类型检查和铸造"></a>类型检查和铸造</h1><p>在讨论类型和转换之前，让我们回顾一下动态方法选择。回想一下，动态方法查找是根据对象的动态类型确定在运行时执行的方法的过程。具体来说，如果 SLList 中的方法被 VengefulSLList 类重写，则在运行时调用的方法由该变量的运行时类型或动态类型确定。</p><p><img src="/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-2/dynamic_selection.png" alt="img"></p><p>对于这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sl.printLostItems();</span><br></pre></td></tr></table></figure><p>上面的这一行会导致编译时错误。请记住，编译器根据对象的静态类型来确定某些内容是否有效。由于 <code>sl</code> 是静态类型 SLList，并且 <code>printLostItems</code> 未在 SLList 类中定义，因此即使 <code>sl</code> 的运行时类型是 VengefulSLList，也不允许运行代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VengefulSLList&lt;Integer&gt; vsl2 = sl;</span><br></pre></td></tr></table></figure><p>出于类似的原因，上面的这一行也会导致编译时错误。通常，编译器只允许基于编译时类型的方法调用和赋值。由于编译器只看到 的静态类型 <code>sl</code> 是 SLList，因此它不允许 VengefulSLList“容器”保存它。</p><p>总结:</p><ul><li>基类无法调用子类的方法</li><li>子类指针无法存储基类地址</li></ul><h2 id="表达-式"><a href="#表达-式" class="headerlink" title="表达 式"></a>表达 式</h2><p>与上面的变量一样，使用关键字的 <code>new</code> 表达式也具有编译时类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLList&lt;Integer&gt; sl = <span class="keyword">new</span> <span class="title class_">VengefulSLList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><p>上面，表达式右侧的编译时类型是 <code>VengefulSLList</code>。编译器检查以确保 <code>VengefulSLList</code> “is-a”<code> SLList</code>，并允许此赋值，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VengefulSLList&lt;Integer&gt; vsl = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><p>上面，表达式右侧的编译时类型是<code> SLList</code>。编译器检查 <code>SLList</code> “is a”<code>VengefulSLList</code>，并非在所有情况下都是如此，因此会导致编译错误。</p><p>此外，方法调用具有与其声明类型相等的编译时类型。假设我们有这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Dog <span class="title function_">maxDog</span><span class="params">(Dog d1, Dog d2)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>由于返回类型 <code>maxDog</code> 为 Dog，因此任何调用 <code>maxDog</code> 都将具有编译时类型 Dog。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Poodle</span> <span class="variable">frank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Poodle</span>(<span class="string">&quot;Frank&quot;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">Poodle</span> <span class="variable">frankJr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Poodle</span>(<span class="string">&quot;Frank Jr.&quot;</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Dog</span> <span class="variable">largerDog</span> <span class="operator">=</span> maxDog(frank, frankJr);</span><br><span class="line"><span class="type">Poodle</span> <span class="variable">largerPoodle</span> <span class="operator">=</span> maxDog(frank, frankJr); <span class="comment">//does not compile! RHS has compile-time type Dog</span></span><br></pre></td></tr></table></figure><p>将 Dog 对象分配给 Poodle 变量（如在 SLList 案例中）会导致编译错误。贵宾犬“是”一只狗，但更一般的狗对象可能并不总是贵宾犬，即使它显然是你和我（我们知道这一点 <code>frank</code> ，并且 <code>frankJr</code> 都是贵宾犬！当我们确定分配会起作用时，有什么办法可以解决这个问题吗？</p><h2 id="转换-Casting"><a href="#转换-Casting" class="headerlink" title="转换(Casting)"></a>转换(Casting)</h2><p>Java 有一种特殊的语法，您可以在其中告诉编译器特定表达式具有特定的编译时类型。这称为<strong>“转换”</strong>。通过强制转换，我们可以告诉编译器将表达式视为不同的编译时类型。</p><p>回顾上面失败的代码，既然我们知道并且 <code>frank</code> <code>frankJr</code> 都是贵宾犬，我们可以强制执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Poodle</span> <span class="variable">largerPoodle</span> <span class="operator">=</span> (Poodle) maxDog(frank, frankJr); <span class="comment">// compiles! Right hand side has compile-time type Poodle after casting</span></span><br></pre></td></tr></table></figure><p><em>注意</em>：转换是一种强大但危险的工具。从本质上讲，强制转换是告诉编译器不要执行其类型检查职责 - 告诉它信任你并按照你希望的方式行事。以下是可能出现的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Poodle</span> <span class="variable">frank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Poodle</span>(<span class="string">&quot;Frank&quot;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">Malamute</span> <span class="variable">frankSr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Malamute</span>(<span class="string">&quot;Frank Sr.&quot;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Poodle</span> <span class="variable">largerPoodle</span> <span class="operator">=</span> (Poodle) maxDog(frank, frankSr); <span class="comment">// runtime exception!</span></span><br></pre></td></tr></table></figure><p>在这种情况下，我们比较贵宾犬和雪橇犬。如果没有强制转换，编译器通常不允许调用编译 <code>maxDog</code> ，因为右侧的编译时类型是 Dog，而不是 Poodle。但是，强制转换允许此代码通过，并且当在运行时返回雪橇犬时，我们尝试将雪橇犬强制转换为贵宾犬时，我们遇到了运行时 <code>maxDog</code> 异常 - a <code>ClassCastException</code> .</p><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>高阶函数是将其他函数视为数据的函数。例如，以这个 Python 程序 <code>do_twice</code> 为例，它接受另一个函数作为输入，并将其应用于输入 <code>x</code> 两次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tenX</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>*x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_twice</span>(<span class="params">f, x</span>):</span><br><span class="line">    <span class="keyword">return</span> f(f(x))</span><br></pre></td></tr></table></figure><p>调用 <code>print(do_twice(tenX, 2))</code> 会将 tenX 应用于 2，然后再次将 tenX 应用于其结果 20，从而得到 200。我们如何在 Java 中做这样的事情？</p><p>在老式的 Java（Java 7 及更早版本）中，内存框（变量）不能包含指向函数的指针。这意味着我们无法编写具有“Function”类型的函数，因为根本没有函数类型。</p><p>为了解决这个问题，我们可以利用接口继承。让我们编写一个接口来定义任何接受整数并返回整数的函数 - 一个 <code>IntUnaryFunction</code> .</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IntUnaryFunction</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以编写一个类来 <code>implements IntUnaryFunction</code> 表示一个具体的函数。让我们创建一个函数，它接受一个整数并返回该整数的 10 倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TenX</span> <span class="keyword">implements</span> <span class="title class_">IntUnaryFunction</span> &#123;</span><br><span class="line">    <span class="comment">/* Returns ten times the argument. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span> * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这一点上，我们已经用 Java 编写了 <code>tenX</code> 该函数的 Python 等价物。让我们现在写 <code>do_twice</code> 吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">do_twice</span><span class="params">(IntUnaryFunction f, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f.apply(f.apply(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 中调用 <code>print(do_twice(tenX, 2))</code> 如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(do_twice(<span class="keyword">new</span> <span class="title class_">TenX</span>(), <span class="number">2</span>));</span><br></pre></td></tr></table></figure><h1 id="继承备忘单"><a href="#继承备忘单" class="headerlink" title="继承备忘单"></a>继承备忘单</h1><p><code>VengefulSLList extends SLList</code> 表示 VengefulSLList “is-an” SLList，并继承 SLList 的所有成员：</p><ul><li>变量、方法、嵌套类</li><li>不是构造函数 子类构造函数必须首先调用超类构造函数。该 <code>super</code> 关键字可用于调用重写的超类方法和构造函数。</li></ul><p>重写方法的调用遵循两个简单的规则：</p><ul><li>编译器是安全的，只允许我们根据静态类型做事。</li><li>对于重写的方法（非重载方法），调用的实际方法基于调用表达式的动态类型</li><li>可以使用强制转换来否决编译器类型检查。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(七)-Rd4.1-导言和接口</title>
      <link href="/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-1/"/>
      <url>/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://joshhug.gitbooks.io/hug61b/content/chap4/chap41.html">4.1 Intro and interfaces · Hug61B (gitbooks.io)</a></p><h1 id="方法重载-method-overloading"><a href="#方法重载-method-overloading" class="headerlink" title="方法重载(method overloading)"></a>方法重载(<em>method overloading</em>)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longest</span><span class="params">(SLList&lt;String&gt; list)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longest</span><span class="params">(AList&lt;String&gt; list)</span></span><br></pre></td></tr></table></figure><p>这就是所谓的方法重载。当您调用 <code>WordUtils.longest</code> 时，Java 会根据您提供的参数类型知道要运行哪一个。如果为其提供 <code>AList</code>，它将调用 <code>AList </code>方法。与 <code>SLList</code> 相同。</p><p>Java 足够聪明，知道如何为不同类型的两种相同的方法处理，这很好，但重载有几个缺点：</p><ul><li>这是超级重复和丑陋的，因为你现在有两个几乎相同的代码块。</li><li>它需要更多的代码来维护，这意味着如果你想对方法进行一些小的更改，例如更正一个错误，你需要在 <code>longest</code> 方法中为每种类型的列表进行更改。</li><li>如果我们想创建更多的列表类型，我们必须为每个新的列表类复制该方法。</li></ul><h1 id="上位词、下位词和接口继承"><a href="#上位词、下位词和接口继承" class="headerlink" title="上位词、下位词和接口继承"></a>上位词、下位词和接口继承</h1><p><strong>Hypernyms, Hyponyms, and Interface Inheritance</strong></p><p>狗是贵宾犬、雪橇犬、哈士奇等的上位词。相反，贵宾犬、雪橇犬和哈士奇是狗的下位词。</p><p>这些词构成了“is-a”关系的层次结构：</p><ul><li>a poodle “is-a” dog<br>贵宾犬“is-a”狗</li><li>a dog “is-a” canine<br>一只狗“是”犬</li><li>a canine “is-a” carnivore<br>犬科动物“IS-A”食肉动物</li><li>a carnivore “is-an” animal<br>食肉动物“is-an”动物</li></ul><p><img src="/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-1/hierarchy.png" alt="hierarchy"></p><p>同样的层次结构也适用于 SLLists 和 ALists！SLList 和 AList 都是更一般的列表的下位词。</p><p>我们将在 Java 中形式化这种关系：如果 SLList 是 List61B 的下位词，那么 SLList 类是 List61B 类的子类，而 List61B 类是 SLList 类的超类。</p><p><strong>图 4.1.1 :</strong></p><p><img src="/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-1/subclass.png" alt="subclass"></p><p>在 Java 中，为了表达这个层次结构，我们需要做<strong>两件事</strong>：</p><ul><li>第 1 步：为常规列表超义词定义一个类型——我们将选择名称 List61B。</li><li>第 2 步：指定 SLList 和 AList 是该类型的下位词。</li></ul><p>新的 List61B 是 Java 所说的**接口(interface)**。它本质上是一个指定列表必须能够执行的操作的协定，但它不为这些行为提供任何实现。</p><p>这是我们的 List61B 接口。至此，我们已经完成了建立关系层次结构的第一步：创建超义词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List61B</span>&lt;Item&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(Item x)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> add <span class="title function_">Last</span><span class="params">(Item y)</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">getFirst</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">getLast</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">removeLast</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Item x, <span class="type">int</span> position)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，要完成步骤 2，我们需要指定 AList 和 SLList 是 List61B 类的下位词。在 Java 中，我们在类定义中定义了这种关系。</p><p>我们将添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class AList&lt;Item&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure><p>定义关系的词：implements。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class AList&lt;Item&gt; implements List61B&lt;Item&gt;&#123;...&#125;</span><br></pre></td></tr></table></figure><p><code>implements List61B&lt;Item&gt;</code> 本质上是一个承诺。AList 说“我保证我将拥有并定义 List61B 接口中指定的所有属性和行为”</p><p>现在我们可以编辑我们 <code>longest</code> 的方法 <code>WordUtils</code> 以接收 List61B。因为 AList 和 SLList 共享“is-a”关系。</p><h1 id="方法覆盖-Override"><a href="#方法覆盖-Override" class="headerlink" title="方法覆盖(@Override)"></a>方法覆盖(@Override)</h1><p>在子类中实现所需的函数时，在方法签名的顶部包含 <code>@Override</code> 标记很有用（实际上在 61B 中也是必需的）。在这里，我们只用一种方法做到了这一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(Item x)</span> &#123;</span><br><span class="line">    insert(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，即使您不包含此标记，您<strong>仍然会</strong>覆盖该方法。所以从技术上讲，你不必包括它。但是，包含标记可以作为程序员的一种保护措施，提醒编译器您打算重写此方法。你问为什么这会有帮助？嗯，这有点像有一个校对员！编译器会告诉您过程中是否出现问题。</p><p>为什么我们要用Override呢？:</p><ul><li>主要原因:防止打字错误。<ul><li>如果你说@Override，但如果这个方法没有覆盖任何东西，你会得到一个编译错误。</li><li>例如public void addLats(项目x)</li></ul></li><li>提醒程序员，方法定义来自继承层次结构中更高的位置。</li></ul><h2 id="接口继承-Interface-Inheritance"><a href="#接口继承-Interface-Inheritance" class="headerlink" title="接口继承(Interface Inheritance)"></a>接口继承(Interface Inheritance)</h2><p>接口继承是指子类继承超类的所有方法&#x2F;行为的关系。正如我们在 Hyponyms 和 Hypernyms 部分中定义的 List61B 类一样，该接口包括所有方法签名，但不包括实现。由子类实际提供这些实现。</p><p>这种继承也是多代的。这意味着，如果我们有一长串的超类&#x2F;子类关系，如图 4.1.1 所示，AList 不仅继承了 List61B 的方法，而且还继承了它上面的所有其他类，一直到最高超类 AKA AList 继承自 Collection。</p><h1 id="GRoE"><a href="#GRoE" class="headerlink" title="GRoE"></a>GRoE</h1><p>回想一下我们在第一章中介绍的平等黄金法则。这意味着每当我们进行赋值时 <code>a = b</code> ，我们都会将 b 中的位复制到 a 中，并要求 b 与 a 的类型相同。你不能分配 <code>Dog b = 1</code> OR <code>Dog b = new Cat()</code> ，因为 1 不是狗，猫也不是。</p><p>让我们尝试将此规则应用于我们之前在本章中编写 <code>longest</code> 的方法。</p><p><code>public static String longest(List61B&lt;String&gt; list)</code> 接受 List61B。我们说过这也可以接受 AList 和 SLList，但由于 AList 和 List61B 是不同的类，这怎么可能呢？好吧，回想一下，AList 与 List61B 共享“is-a”关系，这意味着 AList 应该能够放入 List61B 框中！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List61B&lt;String&gt; someList = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;String&gt;();</span><br><span class="line">    someList.addFirst(<span class="string">&quot;elk&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当它运行时，将创建 SLList，并且其地址存储在 someList 变量中。然后将字符串“elk”插入到 addFirst 引用的 SLList 中。</p></blockquote><h2 id="实现继承"><a href="#实现继承" class="headerlink" title="实现继承"></a>实现继承</h2><p>以前，我们有一个接口 List61B，它只有标识 List61B 应该做什么的方法标头。但是，现在我们将看到我们可以在 List61B 中编写已经填写了实现的方法。这些方法确定 List61B 的上位词应如何表现。</p><p>为此，必须在方法签名中包含 <strong><code>default</code> 关键字</strong>。</p><p>如果我们在 List61B 中定义此方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size(); i += <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print(get(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么所有实现 List61B 类的东西都可以使用该方法！</p><p>然而，这种方法对于SLList来说过于慢，因为他是基于链表实现的列表，这样子相当于运用了两次for循环</p><p>我们希望 SLList 的打印方式与其接口中指定的方式不同。为此，我们需要覆盖它。在 SLList 中，我们实现了这种方法;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> sentinel.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">        System.out.print(p.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，每当我们在 SLList 上调用 print（） 时，它都会调用此方法而不是 List61B 中的方法。</p><h3 id="动态类型以及动态方法选择"><a href="#动态类型以及动态方法选择" class="headerlink" title="动态类型以及动态方法选择"></a>动态类型以及动态方法选择</h3><p>您可能想知道，Java 如何知道要调用哪个 print（）？问得好。Java 之所以能够做到这一点，是因为有一种叫做动态方法选择的东西。</p><p>我们知道 java 中的变量有一个类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List61B&lt;String&gt; lst = new SLList&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>In the above declaration and instantiation, lst is of type “List61B”. This is called the “static type”<br>在上面的声明和实例化中，lst 的类型为“List61B”。这称为“静态类型”</p><p>但是，对象本身也具有类型。LST 指向的对象类型为 SLList。尽管这个对象本质上是一个 SLList（因为它被声明为 SLList），但它也是一个 List61B，因为我们之前探讨过的“is-a”关系。但是，由于对象本身是使用 SLList 构造函数实例化的，因此我们将其称为“动态类型”。</p><h4 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型:"></a>动态类型:</h4><ul><li>这是在实例化时指定的类型(例如在使用new时)。</li><li>等于所指向的对象的类型。</li></ul><p><img src="/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-1/image-20240129204744765.png" alt="image-20240129204744765"></p><p><img src="/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-1/image-20240129204833057.png" alt="image-20240129204833057"></p><p>当 Java 运行被重写的方法时，它会在其动态类型中搜索适当的方法签名并运行它。</p><p><strong>重要提示：这不适用于重载方法！</strong></p><p>假设同一类中有两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">peek</span><span class="params">(List61B&lt;String&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(list.getLast());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">peek</span><span class="params">(SLList&lt;String&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(list.getFirst());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后运行此代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SLList&lt;String&gt; SP = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;String&gt;();</span><br><span class="line">List61B&lt;String&gt; LP = SP;</span><br><span class="line">SP.addLast(<span class="string">&quot;elk&quot;</span>);</span><br><span class="line">SP.addLast(<span class="string">&quot;are&quot;</span>);</span><br><span class="line">SP.addLast(<span class="string">&quot;cool&quot;</span>);</span><br><span class="line">peek(SP);</span><br><span class="line">peek(LP);</span><br></pre></td></tr></table></figure><p>对 peek（） 的第一次调用将使用第二个 peek 方法，该方法接受 SLList。对 peek（） 的第二次调用将使用第一个 peek 方法，该方法接受 List61B。这是因为两个重载方法之间的唯一区别是<strong>参数的类型</strong>。当 Java 检查要调用的方法时，它会检查静态类型并使用相同类型的参数调用该方法。</p><blockquote><p>动态方法不适用于方法重载，方法重载只考虑签名，不考虑指向</p><p>这里的SP和LP的动态类型都是SLList(因为都指向SLList)</p></blockquote><h2 id="接口继承-vs-实现继承"><a href="#接口继承-vs-实现继承" class="headerlink" title="接口继承 vs 实现继承"></a>接口继承 vs 实现继承</h2><ol><li><strong>接口继承（Interface Inheritance）：</strong><ul><li>接口继承是指一个类使用另一个类的接口（方法签名）而不继承其实现。</li><li>在接口继承中，子类仅继承父类的方法签名，但并不继承实际的实现代码。</li><li>接口继承的主要目的是为了定义一组共享的方法规范，以确保实现这些接口的类都有相似的行为。</li><li>多个类可以实现同一个接口，从而达到代码的可复用性和灵活性。</li></ul></li><li><strong>实现继承（Implementation Inheritance）：</strong><ul><li>实现继承是指一个类从另一个类直接继承实现代码，包括属性和方法。</li><li>在实现继承中，子类不仅继承了父类的方法签名，还继承了具体的方法实现。</li><li>实现继承用于在子类中重用和扩展父类的功能，但可能导致较强的耦合性和继承链的脆弱性。</li></ul></li></ol><p>总的来说，区分接口继承和实现继承的关键在于是否继承了具体的实现代码。接口继承注重于定义规范，而实现继承注重于代码的重用和共享。在面向对象设计中，通常倡导使用接口继承来实现松耦合的设计，避免过度依赖具体的实现。</p><p>创建这些层次结构时，请记住，子类和超类之间的关系应为<strong>“is-a”</strong>关系。AKA Cat 应该只实现 Animal Cat is an Animal。您不应该使用“has-a”关系来定义它们。Cat 有爪子，但 Cat 绝对不应该实现 Claw。</p><p>最后，实现继承听起来不错，但也有一些缺点：</p><ul><li>我们是容易犯错的人，我们无法跟踪所有事情，所以你有可能推翻了一种方法，但忘记了你做了。</li><li>I如果两个接口提供冲突的默认方法，则可能很难解决冲突。</li><li>它鼓励过于复杂的代码</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.CS61B项目练习笔记-Proj1</title>
      <link href="/2024/01/29/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj1/"/>
      <url>/2024/01/29/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj1/</url>
      
        <content type="html"><![CDATA[<h1 id="The-Deque-API"><a href="#The-Deque-API" class="headerlink" title="The Deque API"></a>The Deque API</h1><p>Deque（通常发音为“deck”）是双端队列的不规则首字母缩写。双端队列是具有动态大小的序列容器，可以在两端（其前端或后端）扩展或收缩。</p><p>具体而言，任何 deque 实现都必须具有以下操作：</p><ul><li><code>public void addFirst(T item)</code> ：将某个类型的 <code>T</code> 项目添加到 deque 的前面。你可以假设这 <code>item</code> 从来都不是 <code>null</code> .</li><li><code>public void addLast(T item)</code> ：将类型的 <code>T</code> 项目添加到 deque 的背面。你可以假设这 <code>item</code> 从来都不是 <code>null</code> .</li><li><code>public boolean isEmpty()</code> ：如果 deque 为空，则返回， <code>false</code> 否则返回 <code>true</code> 。</li><li><code>public int size()</code> ：返回 deque 中的项数。</li><li><code>public void printDeque()</code> ：从头到尾打印 deque 中的项目，用空格分隔。打印完所有项目后，打印出新行。</li><li><code>public T removeFirst()</code> ：删除并返回 deque 前面的项目。如果不存在此类项，则返回 <code>null</code> 。</li><li><code>public T removeLast()</code> ：删除并返回 deque 背面的项目。如果不存在此类项，则返回 <code>null</code> 。</li><li><code>public T get(int index)</code> ：获取给定索引处的项，其中 0 是前面，1 是下一个项，依此类推。如果不存在此类项，则返回 <code>null</code> 。不得改动deque！</li></ul><p>此外，我们还希望我们的两个 Deque 实现这两个特殊方法：</p><ul><li><code>public Iterator&lt;T&gt; iterator()</code> ：我们将要创建的 Deque 对象是可迭代的（即 <code>Iterable&lt;T&gt;</code> ），因此我们必须提供此方法来返回迭代器。</li><li><code>public boolean equals(Object o)</code> ：返回参数 <code>o</code> 是否等于 Deque。 <code>o</code> 如果它是 Deque，并且如果它以相同的顺序包含相同的内容（由泛型 <code>T</code> <code>equals</code> 方法支配）则被认为是相等的。（添加 2&#x2F;12：您需要为此使用 <code>instance of</code> 关键字。阅读<a href="https://www.javatpoint.com/downcasting-with-instanceof-operator">here</a>了解更多信息）</li></ul><blockquote><p>添加 2&#x2F;12：您不应该实现接口 <code>Deque</code> ，而应该只实现 <code>Iterable</code> 两个实现 <code>LinkedListDeque</code> 和 <code>ArrayDeque</code> .如果您执行前者，我们的自动评分器将为您提供 API 错误。</p><p>您将在第 11 讲 （2&#x2F;12） 中了解 an <code>Iterator</code> 是什么，所以现在不要担心。这个项目旨在随着您从讲座和讨论中学到更多东西而一点一点地完成，这是练习您在本课程中学到的所有东西的绝佳机会。</p><p>您的类应该接受任何泛型类型（而不仅仅是整数）。有关创建和使用泛型数据结构的信息，请参阅 <a href="https://docs.google.com/presentation/d/19TTe3JgFscc4RLwokvQ_gOM72DSrfs9Y6ZST_fv3aQ4">lecture 5</a>。请务必密切注意最后一张幻灯片中关于泛型的经验法则。</p><p>在此项目中，您将为 Deque 接口提供两种实现：一种由链表提供支持，另一种由调整大小数组提供支持</p></blockquote><h1 id="项目任务"><a href="#项目任务" class="headerlink" title="项目任务"></a>项目任务</h1><h2 id="Linked-List-Deque"><a href="#Linked-List-Deque" class="headerlink" title="Linked List Deque"></a>Linked List Deque</h2><p>作为第一个 deque 实现，您将构建基于 <code>LinkedListDeque</code> 链表的类。</p><p>您的操作受以下规则的约束：</p><ul><li><code>add</code> 并且 <code>remove</code> 操作不得涉及任何循环或递归。单个此类操作必须花费“恒定时间”，即执行时间不应取决于 deque 的大小。这意味着您不能使用遍历 deque 的所有&#x2F;大多数元素的循环。</li><li><code>get</code> 必须使用迭代，而不是递归。</li><li><code>size</code> 必须花费恒定的时间。</li><li><code>LinkedListDeque</code> 循环使用 for-each 循环所需的时间应与项目数成正比。</li><li>不要保留对不再在 deque 中的项目的引用。程序在任何给定时间使用的内存量必须与项数成正比。例如，如果将 10,000 个项目添加到 deque，然后删除 9,999 个项目，则生成的内存使用量应等于 1 个项目的 deque，而不是 10,000。请记住，Java 垃圾收集器将在且仅当没有指向该对象的指针时为我们“删除”内容。</li></ul><p>实现上面“Deque API”部分中列出的所有方法。</p><p>此外，您还需要实现：</p><ul><li><code>public LinkedListDeque()</code> ：创建一个空的链表取消。</li><li><code>public T getRecursive(int index)</code> ：与 get 相同，但使用递归。</li></ul><p>虽然这听起来很简单，但有许多设计问题需要考虑，您可能会发现实现比您预期的更具挑战性。请务必查阅有关双向链表的讲座，特别是关于哨兵节点的幻灯片：两个哨兵拓 <a href="https://docs.google.com/presentation/d/1suIeJ1SIGxoNDT8enLwsSrMxcw4JTvJBsMcdARpqQCk/pub?start=false&loop=false&delayms=3000&slide=id.g829fe3f43_0_291">two sentinel topology</a>扑和圆形哨兵拓扑<a href="https://docs.google.com/presentation/d/1suIeJ1SIGxoNDT8enLwsSrMxcw4JTvJBsMcdARpqQCk/pub?start=false&loop=false&delayms=3000&slide=id.g829fe3f43_0_376">circular sentinel topology</a>。我更喜欢循环方法。</p><p><img src="/2024/01/29/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj1/5f80de28514b0bc51dc944e1a7129ac.png" alt="5f80de28514b0bc51dc944e1a7129ac"></p><p><img src="/2024/01/29/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj1/e38a8427e6351cf3a2733e4708df329.png" alt="e38a8427e6351cf3a2733e4708df329"></p><h3 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> deque;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListDeque</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> T item;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        <span class="keyword">public</span> Node prev;</span><br><span class="line">        Node(T i, Node p, Node n) &#123;</span><br><span class="line">            item = i;</span><br><span class="line">            prev = p;</span><br><span class="line">            next = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node sentinel;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListDeque</span><span class="params">()</span> &#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span> ,<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        sentinel.prev = sentinel;</span><br><span class="line">        sentinel.next = sentinel;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListDeque</span><span class="params">(T i)</span> &#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> <span class="title class_">Node</span>(i, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        sentinel.next = <span class="keyword">new</span> <span class="title class_">Node</span>(i, sentinel, sentinel);</span><br><span class="line">        sentinel.prev = sentinel.next;</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item of type T to the front of the deque.</span></span><br><span class="line"><span class="comment">     * You can assume that item is never null. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        sentinel.next = <span class="keyword">new</span> <span class="title class_">Node</span>(item, sentinel, sentinel.next);</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item of type T to the back of the deque.</span></span><br><span class="line"><span class="comment">     * You can assume that item is never null. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        sentinel.prev = <span class="keyword">new</span> <span class="title class_">Node</span>(item, sentinel.prev, sentinel);</span><br><span class="line">        sentinel.prev.prev.next = sentinel.prev;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns true if deque is empty, false otherwise. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns the number of items in the deque. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Prints the items in the deque from first to last, separated by a space.</span></span><br><span class="line"><span class="comment">     * Once all the items have been printed, print out a new line. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printDeque</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print(p.next.item);</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            p = p.next;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes and returns the item at the front of the deque.</span></span><br><span class="line"><span class="comment">     * If no such item exists, returns null. */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="type">T</span> <span class="variable">item</span> <span class="operator">=</span> sentinel.next.item;</span><br><span class="line">        sentinel.next.next.prev = sentinel.next.prev;</span><br><span class="line">        sentinel.next = sentinel.next.next;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes and returns the item at the back of the deque.</span></span><br><span class="line"><span class="comment">     * If no such item exists, returns null. */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="type">T</span> <span class="variable">item</span> <span class="operator">=</span> sentinel.prev.item;</span><br><span class="line">        sentinel.prev.prev.next = sentinel;</span><br><span class="line">        sentinel.prev = sentinel.prev.prev;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Gets the item at the given index, where 0 is the front, 1 is the next item, and so forth.</span></span><br><span class="line"><span class="comment">     * If no such item exists, returns null. Must not alter the deque! */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T <span class="title function_">getRecursivehelper</span><span class="params">(<span class="type">int</span> index, Node s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s.item;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getRecursivehelper(index - <span class="number">1</span>, s.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Same as get, but uses recursion. */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getRecursive</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getRecursivehelper(index, sentinel.next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Array-Deque"><a href="#Array-Deque" class="headerlink" title="Array Deque"></a>Array Deque</h2><p>对于此实现，您的操作受以下规则的约束：</p><ul><li><code>add</code> 并且 <code>remove</code> 必须花费恒定的时间，除非在调整大小操作期间。</li><li><code>get</code> 并且 <code>size</code> 必须花费恒定的时间。</li><li>数组的起始大小应为 8。</li><li>程序在任何给定时间使用的内存量必须与项数成正比。例如，如果将 10,000 个项目添加到 deque，然后删除 9,999 个项目，则不应仍使用长度为 10,000ish 的数组。对于长度为 16 或更大的数组，使用系数应始终至少为 25%。这意味着，在执行将数组中的元素数控制在数组长度的 25% 以下的删除操作之前，应减小数组的大小。对于较小的阵列，使用系数可以任意降低。</li></ul><p>实现上面“Deque API”部分中列出的所有方法。</p><p>此外，您还需要实现：</p><ul><li><code>public ArrayDeque()</code> ：创建一个空数组 deque。</li></ul><p>您将需要以某种方式跟踪哪些数组索引包含 Deque 的正面和背面元素。我们强烈建议您在本练习中将数组视为循环数组。换言之，如果你的前面项位于零位置，而 u <code>addFirst</code> ，则新的前面应该循环回数组的末尾（因此 deque 中的新前面项将是基础数组中的最后一个项）。与非循环方法相比，这将导致更少的头痛。有关更多详细信息，请参阅项目 1 <a href="https://docs.google.com/presentation/d/1XBJOht0xWz1tEvLuvOL4lOIaY0NSfArXAvqgkrx0zpc/edit#slide=id.g1094ff4355_0_450">project 1 demo slides</a> 演示幻灯片。</p><h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> deque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDeque</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] item;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nextFirst;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nextLast;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">()</span> &#123;</span><br><span class="line">        item = (T []) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">8</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        nextFirst = <span class="number">1</span>;</span><br><span class="line">        nextLast = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(ArrayDeque other)</span> &#123;</span><br><span class="line">        item = (T []) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">8</span>];</span><br><span class="line">        System.arraycopy(other.item, <span class="number">0</span>, item, <span class="number">0</span>, size);</span><br><span class="line">        size = other.size;</span><br><span class="line">        nextFirst = other.nextFirst;</span><br><span class="line">        nextLast = other.nextLast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">ForwardValue</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        n--;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            n = item.length - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">BackValue</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= item.length) &#123;</span><br><span class="line">            n = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** before performing a remove operation that will bring the number of elements in the array under 25% the length of the array, </span></span><br><span class="line"><span class="comment">     * resize the size of the array down. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        T[] a = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[x];</span><br><span class="line">        <span class="keyword">if</span> ((size &lt; item.length / <span class="number">4</span>) &amp;&amp; (size &gt; <span class="number">16</span>)) &#123;</span><br><span class="line">            System.arraycopy(item, nextFirst+<span class="number">1</span>, a, <span class="number">0</span>, size);</span><br><span class="line">            nextFirst = -<span class="number">1</span>;</span><br><span class="line">            nextLast = size;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.arraycopy(item, <span class="number">0</span>, a, <span class="number">0</span>, nextFirst+<span class="number">1</span>);</span><br><span class="line">            System.arraycopy(item, nextLast, a, a.length - item.length + nextFirst + <span class="number">1</span>, item.length - nextFirst -<span class="number">1</span>);</span><br><span class="line">            nextFirst = a.length - item.length + nextFirst;</span><br><span class="line">        &#125;</span><br><span class="line">        item = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item of type T to the front of the deque.</span></span><br><span class="line"><span class="comment">     * You can assume that item is never null. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(T i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == item.length) &#123;</span><br><span class="line">            resize(size * <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">while</span> (item[nextFirst] != <span class="literal">null</span>) &#123;</span><br><span class="line">                nextFirst = ForwardValue(nextFirst);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        item[nextFirst] = i;</span><br><span class="line">        size++;</span><br><span class="line">        nextFirst = ForwardValue(nextFirst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item of type T to the back of the deque.</span></span><br><span class="line"><span class="comment">     * You can assume that item is never null. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(T i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == item.length) &#123;</span><br><span class="line">            resize(size * <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">while</span> (item[nextLast] != <span class="literal">null</span>) &#123;</span><br><span class="line">                nextLast = BackValue(nextLast);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        item[nextLast] = i;</span><br><span class="line">        size++;</span><br><span class="line">        nextLast = BackValue(nextLast);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns true if deque is empty, false otherwise. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size &lt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns the number of items in the deque. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Prints the items in the deque from first to last, separated by a space.</span></span><br><span class="line"><span class="comment">     * Once all the items have been printed, print out a new line. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printDeque</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            System.out.println(item[(nextFirst + i + <span class="number">1</span>) % item.length]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes and returns the item at the front of the deque.</span></span><br><span class="line"><span class="comment">     * If no such item exists, returns null. */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((size &lt; item.length / <span class="number">4</span>) &amp;&amp; (size &gt; <span class="number">16</span>)) &#123;</span><br><span class="line">            resize(item.length / <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">curValue</span> <span class="operator">=</span> item[BackValue(nextFirst)];</span><br><span class="line">        item[BackValue(nextFirst)] = <span class="literal">null</span>;</span><br><span class="line">        nextFirst = BackValue(nextFirst);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> curValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes and returns the item at the back of the deque.</span></span><br><span class="line"><span class="comment">     * If no such item exists, returns null. */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((size &lt; item.length / <span class="number">4</span>) &amp;&amp; (size &gt; <span class="number">16</span>)) &#123;</span><br><span class="line">            resize(item.length / <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">T</span> <span class="variable">curValue</span> <span class="operator">=</span> item[ForwardValue(nextLast)];</span><br><span class="line">        item[ForwardValue(nextLast)] = <span class="literal">null</span>;</span><br><span class="line">        nextLast = ForwardValue(nextLast);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> curValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Gets the ith item in the list (0 is the front). */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item[(nextFirst + i + <span class="number">1</span>) % item.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Deque-Interface-接口"><a href="#Deque-Interface-接口" class="headerlink" title="Deque Interface(接口)"></a>Deque Interface(接口)</h1><p>回想一下，我们通过以下方法定义了 <code>Deque</code> API 或行为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void addFirst(T item)</span><br><span class="line">public void addLast(T item)</span><br><span class="line">public boolean isEmpty()</span><br><span class="line">public int size()</span><br><span class="line">public void printDeque()</span><br><span class="line">public T removeFirst()</span><br><span class="line">public T removeLast()</span><br><span class="line">public T get(int index) </span><br></pre></td></tr></table></figure><p>由于程序将依赖于此行为，因此提供什么 <code>Deque</code> 实现对它来说并不重要，或者 <code>LinkedListDeque</code> ， <code>ArrayDeque</code> 并且应该同时适用于两者。为了实现这一点，我们将使用接口的强大功能。</p><p>在包含上述所有方法的新 <code>Deque.java</code> 文件中创建一个接口。在 IntelliJ 中，使用“New → Java Class”。IntelliJ 会假设你想要一个类，所以一定要把 <code>class</code> 关键词换成 <code>interface</code> 。不要忘记声明 <code>Deque</code> 接口是包的一部分 <code>deque</code> ！</p><p>修改你的 <code>LinkedListDeque</code> 或 <code>ArrayDeque</code> ，以便它们通过添加到 <code>implements Deque&lt;T&gt;</code> 声明类存在的行来实现 <code>Deque</code> 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDeque</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Deque</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListDeque</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Deque</span>&lt;T&gt;</span><br></pre></td></tr></table></figure><p>向覆盖方法的每个 <code>Deque</code> 方法添加 <code>@Override</code> 标记。</p><p>现在，在接口中 <code>Deque</code> ，给出 <code>isEmpty()</code> 一个 <code>default</code> 实现，如果 <code>size()</code> 是 <code>0</code> ，则返回 <code>true</code> .由于 your <code>LinkedListDeque</code> 和 实现接口 <code>Deque</code> ，给定默认 <code>isEmpty()</code> 实现，您可以从之前实现的 <code>LinkedListDeque</code> 和 <code>ArrayDeque</code> <code>ArrayDeque</code> 中删除该方法。</p><p>现在，在实现 <code>Deque</code> 接口并从 <code>LinkedListDeque</code> 和 <code>ArrayDeque</code> 实现中删除 <code>isEmpty()</code> 方法后，代码将在完整的自动分级器上编译。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> deque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Deque</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(T i)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(T i)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size() &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printDeque</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">removeFirst</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">removeLast</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Guitar-Hero"><a href="#Guitar-Hero" class="headerlink" title="Guitar Hero"></a>Guitar Hero</h1><p>在项目的这一部分中，我们将创建另一个包，用于使用我们刚刚制作的 <code>deque</code> 包生成合成乐器。我们将有机会使用我们的数据结构来实现一种算法，该算法允许我们模拟吉他弦的弹拨。</p><h2 id="The-GH2-Package"><a href="#The-GH2-Package" class="headerlink" title="The GH2 Package"></a>The GH2 Package</h2><p>该 <code>gh2</code> 包只有一个主要组件，您将对其进行编辑：</p><ul><li><code>GuitarString</code> ，该类使用 <code>Deque&lt;Double&gt;</code> 来实现 <a href="http://en.wikipedia.org/wiki/Karplus%E2%80%93Strong_string_synthesis">Karplus-Strong 算法</a> 来合成吉他弦声音。</li></ul><p>我们为您提供了框架代码 <code>GuitarString</code> ，您将在其中使用在本项目第一部分中创建的 <code>deque</code> 包。</p><h2 id="GuitarString"><a href="#GuitarString" class="headerlink" title="GuitarString"></a>GuitarString</h2><p>我们想要完成 <code>GuitarString</code> 文件，它应该使用包 <code>deque</code> 来复制拨弦的声音。我们将使用 Karplus-Strong 算法，该算法很容易通过 <code>Deque</code> .</p><p>The Karplus-Algorithm is simply the following three steps:<br>Karplus算法只是以下三个步骤：</p><ol><li>用随机噪声（ <code>double</code> 值介于 -0.5 和 0.5 之间）替换 a <code>Deque</code> 中的每个项目。</li><li>去掉<code>Deque</code> 最前面的double值，并和<code>Deque</code> 下一个double （提示：使用 <code>removeFirst()</code> 和 <code>get()</code> )取平均值 然后 乘以能量衰减因子 0.996（我们称之为整个量 <code>newDouble</code> ）。然后，添加到 <code>newDouble</code> 到<code>Deque</code>的最后 .</li><li>播放您在步骤2中退出队列的double (newDouble)。回到步骤2(并不断重复)。</li></ol><p>或者从视觉上看，如果如 <code>Deque</code> 顶部所示，我们将删除 0.2，将其与 0.4 合并形成 0.2988，添加 0.2988，然后播放 0.2。</p><p><img src="/2024/01/29/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj1/karplus-strong.png" alt="karplus-strong"></p><p>您可以使用该 <code>StdAudio.play</code> 方法播放值 <code>double</code> 。例如 <code>StdAudio.play(0.333)</code> ，会告诉扬声器的振膜将自己伸展到其总范围的 1&#x2F;3， <code>StdAudio.play(-0.9)</code> 会告诉它几乎向后伸展它的小心脏，几乎尽可能远。扬声器振膜的运动会取代空气，如果你以很好的模式取代空气，这些干扰将被你的意识解释为令人愉悦，这要归功于数十亿年的进化。有关详细信息，请参阅此页面。如果你只是这样做 <code>StdAudio.play(0.9)</code> ，再也不玩任何东西，那么图像中显示的隔膜将只是静止不动地前进的 9&#x2F;10。</p><p>完成 <code>GuitarString.java</code> ，以便实现 Karplus-Strong 算法的第 1 步和第 2 步。请注意，您必须在 <code>GuitarString</code> 构造函数中用零填充缓冲区 <code>Deque</code> 。第 3 步将由 <code>GuitarString</code> 类的客户端完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gh2;</span><br><span class="line"><span class="keyword">import</span> deque.*;</span><br><span class="line"><span class="comment">// import deque.Deque;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Note: This file will not compile until you complete the Deque implementations</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuitarString</span> &#123;</span><br><span class="line">    <span class="comment">/** Constants. Do not change. In case you&#x27;re curious, the keyword final</span></span><br><span class="line"><span class="comment">     * means the values cannot be changed at runtime. We&#x27;ll discuss this and</span></span><br><span class="line"><span class="comment">     * other topics in lecture on Friday. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SR</span> <span class="operator">=</span> <span class="number">44100</span>;      <span class="comment">// Sampling Rate</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">DECAY</span> <span class="operator">=</span> <span class="number">.996</span>; <span class="comment">// energy decay factor</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Buffer for storing sound data. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Double&gt; buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a guitar string of the given frequency.  */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GuitarString</span><span class="params">(<span class="type">double</span> frequency)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> (<span class="type">int</span>) Math.round(SR / frequency);</span><br><span class="line">        buffer = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Double&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            buffer.addFirst(<span class="number">0.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pluck the guitar string by replacing the buffer with white noise. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pluck</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//       Make sure that your random numbers are different from each</span></span><br><span class="line">        <span class="comment">//       other. This does not mean that you need to check that the numbers</span></span><br><span class="line">        <span class="comment">//       are different from each other. It means you should repeatedly call</span></span><br><span class="line">        <span class="comment">//       Math.random() - 0.5 to generate new random numbers for each array index.</span></span><br><span class="line">        <span class="type">double</span> temp;</span><br><span class="line">        Deque&lt;Double&gt; NewBuffer = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Double&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buffer.size(); i++) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> Math.random() - <span class="number">0.5</span>;</span><br><span class="line">            temp = buffer.get(i);</span><br><span class="line">            NewBuffer.addLast(temp - r);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer = NewBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advance the simulation one time step by performing one iteration of</span></span><br><span class="line"><span class="comment">     * the Karplus-Strong algorithm.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">double</span> NewDouble;</span><br><span class="line">        <span class="type">double</span> <span class="variable">temp</span> <span class="operator">=</span> buffer.get(<span class="number">0</span>);</span><br><span class="line">        buffer.removeFirst();</span><br><span class="line">        NewDouble = DECAY * <span class="number">0.5</span> * (temp + buffer.get(<span class="number">0</span>));</span><br><span class="line">        buffer.addLast(NewDouble);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return the double at the front of the buffer. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sample</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buffer.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GuitarHero"><a href="#GuitarHero" class="headerlink" title="GuitarHero"></a>GuitarHero</h2><p>非作业，单纯好玩</p><p>考虑创建一个类似于 <code>GuitarHeroLite</code> 的程序 <code>GuitarHero</code> ，但支持 37Hz 到 110Hz 的半音阶上总共 880 个音符。使用以下 37 个键来表示键盘，从最低音符到最高音符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String keyboard = &quot;q2we4r5ty7u8i9op-[=zxdcfvgbnjmk,.;/&#x27; &quot;;</span><br></pre></td></tr></table></figure><p>这种键盘排列模仿钢琴键盘：“白键”位于键盘的 qwerty 和 zxcv 行上，“黑键”位于键盘的 12345 和 asdf 行上。</p><p>字符串键盘的第 i 个字符对应于 <img src="/2024/01/29/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj1/image-20240129042827790.png" alt="image-20240129042827790"> 的频率，因此字符“q”为 110Hz，“i”为 220Hz，“v”为 440Hz，“”为 880Hz。甚至不要考虑包含 37 个单独的 GuitarString 变量或 37 路 if 语句！相反，创建一个包含 37 <code>GuitarString</code> 个对象的数组，并用于 <code>keyboard.indexOf(key)</code> 确定键入了哪个键。确保如果按下的键与您的 37 个音符之一不对应，您的程序不会崩溃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gh2;</span><br><span class="line"><span class="keyword">import</span> deque.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdDraw;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.introcs.StdAudio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuitarHero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">keyboard</span> <span class="operator">=</span> <span class="string">&quot;q2we4r5ty7u8i9op-[=zxdcfvgbnjmk,.;/&#x27; &quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FREQ</span> <span class="operator">=</span> <span class="number">440</span>;</span><br><span class="line">        ArrayDeque&lt;GuitarString&gt; guitar = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">/* check if the user has typed a key; if so, process it */</span></span><br><span class="line">            <span class="keyword">if</span> (StdDraw.hasNextKeyTyped()) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> StdDraw.nextKeyTyped();</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> keyboard.indexOf(key);</span><br><span class="line">                <span class="type">double</span> <span class="variable">freq</span> <span class="operator">=</span> FREQ * Math.pow(<span class="number">2</span>, (<span class="type">double</span>) (i - <span class="number">24</span>) /<span class="number">12</span>);</span><br><span class="line">                guitar.addLast(<span class="keyword">new</span> <span class="title class_">GuitarString</span>(freq));</span><br><span class="line">                <span class="keyword">if</span> (guitar.size() &gt; index) &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                guitar.get(index).pluck();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="type">double</span> <span class="variable">sample</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; guitar.size(); j++) &#123;</span><br><span class="line">                sample += guitar.get(j).sample();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* play the sample on standard audio */</span></span><br><span class="line">            StdAudio.play(sample);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* advance the simulation of each guitar string by one step */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; guitar.size(); j++) &#123;</span><br><span class="line">                guitar.get(j).tic();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Even-More-Fun-更有趣"><a href="#Even-More-Fun-更有趣" class="headerlink" title="Even More Fun 更有趣"></a>Even More Fun 更有趣</h2><p>这部分作业没有评分，只是为了好玩。</p><ul><li>Harp 字符串：在包中 <code>gh2</code> 创建一个 Harp 类。在将新值排入队列之前翻转新值的符号 <code>tic()</code> 会将声音从吉他式变为竖琴式。您可能希望使用衰减因子来提高真实感，并将缓冲区大小调整两倍，因为 <code>tic()</code> 自然共振频率会因变化而减半。</li><li>Drums：在包中 <code>gh2</code> 创建一个 Drum 类。在将新值排入队列之前，以 0.5 的概率翻转新值的符号 <code>tic()</code> 将产生鼓声。衰减系数为 1.0（无衰减）将产生更好的声音，您需要调整使用的频率集。</li><li>吉他在 6 根物理弦之一上弹奏每个音符。为了模拟这种情况，您可以将 <code>GuitarString</code> 实例分成 6 组，当一个字符串被摘取时，将该组中的所有其他字符串清零。</li><li>钢琴带有一个阻尼踏板，可用于使琴弦静止。您可以通过在按住某个键（例如 Shift）的迭代中更改衰减因子来实现此目的。</li><li>虽然我们使用了平等的气质，但当音乐音程跟随正音调系统中的小部分时，耳朵会发现它更令人愉悦。例如，当音乐家使用铜管乐器演奏完美的五度和声时，频率之比为 3&#x2F;2 &#x3D; 1.5，而不是 27&#x2F;12 ∼ 1.498。编写一个程序，其中每对连续的音符都只有语调。</li></ul><h2 id="Why-It-Works-为什么有效"><a href="#Why-It-Works-为什么有效" class="headerlink" title="Why It Works 为什么有效"></a>Why It Works 为什么有效</h2><p>使Karplus-Strong算法起作用的两个主要组件是环形缓冲区反馈机制和平均操作。</p><ul><li><strong>The ring buffer feedback mechanism</strong>. The ring buffer models the medium (a string tied down at both ends) in which the energy travels back and forth. The length of the ring buffer determines the fundamental frequency of the resulting sound. Sonically, the feedback mechanism reinforces only the fundamental frequency and its harmonics (frequencies at integer multiples of the fundamental). The energy decay factor (.996 in this case) models the slight dissipation in energy as the wave makes a round trip through the string.<br><strong>环形缓冲区反馈机制。</strong>环形缓冲器模拟能量来回传播的介质（两端系在一起的绳子）。环形缓冲器的长度决定了所产生声音的基频。在声音上，反馈机制仅增强基频及其谐波（基频整数倍的频率）。能量衰减因子（在本例中为 .996）模拟了波在弦上往返时能量的轻微耗散。</li><li><strong>The averaging operation</strong>. The averaging operation serves as a gentle low-pass filter (which removes higher frequencies while allowing lower frequencies to pass, hence the name). Because it is in the path of the feedback, this has the effect of gradually attenuating the higher harmonics while keeping the lower ones, which corresponds closely with how a plucked guitar string sounds.<br>平均操作。平均操作用作温和的低通滤波器（它去除较高频率，同时允许较低频率通过，因此得名）。因为它在反馈的路径中，所以具有逐渐衰减高次谐波同时保持低次谐波的效果，这与弹拨吉他弦的声音非常吻合。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h1><p>通过项目一，我学到了以下东西:</p><ul><li>如何构造出一个Deque API</li><li>package的用法</li><li>接口的创立</li><li>数列的一个使用实例</li><li>更高效的调试方法</li></ul><h2 id="困难复盘点"><a href="#困难复盘点" class="headerlink" title="困难复盘点:"></a>困难复盘点:</h2><h3 id="Linked-List-Deque-1"><a href="#Linked-List-Deque-1" class="headerlink" title="Linked List Deque"></a>Linked List Deque</h3><p>这个部分比较困难的是<code>add</code>和<code>remove</code>方法，刚开始会错意了，以为环状列表中，最后一个不指向哨兵节点导致一开始尝试错误。</p><p>后面比较麻烦的是<code>prev</code>和<code>next</code>的指向问题，我借助了可视化+调试慢慢得完善好。</p><h3 id="Array-Deque-1"><a href="#Array-Deque-1" class="headerlink" title="Array Deque"></a>Array Deque</h3><p>经常遇到<code>NullPointerException</code>或者<code>OutIndex</code>这些问题，于是使用了<strong>异常断点</strong><code>this instanceof NullPointerException</code>+可视化工具来和<strong>条件断点</strong>和<strong>恢复按钮</strong>判断出出错点</p><p>最困难的地方莫过于<code>resize方法</code>分<strong>扩大列表</strong>和缩小列表这两种情况来讨论。我的解决方法是先建立一个新的列表然后借助<code>System.arraycopy(src, srcPos, dest, destPos, length)</code>来快速得复制，其中复制的参数我根据可视化的列表图像和<code>nextFirst</code>和<code>item.length</code>慢慢得摸索，最终完成。</p><p>其中扩大列表应该分有多种扩增方法，我最开始是直接在后面扩增开了，导致<code>remove</code>方法无法找到解决方法，最后选择在<code>nextFirst</code>和<code>nextLast</code>中间扩增开，这样子remove的时候，<code>nextFirst</code>的值会慢慢的增加，然后成功删除掉首尾的值。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国矿业大学寒招介绍</title>
      <link href="/2024/01/26/%E7%9F%BF%E5%A4%A7%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/01/26/%E7%9F%BF%E5%A4%A7%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="学校基本介绍"><a href="#学校基本介绍" class="headerlink" title="学校基本介绍"></a>学校基本介绍</h1><div class="row">    <embed src="攻城狮入学秘籍.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="美照"><a href="#美照" class="headerlink" title="美照"></a>美照</h2><p><img src="/2024/01/26/%E7%9F%BF%E5%A4%A7%E4%BB%8B%E7%BB%8D/image-20240126201435433.png" alt="image-20240126201435433"><br><img src="/2024/01/26/%E7%9F%BF%E5%A4%A7%E4%BB%8B%E7%BB%8D/image-20240126201515111.png" alt="image-20240126201515111"></p><p><img src="/2024/01/26/%E7%9F%BF%E5%A4%A7%E4%BB%8B%E7%BB%8D/image-20240126201524308.png" alt="image-20240126201524308"><br><img src="/2024/01/26/%E7%9F%BF%E5%A4%A7%E4%BB%8B%E7%BB%8D/image-20240126201528737.png" alt="image-20240126201528737"><br><img src="/2024/01/26/%E7%9F%BF%E5%A4%A7%E4%BB%8B%E7%BB%8D/image-20240126201531917.png" alt="image-20240126201531917"></p><h1 id="广东省分数线介绍"><a href="#广东省分数线介绍" class="headerlink" title="广东省分数线介绍"></a>广东省分数线介绍</h1><p><img src="/2024/01/26/%E7%9F%BF%E5%A4%A7%E4%BB%8B%E7%BB%8D/963e7976544c87211d085232790d877.jpg" alt="963e7976544c87211d085232790d877"></p><h2 id="粗略版"><a href="#粗略版" class="headerlink" title="粗略版"></a>粗略版</h2><table><thead><tr><th>招生专业类</th><th>23-计划数</th><th>23-平均分</th><th>23-平均位次</th><th>22-计划数</th><th>22-平均分</th><th>22-平均位次</th><th>21-计划数</th><th>21-平均分</th><th>21-平均位次</th></tr></thead><tbody><tr><td>人工智能</td><td>6</td><td>608</td><td>21079</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>大数据管理与应用</td><td>2</td><td>607</td><td>21726</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>机器人工程</td><td>3</td><td>607</td><td>21726</td><td>2</td><td>599</td><td>22073</td><td></td><td></td><td></td></tr><tr><td>遥感科学与技术</td><td>4</td><td>606</td><td>22388</td><td>4</td><td>595</td><td>26470</td><td></td><td></td><td></td></tr><tr><td>计算机类</td><td>15</td><td>613</td><td>18163</td><td>15</td><td>604</td><td>18725</td><td>15</td><td>605</td><td>19989</td></tr><tr><td>电子信息类</td><td>12</td><td>609</td><td>20482</td><td>12</td><td>600</td><td>21339</td><td>12</td><td>598</td><td>24417</td></tr><tr><td>机械类</td><td>12</td><td>605</td><td>23074</td><td>10</td><td>598</td><td>22774</td><td>12</td><td>595</td><td>26470</td></tr><tr><td>安全科学与工程类</td><td>4</td><td>605</td><td>23074</td><td>5</td><td>596</td><td>25799</td><td></td><td></td><td></td></tr><tr><td>土木类</td><td>7</td><td>596</td><td>25799</td><td>4</td><td>596</td><td>25799</td><td>7</td><td>596</td><td>25799</td></tr><tr><td>建筑类</td><td>3</td><td>603</td><td>24424</td><td>2</td><td>599</td><td>23750</td><td>2</td><td>599</td><td>23750</td></tr><tr><td>数学类</td><td>4</td><td>599</td><td>23750</td><td>6</td><td>600</td><td>21339</td><td>4</td><td>599</td><td>23750</td></tr><tr><td>电气类</td><td>8</td><td>614</td><td>17633</td><td>8</td><td>601</td><td>22482</td><td>8</td><td>601</td><td>22482</td></tr><tr><td>物理学类</td><td>4</td><td>606</td><td>22388</td><td>2</td><td>601</td><td>22482</td><td></td><td></td><td></td></tr><tr><td>能源动力类</td><td>6</td><td>605</td><td>23074</td><td>6</td><td>597</td><td>23542</td><td>6</td><td>594</td><td>27190</td></tr><tr><td>应急管理</td><td>2</td><td>602</td><td>25108</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>金融学</td><td>3</td><td>604</td><td>23748</td><td>2</td><td>606</td><td>22073</td><td>5</td><td>593</td><td>27190</td></tr><tr><td>新能源材料与器件</td><td>2</td><td>609</td><td>20482</td><td>4</td><td>593</td><td>26493</td><td>5</td><td>594</td><td>27190</td></tr><tr><td>会计学</td><td>10</td><td>601</td><td>25783</td><td>16</td><td>594</td><td>27190</td><td>12</td><td>594</td><td>27190</td></tr><tr><td>化工与制药类</td><td>2</td><td>600</td><td>26467</td><td>4</td><td>591</td><td>28044</td><td>6</td><td>595</td><td>26470</td></tr><tr><td>人力资源管理</td><td>10</td><td>580</td><td>6643</td><td>16</td><td>594</td><td>27190</td><td>12</td><td>594</td><td>27190</td></tr><tr><td>行政管理</td><td>6</td><td>577</td><td>7285</td><td>4</td><td>580</td><td>7150</td><td></td><td></td><td></td></tr><tr><td>网络与新媒体</td><td>2</td><td>579</td><td>6826</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>汉语言文学</td><td>4</td><td>585</td><td>5663</td><td>4</td><td>581</td><td>6892</td><td>6</td><td>581</td><td>37607</td></tr><tr><td>英语</td><td>6</td><td>579</td><td>6826</td><td>6</td><td>581</td><td>37607</td><td>6</td><td>581</td><td>37607</td></tr><tr><td>土木工程（中外合作）</td><td>3</td><td>584</td><td>39149</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>建筑环境与能源应用工程(中外合作)</td><td>3</td><td>584</td><td>39149</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>工程力学</td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>环境设计</td><td>5</td><td>541</td><td>-</td><td>5</td><td>538</td><td>-</td><td>5</td><td>540</td><td>-</td></tr><tr><td>运动训练</td><td>2</td><td>78</td><td>-</td><td>2</td><td>78</td><td>-</td><td>2</td><td>78</td><td>-</td></tr></tbody></table><h1 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="Q-矿大保研率怎么样"><a href="#Q-矿大保研率怎么样" class="headerlink" title="Q:矿大保研率怎么样"></a>Q:矿大保研率怎么样</h2><p>A:矿大保研率基本上有15%那个样子</p><h2 id="Q-学校自不自由"><a href="#Q-学校自不自由" class="headerlink" title="Q:学校自不自由"></a>Q:学校自不自由</h2><p>A:上床下桌，不限功率不断电，无门禁，24小时可出入学校宿舍。</p><h2 id="Q-矿大饮食怎么样"><a href="#Q-矿大饮食怎么样" class="headerlink" title="Q:矿大饮食怎么样"></a>Q:矿大饮食怎么样</h2><p>A:矿大饮食基本上挺实惠的，我曾经0.01吃过一顿饭，而且学校里KFC，麦当劳，瑞幸，库迪，霸王茶姬等都有。</p><h2 id="Q-住宿条件怎么样"><a href="#Q-住宿条件怎么样" class="headerlink" title="Q:住宿条件怎么样"></a>Q:住宿条件怎么样</h2><p>A:<img src="/2024/01/26/%E7%9F%BF%E5%A4%A7%E4%BB%8B%E7%BB%8D/image-20240126201549159.png" alt="image-20240126201549159"></p><p>上床下桌，不限功率，不停电，独立浴室。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CS61B项目练习笔记(二)--Lab3</title>
      <link href="/2024/01/25/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-2-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab3/"/>
      <url>/2024/01/25/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-2-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab3/</url>
      
        <content type="html"><![CDATA[<p>经验点:</p><ul><li><code>Stopwatch</code>的使用</li><li>在类的两个实现之间执行比较测试。</li><li>随机调用类内部的方法。</li><li>在类的两个实现之间执行随机比较测试。</li><li>使用 IntelliJ 中的<strong>恢复按钮</strong>。</li><li>向断点添加条件。</li><li>创建<strong>异常断点</strong>。</li></ul><h1 id="Stopwatch库的使用"><a href="#Stopwatch库的使用" class="headerlink" title="Stopwatch库的使用"></a><code>Stopwatch</code>库的使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> timingtest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.Stopwatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hug.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopwatchDemo</span> &#123;</span><br><span class="line">    <span class="comment">/** Computes the nth Fibonacci number using a slow naive recursive strategy.*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stopwatch</span> <span class="variable">sw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stopwatch</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">fib41</span> <span class="operator">=</span> fib(<span class="number">41</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">timeInSeconds</span> <span class="operator">=</span> sw.elapsedTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;The 50th fibonacci number is &quot;</span> + fib41);</span><br><span class="line">        System.out.println(<span class="string">&quot;Time taken to compute 41st fibonacci number: &quot;</span> + timeInSeconds + <span class="string">&quot; seconds.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>import edu.princeton.cs.algs4.Stopwatch;</code>导入库</li><li><code> Stopwatch sw = new Stopwatch();</code>开始计时</li><li><code>double timeInSeconds = sw.elapsedTime();</code>结束计时，返回时间</li></ul><h1 id="在类的两个实现之间执行比较测试。"><a href="#在类的两个实现之间执行比较测试。" class="headerlink" title="在类的两个实现之间执行比较测试。"></a>在类的两个实现之间执行比较测试。</h1><p>测试代码的一种技术是进行“比较测试”。在这样的测试中，我们有两个相同类的实现。一个实现是已知的（或坚信的）是正确的，另一个正在开发中，尚未验证。</p><p>例如，我们提供了类 <code>AListNoResizing</code> 。此类不支持任何调整大小操作，只是具有 1000 的硬编码数组大小。这意味着它实际上没有用，因为它永远不能容纳超过 1000 个项目。但是，由于它非常简单，我们对它的工作充满信心。</p><p>相比之下，我们也提供了课程 <code>BuggyAList</code> 。此类具有一个基础数组，该数组会根据存储的数据量向上和向下调整大小。由于调整大小有点棘手，因此我们更加怀疑此类的正确性。顾名思义，它确实在某处有一个错误。本实验的其余部分的目标是找到此 bug。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> randomizedtest;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testThreeAddThreeRemove</span> &#123;</span><br><span class="line">    AListNoResizing&lt;Integer&gt; list_1 = <span class="keyword">new</span> <span class="title class_">AListNoResizing</span>&lt;&gt;();</span><br><span class="line">    BuggyAList&lt;Integer&gt; list_2 = <span class="keyword">new</span> <span class="title class_">BuggyAList</span>&lt;&gt;();</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_1</span><span class="params">()</span> &#123;</span><br><span class="line">        list_1.addLast(<span class="number">4</span>);</span><br><span class="line">        list_1.addLast(<span class="number">5</span>);</span><br><span class="line">        list_1.addLast(<span class="number">6</span>);</span><br><span class="line">        list_2.addLast(<span class="number">4</span>);</span><br><span class="line">        list_2.addLast(<span class="number">5</span>);</span><br><span class="line">        list_2.addLast(<span class="number">6</span>);</span><br><span class="line">        assertEquals(list_1.removeLast(), list_2.removeLast());</span><br><span class="line">        assertEquals(list_1.removeLast(), list_2.removeLast());</span><br><span class="line">        assertEquals(list_1.removeLast(), list_2.removeLast());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="随机函数调用"><a href="#随机函数调用" class="headerlink" title="随机函数调用"></a>随机函数调用</h1><p>原则上，可以仔细制作一组比较测试，最终找到错误。但是，另一种补充策略是使用随机方法，在该方法中，我们对两个实现进行随机调用，并使用 JUnit 方法来验证它们是否始终返回相同的值。</p><p>作为随机调用方法的函数示例，下面的代码随机调用 <code>AList</code> <code>addLast</code> 对象 <code>AListNoResizing</code> ， <code>size</code> 总共调用其中一个函数的 N 次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> randomizedtest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hug.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBuggyAList</span> &#123;</span><br><span class="line">  <span class="comment">// YOUR TESTS HERE</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">randomizedTest</span><span class="params">()</span> &#123;</span><br><span class="line">      AListNoResizing&lt;Integer&gt; correct = <span class="keyword">new</span> <span class="title class_">AListNoResizing</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">operationNumber</span> <span class="operator">=</span> StdRandom.uniform(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">          <span class="keyword">if</span> (operationNumber == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// addLast</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">randVal</span> <span class="operator">=</span> StdRandom.uniform(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">              correct.addLast(randVal);</span><br><span class="line">              System.out.println(<span class="string">&quot;addLast(&quot;</span> + randVal + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operationNumber == <span class="number">1</span>) &#123;</span><br><span class="line">              <span class="comment">// size</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> correct.size();</span><br><span class="line">              System.out.println(<span class="string">&quot;size: &quot;</span> + size);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="调试器功能-条件断点和恢复"><a href="#调试器功能-条件断点和恢复" class="headerlink" title="调试器功能-条件断点和恢复"></a>调试器功能-条件断点和恢复</h1><ol><li>在显示 的 <code>int operationNumber = StdRandom.uniform(0, 2);</code> 行上设置断点。</li><li>然后，使用 debug 选项在 IntelliJ 中的这一行停止。</li><li>单击可视化工具，您将看到一个包含大量空值的数组，这些空值最终将存储要添加到列表中的数据。</li><li>单击“单步执行”，您将看到 operationNumber 设置为 0 或 1。这是因为该 <code>StdRandom.uniform(0, 2)</code> 函数返回 [0， 2] 范围内的随机整数，即排除正确的参数。如果选择的数字为 0，则将在列表末尾添加一个随机数。如果选择的数字是 1，则将打印尺寸。</li><li>单击调试器上的 <code>resume</code> 按钮（下面以黄色突出显示），我们的代码将再次遇到它，命中断点。<img src="https://sp21.datastructur.es/materials/lab/lab3/img/resume_button.png" alt="folder structure"></li><li>尝试单击“恢复”几次，您将看到值开始填充数组。请注意，每次单击“恢复”时，代码都会运行（就像您多次按下单步执行一样），直到它再次返回到断点。</li><li>我们还可以从可视化工具切换回能够查看打印语句的输出。为此， <code>Debugger</code> 请再次单击（旁边 <code>Java Visualizer</code> ）并继续单击恢复。在某些计算机上，您可能需要单击 <code>Debugger</code> 而不是 <code>Console</code> 。单击“恢复”的每个类型，都会看到另一个 print 语句，对应于对 addLast 或 size 的调用。</li><li>现在让我们尝试一个条件断点。右键单击断点，您会看到一个弹出框，上面写着“条件：”。在框中，键入 <code>L.size() == 12</code> 。<img src="https://sp21.datastructur.es/materials/lab/lab3/img/conditional_breakpoint.png" alt="folder structure"></li><li>单击“恢复”，代码将一直运行，直到满足断点的条件，即大小为 12。尝试一下，然后单击可视化工具，您应该会看到大小现在为 12，数组中有 12 个项目。如果您不小心点击得太远，很遗憾，您必须重新启动测试。</li></ol><p>这两个新功能（恢复和条件断点）对实验 3 的其余部分没有用。但是，它们可能会在将来的项目中派上用场，您需要在实验 4 中使用它们。此时应删除条件断点，以便它不会影响实验室的其余部分。</p><h1 id="执行随机比较"><a href="#执行随机比较" class="headerlink" title="执行随机比较"></a>执行随机比较</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBuggyAList</span> &#123;</span><br><span class="line">  <span class="comment">// YOUR TESTS HERE</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">randomizedTest</span><span class="params">()</span> &#123;</span><br><span class="line">      AListNoResizing&lt;Integer&gt; correct = <span class="keyword">new</span> <span class="title class_">AListNoResizing</span>&lt;&gt;();</span><br><span class="line">      BuggyAList&lt;Integer&gt; broken = <span class="keyword">new</span> <span class="title class_">BuggyAList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">operationNumber</span> <span class="operator">=</span> StdRandom.uniform(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">          <span class="keyword">if</span> (operationNumber == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// addLast</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">randVal</span> <span class="operator">=</span> StdRandom.uniform(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">              correct.addLast(randVal);</span><br><span class="line">              broken.addLast(randVal);</span><br><span class="line">              System.out.println(<span class="string">&quot;addLast(&quot;</span> + randVal + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operationNumber == <span class="number">1</span>) &#123;</span><br><span class="line">              <span class="comment">// size</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> correct.size();</span><br><span class="line">              System.out.println(<span class="string">&quot;size: &quot;</span> + size);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operationNumber == <span class="number">2</span> &amp;&amp; correct.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="type">int</span> <span class="variable">last_num</span> <span class="operator">=</span> correct.getLast();</span><br><span class="line">              assertEquals(correct.removeLast(), broken.removeLast());</span><br><span class="line">              System.out.println(<span class="string">&quot;removeLast(&quot;</span> + last_num + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这就提出了一个关于随机测试的重要观点：如果你应用随机操作，并且这个错误相当模糊，你的随机操作序列可能无法检测到这个错误！有一些方法可以改进随机测试来避免这个问题，但这超出了我们课程的范围。</p><p>另一个注意事项：随机测试不应替代精心设计的单元测试！我个人通常倾向于在可能的情况下进行非随机测试，并将随机测试视为一种补充测试方法。有关此问题的辩论，请参阅此<a href="https://news.ycombinator.com/item?id=24349522">链接</a>。</p><h1 id="异常断点的使用"><a href="#异常断点的使用" class="headerlink" title="异常断点的使用"></a>异常断点的使用</h1><p>请单击“运行 -&gt; 查看断点”。您应该会看到一个类似这样的窗口弹出窗口：</p><p><img src="/2024/01/25/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-2-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab3/breakpoints.png" alt="folder structure"></p><p>单击左侧显示“任何例外”的复选框，然后单击显示“条件：”的复选框，然后在窗口中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this instanceof java.lang.ArrayIndexOutOfBoundsException</span><br></pre></td></tr></table></figure><p>完成此操作后，断点窗口应如下所示：</p><p><img src="/2024/01/25/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-2-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab3/breakpoints_filled_in.png" alt="folder structure"></p><p>单击“调试”按钮，代码应在异常即将发生时停止。单击可视化工具，并尝试找出代码崩溃的原因。现在可以开始真正的问题解决了！</p><p>注意：如果在未指定条件的情况下使用调试功能，则代码将停止在一些不同的神秘位置。确保在未指定条件的情况下，绝不会选中“任何异常”。这是因为启动 JUnit 测试的过程会生成一堆最终被忽略的异常。这远远超出了我们课程的范围。如果使用完执行断点，则应取消选中左上角的“Java Exceptions Breakpoints”框。</p><blockquote><p>答案:</p><p><img src="/2024/01/25/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-2-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab3/image-20240125222121979.png" alt="image-20240125222121979"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    Item[] a = (Item[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i += <span class="number">1</span>) &#123;</span><br><span class="line">        a[i] = items[i];</span><br><span class="line">    &#125;</span><br><span class="line">    items = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Item <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((size &lt; items.length / <span class="number">4</span>) &amp;&amp; (size &gt; <span class="number">4</span>)) &#123;</span><br><span class="line">            resize(size / <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Item</span> <span class="variable">x</span> <span class="operator">=</span> getLast();</span><br><span class="line">        items[size - <span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line">        size = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>观察可知，是<code>removeLast()</code>方法在传入<code>resize</code>方法值的时候过小，导致新收缩的数组太小，没办法存储所有原数组的值，答案为<code>resize(size / 4)</code>改为<code>resize(items.length / 4)</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(六)-数组基础的列表(2.4,2.5)</title>
      <link href="/2024/01/24/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-4-2-5/"/>
      <url>/2024/01/24/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-4-2-5/</url>
      
        <content type="html"><![CDATA[<p><a href="https://joshhug.gitbooks.io/hug61b/content/chap2/chap24.html">2.4 Arrays · Hug61B (gitbooks.io)</a></p><p><a href="https://joshhug.gitbooks.io/hug61b/content/chap2/chap25.html">2.5 The AList · Hug61B (gitbooks.io)</a></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组基础"><a href="#数组基础" class="headerlink" title="数组基础"></a>数组基础</h2><p>数组是一种特殊类型的对象，它由一系列编号的内存盒组成。这与类实例不同，类实例具有命名的内存盒。为了得到数组的第i个元素，我们使用了在HW 0和Project 0中看到的括号表示法，例如 <code>A[i]</code> 得到A的第 <code>i</code> 个元素。</p><p>数组包括：</p><ul><li>一个固定的整数长度N</li><li>一个由N个存储器盒组成的序列（N &#x3D;长度），其中所有盒都是相同类型的，编号为0到N - 1。</li></ul><blockquote><p>和类不同，数组没有方法</p></blockquote><h3 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h3><ul><li><code>x = new int[3];</code></li><li><code>y = new int[]&#123;1, 2, 3, 4, 5&#125;;</code></li><li><code>int[] z = &#123;9, 10, 11, 12, 13&#125;;</code></li></ul><p>所有这三种表达法都创建了一个数组。</p><p>第一种表示法，用于创建 <code>x</code> ，将创建一个指定长度的数组，并使用默认值填充每个内存框。在本例中，它将创建一个长度为3的数组，并使用默认值 <code>int</code> <code>0</code> 填充3个框中的每一个。</p><p>第二种表示法，用于创建 <code>y</code> ，创建一个数组，其大小正好可以容纳指定的起始值。在本例中，它创建了一个长度为5的数组，其中包含这五个特定的元素。</p><p>第三种表示法用于声明和创建 <code>z</code> ，其行为与第二种表示法相同。唯一的区别是它省略了 <code>new</code> 的用法，并且只能在与变量声明组合时使用。</p><blockquote><p>这些符号没有一个比其他符号更好。</p></blockquote><h3 id="数组的访问和修改"><a href="#数组的访问和修改" class="headerlink" title="数组的访问和修改"></a>数组的访问和修改</h3><p>下面的代码展示了我们将用于处理数组的所有关键语法。试着单步执行下面的代码，并确保您理解每行执行时会发生什么。为此，请<a href="https://cscircles.cemc.uwaterloo.ca/java_visualize/#">单击此处</a>查看交互式可视化。除了最后一行代码之外，我们以前见过所有这些语法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] z = <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span>[] x, y;</span><br><span class="line"></span><br><span class="line">x = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">y = x;</span><br><span class="line">x = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">99</span>&#125;;</span><br><span class="line">y = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">z = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">xL</span> <span class="operator">=</span> x.length;</span><br><span class="line"></span><br><span class="line">String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">6</span>];</span><br><span class="line">s[<span class="number">4</span>] = <span class="string">&quot;ketchup&quot;</span>;</span><br><span class="line">s[x[<span class="number">3</span>] - x[<span class="number">1</span>]] = <span class="string">&quot;muffins&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] b = &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line">System.arraycopy(b, <span class="number">0</span>, x, <span class="number">3</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>最后一行演示了一种将信息从一个数组复制到另一个数组的方法。 <code>System.arraycopy</code> 有五个参数：</p><ul><li>用作源的数组</li><li>在源数组中从何处开始</li><li>用作目标的阵列</li><li>在目标阵列中从何处开始</li><li>要复制多少项</li></ul><p>对于Python老手来说， <code>System.arraycopy(b, 0,x, 3, 2)</code> 相当于Python中的 <code>x[3:5] = b[0:2]</code> 。</p><p>复制数组的另一种方法是使用循环。 <code>arraycopy</code> 通常比循环更快，并导致更紧凑的代码。唯一的缺点是 <code>arraycopy</code> （可以说）更难阅读。请注意，Java数组只在运行时执行边界检查。也就是说，下面的代码可以很好地编译，但是会在运行时崩溃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] x = &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] y = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; x.length) &#123;</span><br><span class="line">    y[i] = x[i];</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>容易数组越界</p></blockquote><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>Java中所谓的2D数组实际上只是一个数组的数组。它们遵循我们已经学习过的对象的相同规则，但是让我们回顾一下它们，以确保我们理解它们是如何工作的。</p><p>数组的数组的数组可能有点混乱。代码 <code>int[][] bamboozle = new int[4][]</code> 这将创建一个名为 <code>bamboozle</code> 的整数数组数组。具体来说，这正好创建了四个内存盒，每个内存盒都可以指向一个整数数组（长度未指定）。</p><p>尝试逐行运行下面的代码，看看结果是否符合你的直觉。如需交互式可视化，请<a href="https://cscircles.cemc.uwaterloo.ca/java_visualize/#">单击此处</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] pascalsTriangle;</span><br><span class="line">pascalsTriangle = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][];</span><br><span class="line"><span class="type">int</span>[] rowZero = pascalsTriangle[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">pascalsTriangle[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>&#125;;</span><br><span class="line">pascalsTriangle[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">pascalsTriangle[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">pascalsTriangle[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] rowTwo = pascalsTriangle[<span class="number">2</span>];</span><br><span class="line">rowTwo[<span class="number">1</span>] = -<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] matrix;</span><br><span class="line">matrix = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][];</span><br><span class="line">matrix = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] pascalAgain = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                                 &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>答案:<code>x[0][0]: -1, w[0][0]: 1</code></p></blockquote><h2 id="数组-vs-类"><a href="#数组-vs-类" class="headerlink" title="数组 vs 类"></a>数组 vs 类</h2><p>数组和类都可以用来组织一堆内存盒。在这两种情况下，内存盒的数量是固定的，即数组的长度不能改变，就像类字段不能添加或删除一样。</p><p>数组和类中内存盒的主要区别：</p><ul><li>数组框使用 <code>[]</code> 表示法编号和访问，类框使用点表示法命名和访问。</li><li>数组框必须全部为同一类型。类框可以是不同的类型。</li></ul><p>这些差异的一个特别显著的影响是， <code>[]</code> 表示法允许我们指定我们在运行时想要的索引。例如，考虑下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">indexOfInterest</span> <span class="operator">=</span> askUserForInteger();</span><br><span class="line"><span class="type">int</span>[] x = &#123;<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> x[indexOfInterest];</span><br><span class="line">System.out.println(k);</span><br></pre></td></tr></table></figure><p>如果我们运行这段代码，我们可能会得到这样的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ javac arrayDemo</span><br><span class="line">$ java arrayDemo</span><br><span class="line">What index do you want? 2</span><br><span class="line">102</span><br></pre></td></tr></table></figure><p>相比之下，在类中指定字段不是我们在运行时做的事情。例如，考虑下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">fieldOfInterest</span> <span class="operator">=</span> <span class="string">&quot;mass&quot;</span>;</span><br><span class="line"><span class="type">Planet</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Planet</span>(<span class="number">6e24</span>, <span class="string">&quot;earth&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">mass</span> <span class="operator">=</span> p[fieldOfInterest];</span><br></pre></td></tr></table></figure><p>如果我们试着编译它，我们会得到一个语法错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ javac classDemo</span><br><span class="line">FieldDemo.java:5: error: array required, but Planet found</span><br><span class="line">        double mass = earth[fieldOfInterest];        </span><br><span class="line">                               ^</span><br></pre></td></tr></table></figure><p>如果我们尝试使用点表示法，也会出现同样的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">fieldOfInterest</span> <span class="operator">=</span> <span class="string">&quot;mass&quot;</span>;</span><br><span class="line"><span class="type">Planet</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Planet</span>(<span class="number">6e24</span>, <span class="string">&quot;earth&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">mass</span> <span class="operator">=</span> p.fieldOfInterest;</span><br></pre></td></tr></table></figure><p>编译，我们会得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ javac classDemo</span><br><span class="line">FieldDemo.java:5: error: cannot find symbol</span><br><span class="line">        double mass = earth.fieldOfInterest;        </span><br><span class="line">                           ^</span><br><span class="line">  symbol:   variable fieldOfInterest</span><br><span class="line">  location: variable earth of type Planet</span><br></pre></td></tr></table></figure><p>这并不是你经常会遇到的限制，但值得指出，只是为了获得好的奖学金。值得一提的是，有一种方法可以在运行时指定所需的字段，称为反射，但它被认为是典型程序的非常糟糕的编码风格。你可以在<a href="https://docs.oracle.com/javase/tutorial/reflect/member/fieldValues.html">here</a>阅读更多关于反射的内容。<strong>你永远不应该在任何61B程序中使用反射，我们不会在我们的课程中讨论它。</strong></p><p>一般来说，编程语言的部分设计是为了限制程序员的选择，使代码更容易推理。通过将这些特性限制在特殊的Reflections API中，我们使典型的Java程序更易于阅读和解释。</p><h2 id="附录：Java数组与其他语言"><a href="#附录：Java数组与其他语言" class="headerlink" title="附录：Java数组与其他语言"></a>附录：Java数组与其他语言</h2><p>与其他语言中的数组相比，Java数组：</p><ul><li>没有特殊的“切片”语法（比如Python）。</li><li>不能收缩或展开（例如在Ruby中）。</li><li>不要有成员方法（例如在JavaScript中）。</li><li>必须只包含相同类型的值（与Python不同）。</li></ul><h1 id="AList"><a href="#AList" class="headerlink" title="AList"></a>AList</h1><p>在我们之前实现的<code>DLList</code>中，如果我们使用<code>get()</code>方法，与数组为基础的列表相比，它会非常的慢。这是因为，由于我们只有对列表的第一项和最后一项的引用，因此我们始终需要从前面或后面遍历列表才能找到我们尝试检索的项目。例如，如果我们想在长度为 10,000 的列表中获取项目 #417，我们必须遍历 417 个转发链接才能找到我们想要的项目。</p><p>在最坏的情况下，该项目位于最中间，我们需要浏览与列表长度成比例的多个项目（具体来说，项目数除以 2）。换言之，最坏情况下的 <code>get</code> 执行时间与整个列表的大小呈线性关系。这与 的 <code>getBack</code> 运行时形成鲜明对比，无论列表的大小如何，它都是恒定的。在本课程的后面，我们将根据大 O 和大 Theta 表示法正式定义运行时。现在，我们将坚持非正式的理解。</p><h2 id="AList的实现-初版"><a href="#AList的实现-初版" class="headerlink" title="AList的实现(初版)"></a>AList的实现(初版)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Array based list.</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span> Josh Hug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AList</span> &#123;</span><br><span class="line">    <span class="comment">/** Creates an empty list. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] item;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AList</span><span class="params">()</span> &#123;</span><br><span class="line">        item = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts X into the back of the list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        item[size] = x;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns the item from the back of the list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Gets the ith item in the list (0 is the front). */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns the number of items in the list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Deletes item from back of the list and</span></span><br><span class="line"><span class="comment">     * returns deleted item. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        cur_item = getLast();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> cur_item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这段代码存在一个问题，如果我们创建的列表实际大小比100大，会导致越界，若我们增加一开始的<code>item</code>数组的大小，又会造成空间内存的浪费。</p><h2 id="调节数组大小"><a href="#调节数组大小" class="headerlink" title="调节数组大小"></a>调节数组大小</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">    System.arraycopy(items, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    item = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == item.length) &#123;</span><br><span class="line">        resize(size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    items[size] = x;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 从一个大小为 100 的数组开始，如果我们调用 <code>addLast</code> 1,000 次，大约会创建和填充500,000个内存盒</p><p>创建所有这些存储盒并重新复制其内容需要时间。在下图中，我们在顶部绘制了 SLList 的总时间与操作次数的关系，在底部绘制了基于朴素数组的列表的总时间与操作次数的关系。SLList 显示一条直线，这意味着对于每个 <code>add</code> 操作，列表需要相同的额外时间。这意味着每个操作都需要恒定的时间！你也可以这样想：图形是线性的，表明每个操作都需要恒定的时间，因为常数的积分是一条线。</p><p>相比之下，朴素数组列表显示抛物线，表明每个操作都需要线性时间，因为直线的积分是抛物线。这对现实世界具有重大影响。对于插入 100,000 个项目，我们可以通过计算 N^2&#x2F;N 的比率来粗略计算多长时间。 将 100,000 个项目插入到我们基于数组的列表中需要 （100,000^2）&#x2F;100,000 或 100,000 倍的时间。这显然是不能接受的。</p><p><img src="/2024/01/24/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-4-2-5/insert_experiment.png" alt="fig25/insert_experiment.png"></p><p>这就非常的慢了</p><h3 id="方法二——几何大小调整"><a href="#方法二——几何大小调整" class="headerlink" title="方法二——几何大小调整"></a>方法二——几何大小调整</h3><p>我们可以通过增加数组的大小来增加我们的性能问题，而不是增加一个加法量。也就是说，与其添加等于某个调整大小因子 <code>RFACTOR</code> 的内存盒数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertBack</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == item.length) &#123;</span><br><span class="line">           resize(size + RFACTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    items[size] = x;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相反，我们通过将框数乘以 <code>RFACTOR</code> 来调整大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertBack</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == item.length) &#123;</span><br><span class="line">           resize(size * RFACTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    items[size] = x;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重复我们之前的计算实验，我们看到我们的新 <code>AList</code> 插件在很短的时间内完成了 100,000 个插入，以至于我们甚至没有注意到。我们将推迟到本书的最后一章对为什么会发生这种情况进行全面分析。</p><h2 id="内存性能"><a href="#内存性能" class="headerlink" title="内存性能"></a>内存性能</h2><p>我们 <code>AList</code> 几乎完成了，但我们有一个主要问题。假设我们插入 1,000,000,000 个项目，然后删除 990,000,000 个项目。在这种情况下，我们将只使用 10,000,000 个内存盒，剩下 99% 完全未使用。</p><p>为了解决这个问题，我们还可以在数组开始看起来为空时缩小数组的大小。具体来说，我们定义了一个“使用比率”R，它等于列表的大小除以 <code>items</code> 数组的长度。例如，在下图中，使用率为0.04。</p><p>在典型的实现中，当 R 降至小于 0.25 时，我们将数组的大小减半。</p><h2 id="泛型AList"><a href="#泛型AList" class="headerlink" title="泛型AList"></a>泛型AList</h2><p>就像我们之前所做的那样，我们可以修改我们的 <code>AList</code> ，以便它可以保存任何数据类型，而不仅仅是整数。为此，我们再次在类中使用特殊的角括号表示法，并在适当的情况下将任意类型参数替换为整数。例如，在下面，我们用作 <code>Glorp</code> 类型参数。</p><p>有一个显著的语法差异：Java 不允许我们创建泛型对象数组，因为泛型的实现方式存在一个模糊的问题。也就是说，我们不能做这样的事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glorp[] items = <span class="keyword">new</span> <span class="title class_">Glorp</span>[<span class="number">8</span>];</span><br></pre></td></tr></table></figure><p>相反，我们必须使用如下所示的笨拙语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glorp[] items = (Glorp []) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">8</span>];</span><br></pre></td></tr></table></figure><p>这将产生一个编译警告，但这只是我们必须忍受的事情。我们将在后面的章节中更详细地讨论这一点。</p><p>我们所做的另一个更改是，<strong>我们将“删除”的任何项目都清空。</strong>以前，我们没有理由将已删除的元素清零，而使用泛型对象，我们确实希望清空对所存储对象的引用。这是为了避免“游荡”。回想一下，Java 仅在最后一个引用丢失时销毁对象。如果我们未能清空引用，那么 Java 将不会对已添加到列表中的对象进行垃圾回收。</p><blockquote><p>因为我们使用泛型对象时，相比之前的int对象，我们的列表的内存盒是指向某个对象的引用，若我们没有清空的话，该对象的内存还是会堆叠在内存中，不会被Java垃圾回收。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(五)--链表基础的列表(2.2,2.3)</title>
      <link href="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/"/>
      <url>/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://joshhug.gitbooks.io/hug61b/content/chap2/chap22.html">2.2 SLList ·拥抱61B — 2.2 The SLList · Hug61B (gitbooks.io)</a></p><p><a href="https://joshhug.gitbooks.io/hug61b/content/chap2/chap23.html">2.3 DLList ·拥抱61B — 2.3 The DLList · Hug61B (gitbooks.io)</a></p><h1 id="SLLists"><a href="#SLLists" class="headerlink" title="SLLists"></a>SLLists</h1><p>在第 2.1 章中，我们构建了类 <code>IntList</code> ，这是一个列表数据结构，从技术上讲，它可以完成列表可以执行的所有操作。然而，在实践中，它 <code>IntList</code> 使用起来相当笨拙，导致代码难以阅读和维护。</p><p>从根本上说，问题在于 <code>IntList</code> 这就是我所说的裸递归数据结构。为了正确使用递归，程序员必须理解和利用递归，即使是简单的列表相关任务。这限制了它对新手程序员的有用性，并可能引入一类全新的棘手错误，程序员可能会遇到这些错误，具体取决于该 <code>IntList</code> 类提供的帮助程序方法类型。</p><h2 id="初级版本"><a href="#初级版本" class="headerlink" title="初级版本:"></a>初级版本:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">        <span class="keyword">public</span> IntNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span> &#123;</span><br><span class="line">            item = i;</span><br><span class="line">            next = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IntNode first; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item to the front of the list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, first);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Retrieves the front item from the list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item to the end of the list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">/* Your Code Here! */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns the number of items in the list using recursion. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/* Your Code Here! */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IntList和SLList的比较"><a href="#IntList和SLList的比较" class="headerlink" title="IntList和SLList的比较"></a>IntList和SLList的比较</h1><h2 id="创建："><a href="#创建：" class="headerlink" title="创建："></a>创建：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntList</span> <span class="variable">L1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">5</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="type">SLList</span> <span class="variable">L2</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><blockquote><p>隐藏 <code>SLList</code> 用户存在空链接的详细信息。</p></blockquote><h2 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h2><h3 id="SLList"><a href="#SLList" class="headerlink" title="SLList:"></a>SLList:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SLList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>(<span class="number">15</span>);</span><br><span class="line">L.addFirst(<span class="number">10</span>);</span><br><span class="line">L.addFirst(<span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> L.getFirst();</span><br></pre></td></tr></table></figure><h3 id="IntList"><a href="#IntList" class="headerlink" title="IntList:"></a>IntList:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">15</span>, <span class="literal">null</span>);</span><br><span class="line">L = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">10</span>, L);</span><br><span class="line">L = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">5</span>, L);</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> L.first;</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>直观地比较这两种数据结构，我们有：（ <code>IntList</code> 版本在顶部， <code>SLList</code> 版本在下方）</p><p><img src="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/IntList_vs_SLList.png" alt="IntList_vs_SLList.png"></p><p>从本质上讲，该 <code>SLList</code> 类充当列表用户和裸递归数据结构之间的中间人。如上 <code>IntList</code> 所述， <code>IntList</code> 用户具有指向 <code>IntList</code> .正如奥维德所说：凡人不能在不死的情况下注视神，所以也许最好在那里 <code>SLList</code> 充当我们的中间人。</p><blockquote><p>SLList提高了代码的抽象性，只提供接口出来，而不是提供具有风险的裸数据<code>first</code>来获取。</p></blockquote><h3 id="公有与私有"><a href="#公有与私有" class="headerlink" title="公有与私有"></a>公有与私有</h3><p>IntList的数据皆为public，没有预留接口来调用。</p><p>如果SLList数据也皆为public，那么可以绕过接口直接获取，具有一定风险。</p><p>私有变量和方法只能通过同一 <code>.java</code> 文件中的代码访问，例如在本例 <code>SLList.java</code> 中。这意味着像 <code>SLLTroubleMaker</code> 下面的类将无法编译，从而产生 <code>first has private access in SLList</code> 错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLLTroubleMaker</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SLList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>(<span class="number">15</span>);</span><br><span class="line">        L.addFirst(<span class="number">10</span>);</span><br><span class="line">        L.first.next.next = L.first.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比之下， <code>SLList.java</code> 文件内的任何代码都能够访问该 <code>first</code> 变量。</p><p>限制访问似乎有点愚蠢。毕竟， <code>private</code> 关键字唯一要做的就是破坏原本编译的程序。然而，在大型软件工程项目中， <code>private</code> 关键字是一个非常宝贵的信号，表明最终用户应该忽略某些代码片段（因此不需要理解）。同样，关键字 <code>public</code> 应该被看作是一种方法可用的声明，并且将永远像现在一样工作。</p><p>打个比方，汽车具有某些 <code>public</code> 功能，例如油门和制动踏板。在引擎盖下，有 <code>private</code> 关于它们如何运作的详细信息。在汽油动力汽车中，油门踏板可以控制某种燃油喷射系统，而在电池供电的汽车中，它可以调整输送到电机的电池电量。虽然私人细节可能因汽车而异，但我们预计所有油门踏板都有相同的行为。更改这些会引起用户的极大恐慌，并且很可能会发生可怕的事故。</p><h1 id="SList的改进"><a href="#SList的改进" class="headerlink" title="SList的改进"></a>SList的改进</h1><h2 id="嵌套IntNode类"><a href="#嵌套IntNode类" class="headerlink" title="嵌套IntNode类"></a>嵌套IntNode类</h2><blockquote><p>由IntList改名而来</p></blockquote><p>目前，我们有两个 <code>.java</code> 文件： <code>IntNode</code> 和 <code>SLList</code> .然而，这真的 <code>IntNode</code> 只是故事中的一个配角 <code>SLList</code> 。</p><p>在这种情况下，Java 为我们提供了将一个类声明嵌入到另一个类声明中的能力。语法简单直观：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">            <span class="keyword">public</span> IntNode next;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span> &#123;</span><br><span class="line">                item = i;</span><br><span class="line">                next = n;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> IntNode first; </span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">           first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">       &#125; </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>嵌套类对代码性能没有有意义的影响，只是保持代码井井有条的工具。有关嵌套类的更多信息，请参阅 Oracle 的官方文档。</p><p>如果嵌套类不需要使用 <code>SLList</code> 的任何实例方法或变量，则可以声明嵌套类 <code>static</code> ，如下所示。将嵌套类声明为 意味着 <code>static</code> 静态类中的方法不能访问封闭类的任何成员。在这种情况下，这意味着 中 <code>IntNode</code> 的任何方法都无法访问 <code>first</code> 、 <code>addFirst</code> 或 <code>getFirst</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">            <span class="keyword">public</span> IntNode next;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span> &#123;</span><br><span class="line">                item = i;</span><br><span class="line">                next = n;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> IntNode first;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样可以节省一些内存，因为每个 <code>IntNode</code> 都不再需要跟踪如何访问其封闭 <code>SLList</code> 式 .</p><p>换句话说，如果你检查上面的代码，你会发现该 <code>IntNode</code> 类从不使用 <code>SLList</code> 的 <code>first</code> 变量 ，也不使用 <code>SLList</code> 的任何方法。因此，我们可以使用 static 关键字，这意味着该 <code>IntNode</code> 类不会引用其 boss，从而节省了少量内存。</p><h3 id="一个简单的经验法则是，如果不使用外部类的任何实例成员，请使嵌套类成为静态类。"><a href="#一个简单的经验法则是，如果不使用外部类的任何实例成员，请使嵌套类成为静态类。" class="headerlink" title="一个简单的经验法则是，如果不使用外部类的任何实例成员，请使嵌套类成为静态类。"></a><strong>一个简单的经验法则是，如果不使用外部类的任何实例成员，请使嵌套类成为静态类。</strong></h3><h2 id="addLast-and-size"><a href="#addLast-and-size" class="headerlink" title="addLast() and size()"></a>addLast() and size()</h2><h3 id="addLast"><a href="#addLast" class="headerlink" title="addLast()"></a>addLast()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Adds an item to the end of the list. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advance p to the end of the list. */</span></span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 于 <code>IntList</code> 的 <code>size</code> 递归调用很简单： <code>return 1 + this.rest.size()</code> .对于一个 <code>SLList</code> ，这种方法是没有意义的。 <code>SLList</code> 没有 <code>rest</code> 变量。取而代之的是，我们将使用一种与中间人类一起使用的通用模式，例如 <code>SLList</code> – 我们将创建一个私有帮助程序方法，该方法与底层的裸递归数据结构进行交互。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Returns the size of the list starting at IntNode p. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">(IntNode p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + size(p.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们有两个方法，都命名为 <code>size</code> .这在 Java 中是允许的，因为它们具有不同的参数。我们说两个名称相同但签名不同的方法被重载。有关重载方法的更多信息，请参阅 Java 的官方文档。</p><p>另一种方法是在 <code>IntNode</code> 类本身中创建非静态帮助程序方法。这两种方法都很好，尽管我个人更喜欢 <code>IntNode</code> 在类中没有任何方法。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>我们可以发现，当我们需要得到size的值的时候都会重新调用一遍<code>size()</code>函数，这对性能有一定的影响，</p><p>假设在大小为 1,000 的列表 <code>size</code> 上需要 2 秒。我们预计，在大小为 1,000,000 的列表中，该 <code>size</code> 方法将需要 2,000 秒，因为计算机必须单步执行列表中 1,000 倍的项目才能到达末尾。对于大型列表来说，使用非常 <code>size</code> 慢的方法是不可接受的，因为我们可以做得更好。</p><p>为此，我们可以简单地将一个 <code>size</code> 变量添加到跟踪当前大小的 <code>SLList</code> 类中，从而生成下面的代码。这种保存重要数据以加快检索速度的做法有时称为**缓存(caching)**。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">    ... <span class="comment">/* IntNode declaration omitted. */</span></span><br><span class="line">    <span class="keyword">private</span> IntNode first;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, first);</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种修改使我们 <code>size</code> 的方法非常快，无论列表有多大。当然，它也会减慢我们的 <code>addFirst</code> 和 <code>addLast</code> 方法的速度，也会增加我们类的使用记忆，但只是微不足道的量。在这种情况下，权衡显然有利于创建大小缓存。</p><h2 id="空列表构造引发的空指针异常"><a href="#空列表构造引发的空指针异常" class="headerlink" title="空列表构造引发的空指针异常"></a>空列表构造引发的空指针异常</h2><p>我们能够轻松实现一个创建空列表的构造函数。最自然的方法是设置为 <code>first</code> <code>null</code> 如果列表为空。这将产生以下构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">()</span> &#123;</span><br><span class="line">    first = <span class="literal">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不幸的是，如果我们插入到一个空列表中，这会导致我们 <code>addLast</code> 的方法崩溃。由于 <code>first</code> 是 <code>null</code> ，尝试访问 <code>p.next</code> <code>while (p.next != null)</code> 下面会导致空指针异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">    <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> first;</span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空列表解决方法—哨兵节点"><a href="#空列表解决方法—哨兵节点" class="headerlink" title="空列表解决方法—哨兵节点"></a>空列表解决方法—哨兵节点</h2><p>有两种解决方案</p><h3 id="一-为addLast-添加一种特殊情况处理"><a href="#一-为addLast-添加一种特殊情况处理" class="headerlink" title="(一)为addLast()添加一种特殊情况处理"></a>(一)为<code>addLast()</code>添加一种特殊情况处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> first;</span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此解决方案有效，但在必要时应避免使用上面所示的特殊情况代码。人类只有这么多的工作记忆，因此我们希望尽可能地控制复杂性。对于像 这样的简单数据结构 <code>SLList</code> ，特殊情况的数量很少。更复杂的数据结构（如树）可能会变得更加丑陋。</p><h3 id="二-哨兵节点"><a href="#二-哨兵节点" class="headerlink" title="(二)哨兵节点"></a>(二)哨兵节点</h3><p>一个更干净的，虽然不那么明显的解决方案是让它变得 <code>SLLists</code> “相同”，即使它们是空的。我们可以通过创建一个始终存在的特殊节点来做到这一点，我们称之为哨兵节点。哨兵节点将持有一个值，我们不会关心它。</p><p>例如，创建的 <code>SLList L = new SLList()</code> 空列表如下所示：</p><p><img src="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/empty_sentinelized_SLList.png" alt="empty_sentinelized_SLList.png"></p><p>具有项目 5、10 和 15 的 a <code>SLList</code> 如下所示：</p><p><img src="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/three_item_sentenlized_SLList.png" alt="three_item_sentenlized_SLList.png"></p><p>由于 <code>SLList</code> 没有哨兵没有特殊情况，我们可以简单地从我们 <code>addLast</code> 的方法中删除特殊情况，从而得到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">    <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> sentinel;</span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不变量"><a href="#不变量" class="headerlink" title="不变量"></a>不变量</h2><p>不变性是<strong>关于数据结构的事实</strong>，它保证为真（假设代码中没有错误）。</p><p>具有哨兵节点的 A <code>SLList</code> 至少具有以下不变量：</p><ul><li>引用 <code>sentinel</code> 始终指向哨兵节点。</li><li>前面的项（如果存在）始终位于 <code>sentinel.next.item</code> 。</li><li>该 <code>size</code> 变量始终是已添加的项的总数。</li></ul><p>不变量使推理代码变得更加容易，并且还为您提供了在确保代码正常工作方面要努力实现的具体目标。</p><h1 id="SList最终版本"><a href="#SList最终版本" class="headerlink" title="SList最终版本"></a>SList最终版本</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">        <span class="keyword">public</span> IntNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span> &#123;</span><br><span class="line">            item = i;</span><br><span class="line">            next = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IntNode sentinel;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">()</span> &#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> <span class="title class_">IntNode</span>(<span class="number">99</span>, <span class="literal">null</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> <span class="title class_">IntNode</span>(<span class="number">99</span>, <span class="literal">null</span>);</span><br><span class="line">        sentinel.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, sentinel.next);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item to the front of the list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        sentinel.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, sentinel.next);</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Retrieves the front item from the list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sentinel.next.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns the number of items in the list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item to the end of the list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        <span class="comment">/* Advance p to the end of the list. */</span></span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Crashes when you call addLast on an empty SLList. Fix it. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SLList</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>();</span><br><span class="line">        x.addLast(<span class="number">5</span>);</span><br><span class="line">        x.addLast(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DLLists"><a href="#DLLists" class="headerlink" title="DLLists"></a>DLLists</h1><h2 id="addLast-1"><a href="#addLast-1" class="headerlink" title="addLast"></a>addLast</h2><p>考虑上面 <code>addLast(int x)</code> 中的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">    <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> sentinel;</span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法的问题在于它很慢。对于一个很长的列表，该 <code>addLast</code> 方法必须遍历整个列表，就像我们在第 2.2 章中看到的方法 <code>size</code> 一样。同样，我们可以尝试通过添加变量 <code>last</code> 来加快代码速度，如下所示</p><p>考虑表示上述实现的 <code>SLList</code> 框和指针图，其中包括最后一个指针。假设我们想要支持 <code>addLast</code> 、 <code>getLast</code> 和 <code>removeLast</code> 操作。所示结构是否支持快速 <code>addLast</code> 、 <code>getLast</code> 和 <code>removeLast</code> 操作？如果不是，哪些操作很慢？</p><blockquote><p><code>addLast</code> 会很快，但 <code>getLast</code> <code>removeLast</code> 会很慢。这是因为在删除最后一个节点后，我们没有简单的方法来获取倒数第二个节点来更新 <code>last</code> 指针。</p></blockquote><h2 id="SecondToLast"><a href="#SecondToLast" class="headerlink" title="SecondToLast"></a>SecondToLast</h2><p>结构的问题在于，删除列表中最后一项的方法本身会很慢。这是因为我们需要首先找到倒数第二项，然后将其下一个指针设置为 null。添加 <code>secondToLast</code> 指针也无济于事，因为这样我们就需要找到列表中倒数第三项，以确保 <code>secondToLast</code> 在删除最后一项后 <code>last</code> 遵守适当的不变量</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><h3 id="添加prev指针"><a href="#添加prev指针" class="headerlink" title="添加prev指针"></a>添加prev指针</h3><p>解决此问题的最自然方法是为每个 添加一个前一个指针 <code>IntNode</code> ，即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> IntNode prev;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">public</span> IntNode next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换句话说，我们的列表现在每个节点都有两个链接。此类列表的一个常见术语是“双向链表”，我们简称为 a <code>DLList</code> 。这与第 2.2 章中的单个链表形成鲜明对比，又名 <code>SLList</code> .</p><p>添加这些额外的指针将导致额外的代码复杂性。您将在项目 1 中自行构建一个双向链表，而不是引导您完成它。下面的框图和指针图分别更精确地显示了大小为 0 和大小为 2 的列表的双向链表的外观。</p><p><img src="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/dllist_basic_size_0.png" alt="dllist_basic_size_0.png"></p><p><img src="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/dllist_basic_size_2.png" alt="dllist_basic_size_2.png"></p><h3 id="哨兵-Sentinel-改进"><a href="#哨兵-Sentinel-改进" class="headerlink" title="哨兵(Sentinel )改进"></a>哨兵(Sentinel )改进</h3><p>后退指针允许列表支持在恒定时间内添加、获取和删除列表的正面和背面。这种设计存在一个微妙的问题， <code>last</code> 指针有时指向哨兵节点，有时指向真实节点。就像 的非哨兵版本一样 <code>SLList</code> ，这会导致具有特殊情况的代码比我们在第 8 次也是最后一次改进后得到的代码要丑陋得多。（你能想到什么 <code>DLList</code> 方法会有这些特殊情况吗？</p><p><img src="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/image-20240122183046374.png" alt="image-20240122183046374"></p><blockquote><p>对于每个方法我们都要用if语句检查一下last指向的是不是哨兵节点，这就很麻烦。</p></blockquote><p>一种解决方法是将第二个哨兵节点添加到列表的后面。这导致拓扑如下所示，显示为框和指针图。</p><p><img src="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/dllist_double_sentinel_size_0.png" alt="dllist_double_sentinel_size_0.png"></p><p><img src="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/dllist_double_sentinel_size_2.png" alt="dllist_double_sentinel_size_2.png"></p><p>另一种方法是实现列表，使其呈圆形，前指针和后指针共享同一哨兵节点。</p><p><img src="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/dllist_circular_sentinel_size_0.png" alt="dllist_circular_sentinel_size_0.png"></p><p><img src="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/dllist_circular_sentinel_size_2.png" alt="dllist_circular_sentinel_size_2.png"></p><p>双哨兵和圆形哨兵方法都有效，并产生没有丑陋特殊情况的代码，尽管我个人认为圆形哨兵方法更干净，更美观。我们不会讨论这些实泛型 DLList现的细节，因为你将有机会在项目 1 中探索一个或两个。</p><h2 id="泛型-DLList"><a href="#泛型-DLList" class="headerlink" title="泛型 DLList"></a>泛型 DLList</h2><p>语法一开始有点奇怪。基本思想是，在类声明中的类名称之后，在尖括号内使用任意占位符： <code>&lt;&gt;</code> .然后，在要使用任意类型的任何位置，都可以改用该占位符。</p><p>例如，我们 <code>DLList</code> 之前的声明是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DLList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> IntNode sentinel;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> IntNode prev;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">        <span class="keyword">public</span> IntNode next;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以容纳任何类型的泛型 <code>DLList</code> 如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DLList</span>&lt;BleepBlorp&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> IntNode sentinel;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> IntNode prev;</span><br><span class="line">        <span class="keyword">public</span> BleepBlorp item;</span><br><span class="line">        <span class="keyword">public</span> IntNode next;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>BleepBlorp</code>只是我编造的一个名字，你可以用大多数你可能想用的任何其他名字来代替， <code>BleepBlorp</code> 比如 <code>GloopGlop</code> 、、 <code>Horse</code> <code>TelbudorphMulticulus</code> 或其他什么。</p><p>现在我们已经定义了该类的泛型版本，我们还必须使用特殊语法来实例化该 <code>DLList</code> 类。为此，我们在声明期间将所需的类型放在尖括号内，并在实例化期间使用空尖括号。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DLList&lt;String&gt; d2 = <span class="keyword">new</span> <span class="title class_">DLList</span>&lt;&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">d2.addLast(<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure><p>由于泛型仅适用于引用类型，因此我们不能将原语放在 <code>int</code> 尖括号内或 <code>double</code> 尖括号内，例如 <code>&lt;int&gt;</code> .取而代之的是，我们使用原始类型的参考版本，在 case 的情况下 <code>int</code> 是 <code>Integer</code> ，例如</p><p>关于使用泛型类型还有其他细微差别，但我们会将它们推迟到本书的后面一章，届时您有更多机会自己尝试它们。现在，请使用以下经验法则：</p><ul><li>在<strong>实现</strong>数据结构的 .java 文件中，仅在文件最顶部的类名之后指定一次泛型类型名。</li><li>在其他使用数据结构的 .java 文件中，在声明期间指定所需的特定类型，并在实例化期间使用空菱形运算符。</li><li>如果需要在基元类型上实例化泛型，请使用 <code>Integer</code>  、 <code>Character</code> 、<code>Long</code> 、 <code>Short</code> 、<code>Byte</code>、 <code>Double</code> 、<code>Boolean</code> 或 <code>Float</code> 代替其基元等效项。</li></ul><p>次要细节：您也可以在实例化时在尖括号内声明类型，尽管这不是必需的，只要您还在同一行上声明一个变量即可。换句话说，下面的代码行是完全有效的，即使右侧的 <code>Integer</code> 代码是多余的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DLList&lt;Integer&gt; d1 = <span class="keyword">new</span> <span class="title class_">DLList</span>&lt;Integer&gt;(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(四)--Reading2.1-列表-海象之谜</title>
      <link href="/2024/01/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reading2-1-%E6%95%B0%E7%BB%84/"/>
      <url>/2024/01/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reading2-1-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是海象之谜"><a href="#什么是海象之谜" class="headerlink" title="什么是海象之谜?"></a>什么是海象之谜?</h1><p>尝试预测当我们运行下面的代码时会发生什么。更改为 b 会影响 a 吗，更改为 x 会影响 y 吗？提示：如果你来自 Python，Java 也有相同的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PollQuestions</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Walrus</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Walrus</span>(<span class="number">1000</span>, <span class="number">8.3</span>);</span><br><span class="line">        Walrus b;</span><br><span class="line">        b = a;</span><br><span class="line">        b.weight = <span class="number">5</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        y = x;</span><br><span class="line">        x = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;x is: &quot;</span> + x);</span><br><span class="line">        System.out.println(<span class="string">&quot;y is: &quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Walrus</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> weight;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> tuskSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Walrus</span><span class="params">(<span class="type">int</span> w, <span class="type">double</span> ts)</span> &#123;</span><br><span class="line">            weight = w;</span><br><span class="line">            tuskSize = ts;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">&quot;weight: %d, tusk size: %.2f&quot;</span>, weight, tuskSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a><strong>答案:</strong></h2><p><img src="/2024/01/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reading2-1-%E6%95%B0%E7%BB%84/image-20240120023307369.png" alt="image-20240120023307369"></p><p><img src="/2024/01/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reading2-1-%E6%95%B0%E7%BB%84/image-20240120024122499.png" alt="image-20240120024122499"></p><h1 id="位"><a href="#位" class="headerlink" title="位"></a>位</h1><p>计算机中的所有信息都以 1 和 0 的序列形式存储在内存中。一些例子：</p><ul><li>72 通常存储为 01001000</li><li>205.75 通常存储为 01000011 01001101 11000000 00000000</li><li>字母 H 通常存储为 01001000（与 72 相同）</li><li>真实值通常存储为00000001</li></ul><p>一个有趣的观察结果是，72 和 H 都存储为 01001000。这就提出了一个问题：一段 Java 代码如何知道如何解释 01001000？</p><p>答案是<strong>通过类型</strong></p><h1 id="声明变量（简体）"><a href="#声明变量（简体）" class="headerlink" title="声明变量（简体）"></a>声明变量（简体）</h1><p>您可以将计算机视为包含大量用于存储信息的内存位，每个内存位都有一个唯一的地址。现代计算机可以使用数十亿个这样的比特。</p><p>当你声明某种类型的变量时，Java 会找到一个连续的块，该块的位恰好足够容纳该类型的事物。例如，如果声明一个 int，则会得到一个 32 位的块。如果声明一个字节，则会得到一个 8 位的块。Java 中的每种数据类型都包含不同数量的位。在这个类中，确切的数字对我们来说并不是很重要。</p><p>为了方便的比喻，我们将其中一个块称为比特的“盒子”。</p><p>除了留出内存之外，Java 解释器还在内部表中创建一个条目，该条目将每个变量名称映射到框中第一个位的位置。</p><p>例如，如果声明 <code>int x</code> 了 和 <code>double y</code> ，则 Java 可能会决定使用计算机内存的 352 到 384 位来存储 x，并使用 20800 到 20864 位来存储 y。然后，解释器将记录 int x 从位 352 开始，y 从位 20800 开始。例如，在执行代码后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">double</span> y;</span><br></pre></td></tr></table></figure><p>我们最终会得到尺寸为 32 和 64 的盒子，如下图所示：</p><p><img src="/2024/01/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reading2-1-%E6%95%B0%E7%BB%84/x_and_y_empty_bitwise.png" alt="x_and_y_empty_bitwise"></p><p>声明变量时，Java 不会将任何内容写入保留框中。换句话说，没有默认值。因此，Java 编译器会阻止您使用变量，直到使用 <code>=</code> 运算符将位填充到框中。出于这个原因，我避免在上图的框中显示任何位。</p><p>当您为内存盒赋值时，它将填充您指定的位。例如，如果我们执行以下行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = -<span class="number">1431195969</span>;</span><br><span class="line">y = <span class="number">567213.112</span>;</span><br></pre></td></tr></table></figure><p><img src="/2024/01/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reading2-1-%E6%95%B0%E7%BB%84/x_and_y_empty_filled.png" alt="x_and_y_empty_filled.png"></p><h2 id="简化的框表示法"><a href="#简化的框表示法" class="headerlink" title="简化的框表示法"></a>简化的框表示法</h2><p>虽然我们在上一节中使用的框表示法对于理解引擎盖下发生的事情非常有用，但它对实际目的没有用，因为我们不知道如何解释二进制位。</p><p>因此，我们将用人类可读的符号来编写它们，而不是用二进制文件编写内存盒内容。我们将在课程的其余部分这样做。例如，在执行以下操作后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">double</span> y;</span><br><span class="line">x = -<span class="number">1431195969</span>;</span><br><span class="line">y = <span class="number">567213.112</span>;</span><br></pre></td></tr></table></figure><p>我们可以使用我称之为简化框表示法来表示程序环境，如下所示：</p><p><img src="/2024/01/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reading2-1-%E6%95%B0%E7%BB%84/x_and_y_simplified_box_notation.png" alt="x_and_y_simplified_box_notation.png"></p><h1 id="黄金平等法则-（GRoE）"><a href="#黄金平等法则-（GRoE）" class="headerlink" title="黄金平等法则 （GRoE）"></a>黄金平等法则 （GRoE）</h1><p>现在有了简化的盒子符号，我们终于可以开始解开海象之谜了。</p><p>事实证明，我们的 Mystery 有一个简单的解决方案：当你编写 <code>y = x</code> 时，你告诉 Java 解释器将 x 中的<strong>位</strong>复制到 y 中。在理解我们的海象之谜时，这条平等的黄金法则 （GRoE） 是所有真理的根源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">y = x;</span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;x is: &quot;</span> + x);</span><br><span class="line">System.out.println(<span class="string">&quot;y is: &quot;</span> + y);</span><br></pre></td></tr></table></figure><p>因此，Java的复制操作是复制<strong>位</strong></p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>上面，我们说了 8 种原始类型：byte、short、int、long、float、double、boolean、char。其他所有内容，包括数组，都不是原始类型，而是 <code>reference type</code> .</p><p>当我们使用 <code>new</code> （例如 Dog、Walrus、Planet）实例化一个 Object 时，Java 首先为类的每个实例变量分配一个框，并用默认值填充它们。然后，构造函数通常（但并非总是）用其他值填充每个框。</p><blockquote><p>引用类型可能都需要new，这可能意味着引用变量声明的其实是类似于cpp中的指针?</p></blockquote><h3 id="引用变量声明"><a href="#引用变量声明" class="headerlink" title="引用变量声明"></a>引用变量声明</h3><p>当我们声明任何引用类型（Walrus、Dog、Planet、数组等）的变量时，无论什么类型的对象，Java 都会分配一个 64 位的盒子。</p><p>乍一看，这似乎导致了海象悖论。上一节中的 Walrus 需要超过 64 位来存储。此外，无论对象的类型如何，我们只能获得 64 位来存储它，这似乎很奇怪。</p><p>但是，通过以下信息可以轻松解决此问题：64 位框不包含有关海象的数据，而是内存中海象的地址。</p><blockquote><p>类似cpp中的指针，指针变量存储的是指针指向的地址，通常只有4个字节；而指针所指向的那个地址不一定存储了4个字节。</p></blockquote><h3 id="框和指针表示法"><a href="#框和指针表示法" class="headerlink" title="框和指针表示法"></a>框和指针表示法</h3><p>和以前一样，很难解释引用变量中的一堆位，因此我们将为引用变量创建一个简化的框表示法，如下所示：</p><ul><li>如果一个地址全为零，我们将用 null 表示它。</li><li>非零地址将由指向对象实例化的箭头表示。</li></ul><p>这有时也称为“框和指针”表示法。</p><p>对于上一节中的示例，我们将有：</p><p><img src="/2024/01/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reading2-1-%E6%95%B0%E7%BB%84/someWalrus_simplified_bit_notation.png" alt="someWalrus_simplified_bit_notation.png"></p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>当您将参数传递给函数时，您也只是在复制位。换言之，GRoE 也适用于参数传递。复制位通常称为“按值传递”。在 Java 中，我们总是按值传递。</p><p>例如，请考虑以下函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">average</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们调用这个函数，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5.5</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">10.5</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">avg</span> <span class="operator">=</span> average(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上我们是将x，y的值拷贝给了a, b。</p><h1 id="列表的实例化"><a href="#列表的实例化" class="headerlink" title="列表的实例化"></a>列表的实例化</h1><p>如上所述，存储数组的变量是引用变量，就像任何其他变量一样。例如，请考虑以下声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] x;</span><br><span class="line">Planet[] planets;</span><br></pre></td></tr></table></figure><p>这两个声明都创建了 64 位的内存盒。 <code>x</code> 只能保存数组的地址，并且 <code>planets</code> 只能保存 <code>Planet</code> <code>int</code> 数组的地址。</p><p>实例化数组与实例化对象非常相似。例如，如果我们创建一个大小为 5 的整数数组，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = new int[]&#123;0, 1, 2, 95, 4&#125;;</span><br></pre></td></tr></table></figure><p>然后，关键字 <code>new</code> 创建 5 个框，每个框 32 位，并返回整个对象的地址以分配给 x。</p><h1 id="破碎的被褥法则"><a href="#破碎的被褥法则" class="headerlink" title="破碎的被褥法则"></a>破碎的被褥法则</h1><p><a href="https://readit.site/a/9amjk">https://readit.site/a/9amjk</a></p><p><a href="https://mathwithbaddrawings.com/2015/04/08/the-math-ceiling-wheres-your-cognitive-breaking-point/">数学天花板：你的认知突破点在哪里？– 糟糕的图纸数学 — The Math Ceiling: Where’s your cognitive breaking point? – Math with Bad Drawings</a></p><p>我感觉这个很有意思:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在大学里，我和我的室友从一些朋友那里买了一个二手被褥。他们住在一楼;我们住在四楼。他们很好心，他们帮我们抬上楼梯。</span><br><span class="line">当他们登上三楼的平台时，他们听到了一声裂缝。一根小小的金属棒从被褥上折断了。我们都检查了一下，但甚至不知道这件作品是从哪里来的。由于被褥看起来很好，我们只是耸了耸肩。</span><br><span class="line">在我们的房间里呆了一个星期后，被褥开始下垂。“它总是这样吗？”我们互相问。</span><br><span class="line">一个月后，它尴尬地下垂了。坐在最后，沙发的曲率会把你（和其他人）扔进一个中央的猪堆里。</span><br><span class="line">到学期结束时，它已经倒在尘土飞扬的宿舍地板上，这是曾经繁荣的被褥的破碎骨架。</span><br><span class="line">现在，宜家家具是客厅的果蝇：出了名的短命。毫无疑问，我们的被褥寿命是有上限的，也许是三四年。但这一个只活了八个月。</span><br><span class="line">事后看来，很明显，破碎的碎片绝对至关重要。没有它被褥似乎很好。但日复一日，随着每一个新的屁股，重量都压在结构的某些部分上，从来都不意味着独自承受负载。框架变得扭曲。压力不可持续地增加。被褥的内部时钟默默地滴答作响，直到缺乏支持被证明是压倒性的，整个事情都崩溃了。</span><br><span class="line">而且，可悲的是，数学课也是如此。</span><br><span class="line">假设你正在读八年级。您可以以完美的流动性和精度绘制线性方程。您可以计算它们的斜率、识别点并生成平行线和垂直线。</span><br><span class="line">但是，如果你缺少一个简单的理解——这些图只是满足方程的 x-y 对——那么你就是一个破碎的被褥。你错过了未来学习至关重要的一块。二次函数会困扰你;正弦曲线永远不会有意义;你可能会在微积分之后保释，安慰自己，“好吧，至少我的上限比一些人高。</span><br><span class="line">你可能会问，“既然我现在很好，难道我不能在以后真正需要的时候添加缺失的部分吗？有时，是的。但这要困难得多。你现在已经花了好几年时间没有这个关键的部分。你已经开发了捷径和零敲碎打的方法来度过难关。这些工作了一段时间，但它们扭曲了框架，现在你来了。为了继续前进，你必须忘记你的变通方法--有效地将被褥弯曲回原来的形状--然后才能继续。但是，放弃让你走到这一步的策略几乎是不可能的。</span><br><span class="line">稍后添加缺失的部分意味着要等到损坏已经开始，并且很难挽回。</span><br><span class="line">我相信，这是许多学生所经历的天花板。这不是他们神经病学的固有局限性。这是我们创造的东西。我们通过言语或行动说：“你不明白也没关系。只需按照以下步骤操作，并在后面检查您的答案。我们通过说“只有聪明的人才能得到它;至于其余的，我只想确保他们能做到。我们通过说，“好吧，他们现在不明白，但他们最终会自己弄清楚。</span><br><span class="line">这样一来，我们就可以成功地把被褥弄上楼梯。但在这个过程中会丢失一些东西。在没有关键理解的情况下将我们的学生送上前方，就像在没有替换弹药的情况下将他们送上战场一样。当然，他们会发射几发子弹，但当他们意识到缺少一些东西时，恢复为时已晚。</span><br></pre></td></tr></table></figure><p>一时半解虽然这在短期内可能很好，但从长远来看，在没有完全理解的情况下做问题可能会注定你以后会失败。有一篇关于这个所谓的破碎被褥法则的博客文章，你可能会觉得很有趣。</p><h1 id="IntLists"><a href="#IntLists" class="headerlink" title="IntLists"></a>IntLists</h1><p>事实证明，一个非常基本的列表实现起来是微不足道的，如下所示：</p><p>实现起来其实类似于”链表”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> first;</span><br><span class="line">    <span class="keyword">public</span> IntList rest;        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IntList</span><span class="params">(<span class="type">int</span> f, IntList r)</span> &#123;</span><br><span class="line">        first = f;</span><br><span class="line">        rest = r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Return the size of the list using... recursion! */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">this</span>.rest.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Return the size of the list using no recursion! */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">iterativeSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">IntList</span> <span class="variable">p</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            totalSize += <span class="number">1</span>;</span><br><span class="line">            p = p.rest;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSize;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns the ith item of this IntList*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rest.get(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(三)--Junit测试</title>
      <link href="/2024/01/19/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Junit%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/01/19/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Junit%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="测试理念"><a href="#测试理念" class="headerlink" title="测试理念"></a>测试理念</h1><h2 id="正确性工具-1：自动分级器"><a href="#正确性工具-1：自动分级器" class="headerlink" title="正确性工具#1：自动分级器"></a>正确性工具#1：自动分级器</h2><p>自动评分器可能是您接触到的第一个正确性工具。事实上，CS61B的自动分级器是基于 JUnit 加上一些额外的自定义库。</p><p>对自动分级者有一些很大的好处。也许最重要的是，它可以为您验证正确性，使您免于编写所有测试的繁琐且无指导性的任务。它还通过提供多汁的分数作为实现正确性的激励，使评估过程游戏化。如果学生花费过多的时间追逐实际上不会影响他们的成绩或学习的最终分数，这也可能适得其反。</p><p>然而，自动分级器在现实世界中并不存在，依赖自动分级器会养成坏习惯。偶尔上传代码并等待自动评分器运行会阻碍一个人的工作流程。Autograder Driven Development 是一个极端版本，学生编写所有代码，修复编译器错误，然后提交给自动评分器。在得到错误后，学生可以尝试进行一些更改，在打印语句中撒上一些，然后再次提交。并重复。最终，如果您依赖自动评分器，则无法控制工作流或代码。</p><h2 id="正确性工具-2：JUnit-测试"><a href="#正确性工具-2：JUnit-测试" class="headerlink" title="正确性工具 #2：JUnit 测试"></a>正确性工具 #2：JUnit 测试</h2><p>正如我们所看到的，JUnit 测试为您打开了一个新世界。您无需依赖其他人编写的自动评分器，而是为程序的每个部分编写测试。我们将这些部分中的每一个都称为一个单元。这使您可以对代码的每个单元充满信心 - 您可以依赖它们。这也有助于减少调试时间，因为您可以一次将注意力隔离到一个代码单元（通常是单个方法）。单元测试还迫使您明确每个代码单元应该完成什么。</p><p>但是，单元测试也有一些缺点。首先，编写全面的测试需要时间。编写不完整的单元测试很容易，这会给代码带来错误的信心。为依赖于其他单元的单元编写测试也很困难（考虑 your <code>LinkedListDeque</code> 中 <code>addFirst</code> 的方法）。</p><h3 id="测试驱动开发-（TDD）"><a href="#测试驱动开发-（TDD）" class="headerlink" title="*测试驱动开发 （TDD）*"></a>*<strong>测试驱动开发 （TDD）*</strong></h3><p>TDD 是一个开发过程，在这个过程中，我们在编写代码本身之前为代码编写测试。步骤如下：</p><ol><li>确定新功能。</li><li>为该功能编写单元测试。</li><li>运行测试。它应该失败。</li><li>编写通过测试的代码。</li><li>可选：重构代码以使其更快、更简洁等。除了现在我们有一个应该通过的测试的参考。</li></ol><p><img src="/2024/01/19/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Junit%E6%B5%8B%E8%AF%95/image-20240119190920106.png" alt="image-20240119190920106"></p><h2 id="正确性工具-3：集成测试"><a href="#正确性工具-3：集成测试" class="headerlink" title="正确性工具#3：集成测试"></a>正确性工具#3：集成测试</h2><p>单元测试很棒，但我们也应该确保这些单元能够正常工作（与这个模因不同）。集成测试验证组件是否正确地交互在一起。JUnit 实际上可以用于此目的。你可以把单元测试想象成最细微的，而集成测试的抽象级别高于此。</p><p>集成测试的挑战在于，手动操作很繁琐，但自动化却具有挑战性。在高度抽象的层次上，很容易错过细微或罕见的错误。</p><h1 id="JUnit-测试"><a href="#JUnit-测试" class="headerlink" title="JUnit 测试"></a>JUnit 测试</h1><p><a href="https://junit.org/junit4/javadoc/4.12/org/junit/Assert.html">Assert (JUnit API)</a></p><p>虽然 JUnit 确实改进了一些东西，但我们之前的测试代码在几个方面有点笨拙。在本节的其余部分，我们将讨论您可以进行的两个主要增强功能，以便您的代码更简洁、更易于使用。从语法的角度来看，这些增强功能看起来非常神秘，所以只需复制我们现在正在做的事情，我们将在后面的章节中解释其中的一些（但不是全部）。</p><p>第一个增强功能是使用所谓的<strong>“测试注释”</strong>。为此，我们：</p><ul><li>在每个方法前面加上 <code>@org.junit.Test</code> （不带分号）。</li><li>将每种测试方法更改为非静态。</li><li>从类中删除 <code>TestSort</code> 我们 <code>main</code> 的方法。</li></ul><p>第二个增强功能将允许我们为一些非常长的方法名称以及注释名称使用较短的名称。具体来说，我们将使用所谓的<strong>“import 语句”</strong>。</p><blockquote><p>不同与Python, import语句后要加分号</p></blockquote><p>我们首先将 import 语句 <code>import org.junit.Test;</code> 添加到文件的顶部。完成此操作后，我们可以简单地将 的所有 <code>@org.junit.Test</code> 实例替换为 <code>@Test</code> .</p><p>然后，我们添加第二个 import 语句 <code>import static org.junit.Assert.*</code> 。这样做之后，我们可以省略任何我们拥有的 <code>org.junit.Assert.</code> .例如，我们可以简单地替换为 <code>org.junit.Assert.assertEquals(expected2, actual2);</code> <code>assertEquals(expected2, actual2);</code></p><p>例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSort</span> &#123;</span><br><span class="line">    <span class="comment">//导入包前为@org.junit.Test</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindSmallest</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] input = &#123;<span class="string">&quot;i&quot;</span>, <span class="string">&quot;have&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;egg&quot;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">expected</span> <span class="operator">=</span> <span class="string">&quot;an&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">actual</span> <span class="operator">=</span> Sort.findSmallest(input);</span><br><span class="line">        assertArrayEquals(expected, actual);</span><br><span class="line">        <span class="comment">//导入前为org.junit.Assert.assertArrayEquals(expected, actual);       </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B项目练习笔记(一)--Proj0</title>
      <link href="/2024/01/18/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-1-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj0/"/>
      <url>/2024/01/18/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-1-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj0/</url>
      
        <content type="html"><![CDATA[<p>本人项目链接<a href="https://github.com/xxbaizero0/CS61B-Tutorial/tree/main/proj0/game2048">CS61B-Tutorial&#x2F;proj0&#x2F;game2048 at main · xxbaizero0&#x2F;CS61B-Tutorial (github.com)</a></p><p>我的任务仅驻留在 <code>Model.java</code> 并且仅限于四个方法:</p><ul><li><p><code>public static boolean emptySpaceExists（Board b）</code></p></li><li><p><code>public static boolean maxTileExists（Board b）</code></p></li><li><p><code>public static boolean atLeastOneMoveExists(Board b)</code></p></li><li><p><code>public boolean tilt(Side side)</code></p></li></ul><h1 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h1><h1 id="配置项目cdk，导入库"><a href="#配置项目cdk，导入库" class="headerlink" title="配置项目cdk，导入库"></a>配置项目cdk，导入库</h1><p>我们想要使用 <code>javalib</code> 文件夹中的这些 <code>.jar</code> 文件。仍然在“项目结构”中，单击左侧名为“库”的项目设置部分。如果您看到已添加， <code>javalib</code> 则无事可做。否则，我们将单击“+”按钮，然后单击“Java”，这将启动我们操作系统的文件浏览器，然后单击该 <code>javalib</code> 文件夹。然后，在屏幕的右下角，点击“应用”，然后点击蓝色的“确定”按钮。</p><p><img src="/2024/01/18/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-1-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj0/intellij-setup.gif" alt="IntelliJ Setup"></p><h2 id="修改项目文件"><a href="#修改项目文件" class="headerlink" title="修改项目文件"></a>修改项目文件</h2><p>游戏运行的<strong>上下左右移动键</strong>为<strong>英语语言下的按键</strong>，我们需要修改<code>GUISource.java</code></p><p><img src="/2024/01/18/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-1-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj0/8@%5B%EF%BF%BDVE6Z1%25CL_CM%7BPDK1X.png" alt="img"></p><h1 id="代码答案"><a href="#代码答案" class="headerlink" title="代码答案"></a>代码答案</h1><h2 id="public-static-boolean-emptySpaceExists（Board-b）"><a href="#public-static-boolean-emptySpaceExists（Board-b）" class="headerlink" title="public static boolean emptySpaceExists（Board b）"></a><code>public static boolean emptySpaceExists（Board b）</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Returns true if at least one space on the Board is empty.</span></span><br><span class="line"><span class="comment"> *  Empty spaces are stored as null.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">emptySpaceExists</span><span class="params">(Board b)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Fill in this function.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> b.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b.tile(i, j) == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="public-static-boolean-maxTileExists（Board-b）"><a href="#public-static-boolean-maxTileExists（Board-b）" class="headerlink" title="public static boolean maxTileExists（Board b）"></a><code>public static boolean maxTileExists（Board b）</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns true if any tile is equal to the maximum valid value.</span></span><br><span class="line"><span class="comment"> * Maximum valid value is given by MAX_PIECE. Note that</span></span><br><span class="line"><span class="comment"> * given a Tile object t, we get its value with t.value().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">maxTileExists</span><span class="params">(Board b)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Fill in this function.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> b.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b.tile(i, j) != <span class="literal">null</span>&amp;&amp;b.tile(i, j).value() == MAX_PIECE)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="public-static-boolean-atLeastOneMoveExists-Board-b"><a href="#public-static-boolean-atLeastOneMoveExists-Board-b" class="headerlink" title="public static boolean atLeastOneMoveExists(Board b)"></a><code>public static boolean atLeastOneMoveExists(Board b)</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">atLeastOneMoveExists</span><span class="params">(Board b)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Fill in this function.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> b.size();</span><br><span class="line">    <span class="keyword">if</span>(emptySpaceExists(b)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i + <span class="number">1</span> &lt; length)</span><br><span class="line">                <span class="keyword">if</span>(</span><br><span class="line">                    (b.tile(i-<span class="number">1</span>, j).value() == b.tile(i, j).value())</span><br><span class="line">                    ||(b.tile(i+<span class="number">1</span>, j).value() == b.tile(i, j).value())) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j - <span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; j+<span class="number">1</span> &lt; length)</span><br><span class="line">                <span class="keyword">if</span>((b.tile(i,j-<span class="number">1</span>).value() == b.tile(i, j).value())</span><br><span class="line">                   ||(b.tile(i, j +<span class="number">1</span>).value() == b.tile(i, j).value())) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了<code>emptySpaceExists()</code>函数，实际上增加了无所谓的时间，但是如果要完善的话if条件句还需要加长，可读性不高，因此没有修改。</p><p>如果有任何有效的移动，则应返回 true。所谓“有效移动”，是指如果用户在玩 2048 时可以按下一个按钮（UP、DOWN、LEFT 或 RIGHT），导致至少一个图块移动，那么这样的按键被视为有效移动。</p><p>有两种方法可以进行有效移动：</p><ul><li>棋盘上至少有一个空白区域。</li><li>有两个相邻的图块具有相同的值。</li></ul><p>例如，对于下面的板，我们应该返回 true，因为至少有一个空白区域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|   2|    |   2|    |</span><br><span class="line">|   4|   4|   2|   2|</span><br><span class="line">|    |   4|    |    |</span><br><span class="line">|   2|   4|   4|   8|</span><br></pre></td></tr></table></figure><p>对于下面的板子，我们应该返回 false。无论你在 2048 年按下什么按钮，都不会发生任何事情，即没有两个相邻的瓷砖具有相等的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|   2|   4|   2|   4|</span><br><span class="line">|  16|   2|   4|   2|</span><br><span class="line">|   2|   4|   2|   4|</span><br><span class="line">|   4|   2|   4|   2|</span><br></pre></td></tr></table></figure><p>对于下面的棋盘，我们将返回 true，因为向右或向左移动将合并两个 64 个图块，并且向上或向下移动将合并 32 个图块。或者换句话说，至少存在两个值相等的相邻图块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|   2|   4|  64|  64|</span><br><span class="line">|  16|   2|   4|   8|</span><br><span class="line">|   2|   4|   2|  32|</span><br><span class="line">|   4|   2|   4|  32|</span><br></pre></td></tr></table></figure><h2 id="public-boolean-tilt-Side-side"><a href="#public-boolean-tilt-Side-side" class="headerlink" title="public boolean tilt(Side side)"></a><code>public boolean tilt(Side side)</code></h2><p>倾斜方法的工作是实际移动所有瓷砖。如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|   2|    |   2|    |</span><br><span class="line">|   4|   4|   2|   2|</span><br><span class="line">|    |   4|    |    |</span><br><span class="line">|   2|   4|   4|   8|</span><br></pre></td></tr></table></figure><p>然后按 up，将修改 <code>board</code> 实例变量， <code>tilt</code> 使游戏的状态现在为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|   2|   8|   4|   2|</span><br><span class="line">|   4|   4|   4|   8|</span><br><span class="line">|   2|    |    |    |</span><br><span class="line">|    |    |    |    |</span><br></pre></td></tr></table></figure><p>除了修改板之外，还必须发生另外两件事：</p><ol><li>必须更新评分实例变量，以反映所有图块合并的总值（如果有）。在上面的例子中，我们将两个 4 合并成一个 8，将两个 2 合并成一个 4，因此分数应该增加 8 + 4 &#x3D; 12。</li><li>如果板发生任何变化，我们必须将 <code>changed</code> 局部变量设置为 <code>true</code> 。这是因为在 的 <code>tilt</code> 框架代码的末尾，您可以看到我们调用了一个 <code>setChanged()</code> 方法：这通知 GUI 有一些东西要绘制。您不会对自己 <code>setChanged</code> 进行任何调用：只需修改 <code>changed</code> 局部变量。</li></ol><p>示例：</p><p><img src="/2024/01/18/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-1-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj0/image-20240118213830819.png" alt="image-20240118213830819"></p><p><img src="/2024/01/18/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-1-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj0/image-20240118213851546.png" alt="image-20240118213851546"></p><p><img src="/2024/01/18/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-1-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj0/image-20240118214110920.png" alt="image-20240118214110920"></p><p><img src="/2024/01/18/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-1-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj0/image-20240118214147334.png" alt="image-20240118214147334"></p><h2 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h2><ul><li>我们可以只专注于一个方向的实现，然后通过数组的旋转来实现多方向的实现。</li><li>由上图可知，我们最好从每列顶部开始遍历，这样才能符合游戏逻辑</li></ul><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tilt</span><span class="params">(Side side)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> changed;</span><br><span class="line">        changed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Modify this.board (and perhaps this.score) to account</span></span><br><span class="line">        <span class="comment">// for the tilt to the Side SIDE. If the board changed, set the</span></span><br><span class="line">        <span class="comment">// changed local variable to true.</span></span><br><span class="line">        board.setViewingPerspective(side);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; board.size(); c++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> board.size()-<span class="number">1</span>; r &gt;= <span class="number">0</span>; r--)&#123;</span><br><span class="line">                <span class="type">Tile</span> <span class="variable">t</span> <span class="operator">=</span> board.tile(c, r);</span><br><span class="line">                <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> r;</span><br><span class="line">                <span class="keyword">if</span>(board.tile(c, r) != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> board.size()-<span class="number">1</span>; i &gt; r; i--)&#123;</span><br><span class="line">                        <span class="keyword">if</span> (board.tile(c, i) == <span class="literal">null</span>) &#123;</span><br><span class="line">                            board.move(c, i, t);</span><br><span class="line">                            row = i;</span><br><span class="line">                            changed = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row -<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(board.tile(c, i)!=<span class="literal">null</span> &amp;&amp; t.value() != board.tile(c, i).value()) <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(board.tile(c, i)!=<span class="literal">null</span> &amp;&amp; t.value() == board.tile(c, i).value())&#123;</span><br><span class="line">                            board.move(c, row, board.tile(c, i));</span><br><span class="line">                            changed = <span class="literal">true</span>;</span><br><span class="line">                            score += board.tile(c, row).value();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        board.setViewingPerspective(Side.NORTH);</span><br><span class="line">        checkGameOver();</span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">            setChanged();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(二)--Reading.1.Introducing</title>
      <link href="/2024/01/18/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reading-1-Introducion-to-Java/"/>
      <url>/2024/01/18/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reading-1-Introducion-to-Java/</url>
      
        <content type="html"><![CDATA[<p><a href="https://joshhug.gitbooks.io/hug61b/content/chap1/chap11.html">1.1 要点 ·拥抱61B — 1.1 Essentials · Hug61B (gitbooks.io)</a></p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>System.out.println(&quot;Hello world!&quot;);</code>相当于与c++中的<code>cout&lt;&lt;&quot;Hello world!&quot;&lt;&lt;endl;</code></p><p><code>System.out.print(&quot;Hello world!&quot;);</code>相当于与c++中的<code>cout&lt;&lt;&quot;Hello world!&quot;;</code></p></blockquote><p>对于那些来自像 Python 这样的语言的人来说，这似乎毫无必要地冗长。然而，这一切都是有充分理由的，我们将在接下来的几周内理解这一点。需要注意的一些关键语法特征：</p><ul><li>该程序由一个类声明组成，该声明使用关键字 <code>public class</code> 声明。在 Java 中，所有代码都位于类中。</li><li>运行的代码位于名为 <code>main</code> 的方法中，该方法声明为 <code>public static void main(String[] args)</code> 。</li><li>我们使用大括号 <code>&#123;</code> 和来表示一段代码的开头和 <code>&#125;</code> 结尾。</li><li>语句必须以分号结尾。</li></ul><h2 id="运行-Java-程序"><a href="#运行-Java-程序" class="headerlink" title="运行 Java 程序"></a>运行 Java 程序</h2><p>执行 Java 程序的最常见方法是通过两个程序的序列运行它。第一种是 Java 编译器，或 <code>javac</code> .第二个是 Java 解释器，或 <code>java</code> .</p><p>![image-20240118035144027](2-CS61B学习笔记-Reading.1.Introducion to Java&#x2F;image-20240118035144027.png)</p><p>例如，要运行 <code>HelloWorld.java</code> ，我们会在终端中键入命令，然后键入命令 <code>javac HelloWorld.java</code> <code>java HelloWorld</code> 。结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ javac HelloWorld.java</span><br><span class="line">$ java HelloWorld</span><br><span class="line">Hello World! </span><br></pre></td></tr></table></figure><blockquote><p>在上图中，$ 表示我们终端的命令提示符。</p></blockquote><p>您可能会注意到，我们在编译时包含“.java”，但在解释时不包括“.class”。这就是它的方式（TIJTWII）。</p><h2 id="代码样式、注释、Javadoc"><a href="#代码样式、注释、Javadoc" class="headerlink" title="代码样式、注释、Javadoc"></a>代码样式、注释、Javadoc</h2><p>代码在很多方面都很漂亮。它可以很简洁。它可以很聪明。它可以是有效的。新手最不被重视的代码方面之一是代码风格。当你作为一个新手编程时，你往往一心一意地让它工作，而不考虑再看一遍或不得不长时间维护它。</p><p>在本课程中，我们将努力保持代码的可读性。良好的编码风格的一些最重要的特征是：</p><ul><li>一致的样式（间距、变量命名、大括号样式等）</li><li>大小（行不要太宽，源文件不要太长）</li><li>描述性命名（变量、函数、类），例如名称为 <code>year</code> or 而不是 <code>x</code> or <code>f</code> <code>getUserName</code> 的变量或函数。</li><li>避免重复代码：除了一些更改外，几乎不应该有两个几乎相同的重要代码块。</li><li>酌情注释。Java 中的行注释使用 <code>//</code> 分隔符。阻止（又名多行注释）注释 use <code>/*</code> 和 <code>*/</code> .</li></ul><p>黄金法则是：编写代码，以便陌生人易于理解。</p><p><a href="https://sp19.datastructur.es/materials/guides/style-guide.html">Style Guide | CS 61B Spring 2019 (datastructur.es)</a>这是该课程的官方风格指南。值得一看！</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>所有方法和几乎所有类都应该使用所谓的 Javadoc 格式在注释中进行描述。在 Javadoc 注释中<a href="https://en.wikipedia.org/wiki/Javadoc">Javadoc - 维基百科，自由的百科全书 — Javadoc - Wikipedia</a>，块注释以额外的星号开头，例如 <code>/**</code> ，并且注释通常（但并非总是）包含描述性标记。我们不会在本教科书中讨论这些标签，但请参阅上面的链接以了解它们的工作原理。</p><p>需要特别注意的是，所有方法和几乎所有类都应该使用所谓的 Javadoc 格式在注释中进行描述。在 Javadoc 注释中，块注释以额外的星号开头，例如 <code>/**</code> ，并且注释通常（但并非总是）包含描述性标记。我们不会在本教科书中讨论这些标签，但请参阅上面的链接以了解它们的工作原理。</p><p>举个没有标签的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LargerDemo</span> &#123;</span><br><span class="line">    <span class="comment">/** Returns the larger of x and y. */</span>           </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">larger</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(larger(<span class="number">8</span>, <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>广泛使用的 javadoc 工具<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javadoc.html">javadoc (oracle.com)</a>可用于生成代码的 HTML 描述。</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="定义和使用类"><a href="#定义和使用类" class="headerlink" title="定义和使用类"></a>定义和使用类</h2><p>Java 中的所有代码都必须是类的一部分（或类似于类的东西，我们将在后面学习）。大多数代码都是在方法内部编写的。让我们考虑一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">makeNoise</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bark!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们尝试运行该 <code>Dog</code> 类，我们只会收到一条错误消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ java Dog</span><br><span class="line">Error: Main method not found in <span class="keyword">class</span> <span class="title class_">Dog</span>, please define the main method as:</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br></pre></td></tr></table></figure><p>我们定义的 <code>Dog</code> 类不执行任何操作。我们只是定义了一些 <code>Dog</code> 可以做的事情，即制造噪音。要实际运行该类，我们需要向 <code>Dog</code> 该类添加一个 main 方法，正如我们在第 1.1 章中看到的那样。或者我们可以创建一个单独的 <code>DogLauncher</code> 类来运行该 <code>Dog</code> 类的方法。例如，考虑以下程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogLauncher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Dog.makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java DogLauncher</span><br><span class="line">Bark!</span><br></pre></td></tr></table></figure><p>使用另一个类的类有时称为该类的“客户端”，即 <code>DogLauncher</code> 是 <code>Dog</code> 的客户端。这两种技术都不是更好的：在某些情况下，添加 main 方法可能更好，而在其他情况下创建类似 client 类 <code>Dog</code> <code>DogLauncher</code> 可能更好。随着我们在整个课程中获得额外的练习，每种方法的相对优势将变得清晰。</p><p>因此总结下:</p><ul><li>类的使用有两种方法:<ul><li>一种是带有main方法的类</li><li>一种是只有方法，由另一个类来调用。</li></ul></li></ul><h2 id="静态方法-vs-非静态方法"><a href="#静态方法-vs-非静态方法" class="headerlink" title="静态方法 vs 非静态方法"></a>静态方法 vs 非静态方法</h2><p>同<code>cpp</code>的知识点，静态方法属于类，非静态方法属于对象(实例)。调用静态方法时，通常用<code>类名.方法</code>,调用非静态方法时通常用<code>对象名.方法</code>。</p><p>对比上下两个<code>Dog</code>类的<code>makeNoise</code>方法可以发现，在加上条件判断语句前为静态方法，加上后变为非静态方法，说明是不同体重对象的方法。</p><p>详细下面有说</p><h2 id="实例变量和对象实例化"><a href="#实例变量和对象实例化" class="headerlink" title="实例变量和对象实例化"></a>实例变量和对象实例化</h2><p>并非所有的狗都是一样的。有些狗喜欢不停地吠叫，而另一些狗则发出铿锵有力的咆哮，给所有听到它们光荣呼唤的人带来欢乐。通常，我们编写程序来模仿我们居住的宇宙的特征，而 Java 的语法很容易允许这种模仿。</p><p>允许我们表示 Dogdom 光谱的一种方法是为每种类型的 Dog 创建单独的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TinyDog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">makeNoise</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yip yip yip yip&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MalamuteDog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">makeNoise</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;arooooooooooooooo!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如您过去应该看到的，类可以实例化，实例可以保存数据。这导致了一种更自然的方法，我们创建 <code>Dog</code> 类的实例，并使 <code>Dog</code> 方法的行为取决于特定 <code>Dog</code> .为了更具体地说明这一点，请考虑以下类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weightInPounds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeNoise</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (weightInPounds &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yipyipyip!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (weightInPounds &lt; <span class="number">30</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;bark. bark.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;woof!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为使用这种狗的例子，请考虑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogLauncher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Dog d;</span><br><span class="line">        d = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        d.weightInPounds = <span class="number">20</span>;</span><br><span class="line">        d.makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些关键观察结果和术语：</p><ul><li>Java 中的 <code>Object</code> 是任何类的实例。</li><li>该 <code>Dog</code> 类有自己的变量，也称为实例变量或非静态变量。这些必须在类中声明，这与 Python 或 Matlab 等语言不同，后者可以在运行时添加新变量。</li><li>我们在 <code>Dog</code> 类中创建的方法没有关键字 <code>static</code> 。我们将此类方法称为实例方法或非静态方法。</li><li>要调用该 <code>makeNoise</code> 方法，我们必须首先使用 <code>new</code> 关键字实例化 a <code>Dog</code> ，然后制作特定的 <code>Dog</code> bark。换句话说，我们调用 <code>d.makeNoise()</code> 了 <code>Dog.makeNoise()</code> .</li><li>一旦一个对象被实例化，就可以将其分配给适当类型的声明变量，例如 <code>d = new Dog();</code></li><li>类的变量和方法也称为类的成员。</li><li>使用点表示法访问类的成员。</li></ul><h2 id="类方法与实例方法"><a href="#类方法与实例方法" class="headerlink" title="类方法与实例方法"></a>类方法与实例方法</h2><p>Java 允许我们定义两种类型的方法：</p><ul><li>类方法，又名静态方法。</li><li>实例方法，又名非静态方法。</li></ul><p>实例方法是只能由类的特定实例执行的操作。静态方法是由类本身执行的操作。两者在不同情况下都很有用。作为静态方法的示例，该 <code>Math</code> 类提供了一个 <code>sqrt</code> 方法。因为它是静态的，我们可以这样称呼它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = Math.sqrt(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>如果 <code>sqrt</code> 是一个实例方法，我们将得到下面笨拙的语法。幸运的是，它是一种 <code>sqrt</code> 静态方法，因此我们不必在实际程序中执行此操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Math</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Math</span>();</span><br><span class="line">x = m.sqrt(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>有时，拥有一个同时具有实例和静态方法的类是有意义的。例如，假设想要比较两只狗的能力。一种方法是添加一个用于比较 Dogs 的静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">15</span>);</span><br><span class="line"><span class="type">Dog</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">100</span>);</span><br><span class="line">Dog.maxDog(d, d2);</span><br></pre></td></tr></table></figure><p>请注意，我们已使用类名调用，因为此方法是静态方法。</p><p>我们也可以 <code>maxDog</code> 实现为非静态方法，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Dog <span class="title function_">maxDog</span><span class="params">(Dog d2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.weightInPounds &gt; d2.weightInPounds) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面，我们使用关键字 <code>this</code> 来指代当前对象。例如，可以使用以下方法调用此方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">15</span>);</span><br><span class="line"><span class="type">Dog</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">100</span>);</span><br><span class="line">d.maxDog(d2);</span><br></pre></td></tr></table></figure><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p>类具有静态变量有时很有用。这些是类本身固有的属性，而不是实例的属性。例如，我们可以记录狗的学名（或双子）是<code>Canis familiaris</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weightInPounds;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">binomen</span> <span class="operator">=</span> <span class="string">&quot;Canis familiaris&quot;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态变量应该使用类的名称而不是特定的实例来访问，例如，您应该使用 <code>Dog.binomen</code> ，而不是 <code>d.binomen</code> .</p><p>虽然 Java 在技术上允许你使用实例名称访问静态变量，但它的风格很糟糕，令人困惑，而且在我看来是 Java 设计者的错误。(不是我的评价)</p><h2 id="Java的构造函数"><a href="#Java的构造函数" class="headerlink" title="Java的构造函数"></a>Java的构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weightInPounds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> w)</span> &#123;</span><br><span class="line">        weightInPounds = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeNoise</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (weightInPounds &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yipyipyip!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (weightInPounds &lt; <span class="number">30</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;bark. bark.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;woof!&quot;</span>);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当我们尝试 <code>Dog</code> 创建 using <code>new</code> 关键字和单个整数参数时，都会调用带有签名 <code>public Dog(int w)</code> 的构造函数。对于那些来自 Python 的人来说，构造函数与 <code>__init__</code> 方法非常相似。</p><h2 id="数组实例化，对象数组"><a href="#数组实例化，对象数组" class="headerlink" title="数组实例化，对象数组"></a>数组实例化，对象数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/* Create an array of two dogs. */</span></span><br><span class="line">        Dog[] dogs = <span class="keyword">new</span> <span class="title class_">Dog</span>[<span class="number">2</span>];</span><br><span class="line">        dogs[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">8</span>);</span><br><span class="line">        dogs[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Yipping will result, since dogs[0] has weight 8. */</span></span><br><span class="line">        dogs[<span class="number">0</span>].makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，new 以两种不同的方式使用：一次用于创建一个可以容纳两个 <code>Dog</code> 对象的数组，两次用于创建每个实际 <code>Dog</code> 的 .</p><h3 id="public-static-void-main-String-args-的说明"><a href="#public-static-void-main-String-args-的说明" class="headerlink" title="public static void main(String[] args)的说明"></a>public static void main(String[] args)的说明</h3><p>根据我们目前所学到的知识，是时候揭开我们一直用于 main 方法的声明的神秘面纱了。把它分成几块，我们有：</p><ul><li><code>public</code> ：到目前为止，我们所有的方法都以这个关键字开头。</li><li>static&#96; ：它是一个静态方法，不与任何特定实例关联。</li><li><code>void</code> ：它没有返回类型。</li><li><code>main</code> ：这是方法的名称。</li><li><code>String[] args</code> ：这是传递给 main 方法的参数。</li></ul><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>由于 main 是由 Java 解释器本身调用的，而不是由另一个 Java 类调用的，因此解释器的工作是提供这些参数。它们通常引用命令行参数。例如，考虑以下程序 <code>ArgsDemo</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序打印出第 0 个命令行参数，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java ArgsDemo these are command line arguments</span><br><span class="line">these</span><br></pre></td></tr></table></figure><p>在上面的示例中，将是一个字符串数组， <code>args</code> 其中条目为 {“these”， “are”， “command”， “line”， “arguments”}。</p><blockquote><p>这样子可以识别命名 -m -v 等</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(一)--JAVA快速入门</title>
      <link href="/2024/01/16/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JAVA%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2024/01/16/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JAVA%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cscircles.cemc.uwaterloo.ca/java_visualize/#">Java Visualizer (uwaterloo.ca)</a>类python tutor，可视化代码网站。</p><h1 id="基本程序"><a href="#基本程序" class="headerlink" title="基本程序"></a>基本程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassNameHere</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      x = x + <span class="number">1</span>;</span><br><span class="line">      System.out.println(x);</span><br><span class="line">      <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;</span><br><span class="line">      x = x + <span class="number">1</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;x is: &quot;</span> + x);</span><br><span class="line">      System.out.println(<span class="string">&quot;y is: &quot;</span> + y);      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JAVA是以类为单位的静态语言，不可或缺<strong>文件名命名的类</strong>以及<strong>main函数</strong>,语法类似cpp,结尾需要分号<code>;</code>。</p><blockquote><p>在Java中，如果一个类是public并且包含了main方法，则文件名必须与public类的名称相匹配。这是因为Java要求public类的名称与包含它的文件的名称相同。如果一个Java文件包含多个类，只能有一个类是public，并且文件名必须与public类的名称相匹配。</p></blockquote><h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassNameHere</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">10</span>)</span><br><span class="line">            x = x + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">10</span>)</span><br><span class="line">            x = x + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">dogSize</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (dogSize &gt;= <span class="number">50</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;woof!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dogSize &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;bark!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;yip!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同cpp</p><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">bottles</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line"><span class="keyword">while</span> (bottles &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(bottles + <span class="string">&quot; bottles of beer on the wall.&quot;</span>);</span><br><span class="line">    bottles = bottles - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同cpp</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassNameHere</span> &#123;</span><br><span class="line">    <span class="comment">/** Uses a basic for loop to sum a. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i = i + <span class="number">1</span>) &#123;</span><br><span class="line">        sum = sum + a[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同cpp</p><h2 id="增强的For循环"><a href="#增强的For循环" class="headerlink" title="增强的For循环"></a>增强的For循环</h2><p>Java 还支持使用“增强的 for 循环”通过数组进行迭代。基本思想是，在许多情况下，我们实际上根本不关心指数。在这种情况下，我们避免使用涉及冒号的特殊语法创建索引变量。</p><p>例如，在下面的代码中，我们执行与 <code>BreakDemo</code> 上述完全相同的操作。但是，在这种情况下，我们不会 创建索引 <code>i</code> .取而代之的是，从 <code>a[0]</code> ， <code>String</code> <code>s</code> 一直 <code>String</code> <code>a</code> 到 <code>a[a.length - 1]</code> 。您可以在此链接中试用此代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnhancedForBreakDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] a = &#123;<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;laser horse&quot;</span>, <span class="string">&quot;ketchup&quot;</span>, <span class="string">&quot;horse&quot;</span>, <span class="string">&quot;horbse&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : a) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j += <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                <span class="keyword">if</span> (s.contains(<span class="string">&quot;horse&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(max(<span class="number">10</span>, <span class="number">15</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 中的函数与变量一样，具有特定的返回类型。该 <code>max</code> 函数的返回类型 <code>int</code> 为 （由函数名称前的单词“int”表示）。Java 中的函数也被称为方法，所以我将从这一刻开始永远这样称呼它们。</p><p>我们将整个字符串 <code>public static int max(int x, int y)</code> 称为方法的签名，因为它列出了参数、返回类型、名称和任何修饰符。在这里，我们的修饰符是 <code>public</code> 和 <code>static</code> ，尽管我们几天内不会了解这些修饰符的含义。</p><p>CPP</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> iostream</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> x, iny)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;(<span class="built_in">max</span>(<span class="number">10</span>, <span class="number">15</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y):</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(<span class="number">5</span>, <span class="number">15</span>))</span><br></pre></td></tr></table></figure><p>MATLAB</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m</span> = <span class="title">max</span><span class="params">(x, y)</span></span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">        m = x</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        m = y</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">max</span>(<span class="number">5</span>, <span class="number">15</span>))</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">numbers[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">numbers[<span class="number">1</span>] = <span class="number">7</span>;</span><br><span class="line">numbers[<span class="number">2</span>] = <span class="number">10</span>;</span><br><span class="line">System.out.println(numbers[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>Or</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>&#125;;</span><br><span class="line">System.out.println(numbers[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><blockquote><p>您可以使用 <code>.length</code> 以下代码获取数组的长度 <code>3</code> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP—面对对象</title>
      <link href="/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP—基础语法</title>
      <link href="/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数组之前的知识是基础中的基础就不再整理了,只挑几个稍微要看一下的。</p><h1 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h1><p>基本语法例子示范</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> day = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Monday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Tuesday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Wednesday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thursday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Friday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Weekend&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果为 Wednesday；</p></blockquote><p>如果case语句中没有break;那么将执行该case下的所有语句:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> day = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Monday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 没有break，继续执行下一个case</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Tuesday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 没有break，继续执行下一个case</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Wednesday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 没有break，继续执行下一个case</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thursday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 没有break，继续执行下一个case</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Friday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 没有break，继续执行下一个case</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Weekend&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Wednesday</span><br><span class="line">Thursday</span><br><span class="line">Friday</span><br><span class="line">Weekend</span><br></pre></td></tr></table></figure></blockquote><p>其他需要注意的点:</p><ul><li><p>switch后圆括号中的表达式的类型只能是整型或能够隐式转换为整型的类型(如字符型,或枚举型)</p></li><li><p>每个case语句后必须是与表达式类型兼容的一个常量(但不能是<strong>字符串常量</strong>)</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> grade = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:  <span class="comment">// 字符常量，与表达式类型兼容</span></span><br><span class="line">            <span class="comment">// 代码块</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:    <span class="comment">// 整数常量，与表达式类型兼容</span></span><br><span class="line">            <span class="comment">// 代码块</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2.5</span>:  <span class="comment">// 错误，浮点数常量与字符类型不兼容</span></span><br><span class="line">            <span class="comment">// 代码块</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:  <span class="comment">// 错误，字符串常量不兼容</span></span><br><span class="line">            <span class="comment">// 代码块</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h1><p>基本语法例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (count &lt; <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意while后面有<strong>分号;</strong></li></ul><h1 id="字符串数组常用函数"><a href="#字符串数组常用函数" class="headerlink" title="字符串数组常用函数"></a>字符串数组常用函数</h1><h2 id="strcat-字符串连接函数"><a href="#strcat-字符串连接函数" class="headerlink" title="strcat-字符串连接函数"></a>strcat-字符串连接函数</h2><h3 id="函数原形"><a href="#函数原形" class="headerlink" title="函数原形:"></a>函数原形:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcat</span><span class="params">(<span class="type">char</span> str1[],<span class="type">const</span> <span class="type">char</span> str2[])</span></span>;</span><br></pre></td></tr></table></figure><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>把str2中的字符串连接到str1字符的后面, str1中字符的结束标志<code>\0</code>被st2里的字符串及其结束标志所覆盖。本函数返回值是str1的首地址。</p><p><img src="/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-20231220200644095.png" alt="image-20231220200644095"></p><h2 id="strcpy-字符串复制函数"><a href="#strcpy-字符串复制函数" class="headerlink" title="strcpy-字符串复制函数"></a>strcpy-字符串复制函数</h2><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcat</span><span class="params">(<span class="type">char</span> str1[],<span class="type">const</span> <span class="type">char</span> str2[])</span></span>;</span><br></pre></td></tr></table></figure><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>把str2中的字符串复制到str1中，str2中的串结束标志”\0”也一同复制。参数str2还可以是一个字符串常量，这时相当于把一个字符串赋予一个字符数组。</p><p><img src="/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-20231220200904869.png" alt="image-20231220200904869"></p><h2 id="strcmp-字符串比较函数"><a href="#strcmp-字符串比较函数" class="headerlink" title="strcmp-字符串比较函数"></a>strcmp-字符串比较函数</h2><h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> str1[],<span class="type">const</span> <span class="type">char</span> str2[])</span></span>;</span><br></pre></td></tr></table></figure><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>依照ASCII码表中的值的大小，依次比较两个字符串中对应位置上的字符，并由函数返回值返回比较结果。</p><p><img src="/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-20231220201312707.png" alt="image-20231220201312707"></p><h2 id="strlen-计算字符串长度函数"><a href="#strlen-计算字符串长度函数" class="headerlink" title="strlen-计算字符串长度函数"></a>strlen-计算字符串长度函数</h2><h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> str[])</span></span>;</span><br></pre></td></tr></table></figure><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><p>计算字符串中的长度,返回首次出现的结束标志<code>\0</code>之前的字符数,并作为返回值。</p><blockquote><p>计算时不包括\0</p></blockquote><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="指针的定义与声明"><a href="#指针的定义与声明" class="headerlink" title="指针的定义与声明"></a>指针的定义与声明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr;  <span class="comment">// 定义一个指向整数的指针</span></span><br><span class="line"><span class="type">double</span> *dblPtr;  <span class="comment">// 定义一个指向双精度浮点数的指针</span></span><br><span class="line"><span class="type">char</span> *charPtr;  <span class="comment">// 定义一个指向字符的指针</span></span><br></pre></td></tr></table></figure><h2 id="取地址操作符"><a href="#取地址操作符" class="headerlink" title="取地址操作符&amp;"></a>取地址操作符<code>&amp;</code></h2><p>取地址操作符 <code>&amp;</code> 用于获取变量的内存地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;number;  <span class="comment">// 将变量number的地址赋给指针ptr</span></span><br></pre></td></tr></table></figure><h2 id="指针和函数"><a href="#指针和函数" class="headerlink" title="指针和函数:"></a>指针和函数:</h2><p>指针可以用于传递地址，从而在函数中修改实际参数的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyValue</span><span class="params">(<span class="type">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">    *ptr = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span> *ptr = &amp;number;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">modifyValue</span>(ptr);  <span class="comment">// 传递指向number的指针给函数</span></span><br><span class="line">    <span class="comment">// 现在，number的值被修改为100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针解引用操作符"><a href="#指针解引用操作符" class="headerlink" title="指针解引用操作符 *"></a>指针解引用操作符 <code>*</code></h2><p>指针解引用操作符 <code>*</code> 用于访问指针所指向地址的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = *ptr;  <span class="comment">// 获取ptr指针所指向地址的值，将其赋给变量value</span></span><br></pre></td></tr></table></figure><h2 id="动态内存分配与释放"><a href="#动态内存分配与释放" class="headerlink" title="动态内存分配与释放:"></a>动态内存分配与释放:</h2><p>使用 <code>new</code> 操作符可以在运行时动态分配内存，而 <code>delete</code> 操作符用于释放动态分配的内存：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *dynamicPtr = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">// 动态分配一个整数大小的内存空间</span></span><br><span class="line"><span class="comment">// 使用 dynamicPtr 操作内存</span></span><br><span class="line"><span class="keyword">delete</span> dynamicPtr;  <span class="comment">// 释放动态分配的内存</span></span><br></pre></td></tr></table></figure><h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><p>指针和数组之间有着密切的关系，指针可以用于访问数组元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *arrPtr = numbers;  <span class="comment">// 将数组名赋给指针，指向数组的第一个元素</span></span><br></pre></td></tr></table></figure><h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p>空指针表示不指向任何有效的内存地址。在C++中，可以使用 <code>nullptr</code> 来表示空指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *nullPtr = <span class="literal">nullptr</span>;  <span class="comment">// 定义一个空指针</span></span><br></pre></td></tr></table></figure><h2 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h2><ul><li><p>常量指针：指针本身不可变，但指向的值可变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr = &amp;value;  <span class="comment">// 指向常量的指针</span></span><br></pre></td></tr></table></figure></li><li><p>指针常量：指向的值不可变，但指针本身可变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> ptr = &amp;value;  <span class="comment">// 常量指针</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表的创建"><a href="#链表的创建" class="headerlink" title="链表的创建"></a>链表的创建</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Set a, b;</span><br><span class="line"><span class="built_in">init</span>(&amp;a);</span><br><span class="line"><span class="built_in">init</span>(&amp;b);</span><br><span class="line"><span class="built_in">createSet</span>(&amp;a);</span><br><span class="line"><span class="built_in">createSet</span>(&amp;b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n, k, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k &gt;&gt; m;</span><br><span class="line">List lst;</span><br><span class="line"><span class="built_in">createList</span>(lst, n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向前插入生成"><a href="#向前插入生成" class="headerlink" title="向前插入生成"></a>向前插入生成</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Set</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">Node* head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(Set* x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">x-&gt;num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createSet</span><span class="params">(Set* x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//生成链表时一定采用往前插入的方法，即每个新产生的结点插入到链表的第一个结点的前面。</span></span><br><span class="line"><span class="type">int</span> n, i;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">Node* node = <span class="keyword">new</span> Node;</span><br><span class="line">cin &gt;&gt; node-&gt;data;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">x-&gt;head = node;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">Node* node = <span class="keyword">new</span> Node;</span><br><span class="line">cin &gt;&gt; node -&gt; data;</span><br><span class="line">node -&gt; next = x-&gt;head;</span><br><span class="line">x-&gt;head = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="向后插入"><a href="#向后插入" class="headerlink" title="向后插入"></a>向后插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span> &#123;</span><br><span class="line"></span><br><span class="line">Node* head;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createList</span><span class="params">(List&amp; lst, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">//生成链表时采用往后插入的方法，即每个新结点插入到链表尾部。</span></span><br><span class="line">lst.length = n;</span><br><span class="line">Node* _head = <span class="keyword">new</span> Node;</span><br><span class="line">_head-&gt;data = <span class="number">1</span>;</span><br><span class="line">lst.head = _head;</span><br><span class="line">Node* tail = _head;</span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (i; i &lt;= n; i++) &#123;</span><br><span class="line">Node* node = <span class="keyword">new</span> Node;</span><br><span class="line">node-&gt;data = i;</span><br><span class="line">tail-&gt;next = node;</span><br><span class="line">tail = tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h1><h2 id="漂亮的递归"><a href="#漂亮的递归" class="headerlink" title="漂亮的递归"></a>漂亮的递归</h2><p>【问题描述】键盘输入正整数 n，求出n与其反序数x之和并输出。例如，输入2038，n+x &#x3D; 2038 +8302 &#x3D;10340，输出应为10340。要求：编写函数实现数据转换成反序数值。【输入形式】输入一个整数； 【输出形式】输出一个整数； 【样例输入】2038 【样例输出】10340 【样例说明】不要任何输入输出的文字提示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> store = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">10</span>) <span class="keyword">return</span> store + n;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">store += n % <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reverse</span>(n / <span class="number">10</span>, store * <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n, reverse_num;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line">reverse_num = <span class="built_in">reverse</span>(n);</span><br><span class="line">std::cout &lt;&lt; n + reverse_num;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>写递归最关键的地方在于<strong>基本条件</strong>，基本条件出来了，递归的转折点也就出来了。</p></blockquote><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的旋转"><a href="#数组的旋转" class="headerlink" title="数组的旋转"></a>数组的旋转</h3><p><strong>【问题描述】</strong> 旋转是图像处理的基本操作，在这个问题中，你需要将一个图像逆时针旋转90度。 计算机中的图像表示可以用一个矩阵来表示，为了旋转一个图像，只需要将对应的矩阵旋转即可。 <strong>【输入格式】</strong> 输入的第一行包含两个整数n, m（1≤n, m≤10），分别表示图像矩阵的行数和列数。 接下来n行每行包含m个整数，表示输入的图像。 </p><p><strong>【输出格式】</strong> 输出m行，每行包含n个整数，表示原始矩阵逆时针旋转90度后的矩阵。每行后空格结束。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【样例输入】</span><br><span class="line">        2 3</span><br><span class="line">        1 5 3</span><br><span class="line">        3 2 4</span><br><span class="line">【样例输出】</span><br><span class="line">        3 4 </span><br><span class="line">        5 2 </span><br><span class="line">        1 3 </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> ls[<span class="number">10</span>][<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> ls2[<span class="number">10</span>][<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//初始化ls数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; ls[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数组旋转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            ls2[i][j] = ls[j][m - i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出旋转后的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cout &lt;&lt; ls2[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>也可以动态开辟:</p><p>&#x2F;&#x2F; 使用new运算符分配内存<br>int** ls &#x3D; new int* [n];<br>for (int i &#x3D; 0; i &lt; n; ++i) {<br>    ls[i] &#x3D; new int[m];<br>}<br>for (int i &#x3D; 0; i &lt; n; i++) {<br>    for (int j &#x3D; 0; j &lt; m; j++) {<br>        cin &gt;&gt; ls[i][j];<br>    }<br>}</p></blockquote><h3 id="求二维数组的鞍点"><a href="#求二维数组的鞍点" class="headerlink" title="求二维数组的鞍点"></a>求二维数组的鞍点</h3><p>【问题描述】找出一个二维数组（以三行四列的数组为例）中的鞍点，即该位置上的元素在该行上值最大，在该列上值最小（也可能没有鞍点）。</p><p>【输入形式】二维数组（以三行四列的数组为例）</p><p>【输出形式】如果有鞍点，输出鞍点的值及所在行列（例如[1][2]&#x3D;96 is Saddle Point），如果没有，输出没有鞍点（例如 No Saddle Point）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【样例输入】 </span><br><span class="line">  9 80 205 40</span><br><span class="line">  90 60 96 1</span><br><span class="line">  210 3 101 89</span><br><span class="line">【样例输出】</span><br><span class="line">  [1][2]=96 is Saddle Point</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ls[<span class="number">3</span>][<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> min = <span class="number">999</span>, max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">cin &gt;&gt; ls[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (ls[i][j] &gt; max) &#123;</span><br><span class="line">max = ls[i][j];</span><br><span class="line">col = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (ls[j][col] &lt; min) &#123;</span><br><span class="line">min = ls[j][col];</span><br><span class="line">row = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ls[row][col] == max) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">max = <span class="number">0</span>;</span><br><span class="line">min = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (min == max) cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; row &lt;&lt; <span class="string">&#x27;]&#x27;</span> &lt;&lt; <span class="string">&#x27;[&#x27;</span> &lt;&lt; col &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; min &lt;&lt; <span class="string">&quot; is Saddle Point&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;NO&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h3><p>【题目描述】<br>输入一个字符串（长度不超过255），请找出字符串中的所有的正整数（如-12，当作12），然后输出其中的素数。如果出现12.5，则看作12和5两个整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【样例输入】</span><br><span class="line"> How3.5many12prime-17number79inthestring.</span><br><span class="line">【样例输出】</span><br><span class="line"> 3 5 17 79</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; str.<span class="built_in">length</span>()) &#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (str[i] &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">num = num * <span class="number">10</span> + str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">is_prime</span>(num) &amp;&amp; num &gt; <span class="number">1</span>) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解计算机原理--第一章</title>
      <link href="/2023/12/14/%E8%AF%BB%E4%B8%80%E6%9C%AC%E5%A5%BD%E4%B9%A6-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-index/"/>
      <url>/2023/12/14/%E8%AF%BB%E4%B8%80%E6%9C%AC%E5%A5%BD%E4%B9%A6-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-index/</url>
      
        <content type="html"><![CDATA[<h1 id="二、信息的表示和表达"><a href="#二、信息的表示和表达" class="headerlink" title="二、信息的表示和表达"></a>二、信息的表示和表达</h1><h2 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h2><h3 id="2-1-1-十六进制表示法"><a href="#2-1-1-十六进制表示法" class="headerlink" title="2.1.1 十六进制表示法"></a>2.1.1 十六进制表示法</h3><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998390485614.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998390485614.png?x-oss-process=style/stylename</a>)</p><blockquote><p>转化为二进制需要从右到左每4分为一组转换(不足补0)</p></blockquote><h4 id="十进制和十六进制互选转换"><a href="#十进制和十六进制互选转换" class="headerlink" title="十进制和十六进制互选转换"></a>十进制和十六进制互选转换</h4><p>十进制除16倒取余<br>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998394198795.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998394198795.png?x-oss-process=style/stylename</a>)</p><h3 id="2-1-2-字数据大小"><a href="#2-1-2-字数据大小" class="headerlink" title="2.1.2 字数据大小"></a>2.1.2 字数据大小</h3><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998395609489.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998395609489.png?x-oss-process=style/stylename</a>)</p><blockquote><p>unsigned long、unsigned long int<br>都是同个意思</p></blockquote><h3 id="2-1-3-寻址和字节顺序"><a href="#2-1-3-寻址和字节顺序" class="headerlink" title="2.1.3 寻址和字节顺序"></a>2.1.3 寻址和字节顺序</h3><p>对于跨越多字节的程序对象，两个规则</p><ul><li>这个对象的地址是什么</li><li>字内存中如何排序这些字节</li></ul><h4 id="地址为所使用字节最小的地址"><a href="#地址为所使用字节最小的地址" class="headerlink" title="地址为所使用字节最小的地址"></a>地址为所使用字节最小的地址</h4><h4 id="排序方法有两个通用规则"><a href="#排序方法有两个通用规则" class="headerlink" title="排序方法有两个通用规则"></a>排序方法有两个通用规则</h4><ul><li>大端法:最高有效字节中最前面的方法</li><li>小端法:最低有效字节中最前面的方法<blockquote></blockquote>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998409476624.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998409476624.png?x-oss-process=style/stylename</a>)</li></ul><h3 id="2-1-4-表示字符串"><a href="#2-1-4-表示字符串" class="headerlink" title="2.1.4 表示字符串"></a>2.1.4 表示字符串</h3><p>字符串被编码为一个以null（值为0）字符结尾的字符数组，每个字符都由某个标准编码来表达，因此，文本数据比二进制数据具有更强的平台独立性</p><h3 id="2-1-5-表达代码"><a href="#2-1-5-表达代码" class="headerlink" title="2.1.5 表达代码"></a>2.1.5 表达代码</h3><p>不同机器类型使用不同的且不兼容的指令和编码方式，即使是完全一样的进程，运行中不同操作系统上也有不同的编码规则，因此二进制代码是不兼容的。</p><h3 id="2-1-6-布尔代数"><a href="#2-1-6-布尔代数" class="headerlink" title="2.1.6 布尔代数"></a>2.1.6 布尔代数</h3><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998567614189.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998567614189.png?x-oss-process=style/stylename</a>)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998568366125.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998568366125.png?x-oss-process=style/stylename</a>)</p><blockquote><p>布尔代数符合分配率<br>a&amp;(b|c) &#x3D; (a&amp;b)|(a&amp;c)<br>a|(b&amp;c) &#x3D; (a|b)&amp;(a|c)</p></blockquote><blockquote><p>布尔环<br>加分逆元(x+(-x) &#x3D; 0)<br>a^a &#x3D; 0<br>(a^b)^a &#x3D; b</p></blockquote><h3 id="2-1-7-位级运算"><a href="#2-1-7-位级运算" class="headerlink" title="2.1.7 位级运算"></a>2.1.7 位级运算</h3><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998569179935.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998569179935.png?x-oss-process=style/stylename</a>)</p><h4 id="掩码运算"><a href="#掩码运算" class="headerlink" title="掩码运算"></a>掩码运算</h4><p>掩码是一个位模式，表示一个字中选出的位的集合</p><blockquote><p>例子</p></blockquote><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998575552748.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998575552748.png?x-oss-process=style/stylename</a>)</p><h3 id="2-1-8-逻辑运算"><a href="#2-1-8-逻辑运算" class="headerlink" title="2.1.8 逻辑运算"></a>2.1.8 逻辑运算</h3><p>||、&amp;&amp;和！分别代表媒体逻辑中的OR、AND和NOT运算</p><h3 id="2-1-9移位运算"><a href="#2-1-9移位运算" class="headerlink" title="2.1.9移位运算"></a>2.1.9移位运算</h3><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998578307265.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998578307265.png?x-oss-process=style/stylename</a>)</p><ul><li>唯一例外是算术右移[10010101]的情况。<strong>因为操作数的最高位数1，填充的值就是1.</strong><blockquote><p>一般为算术右移<br>对于无符号数，右移必须是逻辑的<br>x&gt;&gt;j&gt;&gt;k等价于(x&lt;&lt;j)&lt;&lt;k<br>操作符的优先级中，加号的优先级比操作符的高</p></blockquote></li></ul><h2 id="2-2-整数表示"><a href="#2-2-整数表示" class="headerlink" title="2.2 整数表示"></a>2.2 整数表示</h2><p>编码整数的两种不同的方法：</p><ul><li>只能表示非负数</li><li>能够表示负数，0，正数</li></ul><blockquote><p>下文用到的数学术语</p></blockquote><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998582975352.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998582975352.png?x-oss-process=style/stylename</a>)</p><h3 id="2-2-1-整型数据类型"><a href="#2-2-1-整型数据类型" class="headerlink" title="2.2.1 整型数据类型"></a>2.2.1 整型数据类型</h3><h4 id="数据类型的典型取值范围"><a href="#数据类型的典型取值范围" class="headerlink" title="数据类型的典型取值范围"></a>数据类型的典型取值范围</h4><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998586485045.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998586485045.png?x-oss-process=style/stylename</a>)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998586665394.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998586665394.png?x-oss-process=style/stylename</a>)</p><blockquote><p>取值范围是不对称的——负数的范围比整数的范围大1</p></blockquote><blockquote><p>下表是C语言标准定义的每种数据类型必须能够表示的最小的取值范围。</p></blockquote><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998588029453.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998588029453.png?x-oss-process=style/stylename</a>)</p><h3 id="无符号的编码"><a href="#无符号的编码" class="headerlink" title="无符号的编码"></a>无符号的编码</h3><p>将位向量看作二进制表示的数，将获得了位向量的无符号表达</p><h4 id="无符号数编码的定义"><a href="#无符号数编码的定义" class="headerlink" title="无符号数编码的定义"></a>无符号数编码的定义</h4><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998590944911.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998590944911.png?x-oss-process=style/stylename</a>)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998591542514.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998591542514.png?x-oss-process=style/stylename</a>)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998592255921.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998592255921.png?x-oss-process=style/stylename</a>)</p><blockquote><p>B2Uw是一个双射，函数Ｂ2Uw将每个长度为w的位向量都映射位0～2^w - 1之间的一个唯一值；反过来,U2Bw在0～2^w - 1之间的每一个整数都可以映射为一个唯一的长度为w的位模式。</p></blockquote><h3 id="2-2-3-补码编码"><a href="#2-2-3-补码编码" class="headerlink" title="2.2.3 补码编码"></a>2.2.3 补码编码</h3><h4 id="补码编码的定义"><a href="#补码编码的定义" class="headerlink" title="补码编码的定义"></a>补码编码的定义</h4><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998595311062.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998595311062.png?x-oss-process=style/stylename</a>)<br>字的最高有效位解释为负权，也叫做符号位。</p><blockquote><p>符号位为1时值为负<br>符号位为0时值为非负</p></blockquote><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998597654820.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998597654820.png?x-oss-process=style/stylename</a>)</p><blockquote><p>B2Tw也是双射</p></blockquote><h4 id="可表示的整数的范围"><a href="#可表示的整数的范围" class="headerlink" title="可表示的整数的范围"></a>可表示的整数的范围</h4><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998599315139.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998599315139.png?x-oss-process=style/stylename</a>)</p><ul><li>补码范围不对称：｜TMin｜ &#x3D; |TMax| + 1<br>之所以不对称是因为一半的位模式表示负数，而另一半表示为非负数，因为0是非负数所以比负数多1</li><li>最大的无符号值刚好比补码的最大值的两倍大一点：UMaxw &#x3D; 2Tmxw + 1.<blockquote><p>c语言标准并没有要求用补码形式来表示用符号整数，但是几乎所有的机器都是这么做的。</p></blockquote></li></ul><blockquote><p>为来使代码具有最大可移植性，能够做所有可能的机器上运行，我们不应该假设任何可表示的数值类型，也不应该假设也符号数会使用何种特殊的表达方式。<br>许多程序的书写都是用补码来表示用符号数，并且具有图2-9和图2-10所示的典型的取值范围，这些程序能够值大量机器上移植</p></blockquote><p>staint.h中定义了一组数据类型：intN_t和uintN_t（对不同N值指定N位用符号和无符号整数）</p><blockquote><p>N：8、16、32和64</p></blockquote><p>这些数据类型对应着一组宏，定义了每个N对值对应对最小和最大值：INTN_MIN、INTN_MAX和UINTN_MAX</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998607174352.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998607174352.png?x-oss-process=style/stylename</a>)</p><h4 id="有符号的其他表示方法-反码和原码"><a href="#有符号的其他表示方法-反码和原码" class="headerlink" title="有符号的其他表示方法(反码和原码)"></a>有符号的其他表示方法(反码和原码)</h4><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998607836002.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998607836002.png?x-oss-process=style/stylename</a>)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998608162844.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998608162844.png?x-oss-process=style/stylename</a>)</p><p>![图2-15](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998608493945.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998608493945.png?x-oss-process=style/stylename</a>)</p><h3 id="2-2-4-有符号数和无符号数之间的转换"><a href="#2-2-4-有符号数和无符号数之间的转换" class="headerlink" title="2.2.4 有符号数和无符号数之间的转换"></a>2.2.4 有符号数和无符号数之间的转换</h3><p>从位级角度思考<br>转换<strong>数值变但是位模式不变</strong></p><h4 id="补码转换为无符号数"><a href="#补码转换为无符号数" class="headerlink" title="补码转换为无符号数"></a>补码转换为无符号数</h4><ul><li>原理<br>![公式2.5](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998611816561.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998611816561.png?x-oss-process=style/stylename</a>)</li><li>推导<br>![公式2.6](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998612864476.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998612864476.png?x-oss-process=style/stylename</a>)</li></ul><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998613857100.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998613857100.png?x-oss-process=style/stylename</a>)</p><h4 id="无符号数转换为补码"><a href="#无符号数转换为补码" class="headerlink" title="无符号数转换为补码"></a>无符号数转换为补码</h4><ul><li>原理</li></ul><p>![公式2.7](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998613713711.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998613713711.png?x-oss-process=style/stylename</a>)</p><ul><li>推导</li></ul><p>![公式2.8](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999191653704.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999191653704.png?x-oss-process=style/stylename</a>)</p><p>![图2-17](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999191775362.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999191775362.png?x-oss-process=style/stylename</a>)</p><h3 id="2-2-5-C语言中有符号数与无符号数"><a href="#2-2-5-C语言中有符号数与无符号数" class="headerlink" title="2.2.5 Ｃ语言中有符号数与无符号数"></a>2.2.5 Ｃ语言中有符号数与无符号数</h3><p><strong>默认补码，要创建无符号常数，后缀加u&#x2F;U</strong><br>Ｃ语言运算中，如果一个运算数是有符号而另一个是无符号，Ｃ语言就会隐式将<strong>有符号</strong>强制转换为<strong>无符号数</strong>，并假设两个数都是非负的</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/">http://mwebpng.oss-cn-beijing.aliyuncs.com</a><u></u>&#x2F;2023&#x2F;12&#x2F;15&#x2F;16999196070225.png?x-oss-process&#x3D;style&#x2F;stylename)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999196160028.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999196160028.png?x-oss-process=style/stylename</a>)</p><h3 id="2-2-6-扩展一个数的位表示"><a href="#2-2-6-扩展一个数的位表示" class="headerlink" title="2.2.6 扩展一个数的位表示"></a>2.2.6 扩展一个数的位表示</h3><h4 id="从较小类型转换到一个较大的类型-零扩展"><a href="#从较小类型转换到一个较大的类型-零扩展" class="headerlink" title="从较小类型转换到一个较大的类型(零扩展)"></a>从较小类型转换到一个较大的类型(零扩展)</h4><p>将无符号转换为另一个更大的数据类型</p><ul><li>零扩展：在表示的开头添加0</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读一本好书 </category>
          
          <category> 深入了解计算机原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读一本好书 </tag>
            
            <tag> 深入了解计算机原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tree递归</title>
      <link href="/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/"/>
      <url>/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>@<a href="%E9%97%AE%E9%A2%98">TOC</a><br>#Tree ADT<br><img src="/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/tree.jpg" alt="tree" title="tree"></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree</span>(<span class="params">label, branches=[]</span>):</span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches:</span><br><span class="line">        <span class="keyword">assert</span> is_tree(branch),<span class="string">&#x27;branches must be a tree&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> [label] + <span class="built_in">list</span>(branches)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">label</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">branches</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_tree</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(tree) != <span class="built_in">list</span> <span class="keyword">or</span> <span class="built_in">len</span>(tree) &lt;<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(tree):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_tree(branch):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_leaf</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> branches(tree)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>tree函数用于构造，label函数和branches函数用于选择，is_leaf和is_tree函数用于辅助</p></blockquote><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="fib-tree"><a href="#fib-tree" class="headerlink" title="fib_tree"></a>fib_tree</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib_tree</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left, right = fbi_tree(n-<span class="number">1</span>), fbi_tree(n-<span class="number">2</span>)</span><br><span class="line">        fib_n = label(left)+label(right)</span><br><span class="line">        <span class="keyword">return</span> tree(fib_n,left+right)</span><br></pre></td></tr></table></figure><blockquote><p>可见，基本情况是n &#x3D;&#x3D; 0 or n &#x3D;&#x3D;1<br>树递归的思想是从上到下，一旦到达基本情况变返回递归结果<br>这段函数从树顶端递归到0 or 1的情况，然后根据0和1的结果，逐层向上计算树节点的值</p></blockquote><h2 id="count-leaf"><a href="#count-leaf" class="headerlink" title="count_leaf"></a>count_leaf</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_leaves</span>(<span class="params">tree</span>):</span><br><span class="line">      <span class="keyword">if</span> is_leaf(tree):</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          branch_counts = [count_leaves(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(tree)]</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">sum</span>(branch_counts)</span><br></pre></td></tr></table></figure><blockquote><p>不断递归检查树枝是否为叶子，一旦是，便返回1并存储在数列中。最后用sum求树叶数</p></blockquote><h2 id="leaves"><a href="#leaves" class="headerlink" title="leaves"></a>leaves</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leaves</span>(<span class="params">tree</span>):</span><br><span class="line"><span class="keyword">if</span> is_leaf(tree):</span><br><span class="line"><span class="keyword">return</span> [label(tree)]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sum</span>([leaves(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(tree)],[])</span><br></pre></td></tr></table></figure><blockquote><p>分离树叶，不断递归检查树枝是否为树叶，若是，以数列形式存储在[ ]中，最后用sum消去一层[ ]<br>#为什么要用sum(<list>, [])？<br>因为当该分支只存在树叶时，leavers(b) for b in branches(tree)是以数列形式出现的，而若该分支同时存在树叶和树枝时，则返回单单数字(int).</list></p></blockquote><h2 id="increment-leaf"><a href="#increment-leaf" class="headerlink" title="increment_leaf:"></a>increment_leaf:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">increment_leaf</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> tree(label(t)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[increment_leaves(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br><span class="line"><span class="comment">#OR</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">increment</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">return</span> tree(label(t)+<span class="number">1</span>,[increment(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上面的increment只增加leaf<br>下面的increment增加所有节点</p></blockquote><h2 id="print-tree"><a href="#print-tree" class="headerlink" title="print_tree"></a>print_tree</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_tree</span>(<span class="params">t,indent = <span class="number">0</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>*indent + <span class="built_in">str</span>(label(t)))</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> branches(t):</span><br><span class="line">        print_tree(b, indent+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="print-path"><a href="#print-path" class="headerlink" title="print_path"></a>print_path</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_sums</span>(<span class="params">t, so_far</span>):</span><br><span class="line">    so_far = so_far + label(t)</span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="built_in">print</span>(so_far)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> branches(t):</span><br><span class="line">            print_sums(b, so_far)</span><br></pre></td></tr></table></figure><h2 id="count-paths"><a href="#count-paths" class="headerlink" title="count_paths"></a>count_paths</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_paths</span>(<span class="params">t, total</span>):</span><br><span class="line">    <span class="keyword">if</span> label(t) == total:</span><br><span class="line">        found = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        found = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> found + <span class="built_in">sum</span>([count_paths(b,total-label(t)) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br></pre></td></tr></table></figure><blockquote><p>重点在于返回的count_paths(b,total-label(t)中的<code>total-label(t)</code><br>在递归过程中，total-label(t)不断更新到达下一分支时，满足条件的值。</p></blockquote><p><img src="/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/cp.png" alt="输出结果"></p><p><img src="/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/count_paths.png" alt="图示"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="berry-finder"><a href="#berry-finder" class="headerlink" title="berry_finder"></a>berry_finder</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">berry_finder</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns True if t contains a node with the value &#x27;berry&#x27; and </span></span><br><span class="line"><span class="string">    False otherwise.</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = tree(1, [tree(&#x27;berry&#x27;,[tree(&#x27;not berry&#x27;)])])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; berry_finder(t)</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;*** YOUR CODE HERE ***&quot;</span></span><br><span class="line">    <span class="keyword">if</span> label(t) == <span class="string">&#x27;berry&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t):</span><br><span class="line">        <span class="keyword">if</span> berry_finder(branch):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="replace-loki-at-leaf"><a href="#replace-loki-at-leaf" class="headerlink" title="replace_loki_at_leaf"></a>replace_loki_at_leaf</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">replace_loki_at_leaf</span>(<span class="params">t, lokis_replacement</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns a new tree where every leaf value equal to &quot;loki&quot; has</span></span><br><span class="line"><span class="string">    been replaced with lokis_replacement.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> label(t) == <span class="string">&#x27;loki&#x27;</span><span class="keyword">and</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> tree(lokis_replacement, [replace_loki_at_leaf(branch,lokis_replacement) <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t)])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[replace_loki_at_leaf(branch,lokis_replacement) <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Height"><a href="#Height" class="headerlink" title="Height"></a>Height</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Q5: Height</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the height of a tree.</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = tree(3, [tree(5, [tree(1)]), tree(2)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; height(t)</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;*** YOUR CODE HERE ***&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>([height(branch) <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t)])</span><br></pre></td></tr></table></figure><h2 id="find-path"><a href="#find-path" class="headerlink" title="find_path"></a>find_path</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_path</span>(<span class="params">t, x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = tree(2, [tree(7, [tree(3), tree(6, [tree(5), tree(11)])] ), tree(15)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; find_path(t, 5)</span></span><br><span class="line"><span class="string">    [2, 7, 6, 5]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; find_path(t, 10)  # returns None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> label(t) == x:</span><br><span class="line">        <span class="keyword">return</span> [label(t)]</span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t):</span><br><span class="line">        path = find_path(branch, x)</span><br><span class="line">        <span class="keyword">if</span> path:</span><br><span class="line">            <span class="keyword">return</span> [label(t)] + path</span><br></pre></td></tr></table></figure><h2 id="sprout-leaves"><a href="#sprout-leaves" class="headerlink" title="sprout_leaves"></a>sprout_leaves</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sprout_leaves</span>(<span class="params">t, leaves</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Sprout new leaves containing the data in leaves at each leaf in</span></span><br><span class="line"><span class="string">    the original tree t and return the resulting tree.</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t1 = tree(1, [tree(2), tree(3)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(t1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">      3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; new1 = sprout_leaves(t1, [4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(new1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">      3</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[tree(leaf) <span class="keyword">for</span> leaf <span class="keyword">in</span> leaves])</span><br><span class="line">    <span class="keyword">return</span> tree(label(t),[sprout_leaves(branch,leaves) <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们可以发现，完成这些例子和练习的核心思想有：</p><ol><li>重构tree，且将branches部分用递归方法不断更新为我们需要的树枝。</li><li>利用 for语句和branches选择函数对函数进行递归。</li><li>而递归的关键就在于我们对基本情况的定义和对tree ADT的理解应用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CS61A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/"/>
      <url>/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>笔记来源网课教程：<a href="https://www.bilibili.com/video/BV1oD4y1h7S3">C++教程</a><br>10月·8号发布</p><h1 id="C-是怎么工作的"><a href="#C-是怎么工作的" class="headerlink" title="C++是怎么工作的"></a>C++是怎么工作的</h1><p>项目中的源文件传输给编译器，编译器将其转化成二进制的东西，可能转化成某种库，也可能是可执行的程序<br>opp编译成obj文件，然后通过linker将obj整合起来</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>编译前处理include后面的文件，该文件通常叫做“头文件”，我们之所以要包括iostream这个头文件，是因为我们需要一个被调用的函数的声明，例如<code>std::cout</code></p><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>程序的入口，它不一定需要返回值，默认返回0</p><h2 id><a href="#" class="headerlink" title="&lt;&lt;重载语句"></a>&lt;&lt;重载语句</h2><p>相当于一个函数而已，相当于print()<br><code>std::cout &lt;&lt; &quot;Hello World&quot;&lt;&lt; std::endl;</code><br>相当于<br><code>std::cout .print( &quot;Hello World&quot;).pint(std::endl); </code></p><h2 id="链接项目中的函数代码"><a href="#链接项目中的函数代码" class="headerlink" title="链接项目中的函数代码"></a>链接项目中的函数代码</h2><p><strong>Log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; </span><br><span class="line"><span class="comment">// 声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过linker将main.cpp中声明并使用的函数链接到某个项目文件中唯一的log函数中</p></blockquote><blockquote><p>声明只包含了函数，定义包含了函数和函数体</p></blockquote><h1 id="C-编译器的工作"><a href="#C-编译器的工作" class="headerlink" title="C++编译器的工作"></a>C++编译器的工作</h1><p>首先预处理,将所有代码转化成常量数据或指令。<br>将我们项目所有的cpp生成opj文件<br>cpp叫做<strong>翻译单元</strong></p><h2 id="include工作原理"><a href="#include工作原理" class="headerlink" title="#include工作原理"></a>#include工作原理</h2><p>在编译前将指定的文件粘贴并复制到当前cpp当中</p><p><strong>EndBrace.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; </span><br><span class="line"><span class="comment">// 声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&#x27;EndBrace.h&#x27;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>编译器的工作就是，将EndBrace中的所有代码copy进去当前cpp</p></blockquote><h2 id="查看预处理器实际上生成的文件"><a href="#查看预处理器实际上生成的文件" class="headerlink" title="查看预处理器实际上生成的文件"></a>查看预处理器实际上生成的文件</h2><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E9%A2%84%E5%A4%84%E7%90%86.png" alt="预处理器文件"><br>编译后会生成一个.i文件<br>里面含有预处理后的结果</p><h2 id="查看obj文件"><a href="#查看obj文件" class="headerlink" title="查看obj文件"></a>查看obj文件</h2><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E7%A8%8B%E5%BA%8F%E9%9B%86.png" alt="程序集"></p><p>将obj中的二进制文件转化为汇编代码(ASM文件) </p><blockquote><p>若在优化将速度调最大会忽略掉一些无用的操作</p></blockquote><h1 id="C-链接"><a href="#C-链接" class="headerlink" title="C++链接"></a>C++链接</h1><p>编译后的操作，链接的焦点是找到每个符号和函数在哪里然后连接在一起。<br><strong>编译可能不需要main函数，但是链接过程一定需要main函数</strong></p><blockquote><p>编译错误 错误类型是C开头，链接错误是LIN开头</p></blockquote><blockquote><p>不能存在两个相同的函数带着相同的参数，这样链接器不知道链接哪一个，从而产生错误。</p></blockquote><h2 id="易错处"><a href="#易错处" class="headerlink" title="易错处"></a>易错处</h2><p><strong>Log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 注意log函数名字已经被修改了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; </span><br><span class="line"><span class="comment">//声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//log(&quot;multiply&quot;);</span></span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">Multiply</span>(<span class="number">5</span>, <span class="number">8</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链接没有错误</p></blockquote><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; </span><br><span class="line"><span class="comment">//声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;multiply&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; Multiply(5, 8) &lt;&lt; std::endl;</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链接错误</p></blockquote><p><strong>为什么？</strong><br>虽然在这个文件中可能用不上Multiply函数，但在其他文件可能用得上，所以链接器确实需要链接它</p><h3 id="限制链接，函数只在当前翻译单元使用的方法"><a href="#限制链接，函数只在当前翻译单元使用的方法" class="headerlink" title="限制链接，函数只在当前翻译单元使用的方法"></a>限制链接，函数只在当前翻译单元使用的方法</h3><p>用<code>static</code>加在函数前</p><h2 id="产生链接错误的例子及修正"><a href="#产生链接错误的例子及修正" class="headerlink" title="产生链接错误的例子及修正"></a>产生链接错误的例子及修正</h2><h3 id="错误例子"><a href="#错误例子" class="headerlink" title="错误例子"></a>错误例子</h3><p><strong>log.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initlog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;Initialized log&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;multiply&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; Multiply(5, 8) &lt;&lt; std::endl;</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链接失败，log重复了</p></blockquote><p><strong>原因分析：</strong><br>两个头文件同时引入了两个log函数所以产生错误.</p><h3 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h3><ol><li><strong>log.h</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将log函数修改为静态函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>log.h</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>inlind的作用是获得我们实际的函数体并将函数调用替换为函数体。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>(<span class="string">&quot;Initialized log&quot;</span>);</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Initialized log&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><ol start="3"><li>将定义移到一个翻译单元</li></ol><p><strong>log.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initlog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;Initialized log&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-变量"><a href="#C-变量" class="headerlink" title="C++变量"></a>C++变量</h1><p>变量允许我们命名存储在内存中的数据并继续使用<br>当我们创造变量时，他被存储在内存中。</p><h2 id="不同变量类型的区别是内存大小"><a href="#不同变量类型的区别是内存大小" class="headerlink" title="不同变量类型的区别是内存大小"></a>不同变量类型的区别是内存大小</h2><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul><li>char : 1 byte (经常存储字符)</li><li>short : 2 byte</li><li>int : 4 byte</li><li>long : 4 byte</li><li>long long : 8 byte</li><li>float : 4 byte</li><li>double : 8 byte</li><li>bool : 1 byte<blockquote><p>float和double的区别可以是在数字后面加f(float)<br>1 是 Ture,0 是 False.</p></blockquote></li></ul><h3 id="查看数字大小"><a href="#查看数字大小" class="headerlink" title="查看数字大小"></a>查看数字大小</h3><p>sizeof(bool)</p><h1 id="C-函数"><a href="#C-函数" class="headerlink" title="C++函数"></a>C++函数</h1><p>最主要的是提高维护效率<br>避免复制重复<br>我们通常在头文件中写声明，在翻译单元或cpp文件中编写定义，原因就是<strong>链接错误中的修改方法3</strong></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io_mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">multiply</span>(a, b);</span><br><span class="line">std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">io_mul</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">io_mul</span>(<span class="number">3</span>,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">io_mul</span>(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>io_mul的作用就是避免重复</p></blockquote><h1 id="C-头文件"><a href="#C-头文件" class="headerlink" title="C++头文件"></a>C++头文件</h1><p> 当我们跨文件调用函数的时候免不了声明，如果某个函数很常用那就要一直复制粘贴，很繁琐。<br> 而头文件就是塞入一堆声明，然后在其他cpp中include后，让预处理器帮忙复制粘贴。</p><h2 id="pragma-once"><a href="#pragma-once" class="headerlink" title="pragma once"></a>pragma once</h2><p>当我们创建了一个头文件，vs会自动帮我们填写<code>#pragma once</code><br>这个的作用是防止include多个头文件时，里面有重复的声明，导致编译失败。他只会复制一次声明</p><h2 id="ifndef"><a href="#ifndef" class="headerlink" title="ifndef"></a>ifndef</h2><p><strong>log.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nitLog</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>检查是否有个_LOG_H被定义了，如果没有就编译中包括以下代码,如果被定义了，那么这些都不会被包括进来 </p></blockquote><blockquote><p>如果通过了这初次检查，我们定义_LOG_H,如果下次用到的时候，就不会重复声明了</p></blockquote><h2 id="include两个不同形式"><a href="#include两个不同形式" class="headerlink" title="include两个不同形式"></a>include两个不同形式</h2><h3 id="形式"><a href="#形式" class="headerlink" title="&lt; &gt;形式"></a>&lt; &gt;形式</h3><p>告诉编译器去搜索包含路径的文件夹 </p><h3 id="“-“形式"><a href="#“-“形式" class="headerlink" title="“ “形式"></a>“ “形式</h3><p>告诉编译器就在当前文件夹，我们也可以用”..&#x2F;log.h”去返回到当前文件的上级目录</p><h2 id="区别c-标准库和c标准库"><a href="#区别c-标准库和c标准库" class="headerlink" title="区别c++标准库和c标准库"></a>区别c++标准库和c标准库</h2><p>关键在于有无.h扩展，c++文件通常没有。</p><h1 id="如何在vs中调试代码"><a href="#如何在vs中调试代码" class="headerlink" title="如何在vs中调试代码"></a>如何在vs中调试代码</h1><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>在断点处暂停程序</p><h3 id="读取内存"><a href="#读取内存" class="headerlink" title="读取内存"></a>读取内存</h3><p>程序中断后,内存数据实际上还在,查看内存对诊断问题.</p><h2 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h2><ol start="0"><li>确保模式是<strong>debug模式</strong></li><li><strong>设置断点</strong></li><li><strong>读内存</strong></li></ol><h3 id="按键介绍"><a href="#按键介绍" class="headerlink" title="按键介绍"></a>按键介绍</h3><ul><li>逐语句(F11)(step into):进入到当前这行代码上的函数里面</li><li>逐过程(F10)(step over):从当前函数跳到下一行代码</li><li>跳出(shift+F11)(step out):跳出当前函数，回到调用这个函数的位置</li></ul><h3 id="窗口介绍"><a href="#窗口介绍" class="headerlink" title="窗口介绍"></a>窗口介绍</h3><ul><li>自动、局部窗口 : 向你展示可能重要的全局或局部</li><li>监视1：观察变量(输入要观察的变量然后回车)</li></ul><blockquote><p>右键可以修改成查看16进制</p></blockquote><h3 id="内存视图"><a href="#内存视图" class="headerlink" title="内存视图"></a>内存视图</h3><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE.png" alt="内存视图"><br><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE_1.png" alt="内存视图浏览"></p><ul><li>最左侧为内存地址</li><li>中间是以16进制存储的实际值</li><li>最右边是以ACCII对值的解释</li></ul><h4 id="内存视图的使用"><a href="#内存视图的使用" class="headerlink" title="内存视图的使用"></a>内存视图的使用</h4><p>在地址一栏输入&amp;＋变量名即可</p><h1 id="VS的最佳设置"><a href="#VS的最佳设置" class="headerlink" title="VS的最佳设置"></a>VS的最佳设置</h1><h2 id="项目的设置"><a href="#项目的设置" class="headerlink" title="项目的设置"></a>项目的设置</h2><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E8%99%9A%E6%8B%9F%E7%BB%84%E7%BB%87.ong" alt="虚拟组织"></p><blockquote><p>这只是虚拟组织的文件夹，在文件资源管理器中并不存在。</p></blockquote><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E6%98%BE%E7%A4%BA%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt="显示所有文件"><br>我们可以点击<strong>显示所有文件</strong>这个按钮，这样子新添加文件夹的时候就实际的添加了文件夹，而非虚拟文件夹。</p><h2 id="文件夹的设置"><a href="#文件夹的设置" class="headerlink" title="文件夹的设置"></a>文件夹的设置</h2><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E8%AE%BE%E7%BD%AE.png" alt="设置"><br><code>$(SolutionDir)bin\$(Platform)\$(Configuration)\</code></p><h1 id="C-条件与分值-if语句"><a href="#C-条件与分值-if语句" class="headerlink" title="C++条件与分值(if语句)"></a>C++条件与分值(if语句)</h1><p> 检查条件，然后跳转到内存的不同的地方,并从这里开始执行指令。</p><h2 id="内在指令"><a href="#内在指令" class="headerlink" title="内在指令"></a>内在指令</h2><p> <img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E5%8F%8D%E6%B1%87%E7%BC%96.png" alt="反汇编"></p><blockquote><p>设置断点调试时，右键进入反汇编模式</p></blockquote><ul><li>mov : move</li><li>jne ：jump not equal</li><li>je ：jump equel</li></ul><blockquote><ol><li><p><code>mov dword ptr [a], 5</code>：这条指令将立即数5移动到名为<code>a</code>的整数变量。它将5存储到<code>a</code>的内存位置。</p></li><li><p><code>cmp dword ptr [a], 5</code>：这是一个比较指令，用于比较<code>a</code>的值与5的值。它将<code>a</code>的值与5进行比较，但不会更改任何寄存器的值。</p></li><li><p><code>jne main+34h (07FF6F0B823B4h)</code>：这是一个条件跳转指令。它检查前面的比较结果是否不等于（jne表示”jump if not<br>equal”）零，如果不等于零，则跳转到指定的地址，这里是<code>main+34h</code>。</p></li><li><p><code>mov dword ptr [rbp+0F4h], 1</code>：如果比较结果是相等的（即<code>a</code>等于5），则将立即数1移动到内存中的某个位置，该位置可能是一个标志变量，用于表示条件满足。</p></li><li><p><code>jmp main+3Eh (07FF6F0B823BEh)</code>：这是一个无条件跳转指令，它将程序跳转到指定的地址，这里是<code>main+3Eh</code>。</p></li><li><p><code>mov dword ptr [rbp+0F4h], 0</code>：这个指令是前面条件跳转的目标（如果比较结果不等于零），它将立即数0移动到内存中的某个位置，表示条件不满足。</p></li><li><p><code>movzx eax, byte ptr [rbp+0F4h]</code>：这条指令将内存中的一个字节（8位）加载到32位寄存器<code>eax</code>中，并将其零扩展（即高位填充0）。这可能是为了将条件满足与否的标志位加载到寄存器中。</p></li><li><p><code>mov byte ptr [comparisonResult], al</code>：这个指令将寄存器<code>al</code>中的字节值写入名为<code>comparisonResult</code>的布尔变量。这是将条件判断的结果保存到布尔变量中的操作。</p></li><li><p><code>movzx eax, byte ptr [comparisonResult]</code>：这是将布尔变量<code>comparisonResult</code>的值加载到寄存器<code>eax</code>中，以便进行进一步的条件判断。</p></li><li><p><code>test eax, eax</code>：这个指令将寄存器<code>eax</code>与自身进行按位与操作。它的目的是检查<code>eax</code>中的值是否为零。</p></li><li><p><code>je main+5Ch (07FF6F0B823DCh)</code>：这是一个条件跳转指令，如果前面的按位与操作结果等于零（即<code>eax</code>中的值为零），则跳转到指定的地址，这里是<code>main+5Ch</code>。</p></li><li><p><code>lea rcx, [string &quot;hello&quot; (07FF6F0B8BCA4h)]</code>：这个指令将字符串”hello”的地址加载到寄存器<code>rcx</code>中，准备调用一个名为<code>Log</code>的函数。</p></li><li><p><code>call Log (07FF6F0B8135Ch)</code>：这是一个函数调用指令，它调用名为<code>Log</code>的函数，并将<code>rcx</code>中的地址作为参数传递给该函数，用于记录”hello”。</p></li></ol></blockquote><h1 id="C-循环"><a href="#C-循环" class="headerlink" title="C++循环"></a>C++循环</h1><p>for and while 循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; a &lt; <span class="number">5</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line">pass</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>变量的声明,循环的条件(评估后的bool值),一次循环后的操作</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">.....</span><br><span class="line">i ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h1 id="C-控制流语句"><a href="#C-控制流语句" class="headerlink" title="C++控制流语句"></a>C++控制流语句</h1><p>控制流一般和循环一起使用</p><ul><li>continue :只能在循环使用</li><li>break : 能在循环和switch语句使用</li><li>return</li></ul><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>跳到循环的下一个迭代</p><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>跳出循环</p><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>返回值，终止语句</p><h1 id="C-指针"><a href="#C-指针" class="headerlink" title="C++指针"></a>C++指针</h1><p>指针是整数，一种存储内存地址的数字。对管理和操纵内存有很大用处.</p><h2 id="指针的引用和逆引用"><a href="#指针的引用和逆引用" class="headerlink" title="指针的引用和逆引用"></a>指针的引用和逆引用</h2><p>类型的意义在于逆引用指针时可以访问和修改变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;var;</span><br><span class="line">*ptr = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="申请内存和二次指针"><a href="#申请内存和二次指针" class="headerlink" title="申请内存和二次指针"></a>申请内存和二次指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>** ptr = &amp;buffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>pte地址的内存实际上是buffer的内存地址，只不过反了过来<br>比如如果pte的内存是b8 f1 02 00<br>那么buffer的内存地址就是00 02 f1 b8</p></blockquote><h1 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h1><p>(指针的扩展)<br>引用不用占用内存，但是指针是变量，会占用内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;</span><br><span class="line"><span class="comment">//ref 实际上不存在，编译后只会有变量a</span></span><br><span class="line"><span class="comment">//相当于a的别名</span></span><br><span class="line"> </span><br><span class="line"> std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用的作用"><a href="#引用的作用" class="headerlink" title="引用的作用"></a>引用的作用</h2><blockquote><p>运用指针的例子</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increment</span><span class="params">(<span class="type">int</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">(*value)++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">Increment</span>(&amp;a)；</span><br><span class="line"><span class="built_in">Log</span>(a);</span><br><span class="line"><span class="comment">//结果为 : 6</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运用引用的例子</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increment</span><span class="params">(<span class="type">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">Increment</span>(a);</span><br><span class="line"><span class="built_in">Log</span>(a);</span><br><span class="line"><span class="comment">//结果为 : 6</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在C++中，函数参数的默认传递方式是按值传递(pass by value)。这意味着当你调用一个函数时，传递给函数的是原始数据的副本，而不是原始数据本身。这是因为按值传递会创建原始数据的副本，以便函数可以在副本上执行操作，而不会影响原始数据。<br> 当你调用Increment(a)时，a的值被复制到Increment函数的局部变量value中，然后在函数内部对value进行递增操作。这个递增操作只会影响value的副本，而不会影响a的原始值。这就是为什么在main函数中a 的值仍然是5。</p></blockquote><p>那如果我用return a呢？</p><blockquote><p>如果你在 Increment 函数中返回 value，那么你需要在 main 函数中捕获这个返回值并将其分配给 a，才能使 a 的值增加。这是因为在 C++ 中，函数的返回值不会自动修改传递给它的参数。<br>a &#x3D; increment(a)</p></blockquote><p>简而言之，引用可以节约内存开销,避免重复复制。</p><h2 id="引用的注意"><a href="#引用的注意" class="headerlink" title="引用的注意"></a>引用的注意</h2><p>你不能改变它引用的东西<br>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;</span><br><span class="line">ref = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>* ref = &amp;a;</span><br><span class="line">*ref = <span class="number">2</span>;</span><br><span class="line">ref = &amp;b;</span><br><span class="line">*ref = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Log</span>(a);</span><br><span class="line"><span class="built_in">Log</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，错误例子中会运行成功，但是他并不是更改引用,ref这个引用还是引用的a</p></blockquote><h1 id="C-类"><a href="#C-类" class="headerlink" title="C++类"></a>C++类</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> xa, <span class="type">int</span> ya)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x += xa * speed;</span><br><span class="line">y += ya * speed;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void Move(Player&amp; player, int xa, int ya)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//player.x += xa * player.speed;</span></span><br><span class="line"><span class="comment">//player.y += xa * player.speed;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Player player;</span><br><span class="line">player.x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>花括号后面需要有分号<br>由类类型构成的变量称为<strong>对象</strong><br>新的对象变量称为<strong>实例</strong><br>类中的函数称为<strong>方法</strong></p></blockquote><blockquote><p>类中的属性是私有的，如果需要访问修改需要public类中的属性。</p></blockquote><h1 id="C-类与结构体对比"><a href="#C-类与结构体对比" class="headerlink" title="C++类与结构体对比"></a>C++类与结构体对比</h1><p>类默认是私有的，类外部调用时无法调用。<br>技术上说，没什么区别，但是使用情境不同。<br>struct and class</p><blockquote><p>弹幕：用结构体当数据容器，用类来写具备逻辑的功能对象.</p></blockquote><h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2><ol><li>默认的继承访问权 : class默认的是private,strcut默认的是public。</li><li>默认访问权限 : struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。</li><li>“class”这个关键字还用于定义模板参数，就像“typename”。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python—字符串,多态函数（接口），特殊方法名称[61A Fall 2023 Lecture 20——Inheritance]</title>
      <link href="/2023/12/14/Python-Python%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0-61A-Fall-2023-Lecture-20%E2%80%94%E2%80%94Inheritance-Python%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0-61A-Fall-2023-Lecture-20%E2%80%94%E2%80%94Inheritance/"/>
      <url>/2023/12/14/Python-Python%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0-61A-Fall-2023-Lecture-20%E2%80%94%E2%80%94Inheritance-Python%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0-61A-Fall-2023-Lecture-20%E2%80%94%E2%80%94Inheritance/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h1 id="字符串表示形式"><a href="#字符串表示形式" class="headerlink" title="字符串表示形式"></a>字符串表示形式</h1><h2 id="str"><a href="#str" class="headerlink" title="str()"></a>str()</h2><p>方便阅读</p><h2 id="repr"><a href="#repr" class="headerlink" title="repr()"></a>repr()</h2><p>方便调试</p><ul><li>repr 返回对象的官方表示形式</li><li>print 用于打印可读性好的字符串</li><li>str 返回对象的非正式表示</li><li>eval 用于执行字符串表示的代码。</li><li>在字符串示例中，由于字符串中包含引号和全角逗号，因此在 repr 和 str 的输出中会反映这些差异，但 eval 用于执行这些字符串时，它们被正确处理。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half= Fraction(<span class="number">1</span>，<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>halfFraction(<span class="number">1</span>，<span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt;&gt; <span class="built_in">repr</span>(half)</span><br><span class="line"><span class="string">&#x27;Fraction(1，2)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(half)</span><br><span class="line"><span class="number">1</span>/<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(half)</span><br><span class="line"><span class="string">&#x27;1/2&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">repr</span>(half))</span><br><span class="line">Fraction(<span class="number">1</span>，<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">str</span>(half))</span><br><span class="line">05</span><br></pre></td></tr></table></figure><blockquote><p>repr(half) 返回对象的”official”字符串表示形式，它是 Fraction(1，2)，它是有效的Python表达式，可以用于重建相同的对象。<br>print(half) 打印对象时，print 使用对象的 str 方法，所以它输出 ‘1&#x2F;2’，这是用户友好的字符串表示。<br>str(half) 返回对象的”informal”字符串表示形式，这里返回 ‘1&#x2F;2’。<br>eval(repr(half)) 使用 eval 函数来执行 repr(half) 返回的字符串，这将返回一个新的 Fraction 对象，即 Fraction(1，2)。<br>eval(str(half)) 使用 eval 函数来执行 str(half) 返回的字符串，这将返回浮点数 0.5，因为 eval 解释它为数学表达式。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&quot;Hello, World&quot;</span></span><br><span class="line">&gt;&gt;&gt;s</span><br><span class="line"><span class="string">&#x27;Hello，World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">repr</span>(s))</span><br><span class="line"><span class="string">&#x27;Hello，World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s)</span><br><span class="line">Hello，World</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">str</span>(s))</span><br><span class="line">Hello，World</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(s)</span><br><span class="line"><span class="string">&#x27;Hello，World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(s)</span><br><span class="line"><span class="string">&quot;&#x27;Hello,World&#x27;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">repr</span>(s))</span><br><span class="line"><span class="string">&#x27;Hello，World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(<span class="built_in">repr</span>(<span class="built_in">repr</span>(s)))</span><br><span class="line"><span class="string">&#x27;\&#x27;&quot;\\\&#x27;Hello,world\\\&#x27;&quot;\&#x27;&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">eval</span>(<span class="built_in">eval</span>(<span class="built_in">repr</span>(<span class="built_in">repr</span>(<span class="built_in">repr</span>(s)))))))</span><br><span class="line"><span class="string">&#x27;Hello, World&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h1><h2 id="f’-’"><a href="#f’-’" class="headerlink" title="f’{}’"></a>f’{}’</h2><p>花括号里的为Python表达式 会自动计算<br>你也可以用str()或repr()</p><h1 id="多态函数"><a href="#多态函数" class="headerlink" title="多态函数"></a>多态函数</h1><p>使用于许多不同类型数据的函数<br>str和repr函数就是例子</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="repr-1"><a href="#repr-1" class="headerlink" title="repr"></a>repr</h3><p>调用一个零参数方法，相应地称为__repr__</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>half.__repr__()</span><br><span class="line"><span class="string">&#x27;Fraction(1, 2)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="str-1"><a href="#str-1" class="headerlink" title="str"></a>str</h3><p>调用一个零参数方法，相应地称为_str_</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half.__str__()</span><br><span class="line"><span class="string">&#x27;1/2&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用print()时实际上就是调用了__str__()</p></blockquote><h2 id="repr和str的实现"><a href="#repr和str的实现" class="headerlink" title="repr和str的实现"></a>repr和str的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repr</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">type</span>(x).__repr__(x)</span><br></pre></td></tr></table></figure><p>通过查找为你提供的参数类型来设法跳过实例属性或忽略他们</p><blockquote><p>是一个类属性，也是一个函数，但是这个函数不是绑定方法，因为它是在type类中查找的</p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>对象属性是消息传递的一种形式，它允许不同的数据类型以不同的方式响应同一消息。</li></ul><blockquote><p>对象通过发送消息(通常是方法调用)来与其他对象进行交互。对象的属性可以是对象的状态或数据。</p></blockquote><ul><li>从不同类引出类似行为的一组共享消息是一种强大的抽象方法。</li></ul><blockquote><p>不同的类可以实现相同的接口或共享相同的消息。</p></blockquote><ul><li>接口是一组共享属性名称，以及它们的行为规范。在复数的情况下，实现算术所需的接口由四个属性组成： real 、 imag 、 magnitude 和 angle 。<blockquote><p>这是一个具体的示例，说明了接口的用途。如果多个类需要实现某种算术操作（例如复数的加法或乘法），可以定义一个接口，其中包含所需的属性名称和方法，以确保这些类都具有相同的接口，从而可以执行相似的操作。</p></blockquote></li></ul><p>消息传递：对象通过查找彼此的属性（传递消息）进行交互<br>属性查找规则允许不同的数据类型响应相同的消息<br>从不同对象类中引出类似行为的共享消息（属性名）是一种强大的<strong>抽象方法</strong></p><p><strong>实现返回python可解释和人类可读字符串的方法</strong>的<strong>类</strong>实现了用于<strong>生成字符串表示的接口</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ratio</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n , d</span>):</span><br><span class="line">        self.numer = n</span><br><span class="line">        self.denom = d</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Ratio(&#123;0&#125;, &#123;1&#125;)&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;0&#125;/&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half = Ratio(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(half)</span><br><span class="line"><span class="number">1</span>/<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half</span><br><span class="line">Ratio(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p>个人对接口的理解：有一些具有相同行为的类，我们定义了一个接口，使得我们不需要知道传入这些类中的数据类型便知道这些类都有一种可以计算某个结果的方法。这样子不管什么数据类型都可以计算出我们需要的预期结果。[这是抽象接口]</p></blockquote><blockquote><p>Python存在两种接口 一个是面对对象用于继承的抽象接口，一个是用于封装类显露出来的动态接口[下面Ratio类的add方法是一种接口，是动态接口]</p></blockquote><h1 id="特殊方法名称"><a href="#特殊方法名称" class="headerlink" title="特殊方法名称"></a>特殊方法名称</h1><p>总是有__在前面和后面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;zero, one, two = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one + two</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(zero), <span class="built_in">bool</span>(one)</span><br><span class="line">(<span class="literal">False</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt;zero, one, two = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one.__add__(two)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zero.__bool__(), one.__bool__()</span><br><span class="line">(<span class="literal">False</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><blockquote><p>内置语法和内置函数 与 实际执行工作的特殊方法名称中间存在对应关系</p></blockquote><p>这是使用接口来允许用户定义的对象与Python中内置系统进行交互的另一个示例。<br>我们举例类的时候可以覆盖特殊方法来建立我们想要的互动结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ratio</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n , d</span>):</span><br><span class="line">        self.numer = n</span><br><span class="line">        self.denom = d</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Ratio(&#123;0&#125;, &#123;1&#125;)&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;0&#125;/&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, <span class="built_in">int</span>):</span><br><span class="line">            n = self.numer + self.denom * other</span><br><span class="line">            d = self.denom</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(other, Ratio):</span><br><span class="line">            n = self.numer * other.denom + self.denom * other.numer</span><br><span class="line">            d = self.denom * other.denom</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(other, <span class="built_in">float</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">float</span>(self) + other</span><br><span class="line">        g = gcd(n, d)</span><br><span class="line">        <span class="keyword">return</span> Ratio(n//g, d//g)</span><br><span class="line">    __radd__ = __add__</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__float__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.numer/self.denom</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">n, d</span>):</span><br><span class="line">    <span class="keyword">while</span> n != d:</span><br><span class="line">        n, d = <span class="built_in">min</span>(n, d), <span class="built_in">abs</span>(n - d)</span><br><span class="line">    <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure><ul><li>类型分类：用了条件语句对传入的other数据类型进行判断从而提供不同的执行方法</li><li>类型强制：将一种类型的对象转换为另一种类型，以便能够将其与其他值组合。</li></ul><blockquote><p>这是让两个类进行交互时而使用的两种策略</p></blockquote><blockquote><p>__add__函数相当于是一个隐形接口，我们不需要知道传入的数据是不是浮点数、整数还是什么，都可以将他们加起来 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CS61A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是我的第一篇文章</title>
      <link href="/2023/12/14/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F/"/>
      <url>/2023/12/14/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2><p><a href="https://www.bilibili.com/video/BV1G84y1B7NH/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&vd_source=700c4afe7cf00e2775dbed3e27760082">(博客教程视频)</a></p><p><a href="https://www.fomal.cc/posts/e593433d.html">(博客教程网站)</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1G84y1B7NH/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&vd_source=700c4afe7cf00e2775dbed3e27760082">(博客教程视频)</a></p><p><a href="https://www.fomal.cc/posts/e593433d.html">(博客教程网站)</a></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>个人小日记</title>
      <link href="/diary/index.html"/>
      <url>/diary/index.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="4d1857f52c5969e98a96a8921330e0c4117efb53962c8316a4e3b98f722b2612">7a04f49168c16fa5e6499f3676d544844c6ee71d97efcd86407c182421f8c9748441467c5356d4070dfc0ec89c73cad95fbdbaa1469f3bb0c020d40d393c058e20b17f4293d3831de9ff74ea82c612d5e35d6103e70a5831c9b317c6e3a55a309ab3bc19e68dd232cf553b57a7260b23a88d53d82b1ed65716f80b6d1b6a255ad9531d838eae3db02a68e499acaeaaeec58d4adee4cb4e4a445d95a9337d75a06d8a414424e18732794b3ba843b29fdc9322bd2fe9259ce157adb88932a1ac6e7e4da9c91153a7b24822e4335479e9eda389e904766c8d746e5699d662482a465241272d23afe4785e3ccbfdffb70de24459545fef6bc9b1b2d3ffc1c69ca2f16b97e1695881fba5a3049e2dc9bc9612966cf35c7898b36311d0d7b0b3a8bdf792ba3293c5538de2fdf7c2a78cb0d24b2000a70a862a2b726d49676dee3cde9c6f53b3786172c6117a15d32690b5fad5a06bcb5f5a274f4b219d206122c42364877c4e18a93c20ca747132fbdc89fc14e0164d279f30e7d6c945e0bf40a2806923fbf700c5f07935936af5347cfed170494e9745eef4fa3687c6454adf5b873489aa8fa0a7865f40ce15b75dbaf9938d42fb591f649aa6caf10d31e5d93adc59477e05a58972e0e7dbd1d3e2571c760931c30ef691d608840c315ebc06339c56f10796c905c64e40c449d9a7ff420f7c6542193201ec66c57c07efd823f94a19ad45400ffdb1108ed09861943096078e733b1bbe858cd0f62f76c0a0043fd9ae0425c1d1e368d778b0bb96616da862282e4309cc5a5f5da962ff4a31d174e67670ec8f89d4773660f8697b4f22f7ecc5330174a907813de6a2bc0ee31421a3a3b67a97c6d88507efe9c35baec3fec73dc9abf9bc514580b69ddd7d2cb5aabd9b2f25454a59b9296a4baafd71998cacc6b9e9a96f1a332ee5e888a7101496b373f64f032fe62950a0f36e7400de3da57fb9c929ee0fdc24263a379d27a8ba67811adc97d0a507987d940847fe71f3a810f915dc67b5442fc96f6070fdfb99a47faa9702b549cb10d2ca349139197b20dd7116ed97541ddaf7a40af6e0a6e0bff78136ae24683a01cffbaf0668bcce69a225d08e8128d8043fdc1efb38953bacc858c1a40eb572556c3eed4f0c703cdd991b83b2224f3251d109feed4ad50462ea60d36dcec3ebfc05d91f2b7d1e30c0677fdac3b8d5dfc7a555b283bad498a24a53e6678b9dd79658960f2d98aec4a174ab71db5862aa1f9d64a52d293e8a91ed27b952b7538385e1e3f97f81adcd804cd4504f6e262673d13e0f965026bb32081a27aa044f83427b685b8b3484dfe4a6156b75c501bc9fbd7755259c5dd233e8b0355aaab062efa3691482798679514061e191e07d05935ce45b888c38b868d9912f21a6a4e96fb7d47a2dcd0fbf7c81a15caebc61132f0e122333edca6a7fcc7fc785420e4ffb3c4ec22f6364509cb36c58e7cc032b075c9b61360b5bddef8597449c6b412bff09adf12ed2010052cfad2674d163401b43587e525725f324c5e8a0879289bc6e8e275fadf055a8d42b46710066c641743e482164426863e105a28de30eafd03bd669860230ea3a5d95767951dc1b637726291a215aec43ec84da91a2d692e5c546809024be1ee5c4b44eb06069ab390f6276c08d43265544a394b429d30d2e719babf12cd6f1dc05069b98ddf76b30bd83b391ba98e21222c47dbcd6b221aaf7435aebd86182ec1fb48d403c0cfc620d91a945e5f768cf91a63c914326da19af8d5ffeb60d80609e53fdac73d6e99a1f9fc001c6e416efd39ee1cd570be8397dc5b4c2e199fab2c7c69e07ba3255c9063875a184c3964c46ccc9987337bc534bd80bd0c806cd9d2a010f2e1e91a5f00af5b9f1238a8673fdbadeb852dfd89b27fc60c4e6aec44f543ec006f772c80bd3881dbc8d31ea1ae52b0b2828278aac79d189bd3d506149f0c7b03da250211b9af8ecfbbd632706ff43c1055f8a4941627d3c1cb9a20c120e1f1ff9beb7f8350e0df3a5bc488a5dbeb3d003bcd65c97ad264a9e64f4f994231de8a0327cc7bf89052f0107a52d477595a0710b9bcd3c153d4717a9ca0d4ad99230bef277bdf1cda56ec90785927a11817ea6fe793b3a96ab08dead5c9a8288ad76df3c4793a82e6320c5b16b0ae5f2581927328e3e04eb4f60a6303665f58e513dc6a284cd17da735d91d397f091b4f0d25be0fd4649bdc13efa07be6bc788c7de945912e9d31d6ea20df78148ea48ecfb19295089bd0f89db43ad4479b4fab656129f43353898ca634d051155b462484b50f5df94779c26edd98df23fe2bac293022ee3c7de77264fd261b6c20bd7852e94251f70f3e9557cb4d56155c4181d97ade73b426bd715a52eb3978666dcc4f8a026f0fde26203175478f5e511a2fe363418ac8a047ed9217dc7f5636ef17a8771d074a44830f46dc9433219d9bcd0ed2ee550e03aacb1c1237f0e83ffa2de31f6ac29a5e0ee3732e486a567088d96e5e23a763dc9e12e52de84e2414aaedb388c72ca19cdcafaeb0aebd36309d8bf11b2167d00af2201b66cd3ada93ef33ba7ef6db64a1d28b96fcad0b2ceee215640c097538510afe68a0f7856c3b0bff545561c6c86fe2ecc5cfd59bc9ac6173e9010742b0ebfa61e2424f008e2fa93bc0304d1de72dfc4f384ff9ac72e4559914c9029ceaccfa9f49e4533069c529aadd927558066cd035aa395584cca219f5cdcd402ec2f80998bcc21239706306e174481df56d161e73059728a534445749dd1f25f79239299d54a61ad4e60019f0adaec99f67c3656a76e03801edf4f8f3b1cecea72bf230f334a6faa3d651f344317b489a0913415606b46df71c53646909b18fa94282fbfa31d7d650830a358e88665b3d9c4b405c1edaaa0878c5ac7585273ea22718404b2111377808a3ca12f02d9806782c058d712efecd01966829915fe2724f61459342ea1b91b7f724fa850066d6221c7e2cdeac056439c30d31df2224bb7039daaeb608d04e5b1a58fc9e45043f1378599e3fd07549aa97046b740293df142283f9d0154592666973c332b80cbf5f39aea37a32915288851b4ace1db17d947b6081da22c41d8cc91a09575400ef8f8fa25e7097c4fe90a60c9adef1195581e0477a81b322debc5e443cb09c778780a4a3cfaf03b04e019debd36e2e9377801787908c45bbd9bf7ee4d41f3114c4617d1504087901c271bc695ceb8d4d27520f65bdea93f6ad2dcd2484737467d1bd9506b51f426425b16dbad64a6098789d7eb26fa670dad41f80b0018357f633bada49a71707d4d7ea09ee3d12f6c5c792e1f745767c569051b082820381da084d41fe862ce87cc700131df68dbe74829ca652875f44cdb6af2c89c340e74cc2cd329fb3d963ab520daf1864945905e4411f58b447f692d0a3af272c16ac2aa7757e25967c6c9cb49ad98f0264fffff6d7e7ba5d0a32f38a69d5cd53d5e6d1aaa7caf4969d7e641774f9dea4a5ea25f5ecfd92127bd4685179d92588606a2f5510f7d047e61af3697f5dba58feaa6d41a737453df0043dd794a22e01f418a7c9b087895603e20bd6e7101705777d50ddf54bda6397357fd53a4e433b8cb57c9ec5a52887f41c769bc83d7c9f9b055fb4c2f2bf33fc6dd4f0351b4254288ea40c3ca0838bcd16b3f72088bbe64de517a917c16b1c45ad26478491d4621d924ed597bf47cc752f916a2bfde968d7f79feb0a7dd2346bd36c2d1d481393bf03285350d81eeb37e2da088f376745435ae07bd4297cd304f03487d655c8a432a945f18362c781900df8447514aa8183d781719c59da8be9bcac3a583cbf07198e6578f7bd855c8b824cab41a5995c90479367c4da689e53cebc4eae87cd8e5b1acc8fa918b5ace82441d00a1e7b32cd450fe5013f4c54b2662f88628ed2e0363d961ad7f6e4a32e55705e3c9e88a0ecfbc549a09eb6f7e9865d9339e0842c81af223826e92937c1317aa1d79c3f00d73447a3fd2fe0b3eee490146048ba099d4a4d0978b5c762aece1e99f45d8d64066c94161dacef104bcf72cfeba721c1c3045ec80b18c03040291a72729d12091626ada78179d4519bffdb6204fe0d8329454496093cad3a97cf55adc47d17074981e74acbc629edfe141cdc3186b744ec1ad07f5ea2cd68bc0752fe0cadf3aa181c1a91cbd04569e2866497bd53f7a57dfc8c6651a8d72a2324acd3058ffcac894bc8d8258614ba7b79f7cf0816cb5c5d1d593f2f994978c318804a255afad7f8943c3c079f9b656dacd06b96b0f0334f7d9ee69c43d1a54c673e633d6095b25d7fd9f951ab624585e63aad18e5f0aebf038e8fafc183c95f6db34aa3a769d9317211a0e86d307e872e44a3726be9b21b26940c180aae1e4438b1a41dec6058e02562860b9f842c74dcecf0c27b051f407d3045d47e39d0410abe4d9b050a1adcba3f9ae7aba6b9034240b6a33e1dfd1bcf8c10cdebe3fb3f057b4463e70e6e3429c1edbf34e7946a756c1f4896b8349f60e5cef04cbd1c6c3034485737663cbd9f1bc43f4bec39f9d4f485e35c44cec296f49d65b660c6ec96ee8f109a643f86fcd8523937a327c17d7e57c0b13f3a5cfd5ed76bfb3d477df2ef7e181b599a68bbdee8b506034f4eb5aa1cee6f165a2fafba0dc2a81c8b0bd80007266331378731f32eac65d9672ef94e19ec7b6065aad6c9067db97334e65e5a50caadff996f613abac05b8215d3c006b955ff3e2e4d334daff859f2aa36cbc48df59e59739dab6f0345daaca4bd44144fcfbebeab6f392650386731ab096bc85f289e6196915b47cc112645241e5fd806b180652462a90ef440f0d60ac9a48d7c3cc7b296ea236c5aeee502b42ca133898dea291dc7c2d7484f6a232e89da5a674b15460494ded39843c081e8051d0de5a35ac6c25ba1f0eeba158f239ffbc38c33654bbd65edbd44fa0f12386d4e9bee024cad92c5c6e465d1e0a273f7adbc7e942d9b50f8ec59990b8cec550885c50901439adb31960f384b6725391ee6daa95cda81fb05a783917ba6cce46dea3a687d949fed518f78b785ad37619330c6a6ecdebc3e798894ce7539bb6feb4029ff623cbd203c6130770bbdc78d082d3cf863ad7d5420b917c6724f414121aadda29bebd132232e07a5a5d866afcf7e2d15a27d049f1116260a0bb8f1c932307b70378d713e4934eaab25d40b50abcae9b30dbaad65f202447c6f3db6632540831af2a53411610255d92e4f3bfd3bbf7b3f41ba901c1dd6e7340da24cf2be34322b39540390077ee12f1c12accff90b666ad32c8fa6e1e9be88c5e3997b430909c22f8e1f7034c1cb4ccc184c14e8a947373762128140d1cc49c0a6c916dc93abbc3b6feb820f57fdeb774be2f26c7efe1f4b86ceb08e4141612ef535aa8301a21ca4bb0e4772fb26e0b21ccf7f72eb7918bc247d689107d67e45e4d1cff6b2ef08874323badf1ef2d1add956a387bd5ac406712869cc066b9ba785fe2510e43cc0efade960a23ea251deb7b655fc2886ae5213868c6f601a79317d0c4076cc857821aa9dcf7017a805f636541fd2a9e61b9a5945a779bec41ebf6ec038eb3c9d9785d33496331245fb9354e3c2ec6d97aa49efccee10458be6f9c7b5a9d51af0c22438c32bdc190f6f4a6c1e8463db05d5f7be649685d501c6c7a5573e9914e2eeb076317610662aa91dffa64df7fc8cf6d186e8c6e89097859bce1655658ba62bea8bdc23fc03d353fbc9c82282dce7a4f4fc73f1bcfb4afcb1d7a2a861524b7bd232fa3b178cd9dd48dd20426497c447143c8f6881b1f2010c0ee2e26700ffb45f2c71b11d12dc9fe39807a313c44d0a3c921794fd18f570e1083ba95f7cb481e795d4965c17fd54b3c1f4b8486f0c63ab1d44027ade663bd4ef66df5ef6556235f48d2d1c2783829061132f37e420dea2b1cf69fd61410f3283b7eda20797cb11d9e95d67a75598f7028f7838e41a1ed419d8171</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">别猜了别猜了</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }  /* 小冰分类分类磁铁黑夜模式适配 *//* 一般状态 */[data-theme="dark"] .magnet_link_context {  background: #1e1e1e;  color: antiquewhite;}/* 鼠标悬浮状态 */[data-theme="dark"] .magnet_link_context:hover {  background: #3ecdf1;  color: #f2f2f2;}/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>game</title>
      <link href="/game/index.html"/>
      <url>/game/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>23·12·23</title>
      <link href="/diary/23%C2%B712%C2%B723/index.html"/>
      <url>/diary/23%C2%B712%C2%B723/index.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="fac6055b69e98f52462d9cdbb2fdd1ff07debe2c5f3f2f531b8cb4f1d2ae9b13">7a04f49168c16fa5e6499f3676d544847369460cb37b8a9320df2540de47878192e3229550a92ebeb8cdebaea7cb2f0f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">别猜了别猜了</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
    </entry>
    
    
  
</search>
