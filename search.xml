<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>tree递归</title>
      <link href="/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/"/>
      <url>/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>@<a href="%E9%97%AE%E9%A2%98">TOC</a><br>#Tree ADT<br><img src="https://img-blog.csdnimg.cn/7f9e46bc93fb492bbf15e302cbf0116a.jpeg#pic_center" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree</span>(<span class="params">label, branches=[]</span>):</span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches:</span><br><span class="line">        <span class="keyword">assert</span> is_tree(branch),<span class="string">&#x27;branches must be a tree&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> [label] + <span class="built_in">list</span>(branches)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">label</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">branches</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_tree</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(tree) != <span class="built_in">list</span> <span class="keyword">or</span> <span class="built_in">len</span>(tree) &lt;<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(tree):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_tree(branch):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_leaf</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> branches(tree)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>tree函数用于构造，label函数和branches函数用于选择，is_leaf和is_tree函数用于辅助</p></blockquote><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="fib-tree"><a href="#fib-tree" class="headerlink" title="fib_tree"></a>fib_tree</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib_tree</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left, right = fbi_tree(n-<span class="number">1</span>), fbi_tree(n-<span class="number">2</span>)</span><br><span class="line">        fib_n = label(left)+label(right)</span><br><span class="line">        <span class="keyword">return</span> tree(fib_n,left+right)</span><br></pre></td></tr></table></figure><blockquote><p>可见，基本情况是n &#x3D;&#x3D; 0 or n &#x3D;&#x3D;1<br>树递归的思想是从上到下，一旦到达基本情况变返回递归结果<br>这段函数从树顶端递归到0 or 1的情况，然后根据0和1的结果，逐层向上计算树节点的值</p></blockquote><h2 id="count-leaf"><a href="#count-leaf" class="headerlink" title="count_leaf"></a>count_leaf</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_leaves</span>(<span class="params">tree</span>):</span><br><span class="line">      <span class="keyword">if</span> is_leaf(tree):</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          branch_counts = [count_leaves(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(tree)]</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">sum</span>(branch_counts)</span><br></pre></td></tr></table></figure><blockquote><p>不断递归检查树枝是否为叶子，一旦是，便返回1并存储在数列中。最后用sum求树叶数</p></blockquote><h2 id="leaves"><a href="#leaves" class="headerlink" title="leaves"></a>leaves</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leaves</span>(<span class="params">tree</span>):</span><br><span class="line"><span class="keyword">if</span> is_leaf(tree):</span><br><span class="line"><span class="keyword">return</span> [label(tree)]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sum</span>([leaves(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(tree)],[])</span><br></pre></td></tr></table></figure><blockquote><p>分离树叶，不断递归检查树枝是否为树叶，若是，以数列形式存储在[ ]中，最后用sum消去一层[ ]<br>#为什么要用sum(<list>, [])？<br>因为当该分支只存在树叶时，leavers(b) for b in branches(tree)是以数列形式出现的，而若该分支同时存在树叶和树枝时，则返回单单数字(int).</p></blockquote><h2 id="increment-leaf"><a href="#increment-leaf" class="headerlink" title="increment_leaf:"></a>increment_leaf:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">increment_leaf</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> tree(label(t)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[increment_leaves(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br><span class="line"><span class="comment">#OR</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">increment</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">return</span> tree(label(t)+<span class="number">1</span>,[increment(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上面的increment只增加leaf<br>下面的increment增加所有节点</p></blockquote><h2 id="print-tree"><a href="#print-tree" class="headerlink" title="print_tree"></a>print_tree</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_tree</span>(<span class="params">t,indent = <span class="number">0</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>*indent + <span class="built_in">str</span>(label(t)))</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> branches(t):</span><br><span class="line">        print_tree(b, indent+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="print-path"><a href="#print-path" class="headerlink" title="print_path"></a>print_path</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_sums</span>(<span class="params">t, so_far</span>):</span><br><span class="line">    so_far = so_far + label(t)</span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="built_in">print</span>(so_far)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> branches(t):</span><br><span class="line">            print_sums(b, so_far)</span><br></pre></td></tr></table></figure><h2 id="count-paths"><a href="#count-paths" class="headerlink" title="count_paths"></a>count_paths</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_paths</span>(<span class="params">t, total</span>):</span><br><span class="line">    <span class="keyword">if</span> label(t) == total:</span><br><span class="line">        found = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        found = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> found + <span class="built_in">sum</span>([count_paths(b,total-label(t)) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br></pre></td></tr></table></figure><blockquote><p>重点在于返回的count_paths(b,total-label(t)中的<code>total-label(t)</code><br>在递归过程中，total-label(t)不断更新到达下一分支时，满足条件的值。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/0ea3bb6dc6964b6f9db269b6519274e7.png#pic_center" alt="cp2"></p><p><img src="https://img-blog.csdnimg.cn/35c833193485445db423031db5087868.png#pic_center" alt="cp"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="berry-finder"><a href="#berry-finder" class="headerlink" title="berry_finder"></a>berry_finder</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">berry_finder</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns True if t contains a node with the value &#x27;berry&#x27; and </span></span><br><span class="line"><span class="string">    False otherwise.</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = tree(1, [tree(&#x27;berry&#x27;,[tree(&#x27;not berry&#x27;)])])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; berry_finder(t)</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;*** YOUR CODE HERE ***&quot;</span></span><br><span class="line">    <span class="keyword">if</span> label(t) == <span class="string">&#x27;berry&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t):</span><br><span class="line">        <span class="keyword">if</span> berry_finder(branch):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="replace-loki-at-leaf"><a href="#replace-loki-at-leaf" class="headerlink" title="replace_loki_at_leaf"></a>replace_loki_at_leaf</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">replace_loki_at_leaf</span>(<span class="params">t, lokis_replacement</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns a new tree where every leaf value equal to &quot;loki&quot; has</span></span><br><span class="line"><span class="string">    been replaced with lokis_replacement.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> label(t) == <span class="string">&#x27;loki&#x27;</span><span class="keyword">and</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> tree(lokis_replacement, [replace_loki_at_leaf(branch,lokis_replacement) <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t)])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[replace_loki_at_leaf(branch,lokis_replacement) <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Height"><a href="#Height" class="headerlink" title="Height"></a>Height</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Q5: Height</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the height of a tree.</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = tree(3, [tree(5, [tree(1)]), tree(2)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; height(t)</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;*** YOUR CODE HERE ***&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>([height(branch) <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t)])</span><br></pre></td></tr></table></figure><h2 id="find-path"><a href="#find-path" class="headerlink" title="find_path"></a>find_path</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_path</span>(<span class="params">t, x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = tree(2, [tree(7, [tree(3), tree(6, [tree(5), tree(11)])] ), tree(15)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; find_path(t, 5)</span></span><br><span class="line"><span class="string">    [2, 7, 6, 5]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; find_path(t, 10)  # returns None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> label(t) == x:</span><br><span class="line">        <span class="keyword">return</span> [label(t)]</span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t):</span><br><span class="line">        path = find_path(branch, x)</span><br><span class="line">        <span class="keyword">if</span> path:</span><br><span class="line">            <span class="keyword">return</span> [label(t)] + path</span><br></pre></td></tr></table></figure><h2 id="sprout-leaves"><a href="#sprout-leaves" class="headerlink" title="sprout_leaves"></a>sprout_leaves</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sprout_leaves</span>(<span class="params">t, leaves</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Sprout new leaves containing the data in leaves at each leaf in</span></span><br><span class="line"><span class="string">    the original tree t and return the resulting tree.</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t1 = tree(1, [tree(2), tree(3)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(t1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">      3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; new1 = sprout_leaves(t1, [4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(new1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">      3</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[tree(leaf) <span class="keyword">for</span> leaf <span class="keyword">in</span> leaves])</span><br><span class="line">    <span class="keyword">return</span> tree(label(t),[sprout_leaves(branch,leaves) <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们可以发现，完成这些例子和练习的核心思想有：</p><ol><li>重构tree，且将branches部分用递归方法不断更新为我们需要的树枝。</li><li>利用 for语句和branches选择函数对函数进行递归。</li><li>而递归的关键就在于我们对基本情况的定义和对tree ADT的理解应用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CS61A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/"/>
      <url>/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>笔记来源网课教程：<a href="https://www.bilibili.com/video/BV1oD4y1h7S3">C++教程</a><br>10月·8号发布</p><p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><h1 id="C-是怎么工作的"><a href="#C-是怎么工作的" class="headerlink" title="C++是怎么工作的"></a>C++是怎么工作的</h1><p>项目中的源文件传输给编译器，编译器将其转化成二进制的东西，可能转化成某种库，也可能是可执行的程序<br>opp编译成obj文件，然后通过linker将obj整合起来</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>编译前处理include后面的文件，该文件通常叫做“头文件”，我们之所以要包括iostream这个头文件，是因为我们需要一个被调用的函数的声明，例如<code>std::cout</code></p><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>程序的入口，它不一定需要返回值，默认返回0</p><h2 id=""><a href="#" class="headerlink" title="&lt;&lt;重载语句"></a>&lt;&lt;重载语句</h2><p>相当于一个函数而已，相当于print()<br><code>std::cout &lt;&lt; &quot;Hello World&quot;&lt;&lt; std::endl;</code><br>相当于<br><code>std::cout .print( &quot;Hello World&quot;).pint(std::endl); </code></p><h2 id="链接项目中的函数代码"><a href="#链接项目中的函数代码" class="headerlink" title="链接项目中的函数代码"></a>链接项目中的函数代码</h2><p><strong>Log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; </span><br><span class="line"><span class="comment">// 声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过linker将main.cpp中声明并使用的函数链接到某个项目文件中唯一的log函数中</p></blockquote><blockquote><p>声明只包含了函数，定义包含了函数和函数体</p></blockquote><h1 id="C-编译器的工作"><a href="#C-编译器的工作" class="headerlink" title="C++编译器的工作"></a>C++编译器的工作</h1><p>首先预处理,将所有代码转化成常量数据或指令。<br>将我们项目所有的cpp生成opj文件<br>cpp叫做<strong>翻译单元</strong></p><h2 id="include工作原理"><a href="#include工作原理" class="headerlink" title="#include工作原理"></a>#include工作原理</h2><p>在编译前将指定的文件粘贴并复制到当前cpp当中</p><p><strong>EndBrace.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; </span><br><span class="line"><span class="comment">// 声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&#x27;EndBrace.h&#x27;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>编译器的工作就是，将EndBrace中的所有代码copy进去当前cpp</p></blockquote><h2 id="查看预处理器实际上生成的文件"><a href="#查看预处理器实际上生成的文件" class="headerlink" title="查看预处理器实际上生成的文件"></a>查看预处理器实际上生成的文件</h2><p><img src="https://img-blog.csdnimg.cn/c5075273ac124b4baab380f12a62bb3b.png#pic_center" alt="预处理器文件"><br>编译后会生成一个.i文件<br>里面含有预处理后的结果</p><h2 id="查看obj文件"><a href="#查看obj文件" class="headerlink" title="查看obj文件"></a>查看obj文件</h2><p><img src="https://img-blog.csdnimg.cn/cb49d014e53b475e97dc7447616cb94a.png#pic_center" alt="在这里插入图片描述"></p><p>将obj中的二进制文件转化为汇编代码(ASM文件) </p><blockquote><p>若在优化将速度调最大会忽略掉一些无用的操作</p></blockquote><h1 id="C-链接"><a href="#C-链接" class="headerlink" title="C++链接"></a>C++链接</h1><p>编译后的操作，链接的焦点是找到每个符号和函数在哪里然后连接在一起。<br><strong>编译可能不需要main函数，但是链接过程一定需要main函数</strong></p><blockquote><p>编译错误 错误类型是C开头，链接错误是LIN开头</p></blockquote><blockquote><p>不能存在两个相同的函数带着相同的参数，这样链接器不知道链接哪一个，从而产生错误。</p></blockquote><h2 id="易错处"><a href="#易错处" class="headerlink" title="易错处"></a>易错处</h2><p><strong>Log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 注意log函数名字已经被修改了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; </span><br><span class="line"><span class="comment">//声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//log(&quot;multiply&quot;);</span></span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">Multiply</span>(<span class="number">5</span>, <span class="number">8</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链接没有错误</p></blockquote><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; </span><br><span class="line"><span class="comment">//声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;multiply&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; Multiply(5, 8) &lt;&lt; std::endl;</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链接错误</p></blockquote><p><strong>为什么？</strong><br>虽然在这个文件中可能用不上Multiply函数，但在其他文件可能用得上，所以链接器确实需要链接它</p><h3 id="限制链接，函数只在当前翻译单元使用的方法"><a href="#限制链接，函数只在当前翻译单元使用的方法" class="headerlink" title="限制链接，函数只在当前翻译单元使用的方法"></a>限制链接，函数只在当前翻译单元使用的方法</h3><p>用<code>static</code>加在函数前</p><h2 id="产生链接错误的例子及修正"><a href="#产生链接错误的例子及修正" class="headerlink" title="产生链接错误的例子及修正"></a>产生链接错误的例子及修正</h2><h3 id="错误例子"><a href="#错误例子" class="headerlink" title="错误例子"></a>错误例子</h3><p><strong>log.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initlog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;Initialized log&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;multiply&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; Multiply(5, 8) &lt;&lt; std::endl;</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链接失败，log重复了</p></blockquote><p><strong>原因分析：</strong><br>两个头文件同时引入了两个log函数所以产生错误.</p><h3 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h3><ol><li><strong>log.h</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将log函数修改为静态函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>log.h</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>inlind的作用是获得我们实际的函数体并将函数调用替换为函数体。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>(<span class="string">&quot;Initialized log&quot;</span>);</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Initialized log&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><ol start="3"><li>将定义移到一个翻译单元</li></ol><p><strong>log.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initlog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;Initialized log&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-变量"><a href="#C-变量" class="headerlink" title="C++变量"></a>C++变量</h1><p>变量允许我们命名存储在内存中的数据并继续使用<br>当我们创造变量时，他被存储在内存中。</p><h2 id="不同变量类型的区别是内存大小"><a href="#不同变量类型的区别是内存大小" class="headerlink" title="不同变量类型的区别是内存大小"></a>不同变量类型的区别是内存大小</h2><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul><li>char : 1 byte (经常存储字符)</li><li>short : 2 byte</li><li>int : 4 byte</li><li>long : 4 byte</li><li>long long : 8 byte</li><li>float : 4 byte</li><li>double : 8 byte</li><li>bool : 1 byte<blockquote><p>float和double的区别可以是在数字后面加f(float)<br>1 是 Ture,0 是 False.</p></blockquote></li></ul><h3 id="查看数字大小"><a href="#查看数字大小" class="headerlink" title="查看数字大小"></a>查看数字大小</h3><p>sizeof(bool)</p><h1 id="C-函数"><a href="#C-函数" class="headerlink" title="C++函数"></a>C++函数</h1><p>最主要的是提高维护效率<br>避免复制重复<br>我们通常在头文件中写声明，在翻译单元或cpp文件中编写定义，原因就是<strong>链接错误中的修改方法3</strong></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io_mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">multiply</span>(a, b);</span><br><span class="line">std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">io_mul</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">io_mul</span>(<span class="number">3</span>,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">io_mul</span>(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>io_mul的作用就是避免重复</p></blockquote><h1 id="C-头文件"><a href="#C-头文件" class="headerlink" title="C++头文件"></a>C++头文件</h1><p> 当我们跨文件调用函数的时候免不了声明，如果某个函数很常用那就要一直复制粘贴，很繁琐。<br> 而头文件就是塞入一堆声明，然后在其他cpp中include后，让预处理器帮忙复制粘贴。</p><h2 id="pragma-once"><a href="#pragma-once" class="headerlink" title="pragma once"></a>pragma once</h2><p>当我们创建了一个头文件，vs会自动帮我们填写<code>#pragma once</code><br>这个的作用是防止include多个头文件时，里面有重复的声明，导致编译失败。他只会复制一次声明</p><h2 id="ifndef"><a href="#ifndef" class="headerlink" title="ifndef"></a>ifndef</h2><p><strong>log.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nitLog</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>检查是否有个_LOG_H被定义了，如果没有就编译中包括以下代码,如果被定义了，那么这些都不会被包括进来 </p></blockquote><blockquote><p>如果通过了这初次检查，我们定义_LOG_H,如果下次用到的时候，就不会重复声明了</p></blockquote><h2 id="include两个不同形式"><a href="#include两个不同形式" class="headerlink" title="include两个不同形式"></a>include两个不同形式</h2><h3 id="形式"><a href="#形式" class="headerlink" title="&lt; &gt;形式"></a>&lt; &gt;形式</h3><p>告诉编译器去搜索包含路径的文件夹 </p><h3 id="“-“形式"><a href="#“-“形式" class="headerlink" title="“ “形式"></a>“ “形式</h3><p>告诉编译器就在当前文件夹，我们也可以用”..&#x2F;log.h”去返回到当前文件的上级目录</p><h2 id="区别c-标准库和c标准库"><a href="#区别c-标准库和c标准库" class="headerlink" title="区别c++标准库和c标准库"></a>区别c++标准库和c标准库</h2><p>关键在于有无.h扩展，c++文件通常没有。</p><h1 id="如何在vs中调试代码"><a href="#如何在vs中调试代码" class="headerlink" title="如何在vs中调试代码"></a>如何在vs中调试代码</h1><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>在断点处暂停程序</p><h3 id="读取内存"><a href="#读取内存" class="headerlink" title="读取内存"></a>读取内存</h3><p>程序中断后,内存数据实际上还在,查看内存对诊断问题.</p><h2 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h2><ol start="0"><li>确保模式是<strong>debug模式</strong></li><li><strong>设置断点</strong></li><li><strong>读内存</strong></li></ol><h3 id="按键介绍"><a href="#按键介绍" class="headerlink" title="按键介绍"></a>按键介绍</h3><ul><li>逐语句(F11)(step into):进入到当前这行代码上的函数里面</li><li>逐过程(F10)(step over):从当前函数跳到下一行代码</li><li>跳出(shift+F11)(step out):跳出当前函数，回到调用这个函数的位置</li></ul><h3 id="窗口介绍"><a href="#窗口介绍" class="headerlink" title="窗口介绍"></a>窗口介绍</h3><ul><li>自动、局部窗口 : 向你展示可能重要的全局或局部</li><li>监视1：观察变量(输入要观察的变量然后回车)</li></ul><blockquote><p>右键可以修改成查看16进制</p></blockquote><h3 id="内存视图"><a href="#内存视图" class="headerlink" title="内存视图"></a>内存视图</h3><p><img src="https://img-blog.csdnimg.cn/51d4ba2535e64124a473ab3940a8f774.png#pic_center" alt="内存视图"><br><img src="https://img-blog.csdnimg.cn/637bef4806874bcda0457c8f359e6d20.png#pic_center" alt="内存视图浏览"></p><ul><li>最左侧为内存地址</li><li>中间是以16进制存储的实际值</li><li>最右边是以ACCII对值的解释</li></ul><h4 id="内存视图的使用"><a href="#内存视图的使用" class="headerlink" title="内存视图的使用"></a>内存视图的使用</h4><p>在地址一栏输入&amp;＋变量名即可</p><h1 id="VS的最佳设置"><a href="#VS的最佳设置" class="headerlink" title="VS的最佳设置"></a>VS的最佳设置</h1><h2 id="项目的设置"><a href="#项目的设置" class="headerlink" title="项目的设置"></a>项目的设置</h2><p><img src="https://img-blog.csdnimg.cn/c558a0ce3d494992b567799b5271f908.png#pic_center" alt="虚拟组织"></p><blockquote><p>这只是虚拟组织的文件夹，在文件资源管理器中并不存在。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/1f2932ac47be4082b5afea512deab985.png#pic_center" alt="在这里插入图片描述"><br>我们可以点击<strong>显示所有文件</strong>这个按钮，这样子新添加文件夹的时候就实际的添加了文件夹，而非虚拟文件夹。</p><h2 id="文件夹的设置"><a href="#文件夹的设置" class="headerlink" title="文件夹的设置"></a>文件夹的设置</h2><p><img src="https://img-blog.csdnimg.cn/e6698f5f5072499092e3637c8654d2fa.png#pic_center" alt="在这里插入图片描述"><br><code>$(SolutionDir)bin\$(Platform)\$(Configuration)\</code></p><h1 id="C-条件与分值-if语句"><a href="#C-条件与分值-if语句" class="headerlink" title="C++条件与分值(if语句)"></a>C++条件与分值(if语句)</h1><p> 检查条件，然后跳转到内存的不同的地方,并从这里开始执行指令。</p><h2 id="内在指令"><a href="#内在指令" class="headerlink" title="内在指令"></a>内在指令</h2><p> <img src="https://img-blog.csdnimg.cn/1e2c4bf200be401280d2ba7f164430d9.png#pic_center" alt="反汇编"></p><blockquote><p>设置断点调试时，右键进入反汇编模式</p></blockquote><ul><li>mov : move</li><li>jne ：jump not equal</li><li>je ：jump equel</li></ul><blockquote><ol><li><p><code>mov dword ptr [a], 5</code>：这条指令将立即数5移动到名为<code>a</code>的整数变量。它将5存储到<code>a</code>的内存位置。</p></li><li><p><code>cmp dword ptr [a], 5</code>：这是一个比较指令，用于比较<code>a</code>的值与5的值。它将<code>a</code>的值与5进行比较，但不会更改任何寄存器的值。</p></li><li><p><code>jne main+34h (07FF6F0B823B4h)</code>：这是一个条件跳转指令。它检查前面的比较结果是否不等于（jne表示”jump if not<br>equal”）零，如果不等于零，则跳转到指定的地址，这里是<code>main+34h</code>。</p></li><li><p><code>mov dword ptr [rbp+0F4h], 1</code>：如果比较结果是相等的（即<code>a</code>等于5），则将立即数1移动到内存中的某个位置，该位置可能是一个标志变量，用于表示条件满足。</p></li><li><p><code>jmp main+3Eh (07FF6F0B823BEh)</code>：这是一个无条件跳转指令，它将程序跳转到指定的地址，这里是<code>main+3Eh</code>。</p></li><li><p><code>mov dword ptr [rbp+0F4h], 0</code>：这个指令是前面条件跳转的目标（如果比较结果不等于零），它将立即数0移动到内存中的某个位置，表示条件不满足。</p></li><li><p><code>movzx eax, byte ptr [rbp+0F4h]</code>：这条指令将内存中的一个字节（8位）加载到32位寄存器<code>eax</code>中，并将其零扩展（即高位填充0）。这可能是为了将条件满足与否的标志位加载到寄存器中。</p></li><li><p><code>mov byte ptr [comparisonResult], al</code>：这个指令将寄存器<code>al</code>中的字节值写入名为<code>comparisonResult</code>的布尔变量。这是将条件判断的结果保存到布尔变量中的操作。</p></li><li><p><code>movzx eax, byte ptr [comparisonResult]</code>：这是将布尔变量<code>comparisonResult</code>的值加载到寄存器<code>eax</code>中，以便进行进一步的条件判断。</p></li><li><p><code>test eax, eax</code>：这个指令将寄存器<code>eax</code>与自身进行按位与操作。它的目的是检查<code>eax</code>中的值是否为零。</p></li><li><p><code>je main+5Ch (07FF6F0B823DCh)</code>：这是一个条件跳转指令，如果前面的按位与操作结果等于零（即<code>eax</code>中的值为零），则跳转到指定的地址，这里是<code>main+5Ch</code>。</p></li><li><p><code>lea rcx, [string &quot;hello&quot; (07FF6F0B8BCA4h)]</code>：这个指令将字符串”hello”的地址加载到寄存器<code>rcx</code>中，准备调用一个名为<code>Log</code>的函数。</p></li><li><p><code>call Log (07FF6F0B8135Ch)</code>：这是一个函数调用指令，它调用名为<code>Log</code>的函数，并将<code>rcx</code>中的地址作为参数传递给该函数，用于记录”hello”。</p></li></ol></blockquote><h1 id="C-循环"><a href="#C-循环" class="headerlink" title="C++循环"></a>C++循环</h1><p>for and while 循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; a &lt; <span class="number">5</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line">pass</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>变量的声明,循环的条件(评估后的bool值),一次循环后的操作</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">.....</span><br><span class="line">i ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h1 id="C-控制流语句"><a href="#C-控制流语句" class="headerlink" title="C++控制流语句"></a>C++控制流语句</h1><p>控制流一般和循环一起使用</p><ul><li>continue :只能在循环使用</li><li>break : 能在循环和switch语句使用</li><li>return</li></ul><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>跳到循环的下一个迭代</p><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>跳出循环</p><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>返回值，终止语句</p><h1 id="C-指针"><a href="#C-指针" class="headerlink" title="C++指针"></a>C++指针</h1><p>指针是整数，一种存储内存地址的数字。对管理和操纵内存有很大用处.</p><h2 id="指针的引用和逆引用"><a href="#指针的引用和逆引用" class="headerlink" title="指针的引用和逆引用"></a>指针的引用和逆引用</h2><p>类型的意义在于逆引用指针时可以访问和修改变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;var;</span><br><span class="line">*ptr = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="申请内存和二次指针"><a href="#申请内存和二次指针" class="headerlink" title="申请内存和二次指针"></a>申请内存和二次指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>** ptr = &amp;buffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>pte地址的内存实际上是buffer的内存地址，只不过反了过来<br>比如如果pte的内存是b8 f1 02 00<br>那么buffer的内存地址就是00 02 f1 b8</p></blockquote><h1 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h1><p>(指针的扩展)<br>引用不用占用内存，但是指针是变量，会占用内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;</span><br><span class="line"><span class="comment">//ref 实际上不存在，编译后只会有变量a</span></span><br><span class="line"><span class="comment">//相当于a的别名</span></span><br><span class="line"> </span><br><span class="line"> std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用的作用"><a href="#引用的作用" class="headerlink" title="引用的作用"></a>引用的作用</h2><blockquote><p>运用指针的例子</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increment</span><span class="params">(<span class="type">int</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">(*value)++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">Increment</span>(&amp;a)；</span><br><span class="line"><span class="built_in">Log</span>(a);</span><br><span class="line"><span class="comment">//结果为 : 6</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运用引用的例子</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increment</span><span class="params">(<span class="type">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">Increment</span>(a);</span><br><span class="line"><span class="built_in">Log</span>(a);</span><br><span class="line"><span class="comment">//结果为 : 6</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在C++中，函数参数的默认传递方式是按值传递(pass by value)。这意味着当你调用一个函数时，传递给函数的是原始数据的副本，而不是原始数据本身。这是因为按值传递会创建原始数据的副本，以便函数可以在副本上执行操作，而不会影响原始数据。<br> 当你调用Increment(a)时，a的值被复制到Increment函数的局部变量value中，然后在函数内部对value进行递增操作。这个递增操作只会影响value的副本，而不会影响a的原始值。这就是为什么在main函数中a 的值仍然是5。</p></blockquote><p>那如果我用return a呢？</p><blockquote><p>如果你在 Increment 函数中返回 value，那么你需要在 main 函数中捕获这个返回值并将其分配给 a，才能使 a 的值增加。这是因为在 C++ 中，函数的返回值不会自动修改传递给它的参数。<br>a &#x3D; increment(a)</p></blockquote><p>简而言之，引用可以节约内存开销,避免重复复制。</p><h2 id="引用的注意"><a href="#引用的注意" class="headerlink" title="引用的注意"></a>引用的注意</h2><p>你不能改变它引用的东西<br>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;</span><br><span class="line">ref = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>* ref = &amp;a;</span><br><span class="line">*ref = <span class="number">2</span>;</span><br><span class="line">ref = &amp;b;</span><br><span class="line">*ref = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Log</span>(a);</span><br><span class="line"><span class="built_in">Log</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，错误例子中会运行成功，但是他并不是更改引用,ref这个引用还是引用的a</p></blockquote><h1 id="C-类"><a href="#C-类" class="headerlink" title="C++类"></a>C++类</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> xa, <span class="type">int</span> ya)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x += xa * speed;</span><br><span class="line">y += ya * speed;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void Move(Player&amp; player, int xa, int ya)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//player.x += xa * player.speed;</span></span><br><span class="line"><span class="comment">//player.y += xa * player.speed;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Player player;</span><br><span class="line">player.x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>花括号后面需要有分号<br>由类类型构成的变量称为<strong>对象</strong><br>新的对象变量称为<strong>实例</strong><br>类中的函数称为<strong>方法</strong></p></blockquote><blockquote><p>类中的属性是私有的，如果需要访问修改需要public类中的属性。</p></blockquote><h1 id="C-类与结构体对比"><a href="#C-类与结构体对比" class="headerlink" title="C++类与结构体对比"></a>C++类与结构体对比</h1><p>类默认是私有的，类外部调用时无法调用。<br>技术上说，没什么区别，但是使用情境不同。<br>struct and class</p><blockquote><p>弹幕：用结构体当数据容器，用类来写具备逻辑的功能对象.</p></blockquote><h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2><ol><li>默认的继承访问权 : class默认的是private,strcut默认的是public。</li><li>默认访问权限 : struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。</li><li>“class”这个关键字还用于定义模板参数，就像“typename”。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python—字符串,多态函数（接口），特殊方法名称[61A Fall 2023 Lecture 20——Inheritance]</title>
      <link href="/2023/12/14/Python-Python%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0-61A-Fall-2023-Lecture-20%E2%80%94%E2%80%94Inheritance-Python%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0-61A-Fall-2023-Lecture-20%E2%80%94%E2%80%94Inheritance/"/>
      <url>/2023/12/14/Python-Python%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0-61A-Fall-2023-Lecture-20%E2%80%94%E2%80%94Inheritance-Python%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0-61A-Fall-2023-Lecture-20%E2%80%94%E2%80%94Inheritance/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h1 id="字符串表示形式"><a href="#字符串表示形式" class="headerlink" title="字符串表示形式"></a>字符串表示形式</h1><h2 id="str"><a href="#str" class="headerlink" title="str()"></a>str()</h2><p>方便阅读</p><h2 id="repr"><a href="#repr" class="headerlink" title="repr()"></a>repr()</h2><p>方便调试</p><ul><li>repr 返回对象的官方表示形式</li><li>print 用于打印可读性好的字符串</li><li>str 返回对象的非正式表示</li><li>eval 用于执行字符串表示的代码。</li><li>在字符串示例中，由于字符串中包含引号和全角逗号，因此在 repr 和 str 的输出中会反映这些差异，但 eval 用于执行这些字符串时，它们被正确处理。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half= Fraction(<span class="number">1</span>，<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>halfFraction(<span class="number">1</span>，<span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt;&gt; <span class="built_in">repr</span>(half)</span><br><span class="line"><span class="string">&#x27;Fraction(1，2)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(half)</span><br><span class="line"><span class="number">1</span>/<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(half)</span><br><span class="line"><span class="string">&#x27;1/2&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">repr</span>(half))</span><br><span class="line">Fraction(<span class="number">1</span>，<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">str</span>(half))</span><br><span class="line">05</span><br></pre></td></tr></table></figure><blockquote><p>repr(half) 返回对象的”official”字符串表示形式，它是 Fraction(1，2)，它是有效的Python表达式，可以用于重建相同的对象。<br>print(half) 打印对象时，print 使用对象的 str 方法，所以它输出 ‘1&#x2F;2’，这是用户友好的字符串表示。<br>str(half) 返回对象的”informal”字符串表示形式，这里返回 ‘1&#x2F;2’。<br>eval(repr(half)) 使用 eval 函数来执行 repr(half) 返回的字符串，这将返回一个新的 Fraction 对象，即 Fraction(1，2)。<br>eval(str(half)) 使用 eval 函数来执行 str(half) 返回的字符串，这将返回浮点数 0.5，因为 eval 解释它为数学表达式。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&quot;Hello, World&quot;</span></span><br><span class="line">&gt;&gt;&gt;s</span><br><span class="line"><span class="string">&#x27;Hello，World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">repr</span>(s))</span><br><span class="line"><span class="string">&#x27;Hello，World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s)</span><br><span class="line">Hello，World</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">str</span>(s))</span><br><span class="line">Hello，World</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(s)</span><br><span class="line"><span class="string">&#x27;Hello，World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(s)</span><br><span class="line"><span class="string">&quot;&#x27;Hello,World&#x27;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">repr</span>(s))</span><br><span class="line"><span class="string">&#x27;Hello，World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(<span class="built_in">repr</span>(<span class="built_in">repr</span>(s)))</span><br><span class="line"><span class="string">&#x27;\&#x27;&quot;\\\&#x27;Hello,world\\\&#x27;&quot;\&#x27;&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">eval</span>(<span class="built_in">eval</span>(<span class="built_in">repr</span>(<span class="built_in">repr</span>(<span class="built_in">repr</span>(s)))))))</span><br><span class="line"><span class="string">&#x27;Hello, World&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h1><h2 id="f’-’"><a href="#f’-’" class="headerlink" title="f’{}’"></a>f’{}’</h2><p>花括号里的为Python表达式 会自动计算<br>你也可以用str()或repr()</p><h1 id="多态函数"><a href="#多态函数" class="headerlink" title="多态函数"></a>多态函数</h1><p>使用于许多不同类型数据的函数<br>str和repr函数就是例子</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="repr-1"><a href="#repr-1" class="headerlink" title="repr"></a>repr</h3><p>调用一个零参数方法，相应地称为__repr__</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>half.__repr__()</span><br><span class="line"><span class="string">&#x27;Fraction(1, 2)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="str-1"><a href="#str-1" class="headerlink" title="str"></a>str</h3><p>调用一个零参数方法，相应地称为_str_</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half.__str__()</span><br><span class="line"><span class="string">&#x27;1/2&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用print()时实际上就是调用了__str__()</p></blockquote><h2 id="repr和str的实现"><a href="#repr和str的实现" class="headerlink" title="repr和str的实现"></a>repr和str的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repr</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">type</span>(x).__repr__(x)</span><br></pre></td></tr></table></figure><p>通过查找为你提供的参数类型来设法跳过实例属性或忽略他们</p><blockquote><p>是一个类属性，也是一个函数，但是这个函数不是绑定方法，因为它是在type类中查找的</p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>对象属性是消息传递的一种形式，它允许不同的数据类型以不同的方式响应同一消息。</li></ul><blockquote><p>对象通过发送消息(通常是方法调用)来与其他对象进行交互。对象的属性可以是对象的状态或数据。</p></blockquote><ul><li>从不同类引出类似行为的一组共享消息是一种强大的抽象方法。</li></ul><blockquote><p>不同的类可以实现相同的接口或共享相同的消息。</p></blockquote><ul><li>接口是一组共享属性名称，以及它们的行为规范。在复数的情况下，实现算术所需的接口由四个属性组成： real 、 imag 、 magnitude 和 angle 。<blockquote><p>这是一个具体的示例，说明了接口的用途。如果多个类需要实现某种算术操作（例如复数的加法或乘法），可以定义一个接口，其中包含所需的属性名称和方法，以确保这些类都具有相同的接口，从而可以执行相似的操作。</p></blockquote></li></ul><p>消息传递：对象通过查找彼此的属性（传递消息）进行交互<br>属性查找规则允许不同的数据类型响应相同的消息<br>从不同对象类中引出类似行为的共享消息（属性名）是一种强大的<strong>抽象方法</strong></p><p><strong>实现返回python可解释和人类可读字符串的方法</strong>的<strong>类</strong>实现了用于<strong>生成字符串表示的接口</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ratio</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n , d</span>):</span><br><span class="line">        self.numer = n</span><br><span class="line">        self.denom = d</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Ratio(&#123;0&#125;, &#123;1&#125;)&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;0&#125;/&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half = Ratio(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(half)</span><br><span class="line"><span class="number">1</span>/<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half</span><br><span class="line">Ratio(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p>个人对接口的理解：有一些具有相同行为的类，我们定义了一个接口，使得我们不需要知道传入这些类中的数据类型便知道这些类都有一种可以计算某个结果的方法。这样子不管什么数据类型都可以计算出我们需要的预期结果。[这是抽象接口]</p></blockquote><blockquote><p>Python存在两种接口 一个是面对对象用于继承的抽象接口，一个是用于封装类显露出来的动态接口[下面Ratio类的add方法是一种接口，是动态接口]</p></blockquote><h1 id="特殊方法名称"><a href="#特殊方法名称" class="headerlink" title="特殊方法名称"></a>特殊方法名称</h1><p>总是有__在前面和后面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;zero, one, two = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one + two</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(zero), <span class="built_in">bool</span>(one)</span><br><span class="line">(<span class="literal">False</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt;zero, one, two = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one.__add__(two)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zero.__bool__(), one.__bool__()</span><br><span class="line">(<span class="literal">False</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><blockquote><p>内置语法和内置函数 与 实际执行工作的特殊方法名称中间存在对应关系</p></blockquote><p>这是使用接口来允许用户定义的对象与Python中内置系统进行交互的另一个示例。<br>我们举例类的时候可以覆盖特殊方法来建立我们想要的互动结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ratio</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n , d</span>):</span><br><span class="line">        self.numer = n</span><br><span class="line">        self.denom = d</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Ratio(&#123;0&#125;, &#123;1&#125;)&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;0&#125;/&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, <span class="built_in">int</span>):</span><br><span class="line">            n = self.numer + self.denom * other</span><br><span class="line">            d = self.denom</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(other, Ratio):</span><br><span class="line">            n = self.numer * other.denom + self.denom * other.numer</span><br><span class="line">            d = self.denom * other.denom</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(other, <span class="built_in">float</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">float</span>(self) + other</span><br><span class="line">        g = gcd(n, d)</span><br><span class="line">        <span class="keyword">return</span> Ratio(n//g, d//g)</span><br><span class="line">    __radd__ = __add__</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__float__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.numer/self.denom</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">n, d</span>):</span><br><span class="line">    <span class="keyword">while</span> n != d:</span><br><span class="line">        n, d = <span class="built_in">min</span>(n, d), <span class="built_in">abs</span>(n - d)</span><br><span class="line">    <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure><ul><li>类型分类：用了条件语句对传入的other数据类型进行判断从而提供不同的执行方法</li><li>类型强制：将一种类型的对象转换为另一种类型，以便能够将其与其他值组合。</li></ul><blockquote><p>这是让两个类进行交互时而使用的两种策略</p></blockquote><blockquote><p>__add__函数相当于是一个隐形接口，我们不需要知道传入的数据是不是浮点数、整数还是什么，都可以将他们加起来 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CS61A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是我的第一篇文章</title>
      <link href="/2023/12/14/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F/"/>
      <url>/2023/12/14/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }  /* 小冰分类分类磁铁黑夜模式适配 *//* 一般状态 */[data-theme="dark"] .magnet_link_context {  background: #1e1e1e;  color: antiquewhite;}/* 鼠标悬浮状态 */[data-theme="dark"] .magnet_link_context:hover {  background: #3ecdf1;  color: #f2f2f2;}/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解计算机原理--第一章</title>
      <link href="/%E8%AF%BB%E4%B8%80%E6%9C%AC%E5%A5%BD%E4%B9%A6/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/index.html"/>
      <url>/%E8%AF%BB%E4%B8%80%E6%9C%AC%E5%A5%BD%E4%B9%A6/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/index.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%E4%BA%8C%E3%80%81%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%A1%A8%E8%BE%BE">二、信息的表示和表达</a><ul><li><a href="#2-1%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8">2.1 信息存储</a><ul><li><a href="#2-1-1%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95">2.1.1 十六进制表示法</a><ul><li><a href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E5%92%8C%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E4%BA%92%E9%80%89%E8%BD%AC%E6%8D%A2">十进制和十六进制互选转换</a></li></ul></li><li><a href="#2-1-2%E5%AD%97%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F">2.1.2 字数据大小</a></li><li><a href="#2-1-3%E5%AF%BB%E5%9D%80%E5%92%8C%E5%AD%97%E8%8A%82%E9%A1%BA%E5%BA%8F">2.1.3 寻址和字节顺序</a><ul><li><a href="#%E5%9C%B0%E5%9D%80%E4%B8%BA%E6%89%80%E4%BD%BF%E7%94%A8%E5%AD%97%E8%8A%82%E6%9C%80%E5%B0%8F%E7%9A%84%E5%9C%B0%E5%9D%80">地址为所使用字节最小的地址</a></li><li><a href="#%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%80%9A%E7%94%A8%E8%A7%84%E5%88%99">排序方法有两个通用规则</a></li></ul></li><li><a href="#2-1-4%E8%A1%A8%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2">2.1.4 表示字符串</a></li><li><a href="#2-1-5%E8%A1%A8%E8%BE%BE%E4%BB%A3%E7%A0%81">2.1.5 表达代码</a></li><li><a href="#2-1-6%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0">2.1.6 布尔代数</a></li><li><a href="#2-1-7%E4%BD%8D%E7%BA%A7%E8%BF%90%E7%AE%97">2.1.7 位级运算</a><ul><li><a href="#%E6%8E%A9%E7%A0%81%E8%BF%90%E7%AE%97">掩码运算</a></li></ul></li><li><a href="#2-1-8%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97">2.1.8 逻辑运算</a></li><li><a href="#2-1-9%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97">2.1.9移位运算</a></li></ul></li><li><a href="#2-2%E6%95%B4%E6%95%B0%E8%A1%A8%E7%A4%BA">2.2 整数表示</a><ul><li><a href="#2-2-1%E6%95%B4%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">2.2.1 整型数据类型</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B8%E5%9E%8B%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4">数据类型的典型取值范围</a></li></ul></li><li><a href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%9A%84%E7%BC%96%E7%A0%81">无符号的编码</a><ul><li><a href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%BC%96%E7%A0%81%E7%9A%84%E5%AE%9A%E4%B9%89">无符号数编码的定义</a></li></ul></li><li><a href="#2-2-3%E8%A1%A5%E7%A0%81%E7%BC%96%E7%A0%81">2.2.3 补码编码</a><ul><li><a href="#%E8%A1%A5%E7%A0%81%E7%BC%96%E7%A0%81%E7%9A%84%E5%AE%9A%E4%B9%89">补码编码的定义</a></li><li><a href="#%E5%8F%AF%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%95%B4%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4">可表示的整数的范围</a></li><li><a href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%85%B6%E4%BB%96%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E5%8F%8D%E7%A0%81%E5%92%8C%E5%8E%9F%E7%A0%81">有符号的其他表示方法(反码和原码)</a></li></ul></li><li><a href="#2-2-4%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2">2.2.4 有符号数和无符号数之间的转换</a><ul><li><a href="#%E8%A1%A5%E7%A0%81%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0">补码转换为无符号数</a></li><li><a href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E8%A1%A5%E7%A0%81">无符号数转换为补码</a></li></ul></li></ul></li></ul></li></ul><h1 id="二、信息的表示和表达"><a href="#二、信息的表示和表达" class="headerlink" title="二、信息的表示和表达"></a>二、信息的表示和表达</h1><h2 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h2><h3 id="2-1-1-十六进制表示法"><a href="#2-1-1-十六进制表示法" class="headerlink" title="2.1.1 十六进制表示法"></a>2.1.1 十六进制表示法</h3><p><img src="/media/16998385166025/16998390485614.png"></p><blockquote><p>转化为二进制需要从右到左每4分为一组转换(不足补0)</p></blockquote><h4 id="十进制和十六进制互选转换"><a href="#十进制和十六进制互选转换" class="headerlink" title="十进制和十六进制互选转换"></a>十进制和十六进制互选转换</h4><p>十进制除16倒取余<br><img src="/media/16998385166025/16998394198795.png"></p><h3 id="2-1-2-字数据大小"><a href="#2-1-2-字数据大小" class="headerlink" title="2.1.2 字数据大小"></a>2.1.2 字数据大小</h3><p><img src="/media/16998385166025/16998395609489.png"></p><blockquote><p>unsigned long、unsigned long int<br>都是同个意思</p></blockquote><h3 id="2-1-3-寻址和字节顺序"><a href="#2-1-3-寻址和字节顺序" class="headerlink" title="2.1.3 寻址和字节顺序"></a>2.1.3 寻址和字节顺序</h3><p>对于跨越多字节的程序对象，两个规则</p><ul><li>这个对象的地址是什么</li><li>字内存中如何排序这些字节</li></ul><h4 id="地址为所使用字节最小的地址"><a href="#地址为所使用字节最小的地址" class="headerlink" title="地址为所使用字节最小的地址"></a>地址为所使用字节最小的地址</h4><h4 id="排序方法有两个通用规则"><a href="#排序方法有两个通用规则" class="headerlink" title="排序方法有两个通用规则"></a>排序方法有两个通用规则</h4><ul><li>大端法:最高有效字节中最前面的方法</li><li>小端法:最低有效字节中最前面的方法<blockquote></blockquote><img src="/media/16998385166025/16998409476624.png"></li></ul><h3 id="2-1-4-表示字符串"><a href="#2-1-4-表示字符串" class="headerlink" title="2.1.4 表示字符串"></a>2.1.4 表示字符串</h3><p>字符串被编码为一个以null（值为0）字符结尾的字符数组，每个字符都由某个标准编码来表达，因此，文本数据比二进制数据具有更强的平台独立性</p><h3 id="2-1-5-表达代码"><a href="#2-1-5-表达代码" class="headerlink" title="2.1.5 表达代码"></a>2.1.5 表达代码</h3><p>不同机器类型使用不同的且不兼容的指令和编码方式，即使是完全一样的进程，运行中不同操作系统上也有不同的编码规则，因此二进制代码是不兼容的。</p><h3 id="2-1-6-布尔代数"><a href="#2-1-6-布尔代数" class="headerlink" title="2.1.6 布尔代数"></a>2.1.6 布尔代数</h3><p><img src="/media/16998385166025/16998567614189.png"></p><p><img src="/media/16998385166025/16998568366125.png"></p><blockquote><p>布尔代数符合分配率<br>a&amp;(b|c) &#x3D; (a&amp;b)|(a&amp;c)<br>a|(b&amp;c) &#x3D; (a|b)&amp;(a|c)</p></blockquote><blockquote><p>布尔环<br>加分逆元(x+(-x) &#x3D; 0)<br>a^a &#x3D; 0<br>(a^b)^a &#x3D; b</p></blockquote><h3 id="2-1-7-位级运算"><a href="#2-1-7-位级运算" class="headerlink" title="2.1.7 位级运算"></a>2.1.7 位级运算</h3><p><img src="/media/16998385166025/16998569179935.png"></p><h4 id="掩码运算"><a href="#掩码运算" class="headerlink" title="掩码运算"></a>掩码运算</h4><p>掩码是一个位模式，表示一个字中选出的位的集合</p><blockquote><p>例子</p></blockquote><p><img src="/media/16998385166025/16998575552748.png"></p><h3 id="2-1-8-逻辑运算"><a href="#2-1-8-逻辑运算" class="headerlink" title="2.1.8 逻辑运算"></a>2.1.8 逻辑运算</h3><p>||、&amp;&amp;和！分别代表媒体逻辑中的OR、AND和NOT运算</p><h3 id="2-1-9移位运算"><a href="#2-1-9移位运算" class="headerlink" title="2.1.9移位运算"></a>2.1.9移位运算</h3><p><img src="/media/16998385166025/16998578307265.png"></p><ul><li>唯一例外是算术右移[10010101]的情况。<strong>因为操作数的最高位数1，填充的值就是1.</strong><blockquote><p>一般为算术右移<br>对于无符号数，右移必须是逻辑的<br>x&gt;&gt;j&gt;&gt;k等价于(x&lt;&lt;j)&lt;&lt;k<br>操作符的优先级中，加号的优先级比操作符的高</p></blockquote></li></ul><h2 id="2-2-整数表示"><a href="#2-2-整数表示" class="headerlink" title="2.2 整数表示"></a>2.2 整数表示</h2><p>编码整数的两种不同的方法：</p><ul><li>只能表示非负数</li><li>能够表示负数，0，正数</li></ul><blockquote><p>下文用到的数学术语</p></blockquote><p><img src="/media/16998385166025/16998582975352.png"></p><h3 id="2-2-1-整型数据类型"><a href="#2-2-1-整型数据类型" class="headerlink" title="2.2.1 整型数据类型"></a>2.2.1 整型数据类型</h3><h4 id="数据类型的典型取值范围"><a href="#数据类型的典型取值范围" class="headerlink" title="数据类型的典型取值范围"></a>数据类型的典型取值范围</h4><p><img src="/media/16998385166025/16998586485045.png"></p><p><img src="/media/16998385166025/16998586665394.png"></p><blockquote><p>取值范围是不对称的——负数的范围比整数的范围大1</p></blockquote><blockquote><p>下表是C语言标准定义的每种数据类型必须能够表示的最小的取值范围。</p></blockquote><p><img src="/media/16998385166025/16998588029453.png"></p><h3 id="无符号的编码"><a href="#无符号的编码" class="headerlink" title="无符号的编码"></a>无符号的编码</h3><p>将位向量看作二进制表示的数，将获得了位向量的无符号表达</p><h4 id="无符号数编码的定义"><a href="#无符号数编码的定义" class="headerlink" title="无符号数编码的定义"></a>无符号数编码的定义</h4><p><img src="/media/16998385166025/16998590944911.png"></p><p><img src="/media/16998385166025/16998591542514.png"></p><p><img src="/media/16998385166025/16998592255921.png"></p><blockquote><p>B2Uw是一个双射，函数Ｂ2Uw将每个长度为w的位向量都映射位0～2^w - 1之间的一个唯一值；反过来,U2Bw在0～2^w - 1之间的每一个整数都可以映射为一个唯一的长度为w的位模式。</p></blockquote><h3 id="2-2-3-补码编码"><a href="#2-2-3-补码编码" class="headerlink" title="2.2.3 补码编码"></a>2.2.3 补码编码</h3><h4 id="补码编码的定义"><a href="#补码编码的定义" class="headerlink" title="补码编码的定义"></a>补码编码的定义</h4><p><img src="/media/16998385166025/16998595311062.png"><br>字的最高有效位解释为负权，也叫做符号位。</p><blockquote><p>符号位为1时值为负<br>符号位为0时值为非负</p></blockquote><p><img src="/media/16998385166025/16998597654820.png"></p><blockquote><p>B2Tw也是双射</p></blockquote><h4 id="可表示的整数的范围"><a href="#可表示的整数的范围" class="headerlink" title="可表示的整数的范围"></a>可表示的整数的范围</h4><p><img src="/media/16998385166025/16998599315139.png"></p><ul><li>补码范围不对称：｜TMin｜ &#x3D; |TMax| + 1<br>之所以不对称是因为一半的位模式表示负数，而另一半表示为非负数，因为0是非负数所以比负数多1</li><li>最大的无符号值刚好比补码的最大值的两倍大一点：UMaxw &#x3D; 2Tmxw + 1.<blockquote><p>c语言标准并没有要求用补码形式来表示用符号整数，但是几乎所有的机器都是这么做的。</p></blockquote></li></ul><blockquote><p>为来使代码具有最大可移植性，能够做所有可能的机器上运行，我们不应该假设任何可表示的数值类型，也不应该假设也符号数会使用何种特殊的表达方式。<br>许多程序的书写都是用补码来表示用符号数，并且具有图2-9和图2-10所示的典型的取值范围，这些程序能够值大量机器上移植</p></blockquote><p>staint.h中定义了一组数据类型：intN_t和uintN_t（对不同N值指定N位用符号和无符号整数）</p><blockquote><p>N：8、16、32和64</p></blockquote><p>这些数据类型对应着一组宏，定义了每个N对值对应对最小和最大值：INTN_MIN、INTN_MAX和UINTN_MAX</p><p><img src="/media/16998385166025/16998607174352.png"></p><h4 id="有符号的其他表示方法-反码和原码"><a href="#有符号的其他表示方法-反码和原码" class="headerlink" title="有符号的其他表示方法(反码和原码)"></a>有符号的其他表示方法(反码和原码)</h4><p><img src="/media/16998385166025/16998607836002.png"></p><p><img src="/media/16998385166025/16998608162844.png"></p><p><img src="/media/16998385166025/16998608493945.png" alt="图2-15"></p><h3 id="2-2-4-有符号数和无符号数之间的转换"><a href="#2-2-4-有符号数和无符号数之间的转换" class="headerlink" title="2.2.4 有符号数和无符号数之间的转换"></a>2.2.4 有符号数和无符号数之间的转换</h3><p>从位级角度思考<br>转换<strong>数值变但是位模式不变</strong></p><h4 id="补码转换为无符号数"><a href="#补码转换为无符号数" class="headerlink" title="补码转换为无符号数"></a>补码转换为无符号数</h4><ul><li>原理<br><img src="/media/16998385166025/16998611816561.png" alt="公式2.5"></li><li>推导<br><img src="/media/16998385166025/16998612864476.png" alt="公式2.6"></li></ul><p><img src="/media/16998385166025/16998613857100.png"></p><h4 id="无符号数转换为补码"><a href="#无符号数转换为补码" class="headerlink" title="无符号数转换为补码"></a>无符号数转换为补码</h4><ul><li>原理</li></ul><p><img src="/media/16998385166025/16998613713711.png" alt="公式2.7"></p><ul><li>推导</li></ul><p><img src="/media/16998385166025/16999191653704.png" alt="公式2.8"></p><p><img src="/media/16998385166025/16999191775362.png" alt="图2-17"></p><h3 id="2-2-5-C语言中有符号数与无符号数"><a href="#2-2-5-C语言中有符号数与无符号数" class="headerlink" title="2.2.5 Ｃ语言中有符号数与无符号数"></a>2.2.5 Ｃ语言中有符号数与无符号数</h3><p><strong>默认补码，要创建无符号常数，后缀加u&#x2F;U</strong><br>Ｃ语言运算中，如果一个运算数是有符号而另一个是无符号，Ｃ语言就会隐式将<strong>有符号</strong>强制转换为<strong>无符号数</strong>，并假设两个数都是非负的</p><p><img src="/media/16998385166025/16999196070225.png"></p><p><img src="/media/16998385166025/16999196160028.png"></p><h3 id="2-2-6-扩展一个数的位表示"><a href="#2-2-6-扩展一个数的位表示" class="headerlink" title="2.2.6 扩展一个数的位表示"></a>2.2.6 扩展一个数的位表示</h3><h4 id="从较小类型转换到一个较大的类型-零扩展"><a href="#从较小类型转换到一个较大的类型-零扩展" class="headerlink" title="从较小类型转换到一个较大的类型(零扩展)"></a>从较小类型转换到一个较大的类型(零扩展)</h4><p>将无符号转换为另一个更大的数据类型</p><ul><li>零扩展：在表示的开头添加0</li></ul>]]></content>
      
    </entry>
    
    
  
</search>
