<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python爬虫笔记(二)</title>
      <link href="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/"/>
      <url>/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫三步骤简讲"><a href="#爬虫三步骤简讲" class="headerlink" title="爬虫三步骤简讲"></a>爬虫三步骤简讲</h1><ul><li>获取数据</li><li>解析数据</li><li>提取数据</li></ul><h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><h3 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h3><p>安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple requests</span><br></pre></td></tr></table></figure><p>安装完成后，在命令行中输入 <code>pip show requests</code>,能看到 requests 库的版本、简介等信息，说明你已经安装成功啦。</p><p>用request库访问页面只需要一步:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">res = requests.get(<span class="string">&#x27;https://book.douban.com/top250/&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>上面第二行代码我们调用了 requests 库中的 <code>get()</code> 方法，让 Python 帮我们调用计算机网络服务，向传入的 URL 发送请求，并把收到的响应保存到变量 <code>res</code>（response 简写）中。</p></blockquote><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219162841082.png" alt="image-20231219162841082"></p><blockquote><p>我们将res打印出来的结果不是html代码，而是&lt;Response [xxx]&gt;响应状态.</p></blockquote><h3 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h3><p>HTTP 响应内容不单单包括客户端所请求的资源本身，还包含响应状态等信息。因此 requests 库选择将获取的响应打包为 <code>Response</code> 对象，方便我们通过类的 <strong>属性</strong> 或 <strong>方法</strong> 获取想要的内容。而当我们打印 <code>Response</code> 对象本身时，Python 会按照 requests 库约定好的方式，打印出类名（Response）和本次响应状态码。</p><blockquote><p>我们可以查询<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/418">MDN网页开发者手册</a>来看具体错误原因:服务器拒绝冲泡咖啡，因为它是茶壶.</p></blockquote><p>418,这一状态码起源于 1998 年愚人节玩笑，现在多被网站开发者用作彩蛋，也经常用于警告爬虫程序：小心点，你已经被我看穿啦!</p><p>因此，我们用爬虫访问对象时,需要在request.get()里面加上消息头(headers)</p><h3 id="消息头-headers"><a href="#消息头-headers" class="headerlink" title="消息头(headers)"></a>消息头(headers)</h3><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219163736947.png" alt="image-20231219163736947"></p><p>我们没有加消息头相当于告诉网站，我是爬虫。因此我们需要在请求的时候附加上消息头，我们只需要将需要附上的信息组织成 <strong>字典</strong> 的格式，再通过 <code>headers</code> 参数传递给 <code>get()</code> 方法，requests 库帮我们向服务器发送请求时，就会自动带上这些信息了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># 定制消息头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="comment"># 消息头中有一项附加信息 user-agent</span></span><br><span class="line">  <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 携带消息头向服务器发送请求</span></span><br><span class="line">res = requests.get(<span class="string">&#x27;https://book.douban.com/top250/&#x27;</span>, headers=headers)</span><br></pre></td></tr></table></figure><blockquote><p>消息头不止user-agent，我们再后面还会说到params查询参数请求(url地址?后面的内容)和proxies代理(http,https)。</p></blockquote><p>requests库将响应的内容转化为<strong>字符串</strong>类型，保存到 Response 对象的 <code>text</code> 属性中，我们能很轻松地通过 <code>.</code> 运算符访问到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(res.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="comment"># &lt;html lang=&quot;zh-cmn-Hans&quot; class=&quot;ua-mac ua-webkit book-new-nav&quot;&gt;</span></span><br><span class="line"><span class="comment"># &lt;head&gt;</span></span><br><span class="line"><span class="comment">#   &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span></span><br><span class="line"><span class="comment">#   &lt;title&gt;豆瓣读书 Top 250&lt;/title&gt;</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>我们可以发现响应内容为HTML源码，接下来我们将说说如何提取出所需信息。</p><h2 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h2><blockquote><p>对于我们这个例子,因为他是静态网站,我们将使用<strong>bs4</strong>库来解析数据;后面我们还会说到用API和json来获取解析</p></blockquote><p><strong>bs4</strong> 中的 4 是版本号，<strong>bs</strong> 是它名称缩写，全称叫 <strong>BeautifulSoup</strong>——取自刘易斯·卡罗尔在《爱丽丝梦游仙境》里的同名诗歌。正如诗歌所言，<strong>BeautifulSoup</strong> 尝试化平淡为神奇，通过将网页源代码解析成 <strong>BeautifulSoup 对象</strong>，把结构复杂的网页代码内部组织关系捋得清清楚楚。</p><p>安装:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple bs4</span><br></pre></td></tr></table></figure><h3 id="BeautifulSoup-对象"><a href="#BeautifulSoup-对象" class="headerlink" title="BeautifulSoup 对象"></a>BeautifulSoup 对象</h3><p>我们在IDE中用ctrl+左键可以进入库中阅读他的说明文档</p><p>BeautifulSoup 类作用:</p><ul><li>创建 <strong>BeautifulSoup 对象</strong> 时，它会把 HTML&#x2F;XML 文档解析成 <strong>树形结构</strong></li><li>BeautifulSoup 类继承自 Tag 类，因此 BeautifulSoup 类和 Tag 类有许多共用的方法。</li></ul><p>创建 <strong>BeautifulSoup</strong> 对象时需要传入两个参数：</p><ul><li>所需解析的 <strong>HTML 代码</strong>，即响应的文本内容（<code>res.text</code>）；</li><li>用于解析 HTML 代码的 <strong>解析器</strong>，课程内使用的是 Python 内置解析器 <code>html.parser</code>（parser：解析器）。</li></ul><p>我们获取豆瓣读书 Top 250 页面内容并解析成 BeautifulSoup 对象的过程写成代码就是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 库</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># 从 bs4 库中导入 BeautifulSoup</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定制消息头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 发送带消息头的请求</span></span><br><span class="line">res = requests.get(<span class="string">&#x27;https://book.douban.com/top250&#x27;</span>, headers=headers)</span><br><span class="line"><span class="comment"># 创建 BeautifulSoup 对象，解析响应的文本内容</span></span><br><span class="line">soup = BeautifulSoup(res.text, <span class="string">&#x27;html.parser&#x27;</span>)</span><br></pre></td></tr></table></figure><p>按照文档的说法，此时我们得到的 <code>soup</code> 变量已经是解析好的 <strong>树形结构</strong>。这棵树长什么样子呢？我们打印出 <code>soup</code> 变量的 <strong>数据类型</strong> 和 <strong>值</strong> 看看</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219165322498.png" alt="image-20231219165322498"></p><p>打印出来的类型是&lt;class ‘bs4.BeautifulSoup’&gt;，而其值与源代码一模一样。</p><p>其实，它们只是看上去一样，实际上却是不同的东西。</p><p><strong>BeautifulSoup 对象</strong> 内部结构像一棵倒着生长的树，树根在上面，枝叶在下面，每个节点都对应着 HTML 代码中的一个元素。顺着这棵 <strong>HTML 文档树</strong>，我们就能定位到某个或某群具有相同特征的元素，从而提取出元素文本内容——也就是我们所需的数据。</p><h3 id="HTML-文档树"><a href="#HTML-文档树" class="headerlink" title="HTML 文档树"></a>HTML 文档树</h3><p>举个例子:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>我的网页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"> <span class="selector-tag">body</span> &#123; <span class="attribute">background-color</span>: <span class="number">#101324</span>; <span class="attribute">color</span>: <span class="number">#ffffff</span>; <span class="attribute">font-family</span>: -apple-system, BlinkMacSystemFont, <span class="string">&#x27;Segoe UI&#x27;</span>, Roboto, <span class="string">&#x27;Helvetica Neue&#x27;</span>, Arial, <span class="string">&#x27;Noto Sans&#x27;</span>, sans-serif, <span class="string">&#x27;Apple Color Emoji&#x27;</span>, <span class="string">&#x27;Segoe UI Emoji&#x27;</span>, <span class="string">&#x27;Segoe UI Symbol&#x27;</span>, <span class="string">&#x27;Noto Color Emoji&#x27;</span>; &#125; <span class="selector-tag">a</span> &#123; <span class="attribute">color</span>: <span class="number">#1890ff</span>; &#125; <span class="selector-tag">code</span> &#123; <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.15</span>); <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">6px</span>; <span class="attribute">border-radius</span>: <span class="number">4px</span>; <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.87</span>); &#125; <span class="selector-tag">img</span> &#123; <span class="attribute">width</span>: <span class="number">100%</span>; &#125; </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Web 真好玩！<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>今天我在 <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.bailog.top/&quot;</span>&gt;</span>bai的小屋<span class="tag">&lt;/<span class="name">a</span>&gt;</span> 学到了这些内容：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>HTML 基本语法<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>HTML 文档结构<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Elements 面板 <span class="tag">&lt;<span class="name">code</span>&gt;</span>Edit text<span class="tag">&lt;/<span class="name">code</span>&gt;</span> 功能<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>其中常见的 HTML 元素有这些：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://media-image1.baydn.com/storage_media_image/svpyor/ff5185b0ab456965c9f89c7506ed0a9e.bff6930d34f5dca7819b5e571f421b9b.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该 HTML 文档根节点为 <strong>html 元素</strong>。它有两个子节点，分别是 <strong>head 元素</strong> 和 <strong>body 元素</strong>。再往内推，head 与 body 内也分别包含诸多元素。我们将这些元素按照 <strong>根节点 – 子节点 – 子节点的子节点……</strong> 顺序从上至下梳理出的图谱，就是 <strong>HTML 文档树</strong>。</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219165622772.png" alt="image-20231219165622772"></p><p>一棵文档树就像是这些元素的族谱：</p><ul><li>html 元素是所有其它元素的 <strong>祖先</strong>，反过来说，其它元素都是 html 的 <strong>后代</strong>；</li><li>head 元素和 body 元素的 <strong>父节点</strong> 是 html 元素，因此它们是 html 的 <strong>直接后代</strong>；</li><li>由于 head 和 body 父节点相同，所以它们互为 <strong>兄弟节点</strong>；</li></ul><blockquote><p>a 元素的父节点是 p 元素，p 元素的父节点是 body 元素，a 和 body 之间隔了一层“血缘关系”，所以 a 是 body 的 <strong>后代</strong> 而不是 <strong>直接后代</strong>。这点一定要注意</p></blockquote><p>我们解析得到的 BeautifulSoup 对象，本质上就是这样一棵 HTML 文档树。树中每个节点都被抽象为了 <strong>Tag 对象</strong>。还记得吗？BeautifulSoup 类是继承自 Tag 类的，所以 BeautifulSoup 对象不仅代表着整棵 HTML 文档树，还代表着根节点。</p><h2 id="提取数据"><a href="#提取数据" class="headerlink" title="提取数据"></a>提取数据</h2><p>根据<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/#id19">BeautifulSoup 官方中文文档</a>,我们可以看到 bs4 库中提供了多种遍历、检索文档树的方法。其中一个最常用也最强大灵活的一个方法是:通过<strong>CSS选择器</strong>提取</p><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>CSS 选择器是 CSS 语言中的一部分，能通过 HTML 元素的 <strong>类型</strong>、<strong>标识</strong> 和 <strong>关系</strong> 快速选择符合条件的 <strong>所有元素</strong>。由于它简单、好用，也被广泛应用于其它领域。绝大多数与 Web 打交道的语言、工具都支持通过 <strong>CSS 选择器</strong> 检索 HTML 元素，比如我们今天学习的 bs4 库，比如网页开发者工具。</p><ul><li>网页开发者工具:<br>按<code>Ctrl + F</code>打开搜索栏，在搜索栏输入div，表示检索此类型元素，此时开发者工具会将所有符合条件的内容用黄色底色标注出来。</li></ul><p><strong>类别</strong>:</p><ul><li><p><strong>基本选择器</strong>：通过元素的 <strong>类型</strong>、<strong>class 属性值</strong>、<strong>id 属性值</strong> 检索；</p></li><li><p><strong>组合选择器</strong>：通过元素和元素之间的 <strong>关系</strong> 检索，分为 <strong>直接后代组合器</strong>、<strong>后代组合器</strong> 和 <strong>兄弟组合器</strong>。</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219171814988.png" alt="image-20231219171814988"></p></li></ul><h4 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h4><p>例子:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;poem&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>静夜思<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;density&quot;</span>&gt;</span>唐<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="symbol">&amp;bull;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;author&quot;</span>&gt;</span>李白<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;first&quot;</span>&gt;</span>床前明月光，疑是地上霜。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;second&quot;</span>&gt;</span>举头望明月，低头思故乡。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"> <span class="selector-class">.poem</span> &#123;<span class="attribute">text-align</span>: center;&#125; <span class="selector-id">#title</span> &#123;<span class="attribute">font-size</span>: <span class="number">1.3rem</span>; <span class="attribute">font-weight</span>: bold;&#125; <span class="selector-class">.info</span> &#123;<span class="attribute">font-weight</span>: lighter;&#125; <span class="selector-class">.content</span> &#123;<span class="attribute">margin-left</span>: <span class="number">0.5rem</span>;&#125; </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="poem">  <p id="title">静夜思</p>  <div class="info">    <span id="density">唐</span>    <span>&bull;</span>    <span id="author">李白</span>  </div>  <div class="content">    <p id="first">床前明月光，疑是地上霜。</p>    <p id="second">举头望明月，低头思故乡。</p>  </div></div><style> .poem {text-align: center;} #title {font-size: 1.3rem; font-weight: bold;} .info {font-weight: lighter;} .content {margin-left: 0.5rem;} </style><p>我们抛去 style 元素不看，那么整体 HTML 文档树是这样的：</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219171103712.png" alt="image-20231219171103712"></p><p>可以看到，文档树中有三个 p 元素，id 为 <code>title</code> 的 p 元素用于描述唐诗标题，id 为 <code>first</code> 的 p 元素用于描述第一句诗，id 为 <code>second</code> 的用于描述第二句诗。CSS 选择器 <code>p</code> 会同时选中这三个元素：</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219171124251.png" alt="image-20231219171124251"></p><p>但如果我们想 <strong>精准</strong> 地提取出唐诗标题，这时该怎么做呢？</p><p>还记得我们上个笔记的内容吗？元素的 class 属性和 id 属性用于 <strong>标识元素</strong>。而标识的目的就是方便 CSS 选择器定位。</p><p>其中靠 class 属性值检索的选择器被称为 <strong>类选择器</strong>，需要写成 <code>.class_name</code>，表示检索所有 class 属性值为 <code>class_name</code> 的元素。靠 id 属性值检索的被称为 <strong>ID 选择器</strong>，写成 <code>#id_name</code>，表示检索所有 id 属性值为 <code>id_name</code> 的元素。</p><p>类选择器、ID 选择器与元素选择器一起并称为 <strong>基本选择器</strong>。</p><blockquote><p>如果我们想用CSS 选择器 <strong>精准定位</strong> 到唐诗标题所在 p 元素,我们可以用<code>#&#39;&#39;title&#39;&#39;</code>CSS选择器</p></blockquote><p>类选择器和 ID 选择器通常不会孤立出现，而是配合元素选择器一起使用，写成 <strong>元素名.类名</strong> 或 <strong>元素名#ID名</strong> 形式。例如唐诗标题所在 p 元素的完整选择器是 <code>p#title</code>。我们稍后爬取豆瓣网信息时就会使用这种写法。</p><p>了解如何提取唐诗标题后，我们又遇到新的问题：上下两句诗分布在两个 p 元素之中，我们又该同时定位到这两句诗呢？</p><h4 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h4><p>基本选择器无法满足我们需求时，我们可以转换思路——根据元素与其它元素之间的 <strong>关系</strong>，将若干个基本选择器组合起来形成 <strong>组合选择器</strong>，进一步提升检索精确度。</p><p>通过之前学习我们知道，元素与元素之间的关系可以分为 <strong>祖先 – 后代</strong>、<strong>祖先 – 直接后代</strong>、<strong>兄弟 – 兄弟</strong> 三类，因此两个元素之间的组合关系也分为三种：</p><ul><li><code>A B</code>：检索 A 元素 <strong>后代</strong> 中的所有 B 类型元素；</li><li><code>A &gt; B</code>：检索 A 元素 <strong>直接后代</strong> 中所有 B 类型元素；</li><li><code>A ~ B</code>：检索 A 元素 <strong>兄弟</strong> 中所有 B 类型元素。</li></ul><p>回顾《静夜思》文档树我们可以看到，根节点 div 元素后代中有许多 p 元素，标题所在 p 元素是根节点的 <strong>直接后代</strong>，上下两句诗所在 p 元素是根节点的 <strong>后代</strong>。所以当我们从根节点出发，编写选择器 <code>div.poem p</code>，会同时选中这三个 p 元素：</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219171620456.png" alt="image-20231219171620456"></p><p>而选择器 <code>div.poem &gt; p</code> 只会选中根节点的直接后代，即标题所在 p 元素：</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219171635740.png" alt="image-20231219171635740"></p><p>了解了什么是 <strong>组合选择器</strong>，我们就能同时定位上下两句诗啦。我们观察到，上下两句诗都是 p 元素，并且都是 <code>div.content</code> 的 <strong>直接后代</strong>，所以可以编写 <code>div.content &gt; p</code> 同时选中这两句诗：</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219171652356.png" alt="image-20231219171652356"></p><blockquote><p>由于此时 <code>div.content</code> 下没有其它元素，所以 <code>div.content p</code> 也能够定位到两句诗。CSS 选择器写法多种多样，只要能定位到所需元素即可。</p></blockquote><h4 id="实战例子"><a href="#实战例子" class="headerlink" title="实战例子"></a>实战例子</h4><p><a href="https://book.douban.com/top250?icn=index-book250-all">豆瓣读书top250</a>,中中提取出每本书的 <strong>书名</strong>、<strong>作者</strong> 和 <strong>出版社</strong> 信息。</p><p>我们可以先检查元素快速定位到源代码中的位置，然后进行解读:</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219172229454.png" alt="image-20231219172229454"></p><p>观察可知，我们可以用<code>div.class a</code>或者<code>div.class &gt; a</code>来获取书名</p><p>通过同样的方法，我们可以分析得出，作者、出版社等书籍信息都在 class 属性值为 <code>pl</code> 的 p 元素中。因此我们能通过选择器 <code>p.pl</code> 定位到它们。</p><h3 id="select-方法"><a href="#select-方法" class="headerlink" title="select()方法"></a>select()方法</h3><p><strong>BeautifulSoup 对象</strong> 有一个名为 <code>select()</code> 的方法。我们将定位的<code>CSS选择器</code>传进去，它会返回一个列表，列表中每个元素都是符合条件的检索结果。例如我想提取每本书书名信息所在元素，可以写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前面代码省略，soup 为解析好的 BeautifulSoup 对象</span></span><br><span class="line">book_name_tags = soup.select(<span class="string">&#x27;div.pl2 a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(book_name_tags)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># [&lt;a href=&quot;https://book.douban.com/subject/1007305/&quot; onclick=&quot;&amp;quot;moreurl(this,&#123;i:&#x27;0&#x27;&#125;)&amp;quot;&quot; title=&quot;红楼梦&quot;&gt;</span></span><br><span class="line"><span class="comment">#                 红楼梦                </span></span><br><span class="line"><span class="comment">#               &lt;/a&gt;, &lt;a href=&quot;https://book.douban.com/subject/4913064/&quot; onclick=&quot;&amp;quot;moreurl(this,&#123;i:&#x27;1&#x27;&#125;)&amp;quot;&quot; title=&quot;活着&quot;&gt;</span></span><br><span class="line"><span class="comment">#                 活着                </span></span><br><span class="line"><span class="comment">#               &lt;/a&gt;, &lt;a href=&quot;https://book.douban.com/subject/6082808/&quot; onclick=&quot;&amp;quot;moreurl(this,&#123;i:&#x27;2&#x27;&#125;)&amp;quot;&quot; title=&quot;百年孤独&quot;&gt;</span></span><br><span class="line"><span class="comment">#                 百年孤独</span></span><br><span class="line"><span class="comment">#               &lt;/a&gt;, ...]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(book_name_tags[<span class="number">0</span>]))</span><br><span class="line"><span class="comment"># 输出：&lt;class &#x27;bs4.element.Tag&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，所有书名信息所在元素都被我们提取出来了。并且通过打印 <code>book_name_tags</code> 列表第一个元素的数据类型我们发现，它是一个特殊的数据类型，<strong>Tag 类</strong>。正如我在介绍 BeautifulSoup 对象时说过的，BeautifulSoup 类继承自 Tag 类。我们通过 <code>select()</code> 方法获得的一个个节点，是一个个 <strong>Tag 对象</strong>。</p><h3 id="Tag对象"><a href="#Tag对象" class="headerlink" title="Tag对象"></a>Tag对象</h3><p>Tag常用的属性和方法:</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219172714327.png" alt="image-20231219172714327"></p><p>Tag 类也有 <code>select()</code> 方法——这是因为，BeautifulSoup 类中的 <code>select()</code> 方法就是继承自 Tag 类的。除此之外，我们还能通过 Tag 对象的 <code>text</code> 属性访问到该元素的 <strong>元素内容</strong>，通过 <strong>Tag对象[‘元素属性名称’]</strong> 形式访问到该元素的某个属性的值。</p><p>对于 <code>book_name_tags</code> 列表中第一个元素来说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">book = book_name_tags[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(book)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># &lt;a href=&quot;https://book.douban.com/subject/1007305/&quot; onclick=&quot;&amp;quot;moreurl(this,&#123;i:&#x27;0&#x27;&#125;)&amp;quot;&quot; title=&quot;红楼梦&quot;&gt;</span></span><br><span class="line"><span class="comment">#                 红楼梦                </span></span><br><span class="line"><span class="comment">#               &lt;/a&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以通过 <code>book.text</code> 获取元素内容，通过 <code>book[&#39;href&#39;]</code> 获取图书链接,<code>book[&#39;title&#39;]</code> 来获取书名。</p><p>同样的道理，我们可以编写代码提取出每本书作者、出版社信息所在元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前面代码省略，soup 为解析好的 BeautifulSoup 对象</span></span><br><span class="line">book_info_tags = soup.select(<span class="string">&#x27;p.pl&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(book_info_tags)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># [&lt;p class=&quot;pl&quot;&gt;[清] 曹雪芹 著 / 人民文学出版社 / 1996-12 / 59.70元&lt;/p&gt;, &lt;p class=&quot;pl&quot;&gt;余华 / 作家出版社 / 2012-8-1 / 20.00元&lt;/p&gt;, &lt;p class=&quot;pl&quot;&gt;[哥伦比亚] 加西亚·马尔克斯 / 范晔 / 南海出版公司 / 2011-6 / 39.50元&lt;/p&gt;, ...]</span></span><br></pre></td></tr></table></figure><p>可以看到，书籍信息存在于 p 元素的 <strong>文本内容</strong> 中，我们可以通过 <code>text</code> 属性获取。每条书籍信息则由若干项组成，依次是作者、译者（如果为外文作品）、出版社、出版年份、图书价格，每项中间用 <code>/</code> 分割。因此我们在提取图书作者、出版社信息时可分以下四步：</p><ol><li>遍历 <code>book_info_tags</code> 中每个元素；</li><li>对每个元素，通过 <code>text</code> 属性获取书籍信息，保存到 <code>info</code> 里；</li><li>按 <code>/</code> 分割 <code>info</code> 字符串，得到列表 <code>info_list</code>；</li><li><code>info_list</code> 中 <strong>第一项元素</strong> 是作者信息，<strong>倒数第三项元素</strong> 是出版社信息。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前面代码省略，soup 为解析好的 BeautifulSoup 对象</span></span><br><span class="line">book_info_tags = soup.select(<span class="string">&#x27;p.pl&#x27;</span>)</span><br><span class="line"><span class="comment"># 遍历所有书籍信息元素</span></span><br><span class="line"><span class="keyword">for</span> info_tag <span class="keyword">in</span> book_info_tags:</span><br><span class="line">  <span class="comment"># 获取书籍信息</span></span><br><span class="line">  info = info_tag.text</span><br><span class="line">  <span class="comment"># 按“ / ”分割字符串</span></span><br><span class="line">  info_list = info.split(<span class="string">&#x27; / &#x27;</span>)</span><br><span class="line">  <span class="comment"># 结果列表中第一项为作者信息</span></span><br><span class="line">  author = info_list[<span class="number">0</span>]</span><br><span class="line">  <span class="comment"># 倒数第三项为出版社信息</span></span><br><span class="line">  publisher = info_list[-<span class="number">3</span>]</span><br><span class="line">  <span class="built_in">print</span>(author, publisher)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># [清] 曹雪芹 著 人民文学出版社</span></span><br><span class="line"><span class="comment"># 余华 作家出版社</span></span><br><span class="line"><span class="comment"># [哥伦比亚] 加西亚·马尔克斯 南海出版公司</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>我们发现我们只提取了一页的数据，当我们在网站跳转页面的时候,可以发现，跳转后的 URL 相比于豆瓣读书 Top 250 首页 URL <strong><a href="https://book.douban.com/top250">https://book.douban.com/top250</a></strong>，后面多了串小尾巴 <strong>?start&#x3D;xx</strong>，并且随着页码的增加，小尾巴中数字部分也在增加。看起来这串小尾巴的值决定了页面中呈现的内容。</p><p>这部分以 <code>?</code> 开头的内容也是 URL 重要组成部分之一，被称为 <strong>查询参数</strong>，也叫 <strong>查询字符串</strong>。</p><h3 id="URL查询参数"><a href="#URL查询参数" class="headerlink" title="URL查询参数"></a>URL查询参数</h3><p><strong>查询参数</strong> 用于 <strong>过滤</strong>、<strong>组织</strong>、<strong>跟踪</strong> 网站上的信息，格式上以字符 <code>?</code> 开始，包含若干个由 <code>key=value</code> 形式 <strong>键值对</strong> 构成的参数。若 URL 携带多个查询参数，则参数与参数之间需要用 <code>&amp;</code> 相连，写成 <code>?key1=value1&amp;key2=value2&amp;...</code> 形式。</p><p>查询参数将整个站点的内容组织得井井有条。反向思考一下，我们也可以利用这一特点，在发送请求时附带上查询参数，从而自动地控制爬取哪一页的内容，就像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 豆瓣读书 Top 250 首页 URL</span></span><br><span class="line">base_url = <span class="string">&#x27;https://book.douban.com/top250/&#x27;</span></span><br><span class="line"><span class="comment"># 定制消息头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 定制查询参数</span></span><br><span class="line">params = &#123;</span><br><span class="line">  <span class="string">&#x27;start&#x27;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送带消息头、查询参数的请求</span></span><br><span class="line">res = requests.get(base_url, headers=headers, params=params)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># 输出：&lt;Response [200]&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>URL 携带的查询参数不仅能帮助过滤、组织数据，还能帮助网站跟踪用户信息。例如，我们打开百度，在搜索框中输入 <strong>python</strong> 并点击搜索，此时地址栏中 URL 为：</p><p><code>https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=python&amp;fenlei=256&amp;rsv_pq=f730835b0002005a&amp;rsv_t=6ad5qUqos2%2Fe4CWymVeklp9RMX%2FoN57Y5M3wUStajFsbCHW33MZ5kgZYICU&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=6&amp;rsv_sug1=6&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_btype=i&amp;prefixsug=python&amp;rsp=6&amp;inputT=1158&amp;rsv_sug4=1158</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">params = &#123;</span><br><span class="line">  <span class="string">&quot;ie&quot;</span>:<span class="string">&quot;utf-8&quot;</span>, <span class="comment"># InputEncoding，搜索关键字的编码</span></span><br><span class="line">  <span class="string">&quot;f&quot;</span>:<span class="string">&quot;8&quot;</span>, <span class="comment"># 搜索类型，8 为用户自主搜索，3 为下拉框推荐，1 为相关搜索</span></span><br><span class="line">  <span class="string">&quot;rsv_bp&quot;</span>:<span class="string">&quot;0&quot;</span>, <span class="comment"># 搜索位置，0 为从百度首页进入，1 为搜索结果顶部搜索，2 为搜索结果底部搜索</span></span><br><span class="line">  <span class="string">&quot;tn&quot;</span>:<span class="string">&quot;baidu&quot;</span>, <span class="comment"># 搜索来源标识，baidu 表示从百度首页搜索</span></span><br><span class="line">  <span class="string">&quot;wd&quot;</span>:<span class="string">&quot;python&quot;</span>, <span class="comment"># 搜索关键字</span></span><br><span class="line">  <span class="string">&quot;rqlang&quot;</span>:<span class="string">&quot;cn&quot;</span>, <span class="comment"># 用户所使用的语言，cn 表示中文</span></span><br><span class="line">  <span class="string">&quot;prefixsug&quot;</span>:<span class="string">&quot;python&quot;</span>, <span class="comment"># PrefixSuggestion，搜索前缀建议</span></span><br><span class="line">  <span class="string">&quot;rsp&quot;</span>:<span class="string">&quot;6&quot;</span>, <span class="comment"># 相关搜索词在所有推荐词中位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反爬策略"><a href="#反爬策略" class="headerlink" title="反爬策略"></a>反爬策略</h2><h4 id="身份判别与限制"><a href="#身份判别与限制" class="headerlink" title="身份判别与限制"></a>身份判别与限制</h4><ul><li>判别访问网站的是人类还是机器（爬虫程序）；</li><li>判别该用户是否拥有访问权限。</li></ul><h4 id="IP识别与限制"><a href="#IP识别与限制" class="headerlink" title="IP识别与限制"></a>IP识别与限制</h4><p><strong>IP（Internet Protocol）</strong> 全称 <strong>互联网协议地址</strong>，意思是分配给用户上网使用的网际协议的设备的数字标签。每一个可联网设备在访问网络时，都会被上级设备分配一个 IP。例如你使用手机流量访问时，会被附近的信号基站分配一个 IP 地址；连接 Wi-Fi 访问网页时，同一无线网络下所有设备将会被分配到同一网段的 IP 地址。</p><p>不仅我们个人的设备拥有 IP，提供网络服务的服务器也有 IP。我们在发送请求时，需要携带本机 IP，向着目标机器 IP 发送内容；服务器在响应时，也会携带自己的 IP，向着我们的 IP 回应。这些步骤在整个网络通信环节中处于比较底层的位置，无论是浏览器还是 requests 库，都会帮我们自动完成。</p><p>前面说过，当我们爬取大量数据时，如果我们不加以节制地访问目标网站，会使网站超负荷运转，一些个人小网站没什么反爬虫措施可能因此瘫痪。而大网站一般会限制你的访问频率，因为正常人是不会在 1s 内访问几十次甚至上百次网站的。</p><p>因此网站通常会记录访问者 IP，一旦发现某一 IP 短时间内向站点发送了大量请求，就会限制该 IP 继续访问。对此，我们常常使用 <code>time.sleep()</code> 来降低访问的频率。这样一来，对方也就睁一只眼闭一只眼不理会我们的爬虫。</p><p>除了降低访问频率之外，我们也可以使用 <strong>代理</strong> 来解决 IP 限制问题。<strong>代理</strong> 的意思是通过别的 IP 访问网站。这样，在 IP 被封后我们可以换一个 IP 继续爬取数据，或者每次爬取数据时都换不同的 IP，避免同一个 IP 访问的频率过高，这样就能快速地大规模爬取数据了。</p><p>使用代理:</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219175040245.png" alt="image-20231219175040245"></p><p>和 <code>headers</code>、<code>params</code> 一样，我们也需要定义一个字典，将其传递给 <code>get()</code> 方法的 <code>proxies</code> 参数。<code>proxies</code> 字典中有两个键，<code>http</code> 和 <code>https</code>，分别代表两种网络协议，键对应的值就是用于代理的 IP 地址。</p><p>官方文档中给了代理的基本用法，但在爬取大量数据时我们需要很多的 IP 用于切换。因此，我们需要建立一个 IP 代理池（列表），每次从中随机选择一个传给 <code>proxies</code> 参数。我们来看一下如何实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 库</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># 从 bs4 库导入 BeautifulSoup</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将获取一页图书数据代码封装成函数 get_one_page_data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_one_page_data</span>(<span class="params">page, proxy</span>):</span><br><span class="line">  <span class="comment"># 豆瓣读书 Top 250 首页 URL</span></span><br><span class="line">  base_url = <span class="string">&#x27;https://book.douban.com/top250/&#x27;</span></span><br><span class="line">  <span class="comment"># 定制消息头，内容省略</span></span><br><span class="line">  headers = ...</span><br><span class="line">  <span class="comment"># 根据传入参数定制查询参数，内容省略</span></span><br><span class="line">  params = ...</span><br><span class="line">  <span class="comment"># 发送带消息头、查询参数、代理的请求</span></span><br><span class="line">  res = requests.get(</span><br><span class="line">    base_url, headers=headers, params=params, proxies=proxy</span><br><span class="line">  )</span><br><span class="line">  <span class="comment"># 解析成 BeautifulSoup 对象</span></span><br><span class="line">  soup = BeautifulSoup(res.text, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">  <span class="comment"># 提取出书名、作者、出版社信息并按行打印</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># IP 代理池（瞎写的并没有用）</span></span><br><span class="line">proxies_list = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;http&quot;</span>: <span class="string">&quot;http://10.10.1.10:3128&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https&quot;</span>: <span class="string">&quot;http://10.10.1.10:1080&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;http&quot;</span>: <span class="string">&quot;http://10.10.1.11:3128&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https&quot;</span>: <span class="string">&quot;http://10.10.1.11:1080&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;http&quot;</span>: <span class="string">&quot;http://10.10.1.12:3128&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https&quot;</span>: <span class="string">&quot;http://10.10.1.12:1080&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 循环 10 次，分别获取第 1～10 页数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">  <span class="comment"># 从 IP 代理池中随机选择一个</span></span><br><span class="line">  get_one_page_data(i, choice(proxies_list))</span><br></pre></td></tr></table></figure><h4 id="验证码限制"><a href="#验证码限制" class="headerlink" title="验证码限制"></a>验证码限制</h4><p>在处理验证码问题上，我们多采用 <strong>自动与手动相结合</strong> 的方式，让机器控制浏览器，遇到需要输入验证码的场合，等待我们手动输入，接着再完成后面的爬取工作。这部分内容需要用到 <strong>selenium 库</strong>。我们会在后面学习 selenium 库的用法，至于破解验证码的内容，暂时不会涉及。</p><h4 id="文件加密"><a href="#文件加密" class="headerlink" title="文件加密"></a>文件加密</h4><blockquote><p>我们已经知道了网页中的文字内容都在 HTML 元素的 <strong>文本内容</strong> 中，图片是一种文件资源，可以通过 URL 下载。而我们一直没有涉及到 <strong>音视频</strong> 等媒体资源，这是因为，多数音乐平台，如网易云、QQ 音乐，或者视频网站，如腾讯视频、Bilibili，它们都对音视频文件做了特殊的 <strong>加密</strong>。</p></blockquote><p><strong>流媒体传输技术</strong> 和 <strong>加密技术</strong>。</p><p><strong>流媒体传输技术</strong>将庞大的音视频文件编写为长长的 <strong>二进制文件流</strong>，再把它均匀地切分成若干块进行传输；接受到这些信息块的客户端，再按照顺序拼接起来，从而不至于前后错乱。</p><p>流媒体加密算法，其中使用范围最广的就是 <strong>HLS 算法</strong></p><h2 id="静态网站小结"><a href="#静态网站小结" class="headerlink" title="静态网站小结"></a>静态网站小结</h2><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219173250832.png" alt="image-20231219173250832"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫笔记(一)</title>
      <link href="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器基础知识"><a href="#浏览器基础知识" class="headerlink" title="浏览器基础知识"></a>浏览器基础知识</h1><h2 id="网址-URL"><a href="#网址-URL" class="headerlink" title="网址(URL)"></a>网址(URL)</h2><p>学名: <strong>统一资源定位符</strong></p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li><p>网络协议类型:HTTP、HTTPS、FTP等</p></li><li><p>域名:如<a href="http://www.bailog.top/">www.bailog.top</a></p></li><li><p>资源在浏览器中的位置:有时以文件<strong>路径</strong>形式出现,有时以<strong>路由</strong>形式出现.</p><blockquote><p>比如我们一看到 URL <code>https://www.sample.com/编程/测试音频.mp3</code>，就知道这是在获取域名为 <code>sample.com</code> 的服务器中，编程文件夹下的 <strong>测试音频.mp3</strong> 文件。</p><p>比如扇贝编程首页的 URL 是 <code>https://www.bailog.top/archives/</code>，其中的 <code>/archives/</code> 是资源对应的路由，只有提供网络服务这一端知道资源到底在哪里。</p></blockquote></li><li><p>锚点:如<code>https://www.bailog.top/2023/12/14/Python-tree递归-tree递归/#总结</code>后面中的#总结，用于定位文章对应的内容。</p></li></ul><h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><p>浏览器只是一个“中转站”，并没有保存网站内容。我们浏览网页，是在通过浏览器，跟提供资源内容的 <strong>服务器</strong> 通信。它的实际过程是这样的：</p><ul><li>我们在浏览器输入 <strong>网址</strong>（URL）；</li><li>浏览器根据网址，调用我们设备的网络能力，找到域名对应的服务器，向服务器 <strong>请求</strong>（request）获取某某资源；</li><li>服务器收到请求后会作出 <strong>响应</strong>（response），在内部翻箱倒柜找出相应资源，把资源交给浏览器；</li><li>浏览器加载资源，把内容呈现到我们面前。</li><li><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231219000056624.png" alt="image-20231219000056624"></li></ul><blockquote><p>这也是“浏览器”名称的由来，即在自己的联网设备上 <strong>浏览</strong> 他人设备上的资源。在互联网领域，我们自己的设备叫做 <strong>客户端</strong>；他人设备，也就是提供内容的设备，叫做 <strong>服务器</strong>、<strong>服务端</strong>。浏览器每发送一次请求，服务器就会做出一次响应。如此一来一回，我们就在浏览器上看到了网页的内容。</p></blockquote><h2 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h2><h3 id="Network面板"><a href="#Network面板" class="headerlink" title="Network面板"></a>Network面板</h3><p>按F12调用,由四大块部分构成，我们重点关注三个部分：</p><ul><li><strong>功能区</strong>，这里我们重点关注类似 🚫 标志的 <strong>清除（clear）</strong> 按钮，以及 <strong>保留记录（Preserve log）</strong> 选项；</li><li><strong>筛选区</strong>，该功能区可以快速筛选出符合条件的请求，这里我们主要关注以 <strong>所有（All）</strong> 开始直到 <strong>其它（Other）</strong> 结束的类型标签，未来我们将用它来快速筛选指定类型请求；</li><li><strong>请求列表区</strong>，当开发者工具捕捉到发生在页面中的新请求时，会按请求发生顺序陈列在区域中。</li></ul><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231219000350515.png" alt="image-20231219000350515"></p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231219000512260.png" alt="image-20231219000512260"></p><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><p>反映本次响应的状态，分为五类:</p><ul><li>代码 <code>100</code>～<code>199</code>：<strong>信息响应</strong>，这是服务器在表明，“我收到你的请求了，不过处理起来有点麻烦，你接着发其它请求吧，我干完活了告诉你一声”；</li><li>代码 <code>200</code>～<code>299</code>：<strong>成功</strong>，表示服务器成功接收、理解、处理了请求；</li><li>代码 <code>300</code>～<code>399</code>：<strong>重定向</strong>，一般用于 URL 重定向，你可以理解为资源已经搬家了，服务器帮你把请求 URL 改成了资源所在的新地址；</li><li>代码 <code>400</code>～<code>499</code>：<strong>客户端错误</strong>，也就是我们请求获取资源的方式不对，比如 URL 输入错误，或者没有登录等等；</li><li>代码 <code>500</code>～<code>599</code>：<strong>服务器错误</strong>，表明服务器由于某些原因，现在无法作出响应。</li></ul><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231219152306544.png" alt="image-20231219152306544"></p><h2 id="爬虫工作原理"><a href="#爬虫工作原理" class="headerlink" title="爬虫工作原理:"></a>爬虫工作原理:</h2><p>爬虫实际上是充当了浏览器的功能，向服务器发送请求、获取服务器的响应。与使用浏览器浏览网页不同的是，爬虫程序无需将响应内容呈现出来，而是根据我们设定的规则去提取需要的数据，处理数据，最终将数据保存起来。</p><p>包含下面三个步骤:</p><ul><li><strong>第一步：获取数据</strong>，爬虫根据我们提供的 URL，向服务器发送请求获取响应内容</li><li><strong>第二步：处理数据</strong>，处理分为两步，一是解析响应内容，把它整理成 Python 中的数据格式，二是从中提取出所需数据；</li><li><strong>第三步：存储数据</strong>，将处理后的数据保存起来，便于后续的使用和分析等。</li></ul><h1 id="HTML基本语法"><a href="#HTML基本语法" class="headerlink" title="HTML基本语法"></a>HTML基本语法</h1><p><strong>HTML</strong> 全称 Hyper Text Markup Language，翻译过来是 <strong>超文本标记语言</strong>，是计算机语言的一种，由 <strong>元素</strong> 构成，用来结构化 Web 网页及其内容。</p><blockquote><p>比如，我有这么一段话：</p><p>Web 真好玩！</p><p>如果想让这段话显示在网页中，我们需要将它封装成一个 <strong>p（paragraph，段落）元素</strong>：</p><p><code>&lt;p&gt;Web 真好玩! &lt;/p&gt;</code></p></blockquote><p>可以看到，p 元素由三大部分组成：</p><ul><li><strong>开始标签</strong>：一对尖括号（即键盘上的小于号 <code>&lt;</code> 和大于号 <code>&gt;</code>）中间包裹着元素名称；</li><li><strong>元素内容</strong>：页面中用户可以看到的内容；</li><li><strong>结束标签</strong>：与开始标签类似，区别在于元素名称前有一个斜杠 <code>/</code>。</li></ul><h2 id="元素的属性"><a href="#元素的属性" class="headerlink" title="元素的属性"></a>元素的属性</h2><p><code>&lt;a href = &quot;https://www.bailog.top/&quot; target=&quot;_black&quot;&gt;bai的小窝&lt;a&gt;</code></p><blockquote><p>两个属性:</p><ul><li><code>href</code> 属性，值为 <code>https://web.shanbay.com/codetime/home/</code>，也就是扇贝编程首页 URL；</li><li><code>target</code> 属性，值为 <code>_blank</code>。</li></ul></blockquote><p>元素的属性属于额外信息，不会直接展示给我们用户，而是提供给浏览器、程序解析使用。每个元素可以设置什么样的属性，则是由元素类型决定的。比如 a 元素用于描述超链接，必须提供可跳转 URL，因此它具有 <code>href</code>（hypertext reference，超文本引用）属性。而没有这项功能的元素，比如 p 元素、h 系列元素等，也就不具有 <code>href</code> 属性。</p><blockquote><p>拓展：<code>target</code> 属性的值决定了当用户点击超链接时，跳转到指定 URL 的方式。<code>target</code> 属性默认值为 <code>_self</code>，表示在当前页面打开链接。课程中超链接 <code>target</code> 属性值为 <code>_blank</code>，表示会在浏览器新标签页打开。</p></blockquote><p>除了 <code>href</code> 这类特殊的属性，元素也有一些共同属性，最常见的就是 <code>class</code>、<code>id</code> 和 <code>style</code>。</p><p><code>class</code> 和 <code>id</code> 都是用来标识元素的。区别在于，<code>class</code> 用于标识某一类元素，在一份 HTML 文档中可以重复出现；而 <code>id</code> 用于标识具体的某一个元素，其值在整个 HTML 文档中是 <strong>唯一</strong> 的。</p><blockquote><p>你可以理解为：整个 HTML 文档是一所学校，<code>class</code> 是元素所在班级，<code>id</code> 是元素的学号。班级里可以有很多的人，但学号是全学校唯一的。</p></blockquote><p>元素标识的本职工作是方便 CSS、JavaScript 语言找到对应元素设置样式与交互逻辑。而我们的爬虫正可以利用这一点，借助 CSS 选择器定位到所需数据。</p><p><code>style</code> 属性则能够为元素设置样式，相当于在 HTML 中内嵌了一部分 CSS 代码。借助 style 属性，我们可以为 <strong>h1</strong> 元素加上一些样式，让它看起来和 <strong>p</strong> 元素差不多，也能够调整 <strong>p</strong> 元素的样式，让它看起来像个标题，就像这样：</p><p><code>&lt;h1 style=&quot;font-size: 1rem; font-weight: normal; margin-block-start: 1rem; margin-block-end: 1rem; margin: 0;&quot;&gt;加上样式后，一级标题看起来可以像段落正文&lt;/h1&gt;</code></p><h2 id="常见元素"><a href="#常见元素" class="headerlink" title="常见元素"></a>常见元素</h2><ul><li><p>HTML 中用 <strong>img（image）元素</strong> 来描述图片。img 元素有两个特殊属性，一个是 <code>src</code>（source）图片来源属性，值是图片资源对应的 URL；另一个是 <code>alt</code>（alternative text，用于替换的文本）属性。</p><p><code>&lt;img src = URL alt=&quot; &quot;&gt;</code></p><blockquote><p><code>alt</code> 属性功能比较特殊。当用户因为某些原因无法查看图片，比如网络连接速度慢、<code>src</code> 属性或属性值出现错误，或者用户正在使用屏幕阅读器时，浏览器会读取 <code>alt</code> 属性值，作为图片内容的替代信息展示给用户。并且 <code>alt</code> 的值可以为空，此时将由提供网页的服务器决定如何处理图片失效问题。</p></blockquote></li><li><p>空元素：有些元素并不需要提供文本内容，自然不需要元素内容。既然没有元素内容，索性连用于包裹内容的结束标签都不需要了。这类只有开始标签的元素叫做 <strong>空元素</strong></p></li></ul><blockquote><p>除了 img 元素，HTML 中还有许多空元素。它们有的是用于描述网页基本信息的，我们会在稍后章节中学习，有的则是服务于网页内容排版的，比如换行符 <strong>br（break）元素</strong>、水平分割线 <strong>hr（horizontal，水平的）元素</strong>。</p></blockquote><ul><li><p><code>&lt;br&gt;</code>元素:换行</p></li><li><p><code>&lt;hr&gt;</code>元素:水平分割线</p></li><li><p><code>&lt;ol&gt;</code>和<code>&lt;ul&gt;</code>元素:由最外层ol或ul元素以及内层li元素构成有序和无序列表。</p></li><li><p>表示空格:<code>&amp;amp;nbsp;</code></p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231219154503075.png" alt="image-20231219154503075"></p></li></ul><h2 id="HTML文档结构"><a href="#HTML文档结构" class="headerlink" title="HTML文档结构"></a>HTML文档结构</h2><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231219154918216.png" alt="image-20231219154918216"></p><p>我们从网页内容第一行看起。第一行的 <code>!&lt;DOCTYPE html&gt;</code> 表明该文件是 HTML 文档，便于浏览器正确解析，没有实际含义。<code>DOCTYPE</code> 之后的整个网页内容都包裹在 <strong>html 元素</strong> 中，这是约定俗成的格式。如此一来，网页内所有元素都是 html 元素的子元素，整个 HTML 文档像树一样开枝散叶，结构清晰明朗。因此，html 元素也被称为 <strong>根元素</strong>。</p><p>再往内部看，网页根元素最粗壮的两个分支，一个叫 <strong>head 元素</strong>，另一个叫 <strong>body 元素</strong>。它们分别是网页的 <strong>网页头</strong> 和 <strong>网页体</strong>。</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231219154941949.png" alt="image-20231219154941949"></p><blockquote><ul><li>用 <strong>title 元素</strong> 设置网页标题，这个标题将显示在浏览器标签页上，也会作为收藏时的描述文字；</li><li>用 <strong>meta 元素</strong> 设置网页元信息，这些信息包括网页使用什么样的字符编码方式、样式、整体布局，还包含页面描述信息和面向搜索引擎的搜索关键字等等。</li><li>head 元素中还有许多 <strong>link 元素</strong> 和 <strong>script 元素</strong>，它们负责将 HTML 文档与对应的 CSS 样式、JavaScript 代码文件关联起来。仔细观察这些元素中的元素内容或 <code>href</code> 属性的值，就能够了解这个网页用到了哪些技术。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解计算机原理--第一章</title>
      <link href="/2023/12/14/%E8%AF%BB%E4%B8%80%E6%9C%AC%E5%A5%BD%E4%B9%A6-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-index/"/>
      <url>/2023/12/14/%E8%AF%BB%E4%B8%80%E6%9C%AC%E5%A5%BD%E4%B9%A6-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-index/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%E4%BA%8C%E3%80%81%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%A1%A8%E8%BE%BE">二、信息的表示和表达</a><ul><li><a href="#2-1%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8">2.1 信息存储</a><ul><li><a href="#2-1-1%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95">2.1.1 十六进制表示法</a><ul><li><a href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E5%92%8C%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E4%BA%92%E9%80%89%E8%BD%AC%E6%8D%A2">十进制和十六进制互选转换</a></li></ul></li><li><a href="#2-1-2%E5%AD%97%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F">2.1.2 字数据大小</a></li><li><a href="#2-1-3%E5%AF%BB%E5%9D%80%E5%92%8C%E5%AD%97%E8%8A%82%E9%A1%BA%E5%BA%8F">2.1.3 寻址和字节顺序</a><ul><li><a href="#%E5%9C%B0%E5%9D%80%E4%B8%BA%E6%89%80%E4%BD%BF%E7%94%A8%E5%AD%97%E8%8A%82%E6%9C%80%E5%B0%8F%E7%9A%84%E5%9C%B0%E5%9D%80">地址为所使用字节最小的地址</a></li><li><a href="#%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%80%9A%E7%94%A8%E8%A7%84%E5%88%99">排序方法有两个通用规则</a></li></ul></li><li><a href="#2-1-4%E8%A1%A8%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2">2.1.4 表示字符串</a></li><li><a href="#2-1-5%E8%A1%A8%E8%BE%BE%E4%BB%A3%E7%A0%81">2.1.5 表达代码</a></li><li><a href="#2-1-6%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0">2.1.6 布尔代数</a></li><li><a href="#2-1-7%E4%BD%8D%E7%BA%A7%E8%BF%90%E7%AE%97">2.1.7 位级运算</a><ul><li><a href="#%E6%8E%A9%E7%A0%81%E8%BF%90%E7%AE%97">掩码运算</a></li></ul></li><li><a href="#2-1-8%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97">2.1.8 逻辑运算</a></li><li><a href="#2-1-9%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97">2.1.9移位运算</a></li></ul></li><li><a href="#2-2%E6%95%B4%E6%95%B0%E8%A1%A8%E7%A4%BA">2.2 整数表示</a><ul><li><a href="#2-2-1%E6%95%B4%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">2.2.1 整型数据类型</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B8%E5%9E%8B%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4">数据类型的典型取值范围</a></li></ul></li><li><a href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%9A%84%E7%BC%96%E7%A0%81">无符号的编码</a><ul><li><a href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%BC%96%E7%A0%81%E7%9A%84%E5%AE%9A%E4%B9%89">无符号数编码的定义</a></li></ul></li><li><a href="#2-2-3%E8%A1%A5%E7%A0%81%E7%BC%96%E7%A0%81">2.2.3 补码编码</a><ul><li><a href="#%E8%A1%A5%E7%A0%81%E7%BC%96%E7%A0%81%E7%9A%84%E5%AE%9A%E4%B9%89">补码编码的定义</a></li><li><a href="#%E5%8F%AF%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%95%B4%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4">可表示的整数的范围</a></li><li><a href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%85%B6%E4%BB%96%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E5%8F%8D%E7%A0%81%E5%92%8C%E5%8E%9F%E7%A0%81">有符号的其他表示方法(反码和原码)</a></li></ul></li><li><a href="#2-2-4%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2">2.2.4 有符号数和无符号数之间的转换</a><ul><li><a href="#%E8%A1%A5%E7%A0%81%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0">补码转换为无符号数</a></li><li><a href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E8%A1%A5%E7%A0%81">无符号数转换为补码</a></li></ul></li></ul></li></ul></li></ul><h1 id="二、信息的表示和表达"><a href="#二、信息的表示和表达" class="headerlink" title="二、信息的表示和表达"></a>二、信息的表示和表达</h1><h2 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h2><h3 id="2-1-1-十六进制表示法"><a href="#2-1-1-十六进制表示法" class="headerlink" title="2.1.1 十六进制表示法"></a>2.1.1 十六进制表示法</h3><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998390485614.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998390485614.png?x-oss-process=style/stylename</a>)</p><blockquote><p>转化为二进制需要从右到左每4分为一组转换(不足补0)</p></blockquote><h4 id="十进制和十六进制互选转换"><a href="#十进制和十六进制互选转换" class="headerlink" title="十进制和十六进制互选转换"></a>十进制和十六进制互选转换</h4><p>十进制除16倒取余<br>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998394198795.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998394198795.png?x-oss-process=style/stylename</a>)</p><h3 id="2-1-2-字数据大小"><a href="#2-1-2-字数据大小" class="headerlink" title="2.1.2 字数据大小"></a>2.1.2 字数据大小</h3><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998395609489.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998395609489.png?x-oss-process=style/stylename</a>)</p><blockquote><p>unsigned long、unsigned long int<br>都是同个意思</p></blockquote><h3 id="2-1-3-寻址和字节顺序"><a href="#2-1-3-寻址和字节顺序" class="headerlink" title="2.1.3 寻址和字节顺序"></a>2.1.3 寻址和字节顺序</h3><p>对于跨越多字节的程序对象，两个规则</p><ul><li>这个对象的地址是什么</li><li>字内存中如何排序这些字节</li></ul><h4 id="地址为所使用字节最小的地址"><a href="#地址为所使用字节最小的地址" class="headerlink" title="地址为所使用字节最小的地址"></a>地址为所使用字节最小的地址</h4><h4 id="排序方法有两个通用规则"><a href="#排序方法有两个通用规则" class="headerlink" title="排序方法有两个通用规则"></a>排序方法有两个通用规则</h4><ul><li>大端法:最高有效字节中最前面的方法</li><li>小端法:最低有效字节中最前面的方法<blockquote></blockquote>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998409476624.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998409476624.png?x-oss-process=style/stylename</a>)</li></ul><h3 id="2-1-4-表示字符串"><a href="#2-1-4-表示字符串" class="headerlink" title="2.1.4 表示字符串"></a>2.1.4 表示字符串</h3><p>字符串被编码为一个以null（值为0）字符结尾的字符数组，每个字符都由某个标准编码来表达，因此，文本数据比二进制数据具有更强的平台独立性</p><h3 id="2-1-5-表达代码"><a href="#2-1-5-表达代码" class="headerlink" title="2.1.5 表达代码"></a>2.1.5 表达代码</h3><p>不同机器类型使用不同的且不兼容的指令和编码方式，即使是完全一样的进程，运行中不同操作系统上也有不同的编码规则，因此二进制代码是不兼容的。</p><h3 id="2-1-6-布尔代数"><a href="#2-1-6-布尔代数" class="headerlink" title="2.1.6 布尔代数"></a>2.1.6 布尔代数</h3><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998567614189.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998567614189.png?x-oss-process=style/stylename</a>)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998568366125.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998568366125.png?x-oss-process=style/stylename</a>)</p><blockquote><p>布尔代数符合分配率<br>a&amp;(b|c) &#x3D; (a&amp;b)|(a&amp;c)<br>a|(b&amp;c) &#x3D; (a|b)&amp;(a|c)</p></blockquote><blockquote><p>布尔环<br>加分逆元(x+(-x) &#x3D; 0)<br>a^a &#x3D; 0<br>(a^b)^a &#x3D; b</p></blockquote><h3 id="2-1-7-位级运算"><a href="#2-1-7-位级运算" class="headerlink" title="2.1.7 位级运算"></a>2.1.7 位级运算</h3><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998569179935.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998569179935.png?x-oss-process=style/stylename</a>)</p><h4 id="掩码运算"><a href="#掩码运算" class="headerlink" title="掩码运算"></a>掩码运算</h4><p>掩码是一个位模式，表示一个字中选出的位的集合</p><blockquote><p>例子</p></blockquote><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998575552748.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998575552748.png?x-oss-process=style/stylename</a>)</p><h3 id="2-1-8-逻辑运算"><a href="#2-1-8-逻辑运算" class="headerlink" title="2.1.8 逻辑运算"></a>2.1.8 逻辑运算</h3><p>||、&amp;&amp;和！分别代表媒体逻辑中的OR、AND和NOT运算</p><h3 id="2-1-9移位运算"><a href="#2-1-9移位运算" class="headerlink" title="2.1.9移位运算"></a>2.1.9移位运算</h3><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998578307265.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998578307265.png?x-oss-process=style/stylename</a>)</p><ul><li>唯一例外是算术右移[10010101]的情况。<strong>因为操作数的最高位数1，填充的值就是1.</strong><blockquote><p>一般为算术右移<br>对于无符号数，右移必须是逻辑的<br>x&gt;&gt;j&gt;&gt;k等价于(x&lt;&lt;j)&lt;&lt;k<br>操作符的优先级中，加号的优先级比操作符的高</p></blockquote></li></ul><h2 id="2-2-整数表示"><a href="#2-2-整数表示" class="headerlink" title="2.2 整数表示"></a>2.2 整数表示</h2><p>编码整数的两种不同的方法：</p><ul><li>只能表示非负数</li><li>能够表示负数，0，正数</li></ul><blockquote><p>下文用到的数学术语</p></blockquote><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998582975352.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998582975352.png?x-oss-process=style/stylename</a>)</p><h3 id="2-2-1-整型数据类型"><a href="#2-2-1-整型数据类型" class="headerlink" title="2.2.1 整型数据类型"></a>2.2.1 整型数据类型</h3><h4 id="数据类型的典型取值范围"><a href="#数据类型的典型取值范围" class="headerlink" title="数据类型的典型取值范围"></a>数据类型的典型取值范围</h4><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998586485045.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998586485045.png?x-oss-process=style/stylename</a>)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998586665394.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998586665394.png?x-oss-process=style/stylename</a>)</p><blockquote><p>取值范围是不对称的——负数的范围比整数的范围大1</p></blockquote><blockquote><p>下表是C语言标准定义的每种数据类型必须能够表示的最小的取值范围。</p></blockquote><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998588029453.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998588029453.png?x-oss-process=style/stylename</a>)</p><h3 id="无符号的编码"><a href="#无符号的编码" class="headerlink" title="无符号的编码"></a>无符号的编码</h3><p>将位向量看作二进制表示的数，将获得了位向量的无符号表达</p><h4 id="无符号数编码的定义"><a href="#无符号数编码的定义" class="headerlink" title="无符号数编码的定义"></a>无符号数编码的定义</h4><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998590944911.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998590944911.png?x-oss-process=style/stylename</a>)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998591542514.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998591542514.png?x-oss-process=style/stylename</a>)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998592255921.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998592255921.png?x-oss-process=style/stylename</a>)</p><blockquote><p>B2Uw是一个双射，函数Ｂ2Uw将每个长度为w的位向量都映射位0～2^w - 1之间的一个唯一值；反过来,U2Bw在0～2^w - 1之间的每一个整数都可以映射为一个唯一的长度为w的位模式。</p></blockquote><h3 id="2-2-3-补码编码"><a href="#2-2-3-补码编码" class="headerlink" title="2.2.3 补码编码"></a>2.2.3 补码编码</h3><h4 id="补码编码的定义"><a href="#补码编码的定义" class="headerlink" title="补码编码的定义"></a>补码编码的定义</h4><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998595311062.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998595311062.png?x-oss-process=style/stylename</a>)<br>字的最高有效位解释为负权，也叫做符号位。</p><blockquote><p>符号位为1时值为负<br>符号位为0时值为非负</p></blockquote><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998597654820.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998597654820.png?x-oss-process=style/stylename</a>)</p><blockquote><p>B2Tw也是双射</p></blockquote><h4 id="可表示的整数的范围"><a href="#可表示的整数的范围" class="headerlink" title="可表示的整数的范围"></a>可表示的整数的范围</h4><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998599315139.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998599315139.png?x-oss-process=style/stylename</a>)</p><ul><li>补码范围不对称：｜TMin｜ &#x3D; |TMax| + 1<br>之所以不对称是因为一半的位模式表示负数，而另一半表示为非负数，因为0是非负数所以比负数多1</li><li>最大的无符号值刚好比补码的最大值的两倍大一点：UMaxw &#x3D; 2Tmxw + 1.<blockquote><p>c语言标准并没有要求用补码形式来表示用符号整数，但是几乎所有的机器都是这么做的。</p></blockquote></li></ul><blockquote><p>为来使代码具有最大可移植性，能够做所有可能的机器上运行，我们不应该假设任何可表示的数值类型，也不应该假设也符号数会使用何种特殊的表达方式。<br>许多程序的书写都是用补码来表示用符号数，并且具有图2-9和图2-10所示的典型的取值范围，这些程序能够值大量机器上移植</p></blockquote><p>staint.h中定义了一组数据类型：intN_t和uintN_t（对不同N值指定N位用符号和无符号整数）</p><blockquote><p>N：8、16、32和64</p></blockquote><p>这些数据类型对应着一组宏，定义了每个N对值对应对最小和最大值：INTN_MIN、INTN_MAX和UINTN_MAX</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998607174352.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998607174352.png?x-oss-process=style/stylename</a>)</p><h4 id="有符号的其他表示方法-反码和原码"><a href="#有符号的其他表示方法-反码和原码" class="headerlink" title="有符号的其他表示方法(反码和原码)"></a>有符号的其他表示方法(反码和原码)</h4><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998607836002.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998607836002.png?x-oss-process=style/stylename</a>)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998608162844.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998608162844.png?x-oss-process=style/stylename</a>)</p><p>![图2-15](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998608493945.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998608493945.png?x-oss-process=style/stylename</a>)</p><h3 id="2-2-4-有符号数和无符号数之间的转换"><a href="#2-2-4-有符号数和无符号数之间的转换" class="headerlink" title="2.2.4 有符号数和无符号数之间的转换"></a>2.2.4 有符号数和无符号数之间的转换</h3><p>从位级角度思考<br>转换<strong>数值变但是位模式不变</strong></p><h4 id="补码转换为无符号数"><a href="#补码转换为无符号数" class="headerlink" title="补码转换为无符号数"></a>补码转换为无符号数</h4><ul><li>原理<br>![公式2.5](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998611816561.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998611816561.png?x-oss-process=style/stylename</a>)</li><li>推导<br>![公式2.6](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998612864476.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998612864476.png?x-oss-process=style/stylename</a>)</li></ul><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998613857100.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998613857100.png?x-oss-process=style/stylename</a>)</p><h4 id="无符号数转换为补码"><a href="#无符号数转换为补码" class="headerlink" title="无符号数转换为补码"></a>无符号数转换为补码</h4><ul><li>原理</li></ul><p>![公式2.7](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998613713711.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998613713711.png?x-oss-process=style/stylename</a>)</p><ul><li>推导</li></ul><p>![公式2.8](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999191653704.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999191653704.png?x-oss-process=style/stylename</a>)</p><p>![图2-17](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999191775362.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999191775362.png?x-oss-process=style/stylename</a>)</p><h3 id="2-2-5-C语言中有符号数与无符号数"><a href="#2-2-5-C语言中有符号数与无符号数" class="headerlink" title="2.2.5 Ｃ语言中有符号数与无符号数"></a>2.2.5 Ｃ语言中有符号数与无符号数</h3><p><strong>默认补码，要创建无符号常数，后缀加u&#x2F;U</strong><br>Ｃ语言运算中，如果一个运算数是有符号而另一个是无符号，Ｃ语言就会隐式将<strong>有符号</strong>强制转换为<strong>无符号数</strong>，并假设两个数都是非负的</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/">http://mwebpng.oss-cn-beijing.aliyuncs.com</a><u></u>&#x2F;2023&#x2F;12&#x2F;15&#x2F;16999196070225.png?x-oss-process&#x3D;style&#x2F;stylename)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999196160028.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999196160028.png?x-oss-process=style/stylename</a>)</p><h3 id="2-2-6-扩展一个数的位表示"><a href="#2-2-6-扩展一个数的位表示" class="headerlink" title="2.2.6 扩展一个数的位表示"></a>2.2.6 扩展一个数的位表示</h3><h4 id="从较小类型转换到一个较大的类型-零扩展"><a href="#从较小类型转换到一个较大的类型-零扩展" class="headerlink" title="从较小类型转换到一个较大的类型(零扩展)"></a>从较小类型转换到一个较大的类型(零扩展)</h4><p>将无符号转换为另一个更大的数据类型</p><ul><li>零扩展：在表示的开头添加0</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读一本好书 </category>
          
          <category> 深入了解计算机原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读一本好书 </tag>
            
            <tag> 深入了解计算机原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tree递归</title>
      <link href="/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/"/>
      <url>/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>@<a href="%E9%97%AE%E9%A2%98">TOC</a><br>#Tree ADT<br><img src="/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/tree.jpg" alt="tree" title="tree"></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree</span>(<span class="params">label, branches=[]</span>):</span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches:</span><br><span class="line">        <span class="keyword">assert</span> is_tree(branch),<span class="string">&#x27;branches must be a tree&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> [label] + <span class="built_in">list</span>(branches)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">label</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">branches</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_tree</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(tree) != <span class="built_in">list</span> <span class="keyword">or</span> <span class="built_in">len</span>(tree) &lt;<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(tree):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_tree(branch):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_leaf</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> branches(tree)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>tree函数用于构造，label函数和branches函数用于选择，is_leaf和is_tree函数用于辅助</p></blockquote><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="fib-tree"><a href="#fib-tree" class="headerlink" title="fib_tree"></a>fib_tree</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib_tree</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left, right = fbi_tree(n-<span class="number">1</span>), fbi_tree(n-<span class="number">2</span>)</span><br><span class="line">        fib_n = label(left)+label(right)</span><br><span class="line">        <span class="keyword">return</span> tree(fib_n,left+right)</span><br></pre></td></tr></table></figure><blockquote><p>可见，基本情况是n &#x3D;&#x3D; 0 or n &#x3D;&#x3D;1<br>树递归的思想是从上到下，一旦到达基本情况变返回递归结果<br>这段函数从树顶端递归到0 or 1的情况，然后根据0和1的结果，逐层向上计算树节点的值</p></blockquote><h2 id="count-leaf"><a href="#count-leaf" class="headerlink" title="count_leaf"></a>count_leaf</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_leaves</span>(<span class="params">tree</span>):</span><br><span class="line">      <span class="keyword">if</span> is_leaf(tree):</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          branch_counts = [count_leaves(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(tree)]</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">sum</span>(branch_counts)</span><br></pre></td></tr></table></figure><blockquote><p>不断递归检查树枝是否为叶子，一旦是，便返回1并存储在数列中。最后用sum求树叶数</p></blockquote><h2 id="leaves"><a href="#leaves" class="headerlink" title="leaves"></a>leaves</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leaves</span>(<span class="params">tree</span>):</span><br><span class="line"><span class="keyword">if</span> is_leaf(tree):</span><br><span class="line"><span class="keyword">return</span> [label(tree)]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sum</span>([leaves(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(tree)],[])</span><br></pre></td></tr></table></figure><blockquote><p>分离树叶，不断递归检查树枝是否为树叶，若是，以数列形式存储在[ ]中，最后用sum消去一层[ ]<br>#为什么要用sum(<list>, [])？<br>因为当该分支只存在树叶时，leavers(b) for b in branches(tree)是以数列形式出现的，而若该分支同时存在树叶和树枝时，则返回单单数字(int).</list></p></blockquote><h2 id="increment-leaf"><a href="#increment-leaf" class="headerlink" title="increment_leaf:"></a>increment_leaf:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">increment_leaf</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> tree(label(t)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[increment_leaves(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br><span class="line"><span class="comment">#OR</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">increment</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">return</span> tree(label(t)+<span class="number">1</span>,[increment(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上面的increment只增加leaf<br>下面的increment增加所有节点</p></blockquote><h2 id="print-tree"><a href="#print-tree" class="headerlink" title="print_tree"></a>print_tree</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_tree</span>(<span class="params">t,indent = <span class="number">0</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>*indent + <span class="built_in">str</span>(label(t)))</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> branches(t):</span><br><span class="line">        print_tree(b, indent+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="print-path"><a href="#print-path" class="headerlink" title="print_path"></a>print_path</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_sums</span>(<span class="params">t, so_far</span>):</span><br><span class="line">    so_far = so_far + label(t)</span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="built_in">print</span>(so_far)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> branches(t):</span><br><span class="line">            print_sums(b, so_far)</span><br></pre></td></tr></table></figure><h2 id="count-paths"><a href="#count-paths" class="headerlink" title="count_paths"></a>count_paths</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_paths</span>(<span class="params">t, total</span>):</span><br><span class="line">    <span class="keyword">if</span> label(t) == total:</span><br><span class="line">        found = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        found = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> found + <span class="built_in">sum</span>([count_paths(b,total-label(t)) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br></pre></td></tr></table></figure><blockquote><p>重点在于返回的count_paths(b,total-label(t)中的<code>total-label(t)</code><br>在递归过程中，total-label(t)不断更新到达下一分支时，满足条件的值。</p></blockquote><p><img src="/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/cp.png" alt="输出结果"></p><p><img src="/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/count_paths.png" alt="图示"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="berry-finder"><a href="#berry-finder" class="headerlink" title="berry_finder"></a>berry_finder</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">berry_finder</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns True if t contains a node with the value &#x27;berry&#x27; and </span></span><br><span class="line"><span class="string">    False otherwise.</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = tree(1, [tree(&#x27;berry&#x27;,[tree(&#x27;not berry&#x27;)])])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; berry_finder(t)</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;*** YOUR CODE HERE ***&quot;</span></span><br><span class="line">    <span class="keyword">if</span> label(t) == <span class="string">&#x27;berry&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t):</span><br><span class="line">        <span class="keyword">if</span> berry_finder(branch):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="replace-loki-at-leaf"><a href="#replace-loki-at-leaf" class="headerlink" title="replace_loki_at_leaf"></a>replace_loki_at_leaf</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">replace_loki_at_leaf</span>(<span class="params">t, lokis_replacement</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns a new tree where every leaf value equal to &quot;loki&quot; has</span></span><br><span class="line"><span class="string">    been replaced with lokis_replacement.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> label(t) == <span class="string">&#x27;loki&#x27;</span><span class="keyword">and</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> tree(lokis_replacement, [replace_loki_at_leaf(branch,lokis_replacement) <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t)])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[replace_loki_at_leaf(branch,lokis_replacement) <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Height"><a href="#Height" class="headerlink" title="Height"></a>Height</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Q5: Height</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the height of a tree.</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = tree(3, [tree(5, [tree(1)]), tree(2)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; height(t)</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;*** YOUR CODE HERE ***&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>([height(branch) <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t)])</span><br></pre></td></tr></table></figure><h2 id="find-path"><a href="#find-path" class="headerlink" title="find_path"></a>find_path</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_path</span>(<span class="params">t, x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = tree(2, [tree(7, [tree(3), tree(6, [tree(5), tree(11)])] ), tree(15)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; find_path(t, 5)</span></span><br><span class="line"><span class="string">    [2, 7, 6, 5]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; find_path(t, 10)  # returns None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> label(t) == x:</span><br><span class="line">        <span class="keyword">return</span> [label(t)]</span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t):</span><br><span class="line">        path = find_path(branch, x)</span><br><span class="line">        <span class="keyword">if</span> path:</span><br><span class="line">            <span class="keyword">return</span> [label(t)] + path</span><br></pre></td></tr></table></figure><h2 id="sprout-leaves"><a href="#sprout-leaves" class="headerlink" title="sprout_leaves"></a>sprout_leaves</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sprout_leaves</span>(<span class="params">t, leaves</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Sprout new leaves containing the data in leaves at each leaf in</span></span><br><span class="line"><span class="string">    the original tree t and return the resulting tree.</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t1 = tree(1, [tree(2), tree(3)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(t1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">      3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; new1 = sprout_leaves(t1, [4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(new1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">      3</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[tree(leaf) <span class="keyword">for</span> leaf <span class="keyword">in</span> leaves])</span><br><span class="line">    <span class="keyword">return</span> tree(label(t),[sprout_leaves(branch,leaves) <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们可以发现，完成这些例子和练习的核心思想有：</p><ol><li>重构tree，且将branches部分用递归方法不断更新为我们需要的树枝。</li><li>利用 for语句和branches选择函数对函数进行递归。</li><li>而递归的关键就在于我们对基本情况的定义和对tree ADT的理解应用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CS61A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/"/>
      <url>/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>笔记来源网课教程：<a href="https://www.bilibili.com/video/BV1oD4y1h7S3">C++教程</a><br>10月·8号发布</p><p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><h1 id="C-是怎么工作的"><a href="#C-是怎么工作的" class="headerlink" title="C++是怎么工作的"></a>C++是怎么工作的</h1><p>项目中的源文件传输给编译器，编译器将其转化成二进制的东西，可能转化成某种库，也可能是可执行的程序<br>opp编译成obj文件，然后通过linker将obj整合起来</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>编译前处理include后面的文件，该文件通常叫做“头文件”，我们之所以要包括iostream这个头文件，是因为我们需要一个被调用的函数的声明，例如<code>std::cout</code></p><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>程序的入口，它不一定需要返回值，默认返回0</p><h2 id><a href="#" class="headerlink" title="&lt;&lt;重载语句"></a>&lt;&lt;重载语句</h2><p>相当于一个函数而已，相当于print()<br><code>std::cout &lt;&lt; &quot;Hello World&quot;&lt;&lt; std::endl;</code><br>相当于<br><code>std::cout .print( &quot;Hello World&quot;).pint(std::endl); </code></p><h2 id="链接项目中的函数代码"><a href="#链接项目中的函数代码" class="headerlink" title="链接项目中的函数代码"></a>链接项目中的函数代码</h2><p><strong>Log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; </span><br><span class="line"><span class="comment">// 声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过linker将main.cpp中声明并使用的函数链接到某个项目文件中唯一的log函数中</p></blockquote><blockquote><p>声明只包含了函数，定义包含了函数和函数体</p></blockquote><h1 id="C-编译器的工作"><a href="#C-编译器的工作" class="headerlink" title="C++编译器的工作"></a>C++编译器的工作</h1><p>首先预处理,将所有代码转化成常量数据或指令。<br>将我们项目所有的cpp生成opj文件<br>cpp叫做<strong>翻译单元</strong></p><h2 id="include工作原理"><a href="#include工作原理" class="headerlink" title="#include工作原理"></a>#include工作原理</h2><p>在编译前将指定的文件粘贴并复制到当前cpp当中</p><p><strong>EndBrace.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; </span><br><span class="line"><span class="comment">// 声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&#x27;EndBrace.h&#x27;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>编译器的工作就是，将EndBrace中的所有代码copy进去当前cpp</p></blockquote><h2 id="查看预处理器实际上生成的文件"><a href="#查看预处理器实际上生成的文件" class="headerlink" title="查看预处理器实际上生成的文件"></a>查看预处理器实际上生成的文件</h2><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E9%A2%84%E5%A4%84%E7%90%86.png" alt="预处理器文件"><br>编译后会生成一个.i文件<br>里面含有预处理后的结果</p><h2 id="查看obj文件"><a href="#查看obj文件" class="headerlink" title="查看obj文件"></a>查看obj文件</h2><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E7%A8%8B%E5%BA%8F%E9%9B%86.png" alt="程序集"></p><p>将obj中的二进制文件转化为汇编代码(ASM文件) </p><blockquote><p>若在优化将速度调最大会忽略掉一些无用的操作</p></blockquote><h1 id="C-链接"><a href="#C-链接" class="headerlink" title="C++链接"></a>C++链接</h1><p>编译后的操作，链接的焦点是找到每个符号和函数在哪里然后连接在一起。<br><strong>编译可能不需要main函数，但是链接过程一定需要main函数</strong></p><blockquote><p>编译错误 错误类型是C开头，链接错误是LIN开头</p></blockquote><blockquote><p>不能存在两个相同的函数带着相同的参数，这样链接器不知道链接哪一个，从而产生错误。</p></blockquote><h2 id="易错处"><a href="#易错处" class="headerlink" title="易错处"></a>易错处</h2><p><strong>Log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 注意log函数名字已经被修改了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; </span><br><span class="line"><span class="comment">//声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//log(&quot;multiply&quot;);</span></span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">Multiply</span>(<span class="number">5</span>, <span class="number">8</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链接没有错误</p></blockquote><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; </span><br><span class="line"><span class="comment">//声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;multiply&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; Multiply(5, 8) &lt;&lt; std::endl;</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链接错误</p></blockquote><p><strong>为什么？</strong><br>虽然在这个文件中可能用不上Multiply函数，但在其他文件可能用得上，所以链接器确实需要链接它</p><h3 id="限制链接，函数只在当前翻译单元使用的方法"><a href="#限制链接，函数只在当前翻译单元使用的方法" class="headerlink" title="限制链接，函数只在当前翻译单元使用的方法"></a>限制链接，函数只在当前翻译单元使用的方法</h3><p>用<code>static</code>加在函数前</p><h2 id="产生链接错误的例子及修正"><a href="#产生链接错误的例子及修正" class="headerlink" title="产生链接错误的例子及修正"></a>产生链接错误的例子及修正</h2><h3 id="错误例子"><a href="#错误例子" class="headerlink" title="错误例子"></a>错误例子</h3><p><strong>log.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initlog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;Initialized log&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;multiply&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; Multiply(5, 8) &lt;&lt; std::endl;</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链接失败，log重复了</p></blockquote><p><strong>原因分析：</strong><br>两个头文件同时引入了两个log函数所以产生错误.</p><h3 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h3><ol><li><strong>log.h</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将log函数修改为静态函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>log.h</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>inlind的作用是获得我们实际的函数体并将函数调用替换为函数体。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>(<span class="string">&quot;Initialized log&quot;</span>);</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Initialized log&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><ol start="3"><li>将定义移到一个翻译单元</li></ol><p><strong>log.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initlog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;Initialized log&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-变量"><a href="#C-变量" class="headerlink" title="C++变量"></a>C++变量</h1><p>变量允许我们命名存储在内存中的数据并继续使用<br>当我们创造变量时，他被存储在内存中。</p><h2 id="不同变量类型的区别是内存大小"><a href="#不同变量类型的区别是内存大小" class="headerlink" title="不同变量类型的区别是内存大小"></a>不同变量类型的区别是内存大小</h2><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul><li>char : 1 byte (经常存储字符)</li><li>short : 2 byte</li><li>int : 4 byte</li><li>long : 4 byte</li><li>long long : 8 byte</li><li>float : 4 byte</li><li>double : 8 byte</li><li>bool : 1 byte<blockquote><p>float和double的区别可以是在数字后面加f(float)<br>1 是 Ture,0 是 False.</p></blockquote></li></ul><h3 id="查看数字大小"><a href="#查看数字大小" class="headerlink" title="查看数字大小"></a>查看数字大小</h3><p>sizeof(bool)</p><h1 id="C-函数"><a href="#C-函数" class="headerlink" title="C++函数"></a>C++函数</h1><p>最主要的是提高维护效率<br>避免复制重复<br>我们通常在头文件中写声明，在翻译单元或cpp文件中编写定义，原因就是<strong>链接错误中的修改方法3</strong></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io_mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">multiply</span>(a, b);</span><br><span class="line">std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">io_mul</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">io_mul</span>(<span class="number">3</span>,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">io_mul</span>(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>io_mul的作用就是避免重复</p></blockquote><h1 id="C-头文件"><a href="#C-头文件" class="headerlink" title="C++头文件"></a>C++头文件</h1><p> 当我们跨文件调用函数的时候免不了声明，如果某个函数很常用那就要一直复制粘贴，很繁琐。<br> 而头文件就是塞入一堆声明，然后在其他cpp中include后，让预处理器帮忙复制粘贴。</p><h2 id="pragma-once"><a href="#pragma-once" class="headerlink" title="pragma once"></a>pragma once</h2><p>当我们创建了一个头文件，vs会自动帮我们填写<code>#pragma once</code><br>这个的作用是防止include多个头文件时，里面有重复的声明，导致编译失败。他只会复制一次声明</p><h2 id="ifndef"><a href="#ifndef" class="headerlink" title="ifndef"></a>ifndef</h2><p><strong>log.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nitLog</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>检查是否有个_LOG_H被定义了，如果没有就编译中包括以下代码,如果被定义了，那么这些都不会被包括进来 </p></blockquote><blockquote><p>如果通过了这初次检查，我们定义_LOG_H,如果下次用到的时候，就不会重复声明了</p></blockquote><h2 id="include两个不同形式"><a href="#include两个不同形式" class="headerlink" title="include两个不同形式"></a>include两个不同形式</h2><h3 id="形式"><a href="#形式" class="headerlink" title="&lt; &gt;形式"></a>&lt; &gt;形式</h3><p>告诉编译器去搜索包含路径的文件夹 </p><h3 id="“-“形式"><a href="#“-“形式" class="headerlink" title="“ “形式"></a>“ “形式</h3><p>告诉编译器就在当前文件夹，我们也可以用”..&#x2F;log.h”去返回到当前文件的上级目录</p><h2 id="区别c-标准库和c标准库"><a href="#区别c-标准库和c标准库" class="headerlink" title="区别c++标准库和c标准库"></a>区别c++标准库和c标准库</h2><p>关键在于有无.h扩展，c++文件通常没有。</p><h1 id="如何在vs中调试代码"><a href="#如何在vs中调试代码" class="headerlink" title="如何在vs中调试代码"></a>如何在vs中调试代码</h1><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>在断点处暂停程序</p><h3 id="读取内存"><a href="#读取内存" class="headerlink" title="读取内存"></a>读取内存</h3><p>程序中断后,内存数据实际上还在,查看内存对诊断问题.</p><h2 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h2><ol start="0"><li>确保模式是<strong>debug模式</strong></li><li><strong>设置断点</strong></li><li><strong>读内存</strong></li></ol><h3 id="按键介绍"><a href="#按键介绍" class="headerlink" title="按键介绍"></a>按键介绍</h3><ul><li>逐语句(F11)(step into):进入到当前这行代码上的函数里面</li><li>逐过程(F10)(step over):从当前函数跳到下一行代码</li><li>跳出(shift+F11)(step out):跳出当前函数，回到调用这个函数的位置</li></ul><h3 id="窗口介绍"><a href="#窗口介绍" class="headerlink" title="窗口介绍"></a>窗口介绍</h3><ul><li>自动、局部窗口 : 向你展示可能重要的全局或局部</li><li>监视1：观察变量(输入要观察的变量然后回车)</li></ul><blockquote><p>右键可以修改成查看16进制</p></blockquote><h3 id="内存视图"><a href="#内存视图" class="headerlink" title="内存视图"></a>内存视图</h3><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE.png" alt="内存视图"><br><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE_1.png" alt="内存视图浏览"></p><ul><li>最左侧为内存地址</li><li>中间是以16进制存储的实际值</li><li>最右边是以ACCII对值的解释</li></ul><h4 id="内存视图的使用"><a href="#内存视图的使用" class="headerlink" title="内存视图的使用"></a>内存视图的使用</h4><p>在地址一栏输入&amp;＋变量名即可</p><h1 id="VS的最佳设置"><a href="#VS的最佳设置" class="headerlink" title="VS的最佳设置"></a>VS的最佳设置</h1><h2 id="项目的设置"><a href="#项目的设置" class="headerlink" title="项目的设置"></a>项目的设置</h2><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E8%99%9A%E6%8B%9F%E7%BB%84%E7%BB%87.ong" alt="虚拟组织"></p><blockquote><p>这只是虚拟组织的文件夹，在文件资源管理器中并不存在。</p></blockquote><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E6%98%BE%E7%A4%BA%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt="显示所有文件"><br>我们可以点击<strong>显示所有文件</strong>这个按钮，这样子新添加文件夹的时候就实际的添加了文件夹，而非虚拟文件夹。</p><h2 id="文件夹的设置"><a href="#文件夹的设置" class="headerlink" title="文件夹的设置"></a>文件夹的设置</h2><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E8%AE%BE%E7%BD%AE.png" alt="设置"><br><code>$(SolutionDir)bin\$(Platform)\$(Configuration)\</code></p><h1 id="C-条件与分值-if语句"><a href="#C-条件与分值-if语句" class="headerlink" title="C++条件与分值(if语句)"></a>C++条件与分值(if语句)</h1><p> 检查条件，然后跳转到内存的不同的地方,并从这里开始执行指令。</p><h2 id="内在指令"><a href="#内在指令" class="headerlink" title="内在指令"></a>内在指令</h2><p> <img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E5%8F%8D%E6%B1%87%E7%BC%96.png" alt="反汇编"></p><blockquote><p>设置断点调试时，右键进入反汇编模式</p></blockquote><ul><li>mov : move</li><li>jne ：jump not equal</li><li>je ：jump equel</li></ul><blockquote><ol><li><p><code>mov dword ptr [a], 5</code>：这条指令将立即数5移动到名为<code>a</code>的整数变量。它将5存储到<code>a</code>的内存位置。</p></li><li><p><code>cmp dword ptr [a], 5</code>：这是一个比较指令，用于比较<code>a</code>的值与5的值。它将<code>a</code>的值与5进行比较，但不会更改任何寄存器的值。</p></li><li><p><code>jne main+34h (07FF6F0B823B4h)</code>：这是一个条件跳转指令。它检查前面的比较结果是否不等于（jne表示”jump if not<br>equal”）零，如果不等于零，则跳转到指定的地址，这里是<code>main+34h</code>。</p></li><li><p><code>mov dword ptr [rbp+0F4h], 1</code>：如果比较结果是相等的（即<code>a</code>等于5），则将立即数1移动到内存中的某个位置，该位置可能是一个标志变量，用于表示条件满足。</p></li><li><p><code>jmp main+3Eh (07FF6F0B823BEh)</code>：这是一个无条件跳转指令，它将程序跳转到指定的地址，这里是<code>main+3Eh</code>。</p></li><li><p><code>mov dword ptr [rbp+0F4h], 0</code>：这个指令是前面条件跳转的目标（如果比较结果不等于零），它将立即数0移动到内存中的某个位置，表示条件不满足。</p></li><li><p><code>movzx eax, byte ptr [rbp+0F4h]</code>：这条指令将内存中的一个字节（8位）加载到32位寄存器<code>eax</code>中，并将其零扩展（即高位填充0）。这可能是为了将条件满足与否的标志位加载到寄存器中。</p></li><li><p><code>mov byte ptr [comparisonResult], al</code>：这个指令将寄存器<code>al</code>中的字节值写入名为<code>comparisonResult</code>的布尔变量。这是将条件判断的结果保存到布尔变量中的操作。</p></li><li><p><code>movzx eax, byte ptr [comparisonResult]</code>：这是将布尔变量<code>comparisonResult</code>的值加载到寄存器<code>eax</code>中，以便进行进一步的条件判断。</p></li><li><p><code>test eax, eax</code>：这个指令将寄存器<code>eax</code>与自身进行按位与操作。它的目的是检查<code>eax</code>中的值是否为零。</p></li><li><p><code>je main+5Ch (07FF6F0B823DCh)</code>：这是一个条件跳转指令，如果前面的按位与操作结果等于零（即<code>eax</code>中的值为零），则跳转到指定的地址，这里是<code>main+5Ch</code>。</p></li><li><p><code>lea rcx, [string &quot;hello&quot; (07FF6F0B8BCA4h)]</code>：这个指令将字符串”hello”的地址加载到寄存器<code>rcx</code>中，准备调用一个名为<code>Log</code>的函数。</p></li><li><p><code>call Log (07FF6F0B8135Ch)</code>：这是一个函数调用指令，它调用名为<code>Log</code>的函数，并将<code>rcx</code>中的地址作为参数传递给该函数，用于记录”hello”。</p></li></ol></blockquote><h1 id="C-循环"><a href="#C-循环" class="headerlink" title="C++循环"></a>C++循环</h1><p>for and while 循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; a &lt; <span class="number">5</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line">pass</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>变量的声明,循环的条件(评估后的bool值),一次循环后的操作</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">.....</span><br><span class="line">i ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h1 id="C-控制流语句"><a href="#C-控制流语句" class="headerlink" title="C++控制流语句"></a>C++控制流语句</h1><p>控制流一般和循环一起使用</p><ul><li>continue :只能在循环使用</li><li>break : 能在循环和switch语句使用</li><li>return</li></ul><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>跳到循环的下一个迭代</p><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>跳出循环</p><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>返回值，终止语句</p><h1 id="C-指针"><a href="#C-指针" class="headerlink" title="C++指针"></a>C++指针</h1><p>指针是整数，一种存储内存地址的数字。对管理和操纵内存有很大用处.</p><h2 id="指针的引用和逆引用"><a href="#指针的引用和逆引用" class="headerlink" title="指针的引用和逆引用"></a>指针的引用和逆引用</h2><p>类型的意义在于逆引用指针时可以访问和修改变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;var;</span><br><span class="line">*ptr = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="申请内存和二次指针"><a href="#申请内存和二次指针" class="headerlink" title="申请内存和二次指针"></a>申请内存和二次指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>** ptr = &amp;buffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>pte地址的内存实际上是buffer的内存地址，只不过反了过来<br>比如如果pte的内存是b8 f1 02 00<br>那么buffer的内存地址就是00 02 f1 b8</p></blockquote><h1 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h1><p>(指针的扩展)<br>引用不用占用内存，但是指针是变量，会占用内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;</span><br><span class="line"><span class="comment">//ref 实际上不存在，编译后只会有变量a</span></span><br><span class="line"><span class="comment">//相当于a的别名</span></span><br><span class="line"> </span><br><span class="line"> std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用的作用"><a href="#引用的作用" class="headerlink" title="引用的作用"></a>引用的作用</h2><blockquote><p>运用指针的例子</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increment</span><span class="params">(<span class="type">int</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">(*value)++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">Increment</span>(&amp;a)；</span><br><span class="line"><span class="built_in">Log</span>(a);</span><br><span class="line"><span class="comment">//结果为 : 6</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运用引用的例子</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increment</span><span class="params">(<span class="type">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">Increment</span>(a);</span><br><span class="line"><span class="built_in">Log</span>(a);</span><br><span class="line"><span class="comment">//结果为 : 6</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在C++中，函数参数的默认传递方式是按值传递(pass by value)。这意味着当你调用一个函数时，传递给函数的是原始数据的副本，而不是原始数据本身。这是因为按值传递会创建原始数据的副本，以便函数可以在副本上执行操作，而不会影响原始数据。<br> 当你调用Increment(a)时，a的值被复制到Increment函数的局部变量value中，然后在函数内部对value进行递增操作。这个递增操作只会影响value的副本，而不会影响a的原始值。这就是为什么在main函数中a 的值仍然是5。</p></blockquote><p>那如果我用return a呢？</p><blockquote><p>如果你在 Increment 函数中返回 value，那么你需要在 main 函数中捕获这个返回值并将其分配给 a，才能使 a 的值增加。这是因为在 C++ 中，函数的返回值不会自动修改传递给它的参数。<br>a &#x3D; increment(a)</p></blockquote><p>简而言之，引用可以节约内存开销,避免重复复制。</p><h2 id="引用的注意"><a href="#引用的注意" class="headerlink" title="引用的注意"></a>引用的注意</h2><p>你不能改变它引用的东西<br>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;</span><br><span class="line">ref = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>* ref = &amp;a;</span><br><span class="line">*ref = <span class="number">2</span>;</span><br><span class="line">ref = &amp;b;</span><br><span class="line">*ref = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Log</span>(a);</span><br><span class="line"><span class="built_in">Log</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，错误例子中会运行成功，但是他并不是更改引用,ref这个引用还是引用的a</p></blockquote><h1 id="C-类"><a href="#C-类" class="headerlink" title="C++类"></a>C++类</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> xa, <span class="type">int</span> ya)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x += xa * speed;</span><br><span class="line">y += ya * speed;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void Move(Player&amp; player, int xa, int ya)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//player.x += xa * player.speed;</span></span><br><span class="line"><span class="comment">//player.y += xa * player.speed;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Player player;</span><br><span class="line">player.x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>花括号后面需要有分号<br>由类类型构成的变量称为<strong>对象</strong><br>新的对象变量称为<strong>实例</strong><br>类中的函数称为<strong>方法</strong></p></blockquote><blockquote><p>类中的属性是私有的，如果需要访问修改需要public类中的属性。</p></blockquote><h1 id="C-类与结构体对比"><a href="#C-类与结构体对比" class="headerlink" title="C++类与结构体对比"></a>C++类与结构体对比</h1><p>类默认是私有的，类外部调用时无法调用。<br>技术上说，没什么区别，但是使用情境不同。<br>struct and class</p><blockquote><p>弹幕：用结构体当数据容器，用类来写具备逻辑的功能对象.</p></blockquote><h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2><ol><li>默认的继承访问权 : class默认的是private,strcut默认的是public。</li><li>默认访问权限 : struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。</li><li>“class”这个关键字还用于定义模板参数，就像“typename”。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python—字符串,多态函数（接口），特殊方法名称[61A Fall 2023 Lecture 20——Inheritance]</title>
      <link href="/2023/12/14/Python-Python%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0-61A-Fall-2023-Lecture-20%E2%80%94%E2%80%94Inheritance-Python%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0-61A-Fall-2023-Lecture-20%E2%80%94%E2%80%94Inheritance/"/>
      <url>/2023/12/14/Python-Python%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0-61A-Fall-2023-Lecture-20%E2%80%94%E2%80%94Inheritance-Python%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0-61A-Fall-2023-Lecture-20%E2%80%94%E2%80%94Inheritance/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h1 id="字符串表示形式"><a href="#字符串表示形式" class="headerlink" title="字符串表示形式"></a>字符串表示形式</h1><h2 id="str"><a href="#str" class="headerlink" title="str()"></a>str()</h2><p>方便阅读</p><h2 id="repr"><a href="#repr" class="headerlink" title="repr()"></a>repr()</h2><p>方便调试</p><ul><li>repr 返回对象的官方表示形式</li><li>print 用于打印可读性好的字符串</li><li>str 返回对象的非正式表示</li><li>eval 用于执行字符串表示的代码。</li><li>在字符串示例中，由于字符串中包含引号和全角逗号，因此在 repr 和 str 的输出中会反映这些差异，但 eval 用于执行这些字符串时，它们被正确处理。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half= Fraction(<span class="number">1</span>，<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>halfFraction(<span class="number">1</span>，<span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt;&gt; <span class="built_in">repr</span>(half)</span><br><span class="line"><span class="string">&#x27;Fraction(1，2)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(half)</span><br><span class="line"><span class="number">1</span>/<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(half)</span><br><span class="line"><span class="string">&#x27;1/2&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">repr</span>(half))</span><br><span class="line">Fraction(<span class="number">1</span>，<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">str</span>(half))</span><br><span class="line">05</span><br></pre></td></tr></table></figure><blockquote><p>repr(half) 返回对象的”official”字符串表示形式，它是 Fraction(1，2)，它是有效的Python表达式，可以用于重建相同的对象。<br>print(half) 打印对象时，print 使用对象的 str 方法，所以它输出 ‘1&#x2F;2’，这是用户友好的字符串表示。<br>str(half) 返回对象的”informal”字符串表示形式，这里返回 ‘1&#x2F;2’。<br>eval(repr(half)) 使用 eval 函数来执行 repr(half) 返回的字符串，这将返回一个新的 Fraction 对象，即 Fraction(1，2)。<br>eval(str(half)) 使用 eval 函数来执行 str(half) 返回的字符串，这将返回浮点数 0.5，因为 eval 解释它为数学表达式。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&quot;Hello, World&quot;</span></span><br><span class="line">&gt;&gt;&gt;s</span><br><span class="line"><span class="string">&#x27;Hello，World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">repr</span>(s))</span><br><span class="line"><span class="string">&#x27;Hello，World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s)</span><br><span class="line">Hello，World</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">str</span>(s))</span><br><span class="line">Hello，World</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(s)</span><br><span class="line"><span class="string">&#x27;Hello，World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(s)</span><br><span class="line"><span class="string">&quot;&#x27;Hello,World&#x27;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">repr</span>(s))</span><br><span class="line"><span class="string">&#x27;Hello，World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(<span class="built_in">repr</span>(<span class="built_in">repr</span>(s)))</span><br><span class="line"><span class="string">&#x27;\&#x27;&quot;\\\&#x27;Hello,world\\\&#x27;&quot;\&#x27;&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">eval</span>(<span class="built_in">eval</span>(<span class="built_in">repr</span>(<span class="built_in">repr</span>(<span class="built_in">repr</span>(s)))))))</span><br><span class="line"><span class="string">&#x27;Hello, World&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h1><h2 id="f’-’"><a href="#f’-’" class="headerlink" title="f’{}’"></a>f’{}’</h2><p>花括号里的为Python表达式 会自动计算<br>你也可以用str()或repr()</p><h1 id="多态函数"><a href="#多态函数" class="headerlink" title="多态函数"></a>多态函数</h1><p>使用于许多不同类型数据的函数<br>str和repr函数就是例子</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="repr-1"><a href="#repr-1" class="headerlink" title="repr"></a>repr</h3><p>调用一个零参数方法，相应地称为__repr__</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>half.__repr__()</span><br><span class="line"><span class="string">&#x27;Fraction(1, 2)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="str-1"><a href="#str-1" class="headerlink" title="str"></a>str</h3><p>调用一个零参数方法，相应地称为_str_</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half.__str__()</span><br><span class="line"><span class="string">&#x27;1/2&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用print()时实际上就是调用了__str__()</p></blockquote><h2 id="repr和str的实现"><a href="#repr和str的实现" class="headerlink" title="repr和str的实现"></a>repr和str的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repr</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">type</span>(x).__repr__(x)</span><br></pre></td></tr></table></figure><p>通过查找为你提供的参数类型来设法跳过实例属性或忽略他们</p><blockquote><p>是一个类属性，也是一个函数，但是这个函数不是绑定方法，因为它是在type类中查找的</p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>对象属性是消息传递的一种形式，它允许不同的数据类型以不同的方式响应同一消息。</li></ul><blockquote><p>对象通过发送消息(通常是方法调用)来与其他对象进行交互。对象的属性可以是对象的状态或数据。</p></blockquote><ul><li>从不同类引出类似行为的一组共享消息是一种强大的抽象方法。</li></ul><blockquote><p>不同的类可以实现相同的接口或共享相同的消息。</p></blockquote><ul><li>接口是一组共享属性名称，以及它们的行为规范。在复数的情况下，实现算术所需的接口由四个属性组成： real 、 imag 、 magnitude 和 angle 。<blockquote><p>这是一个具体的示例，说明了接口的用途。如果多个类需要实现某种算术操作（例如复数的加法或乘法），可以定义一个接口，其中包含所需的属性名称和方法，以确保这些类都具有相同的接口，从而可以执行相似的操作。</p></blockquote></li></ul><p>消息传递：对象通过查找彼此的属性（传递消息）进行交互<br>属性查找规则允许不同的数据类型响应相同的消息<br>从不同对象类中引出类似行为的共享消息（属性名）是一种强大的<strong>抽象方法</strong></p><p><strong>实现返回python可解释和人类可读字符串的方法</strong>的<strong>类</strong>实现了用于<strong>生成字符串表示的接口</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ratio</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n , d</span>):</span><br><span class="line">        self.numer = n</span><br><span class="line">        self.denom = d</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Ratio(&#123;0&#125;, &#123;1&#125;)&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;0&#125;/&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half = Ratio(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(half)</span><br><span class="line"><span class="number">1</span>/<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half</span><br><span class="line">Ratio(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p>个人对接口的理解：有一些具有相同行为的类，我们定义了一个接口，使得我们不需要知道传入这些类中的数据类型便知道这些类都有一种可以计算某个结果的方法。这样子不管什么数据类型都可以计算出我们需要的预期结果。[这是抽象接口]</p></blockquote><blockquote><p>Python存在两种接口 一个是面对对象用于继承的抽象接口，一个是用于封装类显露出来的动态接口[下面Ratio类的add方法是一种接口，是动态接口]</p></blockquote><h1 id="特殊方法名称"><a href="#特殊方法名称" class="headerlink" title="特殊方法名称"></a>特殊方法名称</h1><p>总是有__在前面和后面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;zero, one, two = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one + two</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(zero), <span class="built_in">bool</span>(one)</span><br><span class="line">(<span class="literal">False</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt;zero, one, two = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one.__add__(two)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zero.__bool__(), one.__bool__()</span><br><span class="line">(<span class="literal">False</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><blockquote><p>内置语法和内置函数 与 实际执行工作的特殊方法名称中间存在对应关系</p></blockquote><p>这是使用接口来允许用户定义的对象与Python中内置系统进行交互的另一个示例。<br>我们举例类的时候可以覆盖特殊方法来建立我们想要的互动结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ratio</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n , d</span>):</span><br><span class="line">        self.numer = n</span><br><span class="line">        self.denom = d</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Ratio(&#123;0&#125;, &#123;1&#125;)&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;0&#125;/&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, <span class="built_in">int</span>):</span><br><span class="line">            n = self.numer + self.denom * other</span><br><span class="line">            d = self.denom</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(other, Ratio):</span><br><span class="line">            n = self.numer * other.denom + self.denom * other.numer</span><br><span class="line">            d = self.denom * other.denom</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(other, <span class="built_in">float</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">float</span>(self) + other</span><br><span class="line">        g = gcd(n, d)</span><br><span class="line">        <span class="keyword">return</span> Ratio(n//g, d//g)</span><br><span class="line">    __radd__ = __add__</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__float__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.numer/self.denom</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">n, d</span>):</span><br><span class="line">    <span class="keyword">while</span> n != d:</span><br><span class="line">        n, d = <span class="built_in">min</span>(n, d), <span class="built_in">abs</span>(n - d)</span><br><span class="line">    <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure><ul><li>类型分类：用了条件语句对传入的other数据类型进行判断从而提供不同的执行方法</li><li>类型强制：将一种类型的对象转换为另一种类型，以便能够将其与其他值组合。</li></ul><blockquote><p>这是让两个类进行交互时而使用的两种策略</p></blockquote><blockquote><p>__add__函数相当于是一个隐形接口，我们不需要知道传入的数据是不是浮点数、整数还是什么，都可以将他们加起来 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CS61A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是我的第一篇文章</title>
      <link href="/2023/12/14/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F/"/>
      <url>/2023/12/14/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }  /* 小冰分类分类磁铁黑夜模式适配 *//* 一般状态 */[data-theme="dark"] .magnet_link_context {  background: #1e1e1e;  color: antiquewhite;}/* 鼠标悬浮状态 */[data-theme="dark"] .magnet_link_context:hover {  background: #3ecdf1;  color: #f2f2f2;}/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
