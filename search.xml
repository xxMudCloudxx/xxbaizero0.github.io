<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>1.数据结构-数据结构绪论</title>
      <link href="/2024/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/"/>
      <url>/2024/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>数据是所有能被输入计算机中且<strong>能被计算机处理</strong>的符号的集合。它是计算机操作的对象的总称,也是计算机处理的信息的某种特定的符号表示形式(例如,A班学生数据包含了该班全体学生记录)。</p><h2 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h2><p><strong>是数据的基本单位</strong>(例如,A班中的每个学生记录都是一个数据元素),数据元素在计算机中通常作为整体处理,数据元素也称为元素、结点、记录等。有时候，一个数据元素可以由若干个数据项组成。</p><h2 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h2><p>具有独立含义的<strong>数据最小单位</strong>,也称为成员或域(例如,A班中的每个数据元素(即学生记录)是由学号、姓名、性别和班号等数据项组成)。</p><h2 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h2><p><strong>性质相同</strong>的有限个数据元素的集合,它是<strong>数据的一个子集</strong>,例如大写字母数据对象是集合 C&#x3D;{‘A’,’B’,’C’,…，Z’};1~100的整数数据对象是集合 N&#x3D;{1,2,…，100}。在默认情况下,数据结构中的数据都是指数据对象。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>指所涉及的数据元素的集合以及数据元素之间的关系,由数据元素之间的关系构成结构,因此可以把数据结构看成是带结构的数据元素的集合。数据结构包括以下三方面:</p><ul><li><p>数据逻辑结构</p><ul><li>数据逻辑结构由数据元素之间的逻辑关系构成,是数据结构在用户面前呈现的形式。</li><li>数据的逻辑结构是从逻辑关系(主要是指数据元素的相邻关系)上描述数据的,它与数据的存储无关,是独立于计算机的。因此,数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。</li></ul></li><li><p>数据存储结构</p><ul><li>数据存储结构指数据元素及其关系在计算机内存中的存储方式，也称为数据的物理结构。</li><li>数据的存储结构是逻辑结构用计算机语言的实现或在计算机中的表示(也称为映像)，也就是逻辑结构在计算机中的存储方式,它是依赖于计算机语言的。一般在高级语言(例如C&#x2F;C++和Java等语言)的层次上讨论存储结构。</li></ul></li><li><p>数据运算</p><ul><li>数据运算指施加在该数据上的操作。</li><li>数据运算是定义在数据的逻辑结构之上的,每种逻辑结构都有一组相应的运算,最常用的运算有查找、插入、删除、更新和排序等。数据运算最终需在对应的存储结构上用算法实现。</li></ul><p>因此,数据结构是一门讨论“描述现实世界实体的数据模型及其之上的运算在计算机中如何表示和实现”的学科。</p></li></ul><h1 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h1><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>逻辑结构:是指数据对象中数据元素之间的相互关系。</p><h3 id="集合结构"><a href="#集合结构" class="headerlink" title="集合结构"></a>集合结构</h3><p>集合结构:集合结构中的数据元素除了同属于个集合外’它们之间没有具他关系。各个数据元素是 “平等”的,它们的共同属性是“同属于—个集合’’。 数据结构中的集合关系就类似于数学中的集合。如右图 所示。</p><p><img src="/2024/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/image-20240519194704075.png" alt="image-20240519194704075"></p><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><p>线性结构:线性结构中的数据元素之间是一对一的关系。如右图所示。</p><p><img src="/2024/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/image-20240519194732765.png" alt="image-20240519194732765"></p><h3 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h3><p>树形结构:树形结构中的数据元素之间存在 一种一对多的层次关系°如右图所示。</p><p><img src="/2024/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/image-20240519194747586.png" alt="image-20240519194747586"></p><h3 id="图形结构"><a href="#图形结构" class="headerlink" title="图形结构"></a>图形结构</h3><p>图形结构:图形结构的数据元素是多对多的关系。如右图所示。<br>我们在用示意图表示数据的逻辑结构时，要注意两点:</p><ul><li>将每一个数据元素看作一个结点，用圆圈表示</li><li>元素之间的逻辑关系用结点之间的连线表示，如果这个关系是有方向的，那么用带箭头的连线表示。</li></ul><p>从之前的例子也可以看出，逻辑结构是针对具体问题的，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系，</p><p><img src="/2024/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/image-20240519194842953.png" alt="image-20240519194842953"></p><h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2><p>物理结构:是指数据的逻辑结构在计算机中的存储形式。</p><h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><p>​<strong>顺序存储结构是把逻辑上相邻的元素存储在物理位置上相邻的存储单元中,元素之间的逻辑关系由存储单元的邻接关系体现(称为直接映射)。</strong>通常顺序存储结构借助于计算机程序设计语言的数组(例如C&#x2F;C++、Java语言等)或者列表(例如Python语言等)实现。</p><p>​<strong>主要优点</strong>是<strong>节省存储空间</strong>,因为分配给数据的存储单元全部用于存放元素值,元素之间的逻辑关系没有占用额外的存储空间。在采用这种方法时可实现对元素的随机存取,即每个元素对应有一个序号,由该序号可直接计算出元素的存储地址;顺序存储方法的主要缺点是初始空间难以确定,插入和删除操作需要移动较多的元素。</p><h2 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><p>​<strong>在链式存储结构中每个逻辑元素用一个结点存储,不要求逻辑上相邻的元素在物理位置上也相邻,元素间的逻辑关系用附加域表示,通常链式存储结构借助于计算机程序设计语言的指针(或者引用)实现。</strong></p><p>​主要优点是<strong>便于插入和删除操作</strong>,实现这些操作仅需修改相应结点的指针域,不必移动结点。</p><p>​与顺序存储方法相比,链式存储方法的主要缺点是<strong>存储空间的利用率较低</strong>,因为分配给数据的存储单元有一部分被用来存储元素之间的逻辑关系。另外,由于逻辑上相邻的元素在存储空间中不一定相邻,所以不能对元素进行随机存取。</p><h2 id="索引存储结构"><a href="#索引存储结构" class="headerlink" title="索引存储结构"></a>索引存储结构</h2><p>​<strong>索引存储结构通常是在存储元素信息的同时还建立附加的索引表。</strong>索引表中的每一项称为索引项,索引项的一般形式是(关键字,地址),关键字唯一标识一个元素,索引表按关键字有序排序,地址作为指向元素的指针。这种带有索引表的存储结构可以大大提高数据查找的速度。<br>​线性结构的数据采用索引存储方法后可以对元素进行随机访问,在进行插入、删除运算时只需移动存储在索引表中对应元素的存储地址,而不必移动存放在元素表中的元素的数据,所以仍<strong>保持较高的数据修改、运算效率</strong>;索引存储方法的缺点是<strong>增加了索引表,降低了存储空间的利用率。</strong></p><h2 id="哈希-散列-存储结构"><a href="#哈希-散列-存储结构" class="headerlink" title="哈希(散列)存储结构"></a>哈希(散列)存储结构</h2><p>​哈希存储结构的基本思想是根据元素的关键字通过哈希(或散列)函数直接计算出一个值,并将这个值作为该元素的存储地址。<br>​哈希存储方法的优点是<strong>查找速度快,只要给出待查元素的关键字就可以立即计算出该元素的存储地址。</strong>与前3种存储方法不同的是,哈希存储方法<strong>只存储元素的数据</strong>,<strong>不存储</strong>元素之间的逻辑关系。哈希存储方法一般只适合数据<strong>快速查找和插入</strong>的场合。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><div class="gallery-container" data-type="data" data-button>      <div class="gallery-data">[{"url":"https://www.bailog.top/2024/02/02/JAVA-CS61B-学习笔记-11-CS61b学习笔记-Rd8-1/","alt":"CS61B学习笔记(十一)-Rd8.1-封装、API、ADT | 云泥小窝 (bailog.top)"}]</div>      <div class="gallery-items">      </div>    </div>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计原理</title>
      <link href="/2024/05/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/"/>
      <url>/2024/05/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Head First设计模式</title>
      <link href="/2024/05/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-HeadFirst%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
      <url>/2024/05/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-HeadFirst%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学复习-谓词逻辑</title>
      <link href="/2024/05/11/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91/"/>
      <url>/2024/05/11/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<h1 id="谓词逻辑基本概念"><a href="#谓词逻辑基本概念" class="headerlink" title="谓词逻辑基本概念"></a>谓词逻辑基本概念</h1><ul><li>原子命题<ul><li>客体<ul><li>不依人们主观而存在的客观实体.具体事物或抽象概念.</li></ul></li><li>谓词<ul><li>描述客体的性质或特征,或客体间的关系的词.</li></ul></li></ul></li></ul><p><strong>基于谓词分析的逻辑,称为谓词逻辑</strong>,它是命题逻辑的扩充和发展。</p><h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><ul><li>命题一般是由主语和谓词两部分组成如：<ul><li>小王是老师       </li><li>小李是老师</li></ul></li></ul><p>其中<strong>小王</strong>和<strong>小李</strong>是主语，可独立存在</p><p>谓语相同：<strong>“是老师”</strong>，描述了小王和小李的共同特征。要表示多个客体之间的关系，可引入多个客体的谓词来表示</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="一元谓词"><a href="#一元谓词" class="headerlink" title="一元谓词"></a>一元谓词</h4><p> P：男男是大学生           Q：毛毛是大学生              S(x): x是大学生男男是大学生  S(a)   a:男男毛毛是大学生  S(c)   c:毛毛</p><h1 id="谓词公式翻译"><a href="#谓词公式翻译" class="headerlink" title="谓词公式翻译"></a>谓词公式翻译</h1><h1 id="约束变元与自由变元"><a href="#约束变元与自由变元" class="headerlink" title="约束变元与自由变元"></a>约束变元与自由变元</h1><h1 id="谓词公式的等价变换和蕴含式"><a href="#谓词公式的等价变换和蕴含式" class="headerlink" title="谓词公式的等价变换和蕴含式"></a>谓词公式的等价变换和蕴含式</h1><h1 id="谓词逻辑的推理理论"><a href="#谓词逻辑的推理理论" class="headerlink" title="谓词逻辑的推理理论"></a>谓词逻辑的推理理论</h1>]]></content>
      
      
      <categories>
          
          <category> 复习笔记 </category>
          
          <category> 离散数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散数学 </tag>
            
            <tag> 复习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创业导论题库整理</title>
      <link href="/2024/05/09/%E5%88%9B%E4%B8%9A%E5%AF%BC%E8%AE%BA%E9%A2%98%E5%BA%93%E6%95%B4%E7%90%86-index/"/>
      <url>/2024/05/09/%E5%88%9B%E4%B8%9A%E5%AF%BC%E8%AE%BA%E9%A2%98%E5%BA%93%E6%95%B4%E7%90%86-index/</url>
      
        <content type="html"><![CDATA[<h3 id="1-1-大学生的创业现状"><a href="#1-1-大学生的创业现状" class="headerlink" title="1.1 大学生的创业现状"></a>1.1 大学生的创业现状</h3><p><strong>1.1 大学生的创业现状</strong></p><ol><li><p>【判断题】创业与创业者的学历存在一定的关系，但在某种程度上又不受学历的束缚。（√）</p></li><li><p>【判断题】从目前的形势来看，社会上自主创业的人将越来越多，甚至有可能成为今后就业的主流。（√）</p></li></ol><h3 id="1-2-大学生创业成为趋势的原因"><a href="#1-2-大学生创业成为趋势的原因" class="headerlink" title="1.2 大学生创业成为趋势的原因"></a>1.2 大学生创业成为趋势的原因</h3><p><strong>1.2 大学生创业成为趋势的原因</strong></p><ol><li><p>【判断题】就业成本的增加是形成创业趋势的原因之一。（√）</p></li><li><p>【判断题】自贸区也是政府职能的一种改革。（√）</p></li></ol><h3 id="1-3-创业的定义及本质"><a href="#1-3-创业的定义及本质" class="headerlink" title="1.3 创业的定义及本质"></a>1.3 创业的定义及本质</h3><p><strong>1.3 创业的定义及本质</strong></p><ol><li><p>【单选题】（C）对失败的容忍率更大。</p><ul><li>A、风险基金</li><li>B、股票基金</li><li>C、天使基金</li><li>D、债券基金</li></ul></li><li><p>【单选题】通过莫里斯所做的创业定义研究发现，对于创业定义的理解中出现频次最高的词是（D）。</p><ul><li>A、新事业、新机会</li><li>B、创新、新产品、新市场</li><li>C、追逐机会</li><li>D、开始、创建、创造</li></ul></li><li><p>【多选题】以下关于创业活动说法正确的是（BCD）。</p><ul><li>A、创业活动是经济快速增长的外生性力量</li><li>B、是激发民间活动力的重要形式</li><li>C、是促进就业的重要途径</li><li>D、是推动自主创新和发展高科技产业、现代服务业等高端产业的重要力量</li></ul></li><li><p>【判断题】现有政策允许知识资本折合成相当比例的有形资产，以股权占有形式参与投入，创办实业。（√）</p></li><li><p>【判断题】网络经济、虚拟经济等经济形态的出现，为大学生自主创办大型知识型企业创造了条件。（X）</p></li></ol><h3 id="1-4-创业的形式"><a href="#1-4-创业的形式" class="headerlink" title="1.4 创业的形式"></a>1.4 创业的形式</h3><p><strong>1.4 创业的形式</strong></p><ol><li><p>【单选题】从（C）的视角来看，创业包含了使已有生产方式或是产品过时的资源独特组合。</p><ul><li>A、财富的创造</li><li>B、企业的创造</li><li>C、创新的创造</li><li>D、变革的创造</li></ul></li><li><p>【单选题】从变革的创造的视角来看，创业（D）。</p><ul><li>A、包含了为了获得利润进行生产的风险承担</li><li>B、包含了对生产要素包括劳动力的雇佣、管理和发展等</li><li>C、是为了开发没有开启的市场机会，为顾客创造价值的过程</li><li>D、包含了为了抓住环境中的机会而进行的创造性的变革</li></ul></li><li><p>【单选题】SWOT 分析中，“W” 代表（B）。</p><ul><li>A、优势</li><li>B、劣势</li><li>C、机会</li><li>D、挑战</li></ul></li><li><p>【单选题】利用机会，克服劣势的战略为（B）。</p><ul><li>A、S-O 战略</li><li>B、W-O 战略</li><li>C、W-T 战略</li><li>D、S-T 战略</li></ul></li><li><p>【多选题】创业的形式包括（ABCD）。</p><ul><li>A、自由资金创业</li><li>B、引进天使基金</li><li>C、引进 PE 风险投资基金</li><li>D、合伙的形式</li></ul></li><li><p>【多选题】从增长的视角来看，创业被定义成为了（BCD）的增长，一种正向的、强烈的导向。</p><ul><li>A、机会</li><li>B、销售</li><li>C、雇佣</li><li>D、资产</li></ul></li><li><p>【判断题】从财富创造的视角来看，创业体现了一项从前没有过的新企业的创造。（X）</p></li></ol><h3 id="1-5-创业面临的问题及处理建议"><a href="#1-5-创业面临的问题及处理建议" class="headerlink" title="1.5 创业面临的问题及处理建议"></a>1.5 创业面临的问题及处理建议</h3><p><strong>1.5 创业面临的问题及处理建议</strong></p><ol><li><p>【单选题】关于大学生创业，社会应负的责任不包括（A）。</p><ul><li>A、设置系统的创业平台</li><li>B、转变思想观念</li><li>C、营造创业氛围，实现全民创业</li><li>D、加强优秀创业人物及创业事迹的宣传</li></ul></li><li><p>【多选题】关于大学生创业，高校应负的责任包括（AB）。</p><ul><li>A、在创业课程设置与创业指导等方面作出进步的努力</li><li>B、创新的教育模式</li><li>C、提高大学生的自身素质</li><li>D、务实的创业具体实施方案</li></ul></li><li><p>【判断题】大学生创业要做好充足的心</p></li></ol><p>理准备，并培养自己的商业头脑意识。（√）</p><h3 id="2-1-中国创业者的素质"><a href="#2-1-中国创业者的素质" class="headerlink" title="2.1 中国创业者的素质"></a>2.1 中国创业者的素质</h3><p><strong>2.1 中国创业者的素质</strong></p><ol><li><p>【单选题】“有努力工作实现个人目标的渴望” 指中国创业者身上具有的（D）素质。</p><ul><li>A、适应能力</li><li>B、竞争性</li><li>C、纪律性</li><li>D、动力</li></ul></li><li><p>【多选题】中国创业者身上具有的素质包括（ABCD）。</p><ul><li>A、诚实</li><li>B、组织</li><li>C、说服力</li><li>D、毅力</li></ul></li><li><p>【判断题】“相信自己能做成计划中的事” 体现了中国创业者身上具有动力的素质。（X）</p></li><li><p>【判断题】根据著名的管理学家巴纳德的理论，每个人都是信息的节点。（√）</p></li></ol><h3 id="2-2-成功创业者具备的特点"><a href="#2-2-成功创业者具备的特点" class="headerlink" title="2.2 成功创业者具备的特点"></a>2.2 成功创业者具备的特点</h3><p><strong>2.2 成功创业者具备的特点</strong></p><ol><li><p>【单选题】“看清最终目标并坚定方向” 体现了中国创业者身上具有（C）的素质。</p><ul><li>A、诚实</li><li>B、毅力</li><li>C、视野</li><li>D、动力</li></ul></li><li><p>【单选题】中国创业者身上具有的 “说服力” 的素质是指（D）。</p><ul><li>A、以诚待人</li><li>B、有能力安排好自己的生活，并使任务和信息条理化</li><li>C、努力实现目标，不放弃</li><li>D、劝说别人明白你的观点并对之感兴趣</li></ul></li><li><p>【判断题】对于创业成功是否能够成功，创业者的素质具有更大的决定性因素。√</p></li></ol><h3 id="2-3-企业家的素质"><a href="#2-3-企业家的素质" class="headerlink" title="2.3 企业家的素质"></a>2.3 企业家的素质</h3><p><strong>2.3 企业家的素质</strong></p><ol><li><p>【单选题】以下不属于 “五缘文化” 的是（C）。</p><ul><li>A、亲缘</li><li>B、业缘</li><li>C、乡缘</li><li>D、地缘</li></ul></li><li><p>【单选题】“同学、同行之间的关系”是指 “五缘文化” 中的（B）。</p><ul><li>A、亲缘</li><li>B、业缘</li><li>C、乡缘</li><li>D、地缘</li></ul></li><li><p>【单选题】成功测创业者是 “三商” 的总和，其中（C）排在首位。</p><ul><li>A、情商</li><li>B、智商</li><li>C、胆商</li><li>D、健商</li></ul></li><li><p>【多选题】一名成功的创业家应具备的素质包括（AB）。</p><ul><li>A、富有强烈的挑战性</li><li>B、求异的创造性思维</li><li>C、应付危机和挑战的能力</li><li>D、团队精神和卓越的领导才能、科学的知识结构</li></ul></li><li><p>【判断题】“清晰的使命感和愿景、严密推理的能力与综合能力、善于整合资源” 等，这些都是一名成功的创业家需要具备的素质。X</p></li><li><p>【判断题】“高度的社会责任感、对机会的把握” 等是一名成功的创业家需要具备的素质。√</p></li></ol><h3 id="2-4-创业者的职业性向"><a href="#2-4-创业者的职业性向" class="headerlink" title="2.4 创业者的职业性向"></a>2.4 创业者的职业性向</h3><p><strong>2.4 创业者的职业性向</strong></p><ol><li><p>【单选题】霍兰德职业性向理论提出（B）种职业性向。</p><ul><li>A、三</li><li>B、六</li><li>C、十二</li><li>D、十八</li></ul></li><li><p>【单选题】具有（B）的人，通常表现为分析、创造、好奇、独立等个性特质，会被吸引去从事那些善于思考、组织和理解的活动。</p><ul><li>A、实际性向</li><li>B、调研性向</li><li>C、社会性向</li><li>D、常规性向</li></ul></li><li><p>【单选题】具有企业性向的人，通常表现为（A）。</p><ul><li>A、自信、进取、精力充沛、威气凌人等个性特质，会被吸引去从事那些包含着大量以影响他人或获得权力为目的的职业</li><li>B、顺从、高效、实际、缺乏想象力、缺乏灵活性等个性特质，会被吸引去从事那些包含着大量结构性的且规则较为固定的职业</li><li>C、分析、创造、好奇、独立等个性特质，会被吸引去从事那些善于思考、组织和理解的活动。</li><li>D、富有想象力、无序、杂乱、理想、情绪化、不实际等个性特质，会被吸引去从事那些包含着大量自我表现、情感表达以及个性化活动的职业</li></ul></li><li><p>【多选题】具有企业性向的人，适合的职业包括（ABC）。</p><ul><li><p>A、法官</p></li><li><p>B、公关专家</p></li><li><p>C、管理人员</p></li><li><p>D、业务经理</p></li></ul></li><li><p>【判断题】具有实际性向的人，通常表现为顺从、高效、实际、缺乏想象力、缺乏灵活性等个性特质，会被吸引去从事那些包含着大量结构性的且规则较为固定的职业。（X）</p></li><li><p>【判断题】具有艺术性向的人，适合的职业包括艺术家、广告制作者、音乐家、室内装饰家等。（√）</p></li></ol><h3 id="2-5-创业者的素质"><a href="#2-5-创业者的素质" class="headerlink" title="2.5 创业者的素质"></a>2.5 创业者的素质</h3><p><strong>2.5 创业者的素质</strong></p><ol><li><p>【单选题】下列不属于美国教育的特点的是（A）。</p><ul><li>A、封闭型</li><li>B、服务型</li><li>C、开放型</li><li>D、学分制</li></ul></li><li><p>【多选题】面对创业，我们需要考虑下列哪些问题？（ABCD）</p><ul><li>A、是否具有无穷的精力</li><li>B、是否相信自己的决策能力</li><li>C、是否富有主动精神，能自我激励</li><li>D、是否自律性高、责任心重</li></ul></li><li><p>【判断题】相对于美国教育，我国的教育是服务型和封闭型的。（X）</p></li></ol><h3 id="3-1-创业的概念及基本要素"><a href="#3-1-创业的概念及基本要素" class="headerlink" title="3.1 创业的概念及基本要素"></a>3.1 创业的概念及基本要素</h3><p><strong>3.1 创业的概念及基本要素</strong></p><ol><li><p>【单选题】创业的基本要素不包括（B）。</p><ul><li>A、组织</li><li>B、产品</li><li>C、资源</li><li>D、价值</li></ul></li><li><p>【多选题】杰弗里 ·A· 蒂蒙斯认为，创业是一种思考、推理和行为方式，这种方式是（ABC）。</p><ul><li>A、机会驱动</li><li>B、注重方法</li><li>C、与领导相平衡</li><li>D、创造出新颖的产品或服务</li></ul></li><li><p>【判断题】霍华德 ·H· 斯蒂文森认为：创业是对机会的追逐，与当时控制的资源无关。（√）</p></li><li><p>【判断题】商业机会是指由当前服务于市场的企业留下的市场缺口。（√）</p></li></ol><h3 id="3-2-创业的类型"><a href="#3-2-创业的类型" class="headerlink" title="3.2 创业的类型"></a>3.2 创业的类型</h3><p><strong>3.2 创业的类型</strong></p><ol><li><p>【单选题】独立创业的方式不包括（C）。</p><ul><li>A、创新型创业</li><li>B、从属型创业</li><li>C、母体分离</li><li>D、模仿型创业</li></ul></li><li><p>【多选题】创业的类型包括（BCD）。</p><ul><li>A、创新型创业</li><li>B、独立创业</li><li>C、母体分离</li><li>D、企业内创业</li></ul></li><li><p>【判断题】组织是协调创业活动的系统，其显著特征包括：创业者的强有力领导和完善的正式的结构和制度。（X）</p></li><li><p>【判断题】企业内创业是指组织内部的管理者、技术人员或职员，离开原组织，但利用在组织中的资源，成立新的企业，进行营利活动。（X）</p></li></ol><h3 id="3-3-创业的动机"><a href="#3-3-创业的动机" class="headerlink" title="3.3 创业的动机"></a>3.3 创业的动机</h3><p><strong>3.3 创业的动机</strong></p><ol><li><p>【单选题】（C）是指进入成熟期的为了获得持续增长和长久的竞争优势，为了倡导创新并使其研成果产品化，通过授权和资源保障等支持的创业。</p><ul><li>A、独立创业</li><li>B、母体分离</li><li>C、企业内创业</li><li>D、从属型创业</li></ul></li><li><p>【多选题】蒂蒙斯模型的含义表明，创业过程依赖于（BCD）三要素的匹配和平衡。</p><ul><li>A、动机</li><li>B、机会</li><li>C、创业团队</li><li>D、资源</li></ul></li><li><p>【判断题】创业的作用包括：促进经济增长、促进就业和有助于技术创新。（√）</p></li><li><p>【判断题】蒂蒙斯模型表明，创业过程是一开始就进行的时断时续的寻求平衡的过程。（X）</p></li></ol><h3 id="3-4-创业的理论模型"><a href="#3-4-创业的理论模型" class="headerlink" title="3.4 创业的理论模型"></a>3.4 创业的理论模型</h3><p><strong>3.4 创业的理论模型</strong></p><ol><li><p>【单选题】（C）实际上就是把一个想法落地为现实的一种创业行动的一个桥梁。</p><ul><li>A、商机</li><li>B、资源</li><li>C、商业计划书</li><li>D、工作团队</li></ul></li><li><p>【单选题】根据蒂蒙斯模型，（A）是创业过程的核心动力。</p><ul><li>A、商业机会</li><li>B、创始人</li><li>C、工作团队</li><li>D、资源</li></ul></li><li><p>【单选题】威克姆模型认为，创业活动包括（C）个要素。</p><ul><li>A、二</li><li>B、三</li><li>C、四</li><li>D、五</li></ul></li><li><p>【单选题】（D）更能考虑</p></li></ol><p>创业者的整个人生发展。</p><ul><li>A、商业模式</li><li>B、商业计划书</li><li>C、管理模型</li><li>D、创业生命周期模型</li></ul><ol start="5"><li><p>【判断题】威克姆模型认为，创业活动包括人、机会、资源、创业过程四个要素。√</p></li><li><p>【判断题】创业生命周期模型将企业的发展过程分为五个阶段，分别是：萌芽期、发展期、成熟期、衰退期和重生期。（X）</p></li></ol><h3 id="3-5-创业的过程"><a href="#3-5-创业的过程" class="headerlink" title="3.5 创业的过程"></a>3.5 创业的过程</h3><p><strong>3.5 创业的过程</strong></p><ol><li><p>【单选题】创业过程不包括（C）。</p><ul><li>A、构思</li><li>B、认识</li><li>C、实施</li><li>D、测试</li></ul></li><li><p>【多选题】创业过程包括（ABC）。</p><ul><li>A、构思</li><li>B、认识</li><li>C、实施</li><li>D、创立</li></ul></li><li><p>【判断题】创业过程是一个创造性的、不断发展和变化的过程，它是动态的。（√）</p></li><li><p>【判断题】创业过程是一个简单的、静态的过程，一旦完成创业过程，企业就不再有发展了。（X）</p></li></ol><h3 id="3-5-创业生命周期理论"><a href="#3-5-创业生命周期理论" class="headerlink" title="3.5 创业生命周期理论"></a>3.5 创业生命周期理论</h3><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p><strong>【单选题】</strong> （B）处于创业的生命周期理论的系统研究阶段。</p><p>A、20 世纪 50 至 60 年代</p><p><strong>B、20 世纪 60 至 70 年代</strong></p><p>C、20 世纪 70 至 80 年代</p><p>D、21 世纪初期</p><h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><p><strong>【单选题】</strong> 葛雷纳的成长性企业阶段模型包括（D）个阶段。</p><p>A、二</p><p>B、三</p><p>C、四</p><p><strong>D、五</strong></p><h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p><strong>【判断题】</strong> 根据爱迪思成长企业十阶段论，孕育期容易出现创业空想。（√）</p><h3 id="3-6-创业的原则"><a href="#3-6-创业的原则" class="headerlink" title="3.6 创业的原则"></a>3.6 创业的原则</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.</h4><p><strong>【单选题】</strong> 创业的（B）包括：启动资金越小越好；不讲究排场，配置以能够运行为准；人员精简到最低限度；生产管理功能尽量社会化。</p><p><strong>A、择业原则</strong></p><p>B、投资最小化原则</p><p>C、风险最低化原则</p><p>D、产品简约化原则</p><h4 id="2-1"><a href="#2-1" class="headerlink" title="2."></a>2.</h4><p><strong>【多选题】</strong> 创业的原则包括（ABCD）。</p><p><strong>A、择业原则</strong></p><p><strong>B、投资最小化原则</strong></p><p><strong>C、产品简约化原则</strong></p><p><strong>D、风险最低化原则</strong></p><h4 id="3-1"><a href="#3-1" class="headerlink" title="3."></a>3.</h4><p><strong>【判断题】</strong> 创业的择业原则包括从事自己力所能及的行业；准入门槛低；竞争对手少，最好是新兴的、独特的行业或产品。（√）</p><h4 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h4><p><strong>【判断题】</strong> 产品的简约化原则是指：不要尝试打政策的擦边球；营销收益能尽快兑现；承接与自己能力相符的业务；保持足够的先进流量。（X）</p><h3 id="4-1-创新思维的本质"><a href="#4-1-创新思维的本质" class="headerlink" title="4.1 创新思维的本质"></a>4.1 创新思维的本质</h3><h4 id="1-2"><a href="#1-2" class="headerlink" title="1."></a>1.</h4><p><strong>【多选题】</strong> 创新思维的特点包括（AB）。</p><p><strong>A、非常规性</strong></p><p><strong>B、积极主动性</strong></p><p>C、常规性</p><p>D、动态性</p><h4 id="2-2"><a href="#2-2" class="headerlink" title="2."></a>2.</h4><p><strong>【判断题】</strong> 搞发明创造要有创造力，创新思维就是构成创造力的核心。（√）</p><h3 id="4-2-创新思维的特征"><a href="#4-2-创新思维的特征" class="headerlink" title="4.2 创新思维的特征"></a>4.2 创新思维的特征</h3><h4 id="1-3"><a href="#1-3" class="headerlink" title="1."></a>1.</h4><p><strong>【判断题】</strong> 通过学习、自我谈话和被领导和家长推出去，不断锻炼可以获得心理安全区。（√）</p><h3 id="4-3-创新思维的培养"><a href="#4-3-创新思维的培养" class="headerlink" title="4.3 创新思维的培养"></a>4.3 创新思维的培养</h3><h4 id="1-4"><a href="#1-4" class="headerlink" title="1."></a>1.</h4><p><strong>【单选题】</strong> 根据研究，企业的竞争包括三个阶段，其中（A）是解决问题的阶段。</p><p><strong>A、争原料、争设备阶段</strong></p><p>B、争科技性人才阶段</p><p>C、争智囊行人才阶段</p><p>D、争管理模式阶段</p><h4 id="2-3"><a href="#2-3" class="headerlink" title="2."></a>2.</h4><p><strong>【单选题】</strong> 根据研究，企业的竞争第二个阶段主要是（B）。</p><p>A、争原料、争设备阶段</p><p><strong>B、争科技性人才阶段</strong></p><p>C、争智囊行人才阶段</p><p>D、争管理模式阶段</p><h4 id="3-2"><a href="#3-2" class="headerlink" title="3."></a>3.</h4><p><strong>【判断题】</strong> 思维惯性和思维定势合起来就称为思维障碍。（√）</p><h3 id="4-4-企业思维的枷锁"><a href="#4-4-企业思维的枷锁" class="headerlink" title="4.4 企业思维的枷锁"></a>4.4 企业思维的枷锁</h3><h4 id="1-5"><a href="#1-5" class="headerlink" title="1."></a>1.</h4><p><strong>【单选题】</strong> （C）表现为不敏感，思维不活跃。</p><p>A、自我中心型思维障碍</p><p>B、自卑型思维障碍</p><p><strong>C、麻木型思维障碍</strong></p><p>D、偏执性思维障碍</p><h4 id="2-4"><a href="#2-4" class="headerlink" title="2."></a>2.</h4><p><strong>【单选题】</strong> 打破权威性思维障碍的解决方法是（B）。</p><p>A、克服从众心理，坚持自我</p><p><strong>B、先来一番彻底的审查，尊重而不是迷信</strong></p><p>C、打破对经验的依赖与崇拜，将经验转变为创新</p><p>D、尽信书不如无书</p><h4 id="3-3"><a href="#3-3" class="headerlink" title="3."></a>3.</h4><p><strong>【判断题】</strong> 自我中心型思维障碍表现为大多颇为自信，但有的是钻牛角尖，明知这条道路走不通，非要往前闯，不知道及时转弯子。（X）</p><h3 id="4-5-创新思维的培养视角"><a href="#4-5-创新思维的培养视角" class="headerlink" title="4.5 创新思维的培养视角"></a>4.5 创新思维的培养视角</h3><h4 id="1-6"><a href="#1-6" class="headerlink" title="1."></a>1.</h4><p><strong>【单选题】</strong> “声不过五，五声之变，不可胜听也；色不过五，五色之变，不可胜观也” 体现了（C）思维。</p><p>A、求同</p><p>B、求异</p><p><strong>C、组合</strong></p><p>D、求合</p><h4 id="2-5"><a href="#2-5" class="headerlink" title="2."></a>2.</h4><p><strong>【多选题】</strong> 下列关于扩展视角的关系叙述正确的是（BC）。</p><p><strong>B、今日 - 往日 - 未日</strong></p><p><strong>C、自我 - 非我 - 大我</strong></p><p>A、否定 - 肯定 - 待定</p><p>D、求合 - 求同 - 求异</p><h4 id="3-4"><a href="#3-4" class="headerlink" title="3."></a>3.</h4><p><strong>【判断题】</strong></p><p> 做市场的生意要注重求异思维。（√）</p><h3 id="4-6-培养创新思维习惯"><a href="#4-6-培养创新思维习惯" class="headerlink" title="4.6 培养创新思维习惯"></a>4.6 培养创新思维习惯</h3><h4 id="1-7"><a href="#1-7" class="headerlink" title="1."></a>1.</h4><p><strong>【单选题】</strong> “无序 - 有序 - 超序”是扩展视角的一种方法，其中 “无序” 指（B）。</p><p>A、逻辑论证</p><p><strong>B、打破条框</strong></p><p>C、实施论证</p><p>D、演绎推理</p><h4 id="2-6"><a href="#2-6" class="headerlink" title="2."></a>2.</h4><p><strong>【判断题】</strong> “无序 - 有序 - 超序”是扩展视角的一种方法，其中 “超序” 指逻辑论证。（X）</p><h3 id="4-7-创新思维修炼的技术"><a href="#4-7-创新思维修炼的技术" class="headerlink" title="4.7 创新思维修炼的技术"></a>4.7 创新思维修炼的技术</h3><h4 id="1-8"><a href="#1-8" class="headerlink" title="1."></a>1.</h4><p><strong>【单选题】</strong> “卫生酒精” 的发明采用了（D）思维方法。</p><p>A、颠倒思维</p><p>B、综合思维</p><p>C、侧向思维</p><p><strong>D、逆向思维</strong></p><h4 id="2-7"><a href="#2-7" class="headerlink" title="2."></a>2.</h4><p><strong>【单选题】</strong> （D）是一种通过把注意力引向外部其他领域和事物，从而受到启发，找到超出限定条件之外的新思路。</p><p>A、逆向思维</p><p>B、颠倒思维</p><p>C、发散思维</p><p><strong>D、侧向思维</strong></p><h4 id="3-5"><a href="#3-5" class="headerlink" title="3."></a>3.</h4><p><strong>【多选题】</strong> 以下哪些属于激发潜能的方式？（ABC）</p><p><strong>A、良性暗示</strong></p><p><strong>B、梦境顿悟</strong></p><p><strong>C、冥想境界</strong></p><p>D、逆向思维</p><h4 id="4-1"><a href="#4-1" class="headerlink" title="4."></a>4.</h4><p><strong>【判断题】</strong> 梦会将毫不想干的事物联系在一起，而这可能恰恰是你的正常思维所忽略的。（√）</p><h4 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h4><p><strong>【判断题】</strong> 颠倒思维从实质上来讲，与逆向思维完全不同。（X）</p><h4 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h4><p><strong>【判断题】</strong> 侧向思维实际上是一种联想思维。（√）</p><h3 id="4-8-创新思维修炼的方法"><a href="#4-8-创新思维修炼的方法" class="headerlink" title="4.8 创新思维修炼的方法"></a>4.8 创新思维修炼的方法</h3><h4 id="1-9"><a href="#1-9" class="headerlink" title="1."></a>1.</h4><p><strong>【单选题】</strong> （A）主要侧重于资料和信息。</p><p><strong>A、白帽思维</strong></p><p>B、红帽思维</p><p>C、黑帽思维</p><p>D、绿帽思维</p><h4 id="2-8"><a href="#2-8" class="headerlink" title="2."></a>2.</h4><p><strong>【单选题】</strong> （D）代表着一种创新与冒险。</p><p>A、白帽思维</p><p>B、红帽思维</p><p>C、黑帽思维</p><p><strong>D、绿帽思维</strong></p><h4 id="3-6"><a href="#3-6" class="headerlink" title="3."></a>3.</h4><p><strong>【判断题】</strong> 白帽思维侧重于直觉与情感。（X）</p><h3 id="5-1-创业机会的重要性"><a href="#5-1-创业机会的重要性" class="headerlink" title="5.1 创业机会的重要性"></a>5.1 创业机会的重要性</h3><h4 id="1-10"><a href="#1-10" class="headerlink" title="1."></a>1.</h4><p><strong>【单选题】</strong> 胡润富豪榜在新中国成立（C）周年时第一次推出。</p><p>A、三十</p><p>B、四十</p><p><strong>C、五十</strong></p><p>D、六十</p><h4 id="2-9"><a href="#2-9" class="headerlink" title="2."></a>2.</h4><p><strong>【判断题】</strong> 一名敏锐的创业者往往能够把握住普通人可能没有意识到的机会，从而占据市场先机。（√）</p><h3 id="5-2-创业机会的含义"><a href="#5-2-创业机会的含义" class="headerlink" title="5.2 创业机会的含义"></a>5.2 创业机会的含义</h3><h4 id="1-11"><a href="#1-11" class="headerlink" title="1."></a>1.</h4><p><strong>【单选题】</strong> （B）的独特性在于能经由重新组合资源来创造一种新的目的 - 手段关系。</p><p>A、商业机会</p><p><strong>B、创业机会</strong></p><p>C、际遇</p><p>D、机遇</p><h4 id="2-10"><a href="#2-10" class="headerlink" title="2."></a>2.</h4><p><strong>【单选题】</strong> 创业机会的来源不包括（D）。</p><p>A、问题型机会</p><p>B、趋势型机会</p><p>C、组合型机会</p><p><strong>D、常规型机会</strong></p><h4 id="3-7"><a href="#3-7" class="headerlink" title="3."></a>3.</h4><p><strong>【单选题】</strong> （B）指当目的或手段任意一方的状况未知，等待创业者去进行机会发掘。</p><p><strong>A、识别型机会</strong></p><p><strong>B、发现型机会</strong></p><p>C、创造型机会</p><p>D、窗口型机会</p><h4 id="4-2"><a href="#4-2" class="headerlink" title="4."></a>4.</h4><p><strong>【多选题】</strong> 奥地利经济学派认为创业机会与商业机会的根本区别在于（AB）或（）创造潜力的差异。</p><p><strong>A、利润</strong></p><p><strong>B、价值</strong></p><p>C、产品</p><p>D、资源</p><h4 id="5-1"><a href="#5-1" class="headerlink" title="5."></a>5.</h4><p><strong>【多选题】</strong> 创业机会是可以为购买者或使用者创造或增加价值的产品或服务，它具有（ABC）的特点。</p><p><strong>A、吸引力</strong></p><p><strong>B、持久性</strong></p><p><strong>C、适时性</strong></p><p>D、独特性</p><h4 id="6-1"><a href="#6-1" class="headerlink" title="6."></a>6.</h4><p><strong>【判断题】</strong> 商机与创业机会实质上是一个概念。（X）</p><h4 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h4><p><strong>【判断题】</strong> 识别型机会指市场中的目的 - 手段关系十分明显时，创业家可通过目的 - 手段关系的连接来辨别机会。（√）</p><h3 id="5-3-创业机会的分类"><a href="#5-3-创业机会的分类" class="headerlink" title="5.3 创业机会的分类"></a>5.3 创业机会的分类</h3><h4 id="1-12"><a href="#1-12" class="headerlink" title="1."></a>1.</h4><p><strong>【判断题】</strong> 创业机会具有客观性的特征。（√）</p><h3 id="5-4-创业机会的特征"><a href="#5-4-创业机会的特征" class="headerlink" title="5.4 创业机会的特征"></a>5.4 创业机会的特征</h3><h4 id="1-13"><a href="#1-13" class="headerlink" title="1."></a>1.</h4><p><strong>【单选题】</strong> （C）是创业机会识别的主要来源。</p><p>A、先前经验</p><p>B、认知因素</p><p><strong>C、社会关系网络</strong></p><p>D、创造性</p><h4 id="2-11"><a href="#2-11" class="headerlink" title="2."></a>2.</h4><p><strong>【多选题】</strong> 创业机会具有（ABCDE）的特征。</p><p>**A、客</p><p>观性**</p><p><strong>B、时效性</strong></p><p>C、均衡性</p><p><strong>D、差异性</strong></p><p>E、成本性</p><h4 id="3-8"><a href="#3-8" class="headerlink" title="3."></a>3.</h4><p><strong>【判断题】</strong> 借助 “弱关系” 的优势在于用最少的成本去获取更多的人际关系。（√）</p><h3 id="5-5-创业机会的来源（上）"><a href="#5-5-创业机会的来源（上）" class="headerlink" title="5.5 创业机会的来源（上）"></a>5.5 创业机会的来源（上）</h3><h4 id="1-14"><a href="#1-14" class="headerlink" title="1."></a>1.</h4><p><strong>【单选题】</strong> 创业机会的来源不包括（C）。</p><p>A、科技的进步</p><p>B、制度变革</p><p><strong>C、社会因素的变化</strong></p><p>D、人口因素的变化</p><h4 id="2-12"><a href="#2-12" class="headerlink" title="2."></a>2.</h4><p><strong>【多选题】</strong> 创业机会的来源包括（ABCD）。</p><p><strong>A、科技的进步</strong></p><p><strong>B、制度变革</strong></p><p><strong>C、社会因素的变化</strong></p><p><strong>D、人口因素的变化</strong></p><h3 id="5-6-创业机会的来源（下）"><a href="#5-6-创业机会的来源（下）" class="headerlink" title="5.6 创业机会的来源（下）"></a>5.6 创业机会的来源（下）</h3><h4 id="1-15"><a href="#1-15" class="headerlink" title="1."></a>1.</h4><p><strong>【判断题】</strong> 市场需求的变化是创业机会的来源之一。（√）</p><h3 id="5-7-创业机会的识别"><a href="#5-7-创业机会的识别" class="headerlink" title="5.7 创业机会的识别"></a>5.7 创业机会的识别</h3><h4 id="1-16"><a href="#1-16" class="headerlink" title="1."></a>1.</h4><p><strong>【单选题】</strong> 新眼光调查注重（B）调查。</p><p>A、初级</p><p><strong>B、二级</strong></p><p>C、三级</p><p>D、四级</p><h4 id="2-13"><a href="#2-13" class="headerlink" title="2."></a>2.</h4><p><strong>【单选题】</strong> 蒂蒙斯的创业机会评价框架涉及（C）个方面 53 项指标。</p><p>A、四</p><p>B、六</p><p><strong>C、八</strong></p><p>D、十六</p><h4 id="3-9"><a href="#3-9" class="headerlink" title="3."></a>3.</h4><p><strong>【判断题】</strong> 通过创造获得创业机会的方法在新技术行业中最为常见。（√）</p><h3 id="5-8-创业机会评价框架"><a href="#5-8-创业机会评价框架" class="headerlink" title="5.8 创业机会评价框架"></a>5.8 创业机会评价框架</h3><h4 id="1-17"><a href="#1-17" class="headerlink" title="1."></a>1.</h4><p><strong>【单选题】</strong> 根据刘常勇的创业机会评价框架，（A）不属于回报评价。</p><p><strong>A、评价创业机会的市场渗透力</strong></p><p>B、毛利率应该高于 40%</p><p>C、能否创造新企业在市场上的战略价值</p><p>D、资本市场的活跃程度</p><h4 id="2-14"><a href="#2-14" class="headerlink" title="2."></a>2.</h4><p><strong>【单选题】</strong> （C）的行业特点是大量规模相近的企业。</p><p>A、新兴行业</p><p>B、成熟行业</p><p><strong>C、分散行业</strong></p><p>D、衰退行业</p><h4 id="3-10"><a href="#3-10" class="headerlink" title="3."></a>3.</h4><p><strong>【判断题】</strong> 头脑风暴法的过程是：提出问题 - 问题组合 - 集思广益 - 意见组合。（√）</p><h4 id="4-3"><a href="#4-3" class="headerlink" title="4."></a>4.</h4><p><strong>【判断题】</strong> 成熟行业的行业特点是需求增长缓慢，有限的产品创新。（√）</p><h3 id="6-1-创业战略的内涵"><a href="#6-1-创业战略的内涵" class="headerlink" title="6.1 创业战略的内涵"></a>6.1 创业战略的内涵</h3><h4 id="1-18"><a href="#1-18" class="headerlink" title="1."></a>1.</h4><p><strong>【多选题】</strong> 创业战略包含的三个问题是（ABC）</p><p><strong>A、做什么</strong></p><p><strong>B、如何做</strong></p><p>C、由谁来做</p><p><strong>D、做到什么程度</strong></p><h3 id="6-2-团队与创业"><a href="#6-2-团队与创业" class="headerlink" title="6.2 团队与创业"></a>6.2 团队与创业</h3><h4 id="1-19"><a href="#1-19" class="headerlink" title="1."></a>1.</h4><p><strong>【多选题】</strong> 创业团队需要具备的特点有（ABCD）。</p><p><strong>A、目标一致</strong></p><p><strong>B、相互了解信任</strong></p><p><strong>C、拥有核心</strong></p><p><strong>D、相濡以沫</strong></p><h4 id="2-15"><a href="#2-15" class="headerlink" title="2."></a>2.</h4><p><strong>【判断题】</strong> 创业关注的核心是卓有成效成效的创业团队。√</p><h3 id="6-3-创业团队的来源"><a href="#6-3-创业团队的来源" class="headerlink" title="6.3 创业团队的来源"></a>6.3 创业团队的来源</h3><h4 id="1-20"><a href="#1-20" class="headerlink" title="1."></a>1.</h4><p><strong>【单选题】</strong> 创业团队的工作绩效应该（C）团队中的每个人的单独的绩效的总和。</p><p>A、小于</p><p>B、等于</p><p><strong>C、大于</strong></p><p>D、不确定</p><h4 id="2-16"><a href="#2-16" class="headerlink" title="2."></a>2.</h4><p><strong>【判断题】</strong> 沈南鹏在携程这个团队主要负责吸引风险投资方面。√</p><h3 id="6-4-创业团队的构成及作用"><a href="#6-4-创业团队的构成及作用" class="headerlink" title="6.4 创业团队的构成及作用"></a>6.4 创业团队的构成及作用</h3><h4 id="1-21"><a href="#1-21" class="headerlink" title="1."></a>1.</h4><p><strong>【单选题】</strong> 如果创业团队存在（D）问题，基本上所有的风险投资家都会拒绝投资。</p><p>A、资金</p><p>B、管理</p><p>C、发展</p><p><strong>D、诚信</strong></p><h4 id="2-17"><a href="#2-17" class="headerlink" title="2."></a>2.</h4><p><strong>【多选题】</strong> 以下选项属于创业机会视角下的创业团队优势的是（BCD）</p><p><strong>A、机会获得能力较高</strong></p><p><strong>B、机会识别能力较高</strong></p><p><strong>C、机会开发能力较高</strong></p><p><strong>D、机会利用能力较高</strong></p><h4 id="3-11"><a href="#3-11" class="headerlink" title="3."></a>3.</h4><p><strong>【判断题】</strong> 董事会具有指导、增加自信的作用。√</p><h3 id="6-5-如何选择创业合作者"><a href="#6-5-如何选择创业合作者" class="headerlink" title="6.5 如何选择创业合作者"></a>6.5 如何选择创业合作者</h3><h4 id="1-22"><a href="#1-22" class="headerlink" title="1."></a>1.</h4><p><strong>【单选题】</strong> 创业团队的相似性特点会团队带来一个明显的缺点就是（B）。</p><p>A、效率问题</p><p><strong>B、冗余问题</strong></p><p>C、沟通问题</p><p>D、发展问题</p><h4 id="2-18"><a href="#2-18" class="headerlink" title="2."></a>2.</h4><p><strong>【单选题】</strong> 生命周期处于（A）阶段时，创业团队的凝聚力和有效性都是低水平。</p><p><strong>A、出生</strong></p><p>B、成长</p><p>C、成熟</p><p>D、衰老</p><h3 id="6-6-创业初期及其管理"><a href="#6-6-创业初期及其管理" class="headerlink" title="6.6 创业初期及其管理"></a>6.6 创业初期及其管理</h3><h4 id="1-23"><a href="#1-23" class="headerlink" title="1."></a>1.</h4><p><strong>【单选题】</strong> 新企业在成长过程中有两个特点，不确定性和（C）。</p><p>A、缓慢性</p><p>B、偏见性</p><p><strong>C、复杂性</strong></p><p>D、稳定性</p><h4 id="2-19"><a href="#2-19" class="headerlink" title="2."></a>2.</h4><p><strong>【多选题】</strong> 以下选项属于创业</p><p>企业的特征的是（ABC）。</p><p><strong>A、不确定性</strong></p><p><strong>B、复杂性</strong></p><p><strong>C、简单性</strong></p><p>D、稳定性</p><h3 id="6-7-创业战略的形成及演变"><a href="#6-7-创业战略的形成及演变" class="headerlink" title="6.7 创业战略的形成及演变"></a>6.7 创业战略的形成及演变</h3><h4 id="1-24"><a href="#1-24" class="headerlink" title="1."></a>1.</h4><p><strong>【多选题】</strong> 形成创业战略的方式包括（ABCD）。</p><p><strong>A、借鉴</strong></p><p><strong>B、充分的调查</strong></p><p><strong>C、专家评估</strong></p><p><strong>D、顾问咨询</strong></p><h4 id="2-20"><a href="#2-20" class="headerlink" title="2."></a>2.</h4><p><strong>【判断题】</strong> 获得创业机会后，创业战略的制定是不可或缺的。√</p><h3 id="6-8-创业战略的决策"><a href="#6-8-创业战略的决策" class="headerlink" title="6.8 创业战略的决策"></a>6.8 创业战略的决策</h3><h4 id="1-25"><a href="#1-25" class="headerlink" title="1."></a>1.</h4><p><strong>【单选题】</strong> 创业战略的选择由（A）进行决策。</p><p><strong>A、创业者</strong></p><p>B、顾问</p><p>C、专家</p><p>D、团队</p><h4 id="2-21"><a href="#2-21" class="headerlink" title="2."></a>2.</h4><p><strong>【单选题】</strong> 实施的创业战略可以是（A）。</p><p>A、唯一的</p><p>B、独特的</p><p>C、差异的</p><p>D、相似的</p><h4 id="3-12"><a href="#3-12" class="headerlink" title="3."></a>3.</h4><p><strong>【判断题】</strong> 创业战略是一个长期决策，通常持续三年以上。√</p><h3 id="7-1-创业计划书的含义"><a href="#7-1-创业计划书的含义" class="headerlink" title="7.1 创业计划书的含义"></a>7.1 创业计划书的含义</h3><p><strong>1.</strong> 创业过程中（A）是一个创业主题的 “灵魂”。</p><ul><li>A、创业项目书</li><li>B、市场营销</li><li>C、人力资源</li><li>D、财务管理</li></ul><p><strong>答案：A</strong></p><p><strong>2.</strong> 下列关于创业计划书叙述正确的是（AB）。</p><ul><li>A、是创业者计划创立的业务的书面摘要</li><li>B、它为业务的发展提供指示图和衡量业务进展情况的标准</li><li>C、仅用于描述与拟创办企业相关的内部环境条件</li><li>D、创业计划项目书仅包含市场营销、财务和人力资源</li></ul><p><strong>答案：AB</strong></p><p><strong>3.</strong> 创业计划书可以帮助创业者树立清晰的愿景、树立创业的信心。（√）</p><hr><h3 id="7-2-创业计划书的内容（上）"><a href="#7-2-创业计划书的内容（上）" class="headerlink" title="7.2 创业计划书的内容（上）"></a>7.2 创业计划书的内容（上）</h3><p><strong>1.</strong> 一般情况下，创业计划书的第四部内容是（B）。</p><ul><li>A、企业介绍</li><li>B、行业分析</li><li>C、产品服务介绍</li><li>D、人员即组织结构</li></ul><p><strong>答案：B</strong></p><p><strong>2.</strong> 对于分散行业，对创业者的建议是（C）。</p><ul><li>A、尽早进入</li><li>B、不轻易进入</li><li>C、加盟连锁</li><li>D、不进入</li></ul><p><strong>答案：C</strong></p><p><strong>3.</strong> “红海战略” 是指进入的行业是新兴行业，几乎没有竞争对手。(X)</p><p><strong>4.</strong> 创业计划书中的企业介绍部分，一定要介绍公司理念和公司的战略目标。（√）</p><hr><h3 id="7-3-创业计划书的内容（下）"><a href="#7-3-创业计划书的内容（下）" class="headerlink" title="7.3 创业计划书的内容（下）"></a>7.3 创业计划书的内容（下）</h3><p><strong>1.</strong> 创业计划书中营销策略的内容不包括（C）。</p><ul><li>A、市场机构和营销渠道的选择</li><li>B、营销队伍和管理</li><li>C、目标顾客和目标市场</li><li>D、价格决策</li></ul><p><strong>答案：C</strong></p><p><strong>2.</strong> （B）反应某一时刻企业的状况、投资这可以用其中的数据得到的比率指标来衡量企业的经营状况。</p><ul><li>A、现金流量</li><li>B、资产负债表</li><li>C、损益表</li><li>D、财务状况变动表</li></ul><p><strong>答案：B</strong></p><p><strong>3.</strong> 创业计划书中关于产品服务的介绍包括（AB）。</p><ul><li>A、产品 &#x2F; 服务的特点和竞争优势</li><li>B、产品 &#x2F; 服务的市场前景预测</li><li>C、需求进行预测</li><li>D、促销计划和广告策略</li></ul><p><strong>答案：AB</strong></p><p><strong>4.</strong> 流动资金反映的是企业的盈利状况，它是企业在一段时间运作后的经营结果。（X）</p><hr><h3 id="7-4-创业计划书的书写格式"><a href="#7-4-创业计划书的书写格式" class="headerlink" title="7.4 创业计划书的书写格式"></a>7.4 创业计划书的书写格式</h3><p><strong>1.</strong> 精简版创业计划书第三部分的内容一般是（A）。</p><ul><li>A、商业模式</li><li>B、解决方案</li><li>C、营销和销售战略</li><li>D、竞争分析</li></ul><p><strong>答案：A</strong></p><p><strong>2.</strong> 精简版创业计划书第四部分的内容一般是 “潜在的魔力”，主要叙述你的公司如何做到与众不同。（√）</p><p><strong>3.</strong> 在创业计划书中，风险资本的退出部分应包括退出方式和退出时间的内容。（√）</p><hr><h3 id="7-5-创业计划书的检查"><a href="#7-5-创业计划书的检查" class="headerlink" title="7.5 创业计划书的检查"></a>7.5 创业计划书的检查</h3><p><strong>1.</strong> “5C 概念 “不包括（C）。</p><ul><li>A、Concept 概念</li><li>B、Customers 顾客</li><li>C、Catalog 目录</li><li>D、Capital 资本</li></ul><p><strong>答案：C</strong></p><p><strong>2.</strong> 创业计划书经常出现的问题包括（AB）。</p><ul><li>A、形象主题不突出</li><li>B、忘记联络方式</li><li>C、形式新颖</li><li>D、名字有号召力</li></ul><p><strong>答案：AB</strong></p><p><strong>3.</strong> 写好创业项目数需要思考的问题包括：关注产品、敢于竞争、了解市场和表明行动的方针等。（√）</p><hr><h3 id="7-6-相关创业实务的步骤"><a href="#7-6-相关创业实务的步骤" class="headerlink" title="7.6 相关创业实务的步骤"></a>7.6 相关创业实务的步骤</h3><p><strong>1.</strong> 创办个体工商户首先应办理（D）</p><ul><li>A、递交申请材料</li><li>B、领取《准予行政许可决定书》</li><li>C、到工商局交费并领取营业执照</li><li>D、名称预先登记</li></ul><p><strong>答案：D</strong></p><p><strong>2.</strong> IMC 定位方法的核心理念和主张是（C）。</p><ul><li>A、强调产品的具体特殊功效和利益</li><li>B、塑造形象长远投资</li><li>C、消费者的认知</li><li>D、创造心理位置、强调第一</li></ul><p><strong>答案：C</strong></p><p><strong>3.</strong> 创办个体工商户需要经过 “领取《企业名称预先核准通知书》，同时领取《企业设立登记申请书》” 的流程。（√）</p><p><strong>4.</strong> 品</p><p>牌定位是为了适应消费者心目中的某一特定地位而涉及产品及其营销组合的行为。（X）</p><hr><h3 id="8-1-创业筹备的风险规避"><a href="#8-1-创业筹备的风险规避" class="headerlink" title="8.1 创业筹备的风险规避"></a>8.1 创业筹备的风险规避</h3><p><strong>1.</strong> （B）是指依法形式职权，从事国家管理活动的各种国家机关。</p><ul><li>A、企业法人</li><li>B、机关法人</li><li>C、社会团体法人</li><li>D、事业单位法人</li></ul><p><strong>答案：B</strong></p><p><strong>2.</strong> 以下哪些属于企业法人？（BD）</p><ul><li>A、机关法人</li><li>B、全民所有制法人</li><li>C、社会团体法人</li><li>D、集体所有制法人</li></ul><p><strong>答案：BD</strong></p><p><strong>3.</strong> 大学生创业者在创业初期一定要做好市场调研，一般来说选择启动资金不多、人手配备要求不高的项目，从小本经营做起来比价适宜。（√）</p><p><strong>4.</strong> 法人是在法律上人格化了的、依法具有民事权利能力和民事行为能力并独立享有民事权利、承担民事义务的自然人。（X）</p><hr><h3 id="9-1-企业上市的原因"><a href="#9-1-企业上市的原因" class="headerlink" title="9.1 企业上市的原因"></a>9.1 企业上市的原因</h3><p><strong>1.</strong> 处于孵化期的企业通过上市获得更多的投资，就具有了收购兼并产业链上下整合的能力。（√）</p><hr><h3 id="9-2-企业上市的意义"><a href="#9-2-企业上市的意义" class="headerlink" title="9.2 企业上市的意义"></a>9.2 企业上市的意义</h3><p><strong>1.</strong> “企业通过上市筹集的充足资本可以帮助企业在市场情况不景气或突发情况时及时进行业务调整或转型而不至于出现经营困难” 体现了上市给企业带来的（D）。</p><ul><li>A、融资效应</li><li>B、财富效应</li><li>C、竞争效应</li><li>D、经营安全效应</li></ul><p><strong>答案：D</strong></p><p><strong>2.</strong> 公司上市后企业品牌提升，银行贷款等间接融资也更为便利，为企业今后的资本运营如收购兼并等业务的开展奠定坚实的基础。（√）</p><p><strong>3.</strong> 境内外市场在供求关系上存在很大不同，在境外发行的股票能够得到境内投资者的踊跃认购。（X）</p><hr><h3 id="9-3-企业上市的流程"><a href="#9-3-企业上市的流程" class="headerlink" title="9.3 企业上市的流程"></a>9.3 企业上市的流程</h3><p><strong>1.</strong> 创业企业上市的流程中第二阶段是（C）。</p><ul><li>A、改制阶段</li><li>B、申报材料制作及申报阶段</li><li>C、辅导阶段</li><li>D、股票发行及上市阶段</li></ul><p><strong>答案：C</strong></p><p><strong>2.</strong> 对于上市企业主体资格要求中，要求企业持续经营（B）年以上。</p><ul><li>A、二</li><li>B、三</li><li>C、五</li><li>D、十</li></ul><p><strong>答案：B</strong></p><p><strong>3.</strong> 企业上市将面临更多市场风险，股票价格易受市场波动，影响公司资产价值的因素增大。（√）</p><p><strong>4.</strong> 在创业企业上市的申报阶段，企业董事、高管要全程参与申报文件制作，包括对反馈意见的处理。（√）</p><hr><h3 id="10-1-创业模式"><a href="#10-1-创业模式" class="headerlink" title="10.1 创业模式"></a>10.1 创业模式</h3><p><strong>1.</strong> 创业的模式包含（BCD）。</p><ul><li>A、继承家族企业模式</li><li>B、白手起家模式</li><li>C、收购现有企业模式</li><li>D、依附创业模式</li></ul><p><strong>答案：BCD</strong></p><hr><h3 id="11-1-走出创业失败的误区"><a href="#11-1-走出创业失败的误区" class="headerlink" title="11.1 走出创业失败的误区"></a>11.1 走出创业失败的误区</h3><p><strong>1.</strong> 以下选项属于创业后的失败误区的有（ABCD）。</p><ul><li>A、机构膨胀与管理失调</li><li>B、过渡扩张与财务失控</li><li>C、坐享其成与挥霍浪费</li><li>D、头脑发热与好大喜功</li></ul><p><strong>答案：ABCD</strong></p><p><strong>2.</strong> 创业者在创业前要有非常乐观的心态和明确的计划。（X）</p><p><strong>3.</strong> 要想成为长赢的高成长企业，要有不断创新的意识和能力。（√）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>离散数学复习-关系</title>
      <link href="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/"/>
      <url>/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="序偶和笛卡尔积"><a href="#序偶和笛卡尔积" class="headerlink" title="序偶和笛卡尔积"></a>序偶和笛卡尔积</h1><h2 id="序偶"><a href="#序偶" class="headerlink" title="序偶"></a>序偶</h2><p>对于有序n元组，当n&#x3D;2时，我们将其称作有序二元组，也称作有序对,或序偶。</p><p>序偶的特点：</p><ul><li><p>若a≠b,则(a,b)≠(b,a)</p></li><li><p>两个有序对(a,b)和(c,d)相等当且仅当a&#x3D;c，b&#x3D;d。</p></li></ul><p><strong>特征：成对出现、具有一定的顺序。</strong></p><p>用序偶表示下列语句中的次序关系</p><p>(1)平面上点A的横坐标是x，纵坐标是y，x,y∈R；</p><p>(2)成都是四川的省会；</p><p>(3)英语课本在书桌上；</p><p>(4)左，右关系。</p><blockquote><p>(1)(x,y)</p><p>(2)(成都,四川)</p><p>(3)(英语课本,书桌)</p><p>(4)(左,右)</p></blockquote><h2 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h2><p>设A，B是两个集合，所有有序对(x, y)做成的集合(其中x∈A，y∈B)，称为A，B的笛卡儿积，记为A×B。A x B &#x3D; {(x，y)|x∈A且y∈B}</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>|A×B|&#x3D;|A|× |B|；</li><li>对任意集合A，有A×Ø&#x3D;Ø，Ø×A&#x3D;Ø；</li><li>笛卡儿积运算不满足交换律，即A×B≠B×A；  </li><li>笛卡儿积运算不满足结合律，即(A×B)×C≠A×(B×C) </li><li><strong>笛卡儿积运算对并和交运算满足分配律</strong>， 即:<ul><li>A×(B∪C)&#x3D;(A×B)∪(A×C)，</li><li>(B∪C)×A&#x3D;(B×A)∪(C×A)，</li><li>A×(B∩C)&#x3D;(A×B)∩(A×C)， </li><li>(B∩C)×A&#x3D;(B×A)∩(C×A)；</li></ul></li><li><strong>设A，B，C，D是集合，若A⊆C且B⊆D，则 A×B ⊆ C×D。</strong></li></ul><h1 id="二元关系"><a href="#二元关系" class="headerlink" title="二元关系"></a>二元关系</h1><p><strong>★关系是一个集合，是序偶的集合。</strong></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>给定任意集合A和B，若R⊆A×B，则称R为从A到B的<strong>二元关系</strong>，特别在A&#x3D;B时，称<strong>R为A上的二元关系</strong>。</p><p><strong>从集合A到集合B的一个关系R是A×B的一个子集</strong></p><ul><li>R是有序对的集合。若(x,y)∈R，则也表示为x R y，即**(x,y)∈ R ⇔ x R y。**<ul><li>若R &#x3D;Ø，则称 R 为A 到 B上<strong>空关系</strong>；</li><li>若R &#x3D;A×B，称R为A 到 B上<strong>全域关系</strong></li><li>当A &#x3D;B 时，<ul><li>称Ø为A上<strong>空关系</strong></li><li>称R &#x3D;A×A为A上的<strong>全域关系</strong></li><li>称R&#x3D;{（x,x）|x∈A}为A上的<strong>恒等关系</strong>，记为**I<del>A</del>**。</li></ul></li></ul></li></ul><p>当集合A,B都是有限集时，A×B共有2^|A|•|B|^个不同的子集，即从A到B的不同关系共有2|^A|•|B|^个。</p><h2 id="定义域、值域、域"><a href="#定义域、值域、域" class="headerlink" title="定义域、值域、域"></a>定义域、值域、域</h2><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507194125919.png" alt="image-20240507194125919"></p><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><ul><li><p>设A&#x3D;{ a , b ,甲，乙}，B&#x3D;{0，1，丙}, 关系S&#x3D;{(a,0) ,(b,0), (甲,1) ,(甲,丙) } </p><ul><li><p>则可知D(S)&#x3D;{a, b, 甲},           </p></li><li><p>R(S)&#x3D;{0, 1, 丙}</p></li></ul></li><li><p>实数集R上的”&lt;”关系可定义为：&lt;&#x3D;{(x,y)|x∈R,y∈R且X小于y}</p><ul><li>D(&lt;)&#x3D;R           R(&lt;)&#x3D;R</li></ul></li></ul><h2 id="关系矩阵"><a href="#关系矩阵" class="headerlink" title="关系矩阵"></a>关系矩阵</h2><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507194248600.png" alt="image-20240507194248600"></p><h3 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h3><p>例： A&#x3D;{1,2,3,4} ，R&#x3D;{( x , y)| x, y∈A且 x &gt; y}，试求M<del>R</del>，R&#x3D;{( 4 ,1),(4,2),(4,3), (3,1),(3,2),(2,1)}</p><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507194310411.png" alt="image-20240507194310411"></p><h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507194403787.png" alt="image-20240507194403787"></p><h3 id="例-2"><a href="#例-2" class="headerlink" title="例"></a>例</h3><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507194442002.png" alt="image-20240507194442002"></p><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507194456644.png" alt="image-20240507194456644"></p><h2 id><a href="#" class="headerlink" title></a></h2><h1 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h1><h2 id="1-关系的交、并、补、差"><a href="#1-关系的交、并、补、差" class="headerlink" title="1. 关系的交、并、补、差"></a>1. 关系的交、并、补、差</h2><p>前已述及，关系是<strong>序偶</strong>(有序对)的集合，因此可以对关系进行运算。</p><p>若R, S⊆A×B，则R∪S，R ∩S，~R，R-S⊆A×B.</p><h2 id="2-复合关系"><a href="#2-复合关系" class="headerlink" title="2.复合关系"></a>2.复合关系</h2><p>设R是从集合X到Y的关系，S是从Y到Z的关系，把X到Z的关系定义为<strong>RoS</strong>。称<strong>RoS</strong>是关系R和S的合成关系或复合关系.</p><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507194818051.png" alt="image-20240507194818051"></p><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507194839433.png" alt="image-20240507194839433"></p><h3 id="分配律"><a href="#分配律" class="headerlink" title="分配律"></a>分配律</h3><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507195230904.png" alt="image-20240507195230904"></p><h3 id="结合律"><a href="#结合律" class="headerlink" title="结合律"></a>结合律</h3><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507194935674.png" alt="image-20240507194935674"></p><h3 id="复合的幂运算"><a href="#复合的幂运算" class="headerlink" title="复合的幂运算"></a>复合的幂运算</h3><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507195001008.png" alt="image-20240507195001008"></p><h2 id="3-逆关系"><a href="#3-逆关系" class="headerlink" title="3.逆关系"></a>3.逆关系</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507195329344.png" alt="image-20240507195329344"></p><h3 id="定理一"><a href="#定理一" class="headerlink" title="定理一"></a>定理一</h3><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507195418936.png" alt="image-20240507195418936"></p><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507195117515.png" alt="image-20240507195117515"></p><h3 id="定理二"><a href="#定理二" class="headerlink" title="定理二"></a>定理二</h3><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507195445152.png" alt="image-20240507195445152"></p><h3 id="定理三"><a href="#定理三" class="headerlink" title="定理三"></a>定理三</h3><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507195528582.png" alt="image-20240507195528582"></p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>任意两个关系R和S能进行复合运算<strong>当且仅当</strong>R的后域是S的前域。<ul><li>注意RoS的前域是R的前域，后域是S的后域；如果对任意的x∈A和z∈C，不存在y∈B使得xRy和ySz同时成立，则RoS为空，从而有ΦoR &#x3D; RoΦ &#x3D; Φ。</li></ul></li><li>复合运算有三种计算方式(集合表达式、关系矩阵和关系图), 其中利用关系矩阵的计算方式是难点，RoS的关系矩阵<strong>等于</strong>R的关系矩阵和S的关系矩阵的布尔积。</li></ul><h2 id="关系运算的应用"><a href="#关系运算的应用" class="headerlink" title="关系运算的应用"></a>关系运算的应用</h2><ul><li>例设有关系R和S分别如表1和表2所示，在R中增加关系S中的所有元组，试求增加后的关系。</li></ul><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507195806488.png" alt="image-20240507195806488"></p><blockquote><p>在关系R中增加S中的所有元组，在关系数据库中称为对关系表的<strong>插入操作</strong>(InsertOperation)，该操作可以通过关系的<strong>并运算</strong>完成，即求在R中增加关系S的所有元组等价于求R∪S。</p><table><thead><tr><th><strong>A</strong></th><th><strong>B</strong></th><th><strong>C</strong></th></tr></thead><tbody><tr><td><strong>1</strong></td><td><strong>2</strong></td><td><strong>5</strong></td></tr><tr><td><strong>2</strong></td><td><strong>1</strong></td><td><strong>3</strong></td></tr><tr><td><strong>5</strong></td><td><strong>6</strong></td><td><strong>2</strong></td></tr><tr><td><strong>4</strong></td><td><strong>6</strong></td><td><strong>2</strong></td></tr><tr><td><strong>6</strong></td><td><strong>1</strong></td><td><strong>5</strong></td></tr></tbody></table></blockquote><ul><li>设有关系R和S如表4和表5所示，现在在R中去掉关系S中所出现的元组，试求去掉S后的关系。</li></ul><blockquote><p>相当于 R - S</p></blockquote><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507195923164.png" alt="image-20240507195923164"></p><h1 id="关系性质"><a href="#关系性质" class="headerlink" title="关系性质"></a>关系性质</h1><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507200526843.png" alt="image-20240507200526843"></p><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507200543946.png" alt="image-20240507200543946"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>若A上关系R是<em>自反</em>的，则M<del>R</del>中主<strong>对角线上元素全为1</strong>，而G<del>R</del>中每个结点<strong>有</strong>有向环；反之亦然。</li><li>若A上关系R是<em>反自反</em>的，则M<del>R</del>中<strong>主对角线上元素全为0</strong>，而G<del>R</del>中每个结点<strong>无</strong>有向环；反之亦然。</li><li>若A上关系R是<em>对称</em>的，则M<del>R</del>是<strong>对称矩阵</strong>，而G<del>R</del>中任何两结点若有<strong>弧必成对</strong>出现；反之亦然。</li><li>若A上关系R是<em>反对称</em>的，则M<del>R</del>中以主对角线为对称元素<strong>不能同时为1</strong>，而G<del>R</del>中若两结点间有弧<strong>不能成对</strong>出现；反之亦然。</li><li>若A上关系R是<em>传递</em>的，则MR中若r<del>ij</del>&#x3D;r<del>jk</del>&#x3D;1，则r<del>ik</del>&#x3D;1，而GR中若有弧（x, y）和（y, z）则必有弧（x, z）；反之亦然。但不易从M<del>R</del>和G<del>R</del>中判定关系R传递性。</li></ul><h2 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h2><ul><li>任何集合上的<strong>相等关系</strong>是<em>自反的、对称的，反对称的和传递</em>的，但<strong>不是反自反</strong>的。</li><li>整数集合Z中，关系<strong>≤</strong>是<em>自反的、反对称的和传递</em>的，<strong>但不是反自反的和对称的</strong>。关系**&lt;<strong>是<em>反自反的，反对称的和传递</em>的，</strong>但不是自反的和对称的**。</li><li><em>非空</em>集合上的<strong>空关系</strong>是<em>反自反的，对称的，反对称的和传递</em>的，<strong>但不是自反</strong>的。</li><li><em>空</em>集合上的<strong>空关系</strong>则是<em>自反的，反自反的，对称的，反对称的和传递</em>的。</li><li>非空集合上的<strong>全域关系</strong>是自反的，对称的和传递的，<strong>但不是反自反的和反对称</strong>的。</li></ul><p><strong>定理</strong>  设R⊆A×A，若R是反自反的和传递的，则R是反对称的。</p><h1 id="闭包运算"><a href="#闭包运算" class="headerlink" title="闭包运算"></a>闭包运算</h1><p>关系的闭包运算是关系上的一元运算，是包含该关系且具有某种性质的最小关系。</p><h2 id="自反闭包"><a href="#自反闭包" class="headerlink" title="自反闭包"></a>自反闭包</h2><p>设R 是 A上的二元关系，若有另一个关系R’满足:</p><ul><li>R’是自反的</li><li>R⊆R’</li><li>对任意的自反关系R’’， R⊆R’’ ，</li></ul><p>则必有R’⊆R’’R’是R的自反闭包,记作**r(R)**。</p><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507202150155.png" alt="image-20240507202150155"></p><h2 id="对称闭包"><a href="#对称闭包" class="headerlink" title="对称闭包"></a>对称闭包</h2><p>设R 是 A上的二元关系，若有另一个关系R’满足:</p><ul><li>R’是对称的</li><li>R⊆R’</li><li>对任意的自反关系R’’， R⊆R’’ ，</li></ul><p>则必有R’⊆R’’R’是R的自反闭包,记作**s(R)**。</p><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507202311540.png" alt="image-20240507202311540"></p><h2 id="传递闭包"><a href="#传递闭包" class="headerlink" title="传递闭包"></a>传递闭包</h2><p>设R 是 A上的二元关系，若有另一个关系R’满足:</p><ul><li>R’是传递的</li><li>R⊆R’</li><li>对任意的自反关系R’’， R⊆R’’ ，</li></ul><p>则必有R’⊆R’’R’是R的自反闭包,记作**t(R)**。</p><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507202340153.png" alt="image-20240507202340153"></p><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507202422180.png" alt="image-20240507202422180"></p><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507202431088.png" alt="image-20240507202431088"></p><h1 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h1><p><strong>划分 &#x3D; 等价 &#x3D; 商集</strong></p><p><strong>划分块 &#x3D; 等价类</strong></p><h2 id="等价关系的定义"><a href="#等价关系的定义" class="headerlink" title="等价关系的定义"></a>等价关系的定义</h2><p>设R是集合X上的二元关系，如果 R是<strong>自反的、对称的、传递</strong>的，那么称R是等价关系。</p><h2 id="等价的证明"><a href="#等价的证明" class="headerlink" title="等价的证明"></a>等价的证明</h2><p>例1：X&#x3D;{1,2,3,4,5,6}，Z是整数集合</p><p>R&#x3D;{(x,y)|x,y∈X 且(x-y)&#x2F;2∈Z}</p><ul><li>证明一：R为等价关系语言描述</li><li>证法二：在其关系矩阵上证明</li><li>证法三：在其关系图上证明</li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507203031273.png" alt="image-20240507203031273"></p><h2 id="等价类"><a href="#等价类" class="headerlink" title="等价类"></a>等价类</h2><p>R是集合S上的等价关系, 对任一x∈S，均可构造一个S的非空子集[x]<del>R</del> ，叫做x关于R的等价类:</p><p><strong>[x]<del>R</del> &#x3D; { y | y∈S 且 xRy }，也可记为 [x]</strong></p><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507203402388.png" alt="image-20240507203402388"></p><h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><ul><li>x∈[x]</li><li>若y∈[x],  则 [y]&#x3D;[x]</li><li>若y∉[x],  则 [y]∩[x]&#x3D;Φ</li></ul><h2 id="商集"><a href="#商集" class="headerlink" title="商集"></a>商集</h2><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507221540981.png" alt="image-20240507221540981"></p><h2 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h2><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507221611008.png" alt="image-20240507221611008"></p><h1 id="偏序关系"><a href="#偏序关系" class="headerlink" title="偏序关系"></a>偏序关系</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>设R是集合A中的二元关系，如果R是<strong>自反的、反对称的和可传递</strong>的，则称R是A中的偏序关系</p><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507203910096.png" alt="image-20240507203910096"></p><blockquote><p>续R&#x3D;{(2,2),(2,6),(2,12),(2,24),(2,36), (3,3),(3,6),(3,12),(3,24),(3,36),   (6,6),(6,12),(6,24),(6,36),(12,12), (12,24),(12,36),(24,24),(36,36)}</p></blockquote><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507203923815.png" alt="image-20240507203923815"></p><h2 id="哈斯图"><a href="#哈斯图" class="headerlink" title="哈斯图"></a>哈斯图</h2><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507204420694.png" alt="image-20240507204420694"></p><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507204430686.png" alt="image-20240507204430686"></p><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507204444251.png" alt="image-20240507204444251"></p><h3 id="最大、最小元素"><a href="#最大、最小元素" class="headerlink" title="最大、最小元素"></a>最大、最小元素</h3><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507204525060.png" alt="image-20240507204525060"></p><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507204533274.png" alt="image-20240507204533274"></p><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507204537722.png" alt="image-20240507204537722"></p><h3 id="极大、极小元素"><a href="#极大、极小元素" class="headerlink" title="极大、极小元素"></a>极大、极小元素</h3><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507204550057.png" alt="image-20240507204550057"></p><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507204603997.png" alt="image-20240507204603997"></p><h3 id="上界与下界"><a href="#上界与下界" class="headerlink" title="上界与下界"></a>上界与下界</h3><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507204612835.png" alt="image-20240507204612835"><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507204622540.png" alt="image-20240507204622540"></p><h3 id="上确界与下确界"><a href="#上确界与下确界" class="headerlink" title="上确界与下确界"></a>上确界与下确界</h3><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507204628809.png" alt="image-20240507204628809"></p><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507204635114.png" alt="image-20240507204635114"></p><h2 id="总结题"><a href="#总结题" class="headerlink" title="总结题"></a>总结题</h2><p><img src="/2024/05/07/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A6%BB%E6%95%A3-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0-%E5%85%B3%E7%B3%BB/image-20240507204714411.png" alt="image-20240507204714411"></p>]]></content>
      
      
      <categories>
          
          <category> 复习笔记 </category>
          
          <category> 离散数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散数学 </tag>
            
            <tag> 复习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61C学习笔记(三)-RISCV-Assembly</title>
      <link href="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/"/>
      <url>/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>RISC-V是基于RISC精简指令集架构开发的一个开放式指令集架构，它是由加州大学伯克利分校的计算机科学教授Krste Asanovic（克里斯蒂安·阿萨诺维奇）领导的团队开发，RISC-V是开放的，任何人都可以使用它来开发处理器芯片和其他硬件，而无需支付任何许可或使用费用。RISC-V的设计简单，易于扩展和自定义，可以在各种应用场景和市场中使用。</p><h1 id="什么是指令集架构？"><a href="#什么是指令集架构？" class="headerlink" title="什么是指令集架构？"></a>什么是指令集架构？</h1><p>指令集架构（Instruction Set Architecture，简称ISA）是计算机系统中的一个重要概念，指的是计算机中处理器的指令集和处理器的内部结构，即处理器是如何执行指令的。</p><p>ISA规定了一套<strong>指令集</strong>，包括指令的<strong>种类</strong>、指令的<strong>格式</strong>、指令的操作数、指令的<strong>执行方式</strong>等。ISA也规定了处理器的内部结构，包括处理器的<strong>寄存器</strong>、指令流水线、内存管理单元等。</p><p>不同的ISA有不同的指令集和内部结构设计，因此处理器的计算能力和性能也会有所不同。常见的ISA包括<code>ARM、x86、MIPS、PowerPC、RISC-V</code>等。ISA的选择对计算机系统的性能、功耗、软件兼容性、应用场景等都有很大的影响。</p><p>简单点比喻可以把指令集架构理解为<strong>图纸</strong>，处理器就是<strong>房子</strong>。</p><p>RISC和RISC-V的区别<br>RISC全称<code>Reduced Instruction Set Computer</code>，即精简指令计算机，它是指令集架构，它的理念在于旨在通过减少指令集的数量和复杂度，提高计算机的性能和效率。</p><p>RISC最初由加州大学伯克利分校<code>David Patterson</code>和<code>John Hennessy</code>在1980年代提出，并于1984年合著了一本名为“Computer Architecture: A Quantitative Approach”（中文译名为《计算机体系结构：量化研究方法》）的经典教材，该书详细介绍了RISC架构和量化分析方法，成为当时计算机体系结构领域的重要参考书。</p><p>RISC-V是由Krste Asanovic教授领导其团队基于RISC精简指令集架构开发的一款<strong>开源指令集架构</strong>，RISC-V具有更好的灵活性以及扩展性，同时它比RISC更加简单便于它人二次开发和扩展，并且它不需要任何授权费，可以应用于商业场景因为它遵循BSD开源协议，可以把RISC-V理解为RISC的扩展版。</p><h1 id="伟大的想法"><a href="#伟大的想法" class="headerlink" title="伟大的想法"></a>伟大的想法</h1><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240423164306259.png" alt="image-20240423164306259"></p><h2 id="寄存器在处理器内部"><a href="#寄存器在处理器内部" class="headerlink" title="寄存器在处理器内部"></a>寄存器在处理器内部</h2><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240423165043829.png" alt="image-20240423165043829"></p><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240423165208494.png" alt="image-20240423165208494"></p><p>##<img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504174707526.png" alt="image-20240504174707526"></p><p>Principle of Locality &#x2F; Memory Hierarchy</p><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240423165235223.png" alt="image-20240423165235223"></p><h1 id="寄存器和存储器的速度对比"><a href="#寄存器和存储器的速度对比" class="headerlink" title="寄存器和存储器的速度对比"></a>寄存器和存储器的速度对比</h1><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240423165330636.png" alt="image-20240423165330636"></p><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240423165339134.png" alt="image-20240423165339134"></p><h1 id="32个寄存器的介绍"><a href="#32个寄存器的介绍" class="headerlink" title="32个寄存器的介绍"></a>32个寄存器的介绍</h1><ol><li><strong>x0 - x31（通用寄存器）</strong>：<ul><li>这些寄存器是通用的，可用于各种目的。</li><li>x0 通常用作零寄存器，任何写入它的值都会被忽略。</li><li>其余的通用寄存器可以用于存储数据、地址、临时值等。</li></ul></li><li><strong>pc（程序计数器）</strong>：<ul><li>用于存储当前正在执行的指令的地址。</li><li>在每次指令执行后，PC会自动增加，以指向下一条指令。</li></ul></li><li><strong>ra（返回地址寄存器）</strong>：<ul><li>用于存储函数调用返回时的地址。</li><li>在函数调用时，调用者将返回地址存储在此寄存器中。</li></ul></li><li><strong>sp（栈指针寄存器）</strong>：<ul><li>指向当前栈顶的地址。</li><li>用于管理函数调用和局部变量的内存分配。</li></ul></li><li><strong>gp（全局指针寄存器）</strong>：<ul><li>指向全局数据区域的起始地址。</li><li>用于访问全局变量和静态数据。</li></ul></li><li><strong>tp（线程指针寄存器）</strong>：<ul><li>指向线程控制块（TCB）的地址。</li><li>在多线程环境中用于管理线程的上下文信息。</li></ul></li><li><strong>t0 - t6（临时寄存器）</strong>：<ul><li>用于存储临时数据。</li><li>可以在函数调用和数据操作中使用。</li></ul></li><li><strong>s0 - s11（保存寄存器）</strong>：<ul><li>用于保存函数调用时需要保持的值。</li><li>在函数调用期间，这些寄存器的值会被保留，并在函数返回时恢复。</li></ul></li><li><strong>a0 - a7（参数寄存器）</strong>：<ul><li>用于存储函数调用的参数。</li><li>调用者将参数传递给被调用函数时，将它们存储在这些寄存器中。</li></ul></li></ol><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504182001538.png" alt="image-20240504182001538"></p><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504184301237.png" alt="image-20240504184301237"></p><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504182827385.png" alt="image-20240504182827385"></p><h1 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h1><h2 id="Addition-subtraction"><a href="#Addition-subtraction" class="headerlink" title="Addition&#x2F;subtraction"></a>Addition&#x2F;subtraction</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add rd, rs1, rs2</span><br><span class="line">R[rd] = R[rs1] + R[rs2]</span><br><span class="line">sub rd, rs1, rs2</span><br><span class="line">R[rd] = R[rs1] - R[rs2]</span><br></pre></td></tr></table></figure><h2 id="Add-immediate"><a href="#Add-immediate" class="headerlink" title="Add immediate"></a>Add immediate</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addi rd, rs1, imm</span><br><span class="line">R[rd] = R[rs1] + imm</span><br></pre></td></tr></table></figure><h2 id="Load-from-Memory-to-Register"><a href="#Load-from-Memory-to-Register" class="headerlink" title="Load from Memory to Register"></a><u>Load from</u> Memory to Register</h2><p><strong>Load Word(lw)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[<span class="number">100</span>];</span><br><span class="line">g = h + A[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lw x10, 12(x15) # Reg x10 gets A[3]</span><br><span class="line">add x11,x12,x10 # g = h + A[3</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> </p><ul><li><p>x15 – base register (<strong>pointer</strong> to A[0]) </p></li><li><p>12 – <strong>offset in bytes</strong> </p></li><li><p><strong>Offset</strong> must be a constant known at assembly time</p></li></ul><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240423170306183.png" alt="image-20240423170306183"></p><h2 id="Store-from-Register-to-Memory"><a href="#Store-from-Register-to-Memory" class="headerlink" title="Store from Register to Memory"></a><u>Store</u> from Register <u>to</u> Memory</h2><p><strong>Store Word(sw)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[<span class="number">100</span>];</span><br><span class="line">A[<span class="number">10</span>] = h + A[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lw x10,12(x15) # Temp reg x10 gets A[3]</span><br><span class="line">add x10,x12,x10 # Temp reg x10 gets h + A[3]</span><br><span class="line">sw x10,40(x15) # A[10] = h + A[3]</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> </p><ul><li><p>x15 – base register (<strong>pointer</strong>) </p></li><li><p>12,40 – offsets in <strong>bytes</strong></p></li><li><p><code>x15+12</code> and<code> x15+40</code> must be <strong>multiples</strong> of 4</p></li></ul><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240423170519415.png" alt="image-20240423170519415"></p><h2 id="Loading-and-Storing-Bytes"><a href="#Loading-and-Storing-Bytes" class="headerlink" title="Loading and Storing Bytes"></a>Loading and Storing Bytes</h2><ul><li><p>load byte: <code>lb</code></p></li><li><p>store byte: <code>sb</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lb x10, 3(x11)</span><br></pre></td></tr></table></figure><blockquote><p>contents of memory location with address &#x3D; sum of “3”  + contents of register x11 is copied to the low byte  position of register x10</p></blockquote><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240423170835108.png" alt="image-20240423170835108"></p><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240423170848646.png" alt="image-20240423170848646"></p><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240423171000144.png" alt="image-20240423171000144"></p><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504180601873.png" alt="image-20240504180601873"></p><blockquote><ol><li><strong>lw</strong>：这是”Load Word”的缩写。它从内存中加载一个32位的字（word）到寄存器中。具体来说，它将内存中指定地址的32位数据加载到目标寄存器中。</li><li><strong>lb</strong>：这是”Load Byte”的缩写。它从内存中加载一个8位的字节（byte）到寄存器中。与lw不同，lb将会把加载的字节进行符号扩展，即最高位的值会被复制到目标寄存器的所有高位上，以保持字节的符号性。</li></ol><p>举个例子，如果在地址0x100处的内存中存储着0xFF123456，当你用lw指令加载0x100地址的数据时，你会得到0xFF123456；但是当你用lb指令加载同样的地址时，你会得到0xFFFFFF56，因为最高位是1，这个字节是负数。</p></blockquote><h2 id="Branches类型"><a href="#Branches类型" class="headerlink" title="Branches类型"></a>Branches类型</h2><p><u>Branch – change of control flow</u></p><h3 id="Conditional-Branch-–-change-control-flow-depending-on-outcome-of-comparison"><a href="#Conditional-Branch-–-change-control-flow-depending-on-outcome-of-comparison" class="headerlink" title="Conditional Branch – change control flow  depending on outcome of comparison"></a>Conditional Branch – change control flow  depending on outcome of comparison</h3><ul><li><p><strong>beq: branch if equal</strong></p></li><li><p><strong>bne: branch if not equal</strong></p></li><li><p><strong>blt: branch if less than</strong></p></li><li><p><strong>bge:  branch if greater  than or equal</strong></p></li><li><p><strong>bltu: unsigned versions of blt</strong></p></li><li><p><strong>bgeu: unsigned versions of bge</strong></p></li></ul><h3 id="Unconditional-Branch-–-always-branch"><a href="#Unconditional-Branch-–-always-branch" class="headerlink" title="Unconditional Branch – always branch"></a>Unconditional Branch – always branch</h3><ul><li><strong>j: jump</strong><ul><li>j label</li></ul></li></ul><p>No <code>bgt</code> or <code>ble</code>!</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beq reg1, reg2, L1</span><br><span class="line"></span><br><span class="line"># go to statement labeled L1 </span><br><span class="line"># if (value in reg1) == (value in reg2)</span><br><span class="line"># ….otherwise, go to next statement</span><br></pre></td></tr></table></figure><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240423171733270.png" alt="image-20240423171733270"></p><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240423171742425.png" alt="image-20240423171742425"></p><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240423171750240.png" alt="image-20240423171750240"></p><h2 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h2><ul><li>C<ul><li>while</li><li>do…while</li><li>for</li></ul></li><li>每一个都可以被重写成另外两个之一，因此相同的分支方法也可以应用到这些循环中。</li><li>关键概念：虽然在 RISC-V 中有多种编写循环的方式，但决策的关键在于条件分支。</li></ul><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240423230114369.png" alt="image-20240423230114369"></p><h2 id="Logical-Instructions"><a href="#Logical-Instructions" class="headerlink" title="Logical Instructions"></a>Logical Instructions</h2><ul><li><p>有助于在一个字内操作位字段</p><ul><li>例如，一个字内的字符（8位）</li></ul></li><li><p>将位打包&#x2F;解包成字的操作</p></li></ul><blockquote><p>对于一个字（8个位，例如二进制数字或字符），在其中操作位字段（例如单独的字符）是很有用的。这就像在一个字母里面寻找、添加或者移除特定的位一样。这些操作可能包括将多个位打包（合并）成一个字，或者将一个字解包（拆分）成多个位。这些操作通常被称为逻辑操作。</p></blockquote><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240423230525052.png" alt="image-20240423230525052"></p><h3 id="and-andi"><a href="#and-andi" class="headerlink" title="and&#x2F;andi"></a>and&#x2F;andi</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and x5, x6, x7 # x5 = x6 &amp; x7</span><br><span class="line">andi x5, x6, 3 # x5 = x6 &amp; 3</span><br></pre></td></tr></table></figure><ul><li><code>andi</code> with <code>0000 00FF</code><del>hex</del> isolates the <strong>least</strong> significant  byte</li><li><code>andi </code>with <code>FF00 0000</code><del>hex</del> isolates the <strong>most</strong> significant  byte</li></ul><h3 id="No-Not-in-RISC-V"><a href="#No-Not-in-RISC-V" class="headerlink" title="No Not in RISC-V"></a>No Not in RISC-V</h3><p>没有逻辑非运算在RISC-V中</p><ul><li>使用xor 1111 1111<del>two</del></li></ul><h3 id="Logical-Shifting"><a href="#Logical-Shifting" class="headerlink" title="Logical Shifting"></a>Logical Shifting</h3><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240423231142563.png" alt="image-20240423231142563"></p><h3 id="Arithmetic-Shifting"><a href="#Arithmetic-Shifting" class="headerlink" title="Arithmetic Shifting"></a>Arithmetic Shifting</h3><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240423231149137.png" alt="image-20240423231149137"></p><h1 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h1><h2 id="函数调用的六个步骤"><a href="#函数调用的六个步骤" class="headerlink" title="函数调用的六个步骤"></a>函数调用的六个步骤</h2><ol><li>将<strong>参数</strong>放在函数能够访问的位置</li><li>转交权利给函数</li><li>请求函数所需要的内存资源</li><li>执行函数预期的任务</li><li>将<strong>返回值</strong>放在调用者可以访问的位置并恢复你用过的寄存器；释放内存空间</li><li>将控制返回调用者，因为一个函数可以被许多项目中的程序点调用</li></ol><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504182714948.png" alt="image-20240504182714948"></p><h2 id="函数的指令支持"><a href="#函数的指令支持" class="headerlink" title="函数的指令支持"></a>函数的指令支持</h2><p>在RISC-V中，所有的指令都是4bytes，并且他们像数据一样存储在内存中</p><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504183024465.png" alt="image-20240504183024465"></p><ul><li>问题: 为什么这里用<code>jr</code>而不是<code>j</code>?</li><li>答案: sum可能在许多地方被调用，所以我们不可能总是回到固定的位置。sum的调用过程必须能够说”回到这里”。</li></ul><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504183415048.png" alt="image-20240504183415048"></p><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504183500943.png" alt="image-20240504183500943"></p><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504183558222.png" alt="image-20240504183558222"></p><h3 id="jal-Jump-and-Link"><a href="#jal-Jump-and-Link" class="headerlink" title="jal (Jump and Link)"></a>jal (Jump and Link)</h3><ul><li><p><strong>指令格式</strong>：<code>jal rd, offset</code></p></li><li><p><strong>功能</strong>：跳转到指定地址，并将下一条指令的地址存储到目标寄存器中（通常用于存储返回地址）。</p></li><li><p>操作</p><p>：</p><ul><li>将当前指令的地址（PC寄存器的值）加上偏移量作为目标地址。</li><li>将下一条指令的地址（PC+4）存储到目标寄存器中。</li></ul></li><li><p><strong>示例</strong>：<code>jal x1, 100</code> 表示跳转到地址为 PC+100 处，并将 PC+4 存储到寄存器 x1 中。</p></li></ul><h3 id="jalr-Jump-and-Link-Register"><a href="#jalr-Jump-and-Link-Register" class="headerlink" title="jalr (Jump and Link Register)"></a>jalr (Jump and Link Register)</h3><ul><li><p><strong>指令格式</strong>：<code>jalr rd, rs1, offset</code></p></li><li><p><strong>功能</strong>：跳转到指定地址（通过寄存器计算得出），并将下一条指令的地址存储到目标寄存器中（通常用于存储返回地址）。</p></li><li><p>操作</p><p>：</p><ul><li>将当前指令的地址（PC寄存器的值）加上偏移量，并将结果与 rs1 寄存器的值相加作为目标地址。</li><li>将下一条指令的地址（PC+4）存储到目标寄存器中。</li></ul></li><li><p><strong>示例</strong>：<code>jalr x1, x2, 0</code> 表示跳转到地址为 x2 的值加上偏移量 0 所指示的地址，并将 PC+4 存储到寄存器 x1 中。</p></li></ul><h3 id="用法比较"><a href="#用法比较" class="headerlink" title="用法比较"></a>用法比较</h3><ul><li><code>jal</code> 直接跳转到指定地址，适用于跳转到相对地址已知的情况。</li><li><code>jalr</code> 可以通过寄存器计算跳转地址，适用于跳转到相对地址不确定但通过寄存器存储的情况。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>准确来说，只有两个指令</p><ul><li><code>jal rd, Label</code> - jump-and-link</li><li><code>jalr rd, rs, imm </code>- jump -and-link register</li></ul><p><code>j</code>, <code>jr</code> 和 <code>ret</code> 是伪指令!</p><ul><li><code>j: jal x0, Label</code></li></ul><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504184434837.png" alt="image-20240504184434837"></p><h2 id="之前的寄存器值在函数调用之后保存在哪里以便恢复它们？"><a href="#之前的寄存器值在函数调用之后保存在哪里以便恢复它们？" class="headerlink" title="之前的寄存器值在函数调用之后保存在哪里以便恢复它们？"></a>之前的寄存器值在函数调用之后保存在哪里以便恢复它们？</h2><ul><li>在函数调用前需要一个地方去保存旧的值，以便在返回时恢复它们，然后删除。</li><li>解决方案就是使用<strong>栈</strong>-last-in-first-out (LIFO) queue<ul><li>Push: placing data onto stack</li><li>Pop: removing data from stack</li></ul></li></ul><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504185029541.png" alt="image-20240504185029541"></p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><ul><li><p>栈帧包括：</p><ul><li><p>返回“指令”地址</p></li><li><p>参数（参数）</p></li><li><p>其他局部变量的空间</p></li></ul></li><li><p>栈帧是内存中连续的块；栈指针告诉我们栈帧的<strong>底部</strong>在哪里。 </p></li><li><p>当过程结束时，栈帧被从栈中移除；为未来的栈帧释放内存。</p><blockquote><p>sp从内存高到低增长</p></blockquote></li></ul><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504185222086.png" alt="image-20240504185222086"></p><h2 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h2><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504185336899.png" alt="image-20240504185336899"></p><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504185346548.png" alt="image-20240504185346548"></p><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504185436994.png" alt="image-20240504185436994"></p><h1 id="嵌套调用和寄存器约定"><a href="#嵌套调用和寄存器约定" class="headerlink" title="嵌套调用和寄存器约定"></a>嵌套调用和寄存器约定</h1><h2 id="嵌套调用"><a href="#嵌套调用" class="headerlink" title="嵌套调用"></a>嵌套调用</h2><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504185906529.png" alt="image-20240504185906529"></p><ul><li>有一个叫做<code>sumSquare</code>的函数，现在<code>sumSquare</code>正在调用<code>mult</code>。</li><li>所以在<code>sumSquare</code>想要跳回的<code>ra</code>寄存器中有一个值，但是这个值将会被对<code>mult</code>的调用<strong>覆盖</strong>。</li><li><strong>嵌套过程需要在调用<code>mult</code>之前保存<code>sumSquare</code>的返回地址 - 再次使用栈。</strong></li></ul><h2 id="寄存器约定"><a href="#寄存器约定" class="headerlink" title="寄存器约定"></a>寄存器约定</h2><ul><li>Caller: 调用函数</li><li>Callee: 被调用的函数</li><li>当被调用函数执行完毕后，调用者需要知道哪些寄存器可能已经改变，哪些是保证不变的。</li><li><strong>寄存器约定</strong>：一组被广泛接受的规则，规定了在过程调用（<code>jal</code>）后哪些寄存器不会改变，哪些可能会改变。</li></ul><p>为了减少因溢出和恢复寄存器而产生的昂贵的加载和存储操作，RISC-V函数调用约定将寄存器分为两类：</p><ol><li><p>在函数调用中保留的寄存器：</p><ul><li>调用者可以依赖于其值不变</li><li>sp、gp、tp、”保存的寄存器” s0-s11（s0也是fp）</li></ul></li><li><p>在函数调用中不保留的寄存器：</p><ul><li><p>调用者不能依赖于其值不变</p></li><li><p>参数&#x2F;返回寄存器 a0-a7、ra、”临时寄存器” t0-t6</p></li></ul></li></ol><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504190209798.png" alt="image-20240504190209798"></p><h1 id="Memory-Allocation"><a href="#Memory-Allocation" class="headerlink" title="Memory Allocation"></a>Memory Allocation</h1><h2 id="在栈中分配空间"><a href="#在栈中分配空间" class="headerlink" title="在栈中分配空间"></a>在栈中分配空间</h2><ul><li><p>C语言有两种存储类别：自动的和静态的。</p><ul><li><p><strong>自动</strong>变量是函数局部的，并在函数退出时被丢弃。</p></li><li><p><strong>静态</strong>变量存在于程序从一个过程退出到另一个过程进入的过程中。</p></li></ul></li><li><p>使用栈来存储不适合寄存器的自动（局部）变量。 </p></li><li><p><strong>过程帧</strong>或<strong>激活记录</strong>：栈中的一个段，包含保存的寄存器和局部变量。</p></li></ul><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504191040378.png" alt="image-20240504191040378"></p><h2 id="使用栈"><a href="#使用栈" class="headerlink" title="使用栈"></a>使用栈</h2><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504191206346.png" alt="image-20240504191206346"></p><h2 id="内存分配Memory-Allocation"><a href="#内存分配Memory-Allocation" class="headerlink" title="内存分配Memory Allocation"></a>内存分配Memory Allocation</h2><p>当运行C程序时，有三个重要的内存区域被分配：</p><ul><li><strong>静态区</strong>：一次性声明的变量，程序执行完毕后才消失 - 例如，C全局变量</li><li><strong>堆</strong>：通过malloc动态声明的变量</li><li><strong>栈</strong>：在执行过程中被过程使用的空间；这是我们可以保存寄存器值的地方</li></ul><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504191550643.png" alt="image-20240504191550643"></p><h2 id="Where-is-the-Stack-in-Memory"><a href="#Where-is-the-Stack-in-Memory" class="headerlink" title="Where is the Stack in Memory?"></a>Where is the Stack in Memory?</h2><p>RV32约定（RV64&#x2F;RV128具有不同的内存布局）</p><ul><li><strong>栈</strong>从高地址开始并向下增长<ul><li>十六进制：bfff_fff0<del>hex</del></li><li>栈必须对齐到16字节边界（在之前的示例中不是这样）</li></ul></li><li>RV32程序（<strong>文本段</strong>）在低端<ul><li>0001_0000<del>hex</del></li></ul></li><li><strong>静态数据段</strong>（常量和其他静态变量）在文本段上方，用于存放静态变量<ul><li>RISC-V约定<strong>全局指针（gp）</strong>指向静态变量</li><li>RV32 gp &#x3D; 1000_0000<del>hex</del></li></ul></li><li><strong>堆</strong>位于静态数据段上方，用于存放增长和收缩的数据结构；堆向高地址增长</li></ul><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504191730738.png" alt="image-20240504191730738"></p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p><img src="/2024/04/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RISCV-Assembly/image-20240504191745535.png" alt="image-20240504191745535"></p>]]></content>
      
      
      <categories>
          
          <category> 体系结构 </category>
          
          <category> CS61C </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 体系结构 </tag>
            
            <tag> CS61C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61C项目笔记(二)-Lab3-RISCV-Assembly</title>
      <link href="/2024/04/23/C-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-2-CS61C%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab3-RISCV-Assembly/"/>
      <url>/2024/04/23/C-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-2-CS61C%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab3-RISCV-Assembly/</url>
      
        <content type="html"><![CDATA[<h1 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">.word 2, 4, 6, 8</span><br><span class="line">n: .word 9</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">main:</span><br><span class="line">    add t0, x0, x0</span><br><span class="line">    addi t1, x0, 1</span><br><span class="line">    la t3, n</span><br><span class="line">    lw t3, 0(t3)</span><br><span class="line">fib:</span><br><span class="line">    beq t3, x0, finish</span><br><span class="line">    add t2, t1, t0</span><br><span class="line">    mv t0, t1</span><br><span class="line">    mv t1, t2</span><br><span class="line">    addi t3, t3, -1</span><br><span class="line">    j fib</span><br><span class="line">finish:</span><br><span class="line">    addi a0, x0, 1</span><br><span class="line">    addi a1, t0, 0</span><br><span class="line">    ecall # print integer ecall</span><br><span class="line">    addi a0, x0, 10</span><br><span class="line">    ecall # terminate ecall</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Q</strong>: <code>.data</code>、 <code>.word</code>,<code> .text</code>指令的作用是什么?</p><p><strong>A</strong>: 汇编语言编程中，像<code>.data</code>、<code>.word</code>和<code>.text</code>这样的指令用于指定代码的不同部分，并定义数据和指令。</p><ul><li><code>.data</code>：该指令标志着数据声明的开始部分。通常后面会跟着变量或常量的声明。在你的示例中：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">.word 2, 4, 6, 8</span><br><span class="line">n: .word 9</span><br></pre></td></tr></table></figure><p>这个部分声明了一个整数数组，包含值2、4、6和8，并且一个变量<code>n</code>被初始化为值9。</p><ul><li><p><code>.word</code>：该指令用于在内存中分配存储单词大小的数据空间（通常是32位或4字节）。在示例中，它用于初始化数组和变量<code>n</code>。</p></li><li><p><code>.text</code>：该指令标志着代码段的开始部分，其中包含了指令。在示例中：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">main:</span><br><span class="line">    ···</span><br><span class="line">fib:</span><br><span class="line">    ···</span><br><span class="line">finish:</span><br><span class="line">    ···</span><br></pre></td></tr></table></figure><h1 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int source[] = &#123;3, 1, 4, 1, 5, 9, 0&#125;;</span><br><span class="line">int dest[10];</span><br><span class="line"></span><br><span class="line">int fun(int x) &#123;</span><br><span class="line">return -x * (x + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int k;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (k = 0; source[k] != 0; k++) &#123;</span><br><span class="line">        dest[k] = fun(source[k]);</span><br><span class="line">        sum += dest[k];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">.globl main</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line"># 初始化数组</span><br><span class="line">source:</span><br><span class="line">    .word   3</span><br><span class="line">    .word   1</span><br><span class="line">    .word   4</span><br><span class="line">    .word   1</span><br><span class="line">    .word   5</span><br><span class="line">    .word   9</span><br><span class="line">    .word   0</span><br><span class="line">dest:</span><br><span class="line">    .word   0</span><br><span class="line">    .word   0</span><br><span class="line">    .word   0</span><br><span class="line">    .word   0</span><br><span class="line">    .word   0</span><br><span class="line">    .word   0</span><br><span class="line">    .word   0</span><br><span class="line">    .word   0</span><br><span class="line">    .word   0</span><br><span class="line">    .word   0</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">fun:</span><br><span class="line">    addi t0, a0, 1</span><br><span class="line">    sub t1, x0, a0</span><br><span class="line">    mul a0, t0, t1</span><br><span class="line">    jr ra</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">    # BEGIN PROLOGUE</span><br><span class="line">    addi sp, sp, -20</span><br><span class="line">    sw s0, 0(sp)    # SUM</span><br><span class="line">    sw s1, 4(sp)    # SOURCE指针</span><br><span class="line">    sw s2, 8(sp)    # DEST指针</span><br><span class="line">    sw s3, 12(sp)</span><br><span class="line">    sw ra, 16(sp)</span><br><span class="line">    # END PROLOGUE</span><br><span class="line">addi t0, x0, 0# K</span><br><span class="line">    addi s0, x0, 0</span><br><span class="line">    la s1, source</span><br><span class="line">    la s2, dest</span><br><span class="line">loop:</span><br><span class="line">    slli s3, t0, 2   # 偏移量</span><br><span class="line">    add t1, s1, s3   # source偏移后的地址</span><br><span class="line">    lw t2, 0(t1)     # source[k]的值</span><br><span class="line">    # CONDITION</span><br><span class="line">    beq t2, x0, exit</span><br><span class="line">    add a0, x0, t2   # a0存储source[k]的值，以便后面传参</span><br><span class="line">    # JUMP FUN</span><br><span class="line">    addi sp, sp, -8</span><br><span class="line">    sw t0, 0(sp)</span><br><span class="line">    sw t2, 4(sp)</span><br><span class="line">    jal fun          # a0存储着fun返回的值</span><br><span class="line">    lw t0, 0(sp)</span><br><span class="line">    lw t2, 4(sp)</span><br><span class="line">    addi sp, sp, 8</span><br><span class="line">    # BACK</span><br><span class="line">    add t2, x0, a0   # t2代a0</span><br><span class="line">    add t3, s2, s3   # dest偏移后的地址</span><br><span class="line">    sw t2, 0(t3)     # 将结果存入dest</span><br><span class="line">    add s0, s0, t2   # sum += t2</span><br><span class="line"></span><br><span class="line">    addi t0, t0, 1   # k++</span><br><span class="line">    jal x0, loop</span><br><span class="line">exit:</span><br><span class="line">    add a0, x0, s0   # return sum</span><br><span class="line">    # BEGIN EPILOGUE</span><br><span class="line">    lw s0, 0(sp)</span><br><span class="line">    lw s1, 4(sp)</span><br><span class="line">    lw s2, 8(sp)</span><br><span class="line">    lw s3, 12(sp)</span><br><span class="line">    lw ra, 16(sp)</span><br><span class="line">    addi sp, sp, 20</span><br><span class="line">    # END EPILOGUE</span><br><span class="line">    jr ra</span><br></pre></td></tr></table></figure><h1 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">.globl factorial</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">n: .word 8</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">main:</span><br><span class="line">    la t0, n</span><br><span class="line">    lw a0, 0(t0)</span><br><span class="line">    jal ra, factorial</span><br><span class="line"></span><br><span class="line">    addi a1, a0, 0</span><br><span class="line">    addi a0, x0, 1</span><br><span class="line">    ecall # Print Result</span><br><span class="line"></span><br><span class="line">    addi a1, x0, &#x27;\n&#x27;</span><br><span class="line">    addi a0, x0, 11</span><br><span class="line">    ecall # Print newline</span><br><span class="line"></span><br><span class="line">    addi a0, x0, 10</span><br><span class="line">    ecall # Exit</span><br><span class="line"></span><br><span class="line">factorial:</span><br><span class="line">    # YOUR CODE HERE</span><br><span class="line">    addi sp, sp, -8</span><br><span class="line">    sw t1, 0(sp)</span><br><span class="line">    sw t2, 4(sp)</span><br><span class="line">    addi t1, x0, 1</span><br><span class="line">    add t2, a0, x0</span><br><span class="line">Loop:</span><br><span class="line">    beq t2, t1, Done</span><br><span class="line">    sub t2, t2, t1</span><br><span class="line">    mul a0, a0, t2</span><br><span class="line">    j Loop</span><br><span class="line">Done:</span><br><span class="line">    lw t2, 4(sp)</span><br><span class="line">    lw t1, 0(sp)</span><br><span class="line">    addi sp, sp, 8</span><br><span class="line">    jr ra</span><br></pre></td></tr></table></figure><h1 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h1><ol><li>在 <code>simple_fn</code>、<code>naive_pow</code> 和 <code>inc_arr</code> 函数中，调用约定错误是由于未正确保存和恢复被调用的寄存器所致。在 <code>simple_fn</code> 中，没有保存和恢复 <code>ra</code> 寄存器；在 <code>naive_pow</code> 中，没有保存和恢复 <code>s0</code> 寄存器；在 <code>inc_arr</code> 中，没有保存和恢复 <code>ra</code> 寄存器。</li><li>在 RISC-V 中，调用函数是通过跳转实现的，并将返回地址存储在 <code>ra</code> 寄存器中。然而，调用约定仅适用于实际的函数调用，而不适用于跳转到标签（如 <code>naive_pow_loop</code> 或 <code>naive_pow_end</code>）。因此，在这种情况下，调用约定不适用于这些标签。</li><li>我们需要在 <code>inc_arr</code> 函数中保存和恢复 <code>ra</code> 寄存器，因为在函数内部调用了另一个函数 <code>helper_fn</code>。根据调用约定，被调用的函数必须保存并恢复 <code>ra</code> 寄存器。而其他函数没有调用其他函数，因此不需要在其中保存和恢复 <code>ra</code> 寄存器。</li><li>虽然 <code>helper_fn</code> 函数也违反了调用约定（未保存和恢复被调用的寄存器），但 Venus CC 检查器可能没有报告这个错误。这是因为检查器主要关注寄存器的直接使用情况，而不会分析通过指针间接访问的内存位置的修改。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 体系结构 </category>
          
          <category> CS61C </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 体系结构 </tag>
            
            <tag> CS61C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61C项目笔记(一)-Lab1-编译调试初体验</title>
      <link href="/2024/04/13/C-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-1-CS61C%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab1-%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2024/04/13/C-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-1-CS61C%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab1-%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="C的编译和运行"><a href="#C的编译和运行" class="headerlink" title="C的编译和运行"></a>C的编译和运行</h1><p>在本实验中，我们将使用命令行程序 gcc 在 C 语言中编译程序。运行 gcc 的最简单方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc program.c</span><br></pre></td></tr></table></figure><p>这会将 program.c 编译为名为 a.out 的可执行文件。如果你学过 CS61B 或有 Java 经验，你可以把 gcc 看作是 Java 的 C 等价物。可以使用以下命令运行此文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br></pre></td></tr></table></figure><p>可执行文件是 <code>a.out</code> ，那么到底 <code>./</code> 是干什么用的呢？答：当您要执行可执行文件时，您需要在文件路径前面加上一个文件路径，以便将您的命令与 python3 等命令区分开来。该点表示“当前目录”。顺便说一句，双点 （ <code>..</code> ） 表示更高一级的目录。</p><p><code>gcc</code> 有各种命令行选项，鼓励您探索。但是，在本实验中，我们将仅使用 <code>-o</code> ，它用于指定 <code>gcc</code> 创建的可执行文件的名称。您可以使用以下命令编译 <code>program.c</code> 为名为 program 的程序，然后运行它。如果您不希望所有可执行文件都命名 <code>a.out</code> ，这将很有帮助。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o program program.c</span><br><span class="line">$ ./program</span><br></pre></td></tr></table></figure><blockquote><p>若编译的程序需要调试，加上-g指令</p></blockquote><h1 id="C的调试器——gdb"><a href="#C的调试器——gdb" class="headerlink" title="C的调试器——gdb"></a>C的调试器——gdb</h1><p>在本练习中，您会发现 GDB 参考卡很有用。GDB 代表“GNU De-Bugger”。 <code>hello.c</code> 使用 <code>-g</code> 标志编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g -o hello hello.c</span><br></pre></td></tr></table></figure><p>这会导致 gcc 将信息存储在可执行程序中，以便 <code>gdb</code> 理解它。现在启动调试器 （c）gdb：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cgdb hello</span><br></pre></td></tr></table></figure><p>学习这些命令将对本实验的其余部分以及您的 C 编程生涯很有用。在名为 <code>gdb.txt</code> 的文本文件中，回答以下问题。</p><ol><li>当您处于 gdb 会话中时，如何<strong>设置在程序运行时将传递给程序的参数</strong>？<ol><li><em>set args arg1 arg2</em></li></ol></li><li>如何<strong>创建断点</strong>？<ol><li><em>break <name></name></em></li></ol></li><li>在断点处停止后，如何在程序中<strong>执行下一行 C 代码</strong>？<ol><li><em>next or n</em></li></ol></li><li>如果下一行代码是函数调用，则使用对 #3 的答案，则将立即执行整个函数调用。（如果没有，请考虑对 #3 使用不同的命令！你如何告诉GDB<strong>你想调试函数内部的代码</strong>（即单步执行函数）？（如果您将答案更改为 #3，那么该答案现在很可能适用于此处。<ol><li><em>step or s</em></li></ol></li><li><strong>在断点停止后如何继续程序</strong>？<ol><li><em>continue or c</em></li></ol></li><li>如何在 gdb 中<strong>打印变量</strong>（甚至是像 1+2 这样的表达式）的值？<ol><li><em>ptint <variable_name></variable_name></em></li><li><em>print 1+2</em></li></ol></li><li>如何配置 gdb 以便它<strong>在每个步骤后显示变量的值</strong>？<ol><li><em>display variable_name</em></li></ol></li><li>如何在当前函数中<strong>显示所有变量及其值的列表</strong>？<ol><li><em>info locals</em></li></ol></li><li>你如何<strong>退出</strong> gdb？<ol><li><em>quit or q</em></li></ol></li></ol><h1 id="重定向——使用包含你输入的文本文件来运行"><a href="#重定向——使用包含你输入的文本文件来运行" class="headerlink" title="重定向——使用包含你输入的文本文件来运行"></a>重定向——使用包含你输入的文本文件来运行</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out &lt; fileName.txt</span><br></pre></td></tr></table></figure><h1 id="Valgrind’ing工具"><a href="#Valgrind’ing工具" class="headerlink" title="Valgrind’ing工具"></a>Valgrind’ing工具</h1><p>Valgrind 是一个模拟您的 CPU 并跟踪您的内存访问的程序。这会减慢您正在运行的进程（例如，这就是为什么我们并不总是在 Valgrind 中运行所有可执行文件的原因），但也可能会暴露可能仅在一组特殊情况下显示可见的错误行为的错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind ./segfault_ex</span><br></pre></td></tr></table></figure><p>这应该会导致 Valgrind 输出发生非法访问的位置。将这些结果与您通过打开文件确定的结果进行比较。Valgrind 如何帮助您解决未来的段错误？现在尝试在 <code>no_segfault_ex</code> 上运行 Valgrind。程序不应该崩溃，但文件仍然存在问题。Valgrind可以帮助我们找到（看似看不见的）问题。</p><p>不幸的是，在这里您会看到 Valgrind 似乎无法告诉您问题的确切位置。<strong>使用 Valgrind 提供的消息来确定哪个变量具有未定义的行为，然后尝试推断一定发生了什么</strong>（提示：什么是未初始化的值？</p><p>At this point we do not expect you to be familiar with <code>sizeof</code> (that comes next week!) so all we want 在这一点上，我们不希望您熟悉 <code>sizeof</code> （下周！），因此我们希望您从本节中得到的只是关于问题可能发生位置的一些直觉。</p><p>希望在完成此示例后，您将能够理解并回答以下问题：</p><ul><li>为什么 Valgrind 很重要，它有什么用？</li><li>你如何在 Valgrind 中运行程序？</li><li>您如何解释错误消息？不要害怕他们。尽力而为，向我们寻求帮助。</li><li>为什么未初始化的变量会导致“heisenbugs”？</li></ul><p>我们现在向您介绍 Valgrind，因为它是一个非常重要的工具，一旦您开始编写 C，您就会想要它。<strong>然而，要真正理解它，我们需要了解 C 的内存模型，我们将在下周完成。</strong>在讲座中介绍完记忆后，回到这个实验并尝试回答以下问题：</p><ul><li>为什么 <code>no_segfault_ex</code> 程序<strong>没有</strong>段错误？</li><li>为什么 <code>no_segfault_ex</code> 会产生不一致的输出？</li><li>为什么不正确 <code>sizeof</code> ？你怎么能仍然使用 <code>sizeof</code> ，但要使代码正确？</li></ul>]]></content>
      
      
      <categories>
          
          <category> 体系结构 </category>
          
          <category> CS61C </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 体系结构 </tag>
            
            <tag> CS61C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-CS61C学习笔记-C语言介绍</title>
      <link href="/2024/04/07/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-C%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/04/07/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-C%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 体系结构 </category>
          
          <category> CS61C </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 体系结构 </tag>
            
            <tag> CS61C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61C学习笔记(一)-数字表示法</title>
      <link href="/2024/04/07/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
      <url>/2024/04/07/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="位-Bits-能表示一切！"><a href="#位-Bits-能表示一切！" class="headerlink" title="位(Bits)能表示一切！"></a>位(Bits)能表示一切！</h1><p><img src="/2024/04/07/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E6%B3%95/image-20240407224529490.png" alt="image-20240407224529490"></p><h2 id="Binary、Decimal、Hex"><a href="#Binary、Decimal、Hex" class="headerlink" title="Binary、Decimal、Hex"></a>Binary、Decimal、Hex</h2><p><img src="/2024/04/07/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E6%B3%95/image-20240407224633741.png" alt="image-20240407224633741"></p><h2 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h2><p><img src="/2024/04/07/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E6%B3%95/image-20240407224702160.png" alt="image-20240407224702160"></p><h2 id="二转十进制"><a href="#二转十进制" class="headerlink" title="二转十进制"></a>二转十进制</h2><p><img src="/2024/04/07/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E6%B3%95/image-20240407224721049.png" alt="image-20240407224721049"></p><h2 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h2><p><img src="/2024/04/07/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E6%B3%95/image-20240407224736051.png" alt="image-20240407224736051"></p><h2 id="十进制到二-十六进制"><a href="#十进制到二-十六进制" class="headerlink" title="十进制到二&#x2F;十六进制"></a>十进制到二&#x2F;十六进制</h2><p>从左到右赋满</p><p><img src="/2024/04/07/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E6%B3%95/image-20240407224836619.png" alt="image-20240407224836619"></p><h2 id="二进制到十六进制"><a href="#二进制到十六进制" class="headerlink" title="二进制到十六进制"></a>二进制到十六进制</h2><p>因为十六进制是逢16进1，所以取四位作为一位十六进制</p><p><img src="/2024/04/07/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E6%B3%95/image-20240407225025480.png" alt="image-20240407225025480"></p><h1 id="数字表达法"><a href="#数字表达法" class="headerlink" title="数字表达法"></a>数字表达法</h1><h2 id="无修饰"><a href="#无修饰" class="headerlink" title="无修饰"></a>无修饰</h2><ul><li>五位bits来表达<ul><li>范围是0 ~ 2^4^-1</li></ul></li></ul><h2 id="修饰"><a href="#修饰" class="headerlink" title="修饰"></a>修饰</h2><ul><li><p>五位bits中的最高位表示正负</p><ul><li>范围 -15 ~ 15</li><li>问题: <ul><li>存在两个0 (<code>00000</code>和<code>10000</code>)</li><li>中间往两边变大</li></ul></li></ul><p><img src="/2024/04/07/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E6%B3%95/image-20240407230249723.png" alt="image-20240407230249723"></p></li></ul><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>将修饰全部取反</p><p><img src="/2024/04/07/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E6%B3%95/image-20240407230621595.png" alt="image-20240407230621595"></p><p>但是有个问题，还是有两个重叠的0</p><p>所以我们把负往左移动一位 及 加一位，于是获得了补码</p><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p><img src="/2024/04/07/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E6%B3%95/image-20240407230830977.png" alt="image-20240407230830977"></p><p><img src="/2024/04/07/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E6%B3%95/image-20240407230952371.png" alt="image-20240407230952371"></p><h2 id="偏置"><a href="#偏置" class="headerlink" title="偏置"></a>偏置</h2><p><img src="/2024/04/07/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-CS61C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E6%B3%95/image-20240407230903149.png" alt="image-20240407230903149"></p><p>注意: 是 <strong>未修饰 加上 bias偏置</strong></p>]]></content>
      
      
      <categories>
          
          <category> 体系结构 </category>
          
          <category> CS61C </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 体系结构 </tag>
            
            <tag> CS61C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22-CS61B学习笔记-Rd21-拓扑排序与DAG和还原与分解</title>
      <link href="/2024/04/06/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-22-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd21-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8EDAG%E5%92%8C%E8%BF%98%E5%8E%9F%E4%B8%8E%E5%88%86%E8%A7%A3/"/>
      <url>/2024/04/06/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-22-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd21-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8EDAG%E5%92%8C%E8%BF%98%E5%8E%9F%E4%B8%8E%E5%88%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="目前关于图的问题"><a href="#目前关于图的问题" class="headerlink" title="目前关于图的问题"></a>目前关于图的问题</h1><table><thead><tr><th>Problem</th><th>Problem Description</th><th>Solution</th><th>Efficiency</th></tr></thead><tbody><tr><td>paths</td><td>Find a path from s to every reachable vertex.</td><td>DepthFirstPaths.java<a href="https://docs.google.com/presentation/d/1lTo8LZUGi3XQ1VlOmBUF9KkJTW_JWsw_DOPq8VBiI3A/edit?usp=sharing">Demo</a></td><td>O(V+E) timeΘ(V) space</td></tr><tr><td>shortest paths</td><td>Find the shortest path from s to every reachable vertex.</td><td>BreadthFirstPaths.java<a href="https://docs.google.com/presentation/d/1JoYCelH4YE6IkSMq_LfTJMzJ00WxDj7rEa49gYmAtc4/edit?usp=sharing">Demo</a></td><td>O(V+E) timeΘ(V) space</td></tr><tr><td>shortest weighted paths</td><td>Find the shortest path, considering weights, from s to every reachable vertex.</td><td>DijkstrasSP.java<a href="https://docs.google.com/presentation/d/1_bw2z1ggUkquPdhl7gwdVBoTaoJmaZdpkV6MoAgxlJc/pub?start=false&loop=false&delayms=3000">Demo</a></td><td>O(E log V) timeΘ(V) space</td></tr><tr><td>shortest weighted path</td><td>Find the shortest path, consider weights, from s to some target vertex</td><td>A*: Same as Dijkstra’s but with h(v, goal) added to priority of each vertex.<a href="https://docs.google.com/presentation/d/177bRUTdCa60fjExdr9eO04NHm0MRfPtCzvEup1iMccM/edit#slide=id.g369665031c_0_350">Demo</a></td><td>Time depends on heuristic.Θ(V) space</td></tr><tr><td>minimum spanning tree</td><td>Find a minimum spanning tree.</td><td>LazyPrimMST.java<a href="https://docs.google.com/presentation/d/18leOHESniaJqqehiTR-YAL4WeEEcHJyRB9aw_S1FLG0/edit#slide=id.g772f8a8e2_0_28">Demo</a></td><td>O(???) timeΘ(???) space</td></tr><tr><td>minimum spanning tree</td><td>Find a minimum spanning tree.</td><td>PrimMST.java<a href="https://docs.google.com/presentation/d/1GPizbySYMsUhnXSXKvbqV4UhPCvrt750MiqPPgU-eCY/edit#slide=id.g9a60b2f52_0_0">Demo</a></td><td>O(E log V) timeΘ(V) space</td></tr><tr><td>minimum spanning tree</td><td>Find a minimum spanning tree.</td><td>KruskalMST.java<a href="https://docs.google.com/presentation/d/18leOHESniaJqqehiTR-YAL4WeEEcHJyRB9aw_S1FLG0/edit#slide=id.g5347e2c8f_2213">Demo</a></td><td>O(E log E) timeΘ(E) sp</td></tr></tbody></table><h1 id="拓扑排序与DAG"><a href="#拓扑排序与DAG" class="headerlink" title="拓扑排序与DAG"></a>拓扑排序与DAG</h1><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>假设我们收集了不同的任务或活动，其中一些任务或活动必须在另一个任务或活动之前发生。我们如何找到对任务的排序，以便对于每个任务 <em>v</em> ，之前 <em>v</em> 发生的任务在我们的排序中更早出现？</p><p>我们可以首先将任务集合视为一个图，其中每个节点代表一个任务。边<em>v</em>→<em>w</em> 表示 <em>v</em> 必须在 <em>w</em> 之前发生。现在，我们原来的问题被简化为找到一个拓扑排序。</p><blockquote><p>拓扑排序：对图的顶点进行排序，使得对于每个有向边 <em>u</em>→<em>v</em> ， <em>u</em> 在排序中都排在前面 <em>v</em> 。</p></blockquote><p><img src="/2024/04/06/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-22-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd21-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8EDAG%E5%92%8C%E8%BF%98%E5%8E%9F%E4%B8%8E%E5%88%86%E8%A7%A3/21.1.1.jpg" alt="img"></p><blockquote><p><strong>问题 1.1</strong>：上图有哪些有效的拓扑顺序？<br><strong>答</strong>：[<em>D</em>,<em>B</em>,<em>A</em>,<em>E</em>,<em>C</em>,<em>F</em>], [<em>E</em>,<em>D</em>,<em>C</em>,<em>B</em>,<em>A</em>,<em>F</em>].</p></blockquote><p>需要注意的是，只有对某些类型的图进行拓扑排序才有意义。若要查看此内容，请考虑下图：</p><p><img src="/2024/04/06/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-22-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd21-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8EDAG%E5%92%8C%E8%BF%98%E5%8E%9F%E4%B8%8E%E5%88%86%E8%A7%A3/21.1.3.png" alt="img"></p><p>什么是有效的拓扑排序？</p><p>没有一个！D 在 B 之前，但 B 在 C、E、D 之前。由于我们有一个循环，因此没有定义拓扑排序。我们也不能对无向图进行拓扑排序，因为无向图中的每条边都会创建一个循环。</p><p><img src="/2024/04/06/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-22-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd21-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8EDAG%E5%92%8C%E8%BF%98%E5%8E%9F%E4%B8%8E%E5%88%86%E8%A7%A3/21.1.4.png" alt="img"><br>因此，拓扑排序仅适用于<strong>有向、无环（无周期）图或 DAG。</strong></p><blockquote><p>*<em>Topological Sort:*<em>：对 <strong>DAG</strong> 顶点的排序，使得对于每个有向边 u</em>→*v</em> ， <em>u</em> 在排序中排在前面 <em>v</em> 。</p></blockquote><p>对于任何拓扑排序，都可以重新绘制图形，使顶点全部位于一行中。因此，拓扑排序有时称为图的<strong>线性化</strong>。例如，下面是针对其中一个拓扑排序线性化的前面示例。</p><p><img src="/2024/04/06/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-22-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd21-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8EDAG%E5%92%8C%E8%BF%98%E5%8E%9F%E4%B8%8E%E5%88%86%E8%A7%A3/21.1.2.png" alt="img"></p><p>请注意，上述 DAG 的拓扑排序必须以 D 或 E 开头，并且必须以 F 或 C 结尾。因此，D 和 E 称为源，F 和 C 称为接收器。</p><h2 id="拓扑排序算法"><a href="#拓扑排序算法" class="headerlink" title="拓扑排序算法"></a>拓扑排序算法</h2><p>我们怎样才能找到拓扑排序？花点时间想想你已经知道的现有图算法可能有助于解决这个问题。</p><p>拓扑排序算法：</p><ul><li>从图形中的每个顶点执行 DFS 遍历，而不是清除遍历之间的标记。</li><li>在此过程中记录 DFS 的后序。</li><li>拓扑顺序与后顺序相反。</li></ul><p><strong>工作原理</strong>：只有在考虑了给定源点的所有后代之后，每个顶点 <em>v</em> 才会被添加到后排序列表的末尾 <em>v</em> 。因此，当任何一个 <em>v</em> 被添加到后排序列表中时，它的所有后代都已经在列表中。因此，颠倒此列表会给出拓扑排序。</p><p><img src="/2024/04/06/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-22-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd21-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8EDAG%E5%92%8C%E8%BF%98%E5%8E%9F%E4%B8%8E%E5%88%86%E8%A7%A3/image-20240406221218217.png" alt="image-20240406221218217"></p><p><img src="/2024/04/06/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-22-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd21-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8EDAG%E5%92%8C%E8%BF%98%E5%8E%9F%E4%B8%8E%E5%88%86%E8%A7%A3/image-20240406221227292.png" alt="image-20240406221227292"></p><p><img src="/2024/04/06/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-22-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd21-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8EDAG%E5%92%8C%E8%BF%98%E5%8E%9F%E4%B8%8E%E5%88%86%E8%A7%A3/image-20240406221247104.png" alt="image-20240406221247104"></p><p>由于我们只是使用 DFS，因此它的运行时分别是 <em>O</em>(<em>V</em>+<em>E</em>) ，<em>V</em> <em>E</em> 是图中的节点数和边数。</p><h3 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">topological(DAG):</span><br><span class="line">    initialize marked array</span><br><span class="line">    initialize postOrder list</span><br><span class="line">    for all vertices in DAG:</span><br><span class="line">        if vertex is not marked:</span><br><span class="line">            dfs(vertex, marked, postOrder)</span><br><span class="line">    return postOrder reversed</span><br><span class="line"></span><br><span class="line">dfs(vertex, marked, postOrder):</span><br><span class="line">    marked[vertex] = true</span><br><span class="line">    for neighbor of vertex:</span><br><span class="line">        dfs(neighbor, marked, postOrder)</span><br><span class="line">    postOrder.add(vertex)</span><br></pre></td></tr></table></figure><p><strong>（超出范围）额外的问题</strong>：我们如何使用 BFS 实现拓扑排序？提示 1：我们肯定需要存储一些额外的信息。提示 2：考虑跟踪每个顶点的度数。</p><p><strong>Solution: ：</strong></p><ol><li>计算所有顶点的度数。</li><li>选取任何 in-degree 为 0 的顶点 <em>v</em> 。</li><li>添加到 <em>v</em> 我们的拓扑排序列表。移除顶点 <em>v</em> 和从顶点出来的所有边。将顶点 <em>v</em> 的所有相邻项的度数递减 1。</li><li>重复步骤 2 和 3，直到删除所有顶点。</li></ol><p>我们如何才能有效地完成第 2 步？我们可以使用优先级等于度数的顶点的最小优先级队列。</p><h2 id="Review-回顾"><a href="#Review-回顾" class="headerlink" title="Review 回顾"></a>Review 回顾</h2><ul><li><p>拓扑排序是一种线性化<strong>有向无环图(DAG)</strong> 的方法。</p></li><li><p>我们可以使用 DFS（或 BFS）在 O*(<em>V</em>+*E) 时间内找到任何 DAG 的拓扑类型。</p></li><li></li><li><table><thead><tr><th>Problem</th><th>Problem Description</th><th>Solution</th><th>Efficiency</th></tr></thead><tbody><tr><td>topological sort</td><td>Find an ordering of vertices that respects edges of our DAG.</td><td><a href="https://docs.google.com/presentation/d/1Bvf4PooGooUCr-K9cA1kbhsNc0hXW5Jwn-QD0in-1pc/edit#slide=id.g99668982c_1_693">Demo</a>Topological.java</td><td>O(V+E) timeΘ(V) space</td></tr></tbody></table></li></ul><h1 id="DAG上的最短路径"><a href="#DAG上的最短路径" class="headerlink" title="DAG上的最短路径"></a>DAG上的最短路径</h1><p>回想一下上一节，DAG 是有向的无环图。如果我们想在 DAG 上找到最短的路径，我们可以使用 Dijkstra 的路径。但是，对于 DAG，有一个简单的最短路径算法，它也可以处理负边权重！</p><h2 id="Dijkstra-的负边权重失效"><a href="#Dijkstra-的负边权重失效" class="headerlink" title="Dijkstra 的负边权重失效"></a>Dijkstra 的负边权重失效</h2><p>回想一下，如果存在负边，Dijkstra 可能会失败，因为它依赖于这样的假设，即一旦我们访问一条边，我们就找到了通往该边的最短路径。但是，如果负边权重可以存在于我们可以看到的地方之前，那么这个假设就失败了。请看以下示例：</p><p><img src="/2024/04/06/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-22-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd21-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8EDAG%E5%92%8C%E8%BF%98%E5%8E%9F%E4%B8%8E%E5%88%86%E8%A7%A3/21.2.1.png" alt="img"></p><p>从 A 开始，Dijkstra 将首先访问 C，然后是 B（甚至从不考虑边缘 B<em>→</em>C* ）</p><p>当然，负边缘权重并不意味着 Dijkstra 一定会失败。Dijkstra’s 通过以下示例成功：</p><p><img src="/2024/04/06/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-22-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd21-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8EDAG%E5%92%8C%E8%BF%98%E5%8E%9F%E4%B8%8E%E5%88%86%E8%A7%A3/21.2.2.png" alt="img"></p><blockquote><p>从技术上讲，这取决于您对 Dijkstra 的实现。如果我们确保放宽步骤只考虑仍在队列中（尚未访问）的邻居，那么确实 B<em>→</em>C* 永远不会考虑。如果你没有这个检查，那么从技术上讲，当我们从队列中弹出最后一个节点（B）时，我们会考虑B的邻居并更新C，这为我们提供了这个特定示例的正确答案。然而，在这种情况下，人们可能会争辩说该图打破了 Dijkstra 不变量，因此 Dijkstra 已经“失败”。请注意，Dijkstra 不变性：一旦从队列中删除一个节点（访问），您就找到了该节点的最短路径。</p></blockquote><p><img src="/2024/04/06/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-22-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd21-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8EDAG%E5%92%8C%E8%BF%98%E5%8E%9F%E4%B8%8E%E5%88%86%E8%A7%A3/image-20240406221358930.png" alt="image-20240406221358930"></p><p><img src="/2024/04/06/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-22-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd21-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8EDAG%E5%92%8C%E8%BF%98%E5%8E%9F%E4%B8%8E%E5%88%86%E8%A7%A3/image-20240406221418601.png" alt="image-20240406221418601"></p><h2 id="DAG-的最短路径算法"><a href="#DAG-的最短路径算法" class="headerlink" title="DAG 的最短路径算法"></a>DAG 的最短路径算法</h2><div class="row">    <embed src="CS61BDAGSPTDemoWithNegativeEdge.pdf" width="100%" height="550" type="application/pdf"></div><p>按拓扑顺序访问顶点：</p><ul><li>每次访问时，释放所有外向的边缘</li></ul><p>回想一下用重量 <em>w</em> 释放边缘<em>u</em>→<em>v</em> 的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if distTo[u] + w &lt; distTo[v]:</span><br><span class="line">    distTo[v] = distTo[u] + w</span><br><span class="line">    edgeTo[v] = u</span><br></pre></td></tr></table></figure><p>由于我们按拓扑顺序访问顶点，因此只有在考虑了有关顶点的所有可能信息后，才会访问顶点。这意味着，如果负边权重存在于通往 <em>v</em> 的路径上，那么当我们到达 <em>v</em> ！</p><p>找到拓扑排序需要 <em>O</em>(<em>V</em>+<em>E</em>) 时间，而每个顶点的松弛也需要总共时间 <em>O</em>(<em>V</em>+<em>E</em>) 。因此，整个运行时为 <em>O</em>(<em>V</em>+<em>E</em>) 。回想一下，Dijkstra 需要 <em>O</em>((<em>V</em>+<em>E</em>)log<em>V</em>) 时间，因为我们的最小堆操作。</p><p>如果我们想解决不是 DAG 并且可能具有负边的图上的最短路径问题，该怎么办？Dijkstra 的扩展称为 Bellman Ford 可以满足您的需求，尽管它超出了本课程的范围。</p><table><thead><tr><th>Problem</th><th>Problem Description</th><th>Solution</th><th>Efficiency</th></tr></thead><tbody><tr><td>topological sort</td><td>Find an ordering of vertices that respects edges of our DAG.</td><td><a href="https://docs.google.com/presentation/d/1Bvf4PooGooUCr-K9cA1kbhsNc0hXW5Jwn-QD0in-1pc/edit#slide=id.g99668982c_1_693">Demo</a>Code: Topological.java</td><td>O(V+E) timeΘ(V) space</td></tr><tr><td>DAG shortest paths</td><td>Find a shortest paths tree on a DAG.</td><td><a href="https://docs.google.com/presentation/d/1CfnLS3FSXV8X2sXPTravZGXeBUUkcFQv7Uf2iGWGUfs/edit#slide=id.g76e0dad85_2_380">Demo</a>Code: <a href="https://algs4.cs.princeton.edu/44sp/AcyclicSP.java">AcyclicSP.java</a></td><td>O(V+E) timeΘ(V) space</td></tr></tbody></table><h1 id="最长路径"><a href="#最长路径" class="headerlink" title="最长路径"></a>最长路径</h1><h2 id="通常"><a href="#通常" class="headerlink" title="通常"></a>通常</h2><p>考虑查找从起始顶点到其他每个顶点的最长路径的问题。路径必须简单（不包含循环）。</p><p>事实证明，最著名的算法是指数级的（不切实际的低效）。</p><p>取负所有的边缘权重并找到最短路径会让我们处于一个棘手的境地，因为这样我们可能会有负循环，我们可能无限期地绕过它们。</p><h3 id="DAG-上的最长路径"><a href="#DAG-上的最长路径" class="headerlink" title="DAG 上的最长路径"></a>DAG 上的最长路径</h3><p>但是，如果我们处理的是 DAG，该怎么办？在这种情况下，我们没有循环，因此我们可以按照上面的建议进行操作：</p><ol><li>形成图形的新副本，称为 G’，所有边权重均被否定（符号翻转）。</li><li>在 G’ 上运行 DAG 最短路径，得到结果 X</li><li>翻转 X.distTo 中所有值的符号。X.edgeTo 已经正确。</li></ol><p>或者，我们可以修改上一节中的 DAG 最短路径算法，以在松弛边时选择较大的 distTo。虽然这在实践中更有意义，但考虑第一种方法的好处是能够将现有算法用作”<a href="https://en.wikipedia.org/wiki/Black_box">black box</a>“来解决新问题。我们将在下一节中详细了解此类问题解决： <a href="https://joshhug.gitbooks.io/hug61b/content/chap214.md">Reductions</a>.</p><h1 id="还原和分解"><a href="#还原和分解" class="headerlink" title="还原和分解"></a>还原和分解</h1><p>回想一下在上一节中，为了解决一个问题（最长路径），我们创建了一个新的图形 G’ 并将其输入到不同的算法中，然后解释结果。</p><p><img src="/2024/04/06/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-22-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd21-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8EDAG%E5%92%8C%E8%BF%98%E5%8E%9F%E4%B8%8E%E5%88%86%E8%A7%A3/21.4.2.png" alt="img"></p><p>这个过程称为<strong>reduction还原</strong>。由于 DAG-SPT 可用于求解 DAG-LPT，因此我们说“DAG-LPT 简化为 DAG-SPT”。</p><p>换句话说，DAG-LPT的问题可以简化为DAG-SPT的问题。</p><p>像 DAG-LPT 这样的问题可能会简化为多个其他问题。作为现实世界的类比，考虑爬山。有很多方法可以解决“爬山”的问题。</p><ul><li>“爬山”简化为“乘坐滑雪缆车”</li><li>“爬山”沦为“被大炮射出”</li><li>爬山”简化为“骑自行车上山”</li></ul><p>从形式上讲，<strong>如果任务 Q 的任何子程序都可以用来求解 P，我们说 P 简化为 Q。</strong></p><p>此定义可视化如下：</p><p><img src="/2024/04/06/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-22-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd21-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8EDAG%E5%92%8C%E8%BF%98%E5%8E%9F%E4%B8%8E%E5%88%86%E8%A7%A3/21.4.1.png" alt="img"></p><p>请注意，这只是本页第一个图形的概括。P 简化为 Q，因为 Q 用于求解 P。其工作原理是将输入 <em>x</em> 预处理成 <em>y</em> ，运行算法 Q 到 <em>y</em> ，并将输出后处理成 P 的解。这就是我们将 DAG-LPT 简化为 DAG-SPT 的方法。</p><h2 id="Reflection-反射"><a href="#Reflection-反射" class="headerlink" title="Reflection 反射"></a>Reflection 反射</h2><p>可以说，我们在整个过程中一直在reduction。</p><ul><li>Abstract Lists reduce to arrays or linked lists<br>摘要列表简化为数组或链表</li><li>Percolation reduces to Disjoint Sets<br>渗流减少到不相交集</li><li>Maze generation reduces to [your solution here ;)]<br>迷宫生成减少到 [您的解决方案在这里;)]</li></ul><p>但是，这些并不完全是减少，因为您没有使用其他单一算法来解决您的问题。值得注意的是，在前面的约简示例中，我们使用独立集算法作为’<a href="https://en.wikipedia.org/wiki/Black_box">black box</a>‘来解决 3SAT。</p><p>对于我们在课程前面所完成的工作来说，也许一个更好的术语是<em>decomposition分解</em> - 将复杂的任务分解成更小的部分。使用抽象使解决问题更容易。这是计算机科学的核心。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记-数据结构代码实现</title>
      <link href="/2024/04/06/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/04/06/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B项目笔记(四)-Lab6-文件序列化</title>
      <link href="/2024/03/23/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-5-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab6-%E6%96%87%E4%BB%B6%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2024/03/23/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-5-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab6-%E6%96%87%E4%BB%B6%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab知识点"><a href="#Lab知识点" class="headerlink" title="Lab知识点"></a>Lab知识点</h1><ul><li>如何从命令行运行 Java 并运行 Capers 的测试（Gitlet 的测试非常非常相似）。</li><li>如何在 Java 中使用文件和目录。</li><li>如何将 Java 对象序列化为文件并在以后读回它们（也称为持久性）。</li></ul><p><strong>重要说明</strong>：静态变量在两次执行之间不会在 Java 中保留。当程序完成执行时，所有实例和静态变量都将完全丢失。我们可以在执行之间保持持久性的唯一方法是将数据存储在文件系统上。</p><h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><p>不用shell和cmd，我们用git bash来打开文件夹</p><p>首先，确保您当前的工作目录是 <code>sp21-s***/lab6/capers</code> 。这些命令将带您到达那里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd $REPO_DIR</span><br><span class="line">$ cd lab6/capers</span><br></pre></td></tr></table></figure><h2 id="编译JAVA文件"><a href="#编译JAVA文件" class="headerlink" title="编译JAVA文件"></a>编译JAVA文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac *.java</span><br></pre></td></tr></table></figure><p><code>*.java</code> 通配符仅返回当前目录中的所有 <code>.java</code> 文件。再次运行 <code>ls</code> ，您将看到一堆新 <code>.class</code> 文件，包括 <code>Main.class</code> .这些文件构成编译的代码。让我们看看它是什么样子的。</p><h2 id="查看JAVA文件"><a href="#查看JAVA文件" class="headerlink" title="查看JAVA文件"></a>查看JAVA文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat Main.class</span><br></pre></td></tr></table></figure><p>该命令将打印出文件的内容。你会看到大部分带有许多特殊字符的垃圾。这被称为字节码，尽管它对我们来说看起来很陌生，但 <code>java</code> 程序可以获取这些编译的代码并实际解释它以运行程序。让我们看看它发生：</p><h2 id="运行JAVA文件"><a href="#运行JAVA文件" class="headerlink" title="运行JAVA文件"></a>运行JAVA文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java Main</span><br></pre></td></tr></table></figure><p>我们得到一个错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: Could not find or load main class Main</span><br><span class="line">Caused by: java.lang.NoClassDefFoundError: capers/Main (wrong name: Main)</span><br></pre></td></tr></table></figure><p>如果我们把这个错误翻译成英语，那就是说“我不知道 <code>Main</code> 你在说什么”。那是因为 <code>Main.java</code> 在包中，所以我们必须使用它的完全规范名称，即 <code>capers.Main</code> .为此，请执行以下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ..                 # takes us up a directory to sp21-s***/lab6</span><br><span class="line">$ java capers.Main</span><br></pre></td></tr></table></figure><p>现在程序终于运行并打印出来了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Must have at least one argument</span><br></pre></td></tr></table></figure><p><strong>教训：</strong>要运行包中的 Java 文件，我们必须输入父目录（在我们的例子中是 <code>lab6</code> ）并使用完全规范的名称。</p><p>关于命令行执行的最后一件事：我们如何将参数传递给 <code>main</code> 方法？回想一下，当我们运行一个类（即 <code>java Main</code> ），真正发生的是调用该类 <code>main(String[] args)</code> 的方法。要传递参数，只需在调用中将它们添加到： <code>java</code></p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java capers.Main story &quot;this is a single argument&quot;</span><br></pre></td></tr></table></figure><p>如上所述，您可以通过将该参数用引号括起来，在其中一个 <code>String[] args</code> 元素中有一个空格。</p><p>在上面的执行中，变量 <code>String[] args</code> 具有以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;story&quot;, &quot;this is a single argument&quot;&#125;</span><br></pre></td></tr></table></figure><p>您将在本实验和 Gitlet 中使用该 <code>String[] args</code> 变量。已经提供了一些骨架来向您展示如何在 <code>Main</code> 类 <code>main</code> 的方法中完成它。</p><h1 id="make的git套件"><a href="#make的git套件" class="headerlink" title="make的git套件"></a>make的git套件</h1><p>由 Paul Hilfinger 和 61B 助教构建的自定义命令行测试套件，该套件使用 python 作为基本引擎来验证本实验和项目 2 的程序正确性。</p><p>测试套件使用名为 <code>make</code> 的标准 unix 工具执行。我们不会 <code>make</code> 详细讨论如何使用。只要知道有两件事你可以用 <code>make</code> ：</p><ol><li>使用命令 <code>make</code> 编译代码。</li><li>使用 <code>make check</code> 命令运行测试套件。</li></ol><p>还有一种线程方式可以使用 <code>make</code> 。具体 <code>make clean</code> 来说， <code>.class</code> 如果项目文件夹中有太多文件会打扰您，将删除所有文件和其他混乱。我们建议您在完成测试并希望返回 IntelliJ 中编辑 <code>.java</code> 文件后运行此文件。</p><h1 id="Java-中的文件和目录"><a href="#Java-中的文件和目录" class="headerlink" title="Java 中的文件和目录"></a>Java 中的文件和目录</h1><h2 id="当前工作目录"><a href="#当前工作目录" class="headerlink" title="当前工作目录"></a>当前工作目录</h2><p>Java 程序的当前工作目录 （CWD&#x2F;<a href="https://en.wikipedia.org/wiki/Working_directory">current working directory</a> ） 是执行该 Java 程序的目录。您可以使用 从 Java 程序中访问 <code>System.getProperty(&quot;user.dir&quot;)</code> CWD。以下是 Windows 和 Mac&#x2F;Linux 用户的示例 - 它们非常相似，只是在风格上有所不同。</p><p>Windows 例如，对于 Windows 用户，假设我们有这个小 Java 程序位于名为 <code>C:/Users/Michelle/example</code> <code>Example.java</code> 的文件夹（或 <code>~/example</code> ）中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file C:/Users/Michelle/example/Example.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     System.out.println(System.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个打印出该 Java 程序的 CWD 的程序。</p><p>如果我跑了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd C:/Users/Michelle/example/</span><br><span class="line">$ javac Example.java</span><br><span class="line">$ java Example</span><br></pre></td></tr></table></figure><p>输出应为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Michelle\example</span><br></pre></td></tr></table></figure><h3 id="IntelliJ"><a href="#IntelliJ" class="headerlink" title="IntelliJ"></a>IntelliJ</h3><p>在 IntelliJ 中，CWD 由“运行”&gt;“&gt;工作目录编辑配置”下的指定目录给出：</p><p><img src="/2024/03/23/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-5-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab6-%E6%96%87%E4%BB%B6%E5%BA%8F%E5%88%97%E5%8C%96/intellij_cwd.png" alt="IntelliJ Working Directory"></p><p>请注意，您可能需要运行 <code>Main.java</code> 一次才能显示此选项。</p><h3 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h3><p>在终端 &#x2F; Git Bash 中，该命令 <code>pwd</code> 将为您提供 CWD。</p><h2 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h2><p>路径是文件或目录的位置。有两种路径：绝对路径和相对路径。</p><ul><li><strong>绝对路径</strong>是文件或目录相对于文件系统根目录的位置。<ul><li>在上面的示例中， <code>Example.java</code> 绝对路径是 <code>C:/Users/Michelle/example/Example.java</code> （Windows） 或 <code>/home/Michelle/example/Example.java</code> （Mac&#x2F;Linux）。请注意，这些路径 Windows 以<code>C:/</code> 和Mac&#x2F;Linux 以 <code>/</code> 的根目录开头。</li></ul></li><li><strong>相对路径</strong>是文件或目录相对于程序的 CWD 的位置。<ul><li>在上面的示例中，如果我在 <code>C:/Users/Michelle/example/</code> （Windows） 或 <code>/home/Michelle/example/（Mac/Linux）</code> 文件夹中 ，那么  <code>Example.java</code> 的相对路径将是 <code>Example.java</code> 。 </li><li>如果我在 <code>C:/Users/Michelle/</code> 或 <code>/home/Michelle/</code> 中，则 的 <code>Example.java</code> 相对路径为 <code>example/Example.java</code> 。</li></ul></li></ul><p>注意：文件系统的根目录与主目录不同。您的主目录通常位于 <code>C:/Users/&lt;your username&gt;</code> （Windows） 或 <code>/home/&lt;your username&gt;</code> （Mac&#x2F;Linux）。我们用作 <code>~</code> 指代您的主目录的简写，因此当您在 <code>~/sp21-s***</code> 时，您实际上是在 <code>C:/Users/&lt;your username&gt;/sp21-s***</code> （Windows） 或 <code>/home/&lt;your username&gt;/sp21-s***</code> （Mac&#x2F;Linux）。*</p><p>使用路径时， <code>.</code> 指 CWD。因此，相对路径 <code>./example/Example.java</code> 与 <code>example/Example.java</code> 相同。</p><p>同样， <code>..</code> 引用父（或封闭）目录。所以命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure><p>是导航到父目录的一种快速而简单的方法。如果要转到父目录，可以将它们串在一起，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ../..</span><br></pre></td></tr></table></figure><p>与父级的父级目录类似。在此实验室&#x2F;项目中，您不需要执行此操作，尽管快速浏览终端很有用。</p><p><img src="/2024/03/23/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-5-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab6-%E6%96%87%E4%BB%B6%E5%BA%8F%E5%88%97%E5%8C%96/image-20240323174651000.png" alt="image-20240323174651000"></p><h2 id="Java-中的文件和目录操作"><a href="#Java-中的文件和目录操作" class="headerlink" title="Java 中的文件和目录操作"></a>Java 中的文件和目录操作</h2><p>Java File 类表示操作系统中的文件或目录，并允许您对这些文件和目录执行操作。在本类中，您通常希望通过引用文件和目录的相对路径来对文件和目录执行操作。您希望您创建的任何新文件或目录都与运行程序的位置（在本实验中为 <code>sp21-s***/lab6</code> 文件夹）位于同一目录中，而不是计算机上的某个随机位置。</p><h3 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h3><p>在Java中，你可以使用File构造函数并传入文件路径来创建一个File对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dummy.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面的路径是一个相对路径，在这里我们引用了Java程序当前工作目录中的dummy.txt文件。你可以将这个File对象视为对实际文件dummy.txt的引用 - 当我们创建新的File对象时，我们实际上<strong>并没有创建</strong>dummy.txt文件本身，我们只是在说，“将来，当我对f进行操作时，我想在dummy.txt上执行这些操作”。要实际创建这个dummy.txt文件，我们可以调用：</p><blockquote><p>类似指代我需要操作的文件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.createNewFile();</span><br></pre></td></tr></table></figure><p>然后dummy.txt文件现在实际上就存在了（你可以在文件浏览器&#x2F;查找器中看到它）。</p><p>你可以使用File类的exists方法检查文件“dummy.txt”是否已经存在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.exists()</span><br></pre></td></tr></table></figure><p>实际上，在Java中写文件相当丑陋。为了保持简单，我们为你提供了一个Utils.java。这个类在这个实验室和Gitlet中都非常方便。你应该查看Utils.java中提供的可用方法列表，以了解它可以为你做些什么。查看本实验室底部的FAQ以获取关注点提示。</p><p>例如，如果你想将一个字符串写入文件，你可以这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Utils.writeContents(f, <span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure><p>现在dummy.txt文件中将包含文本“Hello World”。</p><h3 id="Directories"><a href="#Directories" class="headerlink" title="Directories"></a>Directories</h3><p>在Java中，目录也用File对象表示。例如，你可以创建一个表示目录的File对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dummy&quot;</span>);</span><br></pre></td></tr></table></figure><p>与文件类似，这个目录在你的文件系统中可能实际上并不存在。要在你的文件系统中实际创建这个文件夹，你可以运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.mkdir();</span><br></pre></td></tr></table></figure><p>现在你的当前工作目录中应该有一个名为dummy的文件夹。你还应该查看mkdirs()方法，其文档可以在此处找到。</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>在Java中有许多操作文件的方法，你可以通过查看File的Javadoc和搜索来探索更多。在线资源有很多，如果你搜索一下，使用Java进行更多的复杂文件操作可能会变得有点复杂。我们建议通过完成这个实验室来理解基础知识，在将来，如果你遇到不知道如何处理的用例，再开始搜索或在Ed上提问。对于这个实验室和Gitlet，你应该使用我们的Utils.java类，它具有许多有用的文件操作辅助函数。</p><h1 id="序列化-Serializable"><a href="#序列化-Serializable" class="headerlink" title="序列化(Serializable)"></a>序列化(Serializable)</h1><p>将文本写入文件很棒，但如果我们想要在程序中保存一些更复杂的状态怎么办？例如，如果我们想要能够保存2048游戏中的Model对象，以便以后再次使用它呢？我们可以编写一个toString方法将Model转换为String，然后将该String写入文件。然后，我们还必须编写能够读取该String并将其解析回Model的代码。虽然这样做肯定是可能的，但编写这样的代码是很烦琐的。</p><p>幸运的是，我们有一个称为序列化的替代方法，Java已经为我们实现了它。序列化是将对象转换为一系列字节的过程，然后可以将这些字节存储在文件中。然后我们可以反序列化这些字节，并在程序的将来调用中获得原始对象。</p><p>要为Java中的给定类启用此功能，只需实现java.io.Serializable接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Model</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口没有方法；它只是为了一些特殊的Java类来执行对象的I&#x2F;O而标记其子类型。例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Model</span> <span class="variable">m</span> <span class="operator">=</span> ....;</span><br><span class="line"><span class="type">File</span> <span class="variable">outFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveFileName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(outFile));</span><br><span class="line">    out.writeObject(m);</span><br><span class="line">    out.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException excp) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将m转换为一系列字节，并将其存储在名为saveFileName的文件中。然后可以通过以下代码序列化对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Model m;</span><br><span class="line"><span class="type">File</span> <span class="variable">inFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveFileName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">inp</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(inFile));</span><br><span class="line">    m = (Model) inp.readObject();</span><br><span class="line">    inp.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException excp) &#123;</span><br><span class="line">    ...</span><br><span class="line">    m = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java运行时会自动执行所有的工作，找出哪些字段需要转换为字节以及如何执行转换。你将会左右序列化对象，为了减少你需要编写的代码量，我们在Utils.java中提供了处理读写对象的辅助函数。</p><p>请注意，上面的代码非常烦人，有很多神秘的类和try&#x2F;catch语句。如果你使用Utils类中提供的辅助函数，那么序列化就会变得非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Model m;</span><br><span class="line"><span class="type">File</span> <span class="variable">outFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化Model对象</span></span><br><span class="line">writeObject(outFile, m);</span><br></pre></td></tr></table></figure><p>类似地，反序列化只需简单地：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Model m;</span><br><span class="line"><span class="type">File</span> <span class="variable">inFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化Model对象</span></span><br><span class="line">m = readObject(inFile, Model.class);</span><br></pre></td></tr></table></figure><p>注意：在Project 2规范中有一些Serializable的限制，你在这个实验室中不会遇到它们。</p><h2 id="有用的Utils类方法"><a href="#有用的Utils类方法" class="headerlink" title="有用的Utils类方法"></a>有用的Utils类方法</h2><ul><li><p>这些实用的工具函数（作为起点，可能需要更多，而且您可能并不需要全部）：</p><ul><li><code>static void writeContents(File file, Object... contents)</code> - 将字符串&#x2F;字节数组写入文件。<code>...</code> 允许我们使用 <em>可变参数</em>，这意味着我们可以使用任意数量的参数调用 <code>writeContents</code>。例如，我们可以调用 <code>writeContents(outFile, &quot;dog&quot;, &quot;cat&quot;, &quot;mouse&quot;)</code>，函数 <code>writeContents</code> 将通过数组访问我们传入的所有三个对象。</li><li><code>static String readContentsAsString(File file)</code> - 将文件读取为字符串。</li><li><code>static byte[] readContents(File file)</code> - 将文件读取为字节数组。</li><li><code>static void writeObject(File file, Serializable obj)</code> - 将可序列化对象写入文件。</li><li><code>static &lt;T extends Serializable&gt; T readObject(File file, Class&lt;T&gt; expectedClass)</code> - 从文件中读取可序列化对象。您可以使用 <code>&lt;类名&gt;.class</code> 获取一个 <code>Class</code> 对象，例如 <code>Dog d = readObject(inFile, Dog.class)</code>。</li><li><code>static File join(String first, String... others)</code> - 将字符串或文件组合成路径。例如，<code>Utils.join(&quot;.capers&quot;, &quot;dogs&quot;)</code> 将为您提供一个路径为 “.capers&#x2F;dogs”的 <code>File</code> 对象，<code>Utils.join(&quot;.capers&quot;, &quot;dogs&quot;, &quot;shitzus&quot;)</code> 将为您提供一个路径为 “.capers&#x2F;dogs&#x2F;shitzus”的 <code>File</code> 对象。您 <strong>不应该</strong> 使用字符串连接来创建文件！这可能会根据您正在运行的系统产生奇怪的错误。</li></ul></li></ul><h1 id="远程JVM调试"><a href="#远程JVM调试" class="headerlink" title="远程JVM调试"></a>远程JVM调试</h1><p>在本节中，我们将讨论如何使用IntelliJ调试lab 6。乍一看，这似乎是不可能的，因为我们是从命令行运行所有东西的。然而，IntelliJ提供了一个称为“远程JVM调试”的功能，它允许您添加断点，在集成测试期间触发。</p><p>首先使用git来检出骨架代码的原始版本。也就是说，在检出后，你应该回到实验室的一开始。如果你不知道怎么做，请阅读Lab 4中的这一部分。</p><p>此部分剩余部分的操作步骤可以在这里找到。视频简单地介绍了规范中列出的步骤，所以如果你在方向上感到困惑，可以看看它。</p><p>由于没有JUnit测试，你可能想知道如何调试你的代码。我们将向你展示如何在Capers和Gitlet中完成。</p><p>首先，让我们讨论如何知道你有一个bug。如果你运行<code>make check</code>测试，你会发现你未通过测试<code>test02-two-part-story.in</code>。现在我们需要弄清楚哪次执行你的程序有bug。记住，我们的测试会多次运行你的程序；在这种情况下，<code>.in</code>文件有两行调用capers.Main，所以这个测试运行了两次（在Gitlet中通常会更多）。</p><p>要调试这个集成测试，首先我们需要让IntelliJ知道我们想要远程调试。在你的IntelliJ中导航到你的lab6项目，如果你还没有打开的话。在顶部，转到“Run” -&gt; “Run”：</p><p><img src="/2024/03/23/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-5-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab6-%E6%96%87%E4%BB%B6%E5%BA%8F%E5%88%97%E5%8C%96/run.png" alt="Run to Run"></p><p>你会得到一个要求你编辑配置的框，看起来像下面这样：</p><p><img src="/2024/03/23/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-5-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab6-%E6%96%87%E4%BB%B6%E5%BA%8F%E5%88%97%E5%8C%96/edit-box.png" alt="Edit Box"></p><p>你的界面可能会有更多或更少的框，其他名称，如果你已经在IntelliJ中尝试运行了一个类。如果是这种情况，只需点击其中一个名称为“Edit Configurations”的框。</p><p>在这个框中，你需要点击左上角的“+”按钮，并选择“Remote JVM Debug”。现在它应该看起来像这样：</p><p><img src="/2024/03/23/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-5-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab6-%E6%96%87%E4%BB%B6%E5%BA%8F%E5%88%97%E5%8C%96/remote-debug.png" alt="Remote Debug"></p><p>我们只需要默认设置。你应该在顶部的框中添加一个描述性名称，也许是“Capers Remote Debug”。添加名称后，点击“Apply”，然后退出此屏幕。在我们离开IntelliJ之前，<strong>在Main类的main方法中设置一个断点</strong>，以便我们实际上可以进行调试。确保这个断点实际上会被触发，所以把它放在main方法的第一行。</p><p>现在你将导航到终端中的测试目录。连接到IntelliJ JVM的脚本是runner.py：使用以下命令启动测试脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 runner.py --debug our/test02-two-part-story.in</span><br></pre></td></tr></table></figure><p>如果你想运行不同的测试，只需放置不同的<code>.in</code>文件。如果你想在测试完成后保留<code>.capers</code>文件夹，以便调查其内容，请使用<code>--keep</code>标志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 runner.py --keep --debug our/test02-two-part-story.in</span><br></pre></td></tr></table></figure><p>对于我们的示例，你可以做任何事情；我们只是包含它，以防你想四处看看。默认情况下，生成的<code>.capers</code>将被删除。</p><p>如果你看到错误消息，则意味着你要么不在测试目录中，要么你的REPO_DIR环境变量设置不正确。检查这两件事情，如果你还是困惑，那就问TA。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$env:REPO_DIR = &quot;D:\hj\CS61B-Tutorial\&quot; </span><br></pre></td></tr></table></figure></blockquote><p>否则，你应该准备好调试了！你会看到类似于这样的东西：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   ============================================================================</span><br><span class="line">  |                   ~~~~~  You are in debug mode  ~~~~~                      |</span><br><span class="line">  |   In this mode, you will be shown each command from the test case.         |</span><br><span class="line">  |                                                                            |</span><br><span class="line">  |   There are three commands:                                                |</span><br><span class="line">  |                                                                            |</span><br><span class="line">  |   1. &#x27;n&#x27; - type in &#x27;n&#x27; to go to the next command without debugging the     |</span><br><span class="line">  |            current one (analogous to &quot;Step Over&quot; in IntelliJ).             |</span><br><span class="line">  |                                                                            |</span><br><span class="line">  |   2. &#x27;s&#x27; - type in &#x27;s&#x27; to debug the current command (analogous to          |</span><br><span class="line">  |            &quot;Step Into&quot; in IntelliJ). Make sure to set breakpoints!         |</span><br><span class="line">  |                                                                            |</span><br><span class="line">  |   3. &#x27;q&#x27; - type in &#x27;q&#x27; to quit and stop debugging. If you had the `--keep` |</span><br><span class="line">  |            flag, then your directory state will be saved and you can       |</span><br><span class="line">  |            investigate it.                                                 |</span><br><span class="line">   ============================================================================</span><br><span class="line"></span><br><span class="line">test02-two-part-story: </span><br><span class="line">&gt;&gt;&gt; capers story &quot;Hello&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>顶部框中包含有用的提示。接下来我们看到的是我们正在调试的<code>.in</code>文件的名称，然后是一系列以<code>&gt;&gt;&gt;</code>和<code>&gt;</code>开头的行。</p><ul><li><p>以<code>&gt;&gt;&gt;</code>开头的行是将在你的Main类上运行的capers命令，即你程序的特定执行。这些对应于我们在<code>.in</code>文件中看到的命令，在<code>&gt;</code>右侧。</p></li><li><p>以<code>&gt;</code>开头的行是让你输入调试命令的。有一个提示框列出了3个命令。</p></li></ul><p>记住，每个输入文件都会列出多个命令，因此我们需要首先弄清楚哪个命令是问题所在的。</p><p>键入单个字符“n”（表示“next”）以在不调试的情况下执行此命令。你可以将其视为带您到下一个命令。</p><p>其中一个将会出错：要么你的代码会产生运行时错误，要么你的输出与预期不同。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   ============================================================================</span><br><span class="line">  |                   ~~~~~  You are in debug mode  ~~~~~                      |</span><br><span class="line">  |   In this mode, you will be shown each command from the test case.         |</span><br><span class="line">  |                                                                            |</span><br><span class="line">  |   There are three commands:                                                |</span><br><span class="line">  |                                                                            |</span><br><span class="line">  |   1. &#x27;n&#x27; - type in &#x27;n&#x27; to go to the next command without debugging the     |</span><br><span class="line">  |            current one (analogous to &quot;Step Over&quot; in IntelliJ).             |</span><br><span class="line">  |                                                                            |</span><br><span class="line">  |   2. &#x27;s&#x27; - type in &#x27;s&#x27; to debug the current command (analogous to          |</span><br><span class="line">  |            &quot;Step Into&quot; in IntelliJ). Make sure to set breakpoints!         |</span><br><span class="line">  |                                                                            |</span><br><span class="line">  |   3. &#x27;q&#x27; - type in &#x27;q&#x27; to quit and stop debugging. If you had the `--keep` |</span><br><span class="line">  |            flag, then your directory state will be saved and you can       |</span><br><span class="line">  |            investigate it.                                                 |</span><br><span class="line">   ============================================================================</span><br><span class="line"></span><br><span class="line">test02-two-part-story: </span><br><span class="line">&gt;&gt;&gt; capers story &quot;Hello&quot;</span><br><span class="line">&gt; n</span><br><span class="line">ERROR (incorrect output)</span><br><span class="line"></span><br><span class="line">Directory state saved in test02-two-part-story_0</span><br><span class="line"></span><br><span class="line">Ran 1 tests. 0 passed.</span><br></pre></td></tr></table></figure><h1 id="实验室项目"><a href="#实验室项目" class="headerlink" title="实验室项目"></a>实验室项目</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>哎呀！我们终于准备好开始这个实验的实际工作了。在这个实验中，您将编写一个程序，该程序将利用文件操作和序列化。我们为您提供了三个文件：</p><ul><li>Main.java：程序的主方法。使用 <code>java capers.Main [args]</code> 运行它以执行下面指定的操作。这个类本身并没有太多的逻辑：相反，它充当了一个“入口点”，只是知道何时调用 CapersRepository.java 中的正确方法。</li><li>CapersRepository.java：负责所有其他类之间的协调。此程序中大多数的 FIXME 都在这里。</li><li>Dog.java：代表具有名称、品种和年龄的狗。包含一些 FIXME。</li><li>Utils.java：用于文件操作和序列化的实用函数。这些是 Gitlet 提供的一部分。</li></ul><p>您不需要担心错误情况或无效输入，在这个实验中我们不会对此进行测试（尽管请注意，您需要在 Gitlet 中处理这些）。您可以仅使用 Utils.java 中提供的方法以及本规范中提到的其他 File 类方法完成这个实验，但如果您感觉冒险，可以随意尝试其他方法。</p><h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><p>您的代码将支持以下三个命令：</p><ul><li><code>story [text]</code>：将 “text” + 换行符（即 “\n”）附加到 .capers 目录中的一个故事文件中。此外，打印出当前故事（当前故事应包含最近添加的 “text”）。</li><li><code>dog [name] [breed] [age]</code>：使用指定的参数持久创建一只狗；还应该打印狗的 toString()。假设狗名是唯一的。</li><li><code>birthday [name]</code>：持久地提升狗的年龄并打印出庆祝消息。</li></ul><p>例如，下面是一系列 capers.Main 的执行，后跟每个命令的输出。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ java capers.Main story <span class="string">&quot;Once upon a time, there was a beautiful dog.&quot;</span></span><br><span class="line">Once upon a time, there was a beautiful dog.</span><br><span class="line"></span><br><span class="line">$ java capers.Main story <span class="string">&quot;That dog was named Fjerf.&quot;</span></span><br><span class="line">Once upon a time, there was a beautiful dog.</span><br><span class="line">That dog was named Fjerf.</span><br><span class="line"></span><br><span class="line">$ java capers.Main story <span class="string">&quot;Fjerf loved to run and jump.&quot;</span></span><br><span class="line">Once upon a time, there was a beautiful dog.</span><br><span class="line">That dog was named Fjerf.</span><br><span class="line">Fjerf loved to run and jump.</span><br><span class="line"></span><br><span class="line">$ java capers.Main dog Mammoth <span class="string">&quot;German Spitz&quot;</span> 10</span><br><span class="line">Woof! My name is Mammoth and I am a German Spitz! I am 10 years old! Woof!</span><br><span class="line">$ java capers.Main dog Qitmir Saluki 3 </span><br><span class="line">Woof! My name is Qitmir and I am a Saluki! I am 3 years old! Woof!</span><br><span class="line">$ java capers.Main birthday Qitmir</span><br><span class="line">Woof! My name is Qitmir and I am a Saluki! I am 4 years old! Woof!</span><br><span class="line">Happy birthday! Woof! Woof!</span><br><span class="line">$ java capers.Main birthday Qitmir</span><br><span class="line">Woof! My name is Qitmir and I am a Saluki! I am 5 years old! Woof!</span><br><span class="line">Happy birthday! Woof! Woof!</span><br></pre></td></tr></table></figure><p>请注意，dog 和 birthday 命令具有相关的功能。还要注意，story 命令的功能完全独立于 dog 或 birthday。</p><p>还要注意，您的代码不应在每一步打印出命令行参数。换句话说，您应该删除在此实验早期添加的调用 <code>System.out.println(&quot;args: &quot; + Arrays.toString(args));</code>。</p><p>所有持久数据应存储在当前工作目录中的 .capers 目录中。我们在前面加上 . 是因为以 . 开头的文件和目录默认在文件查看器中是隐藏的。毕竟，我们不希望我们的 Java 程序的用户关心我们如何、在哪里或者是否存储持久数据。他们只关心程序是否正常工作。IntelliJ 和 Git 都利用了这个想法：每当您创建一个 IntelliJ 项目时，它都会在当前工作目录中创建一个隐藏的 .idea 文件夹来存储所有的元数据。类似地，每当您初始化一个 Git 仓库时，它都会将所有的持久数据存储在一个 .git 文件夹中。您可以通过在终端中键入 ls -a 而不是只键入 ls 来查看隐藏文件。</p><p>推荐的文件结构（您不必遵循此结构）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.capers/ -- 所有持久数据的顶级文件夹</span><br><span class="line">    - dogs/ -- 包含所有狗的持久数据的文件夹</span><br><span class="line">    - story --</span><br></pre></td></tr></table></figure><h2 id="完成顺序"><a href="#完成顺序" class="headerlink" title="完成顺序"></a>完成顺序</h2><p>建议完成顺序：</p><ol><li>在 CapersRepository.java 中填写 CAPERS_FOLDER，然后在 Dog.java 中填写 DOG_FOLDER，然后在 CapersRepository.java 中填写 setUpPersistence。</li><li>在 Main.java 中填写 main 方法。这主要应该是调用 CapersRepository 中的其他方法。</li><li>在 CapersRepository.java 中填写 writeStory 方法。现在 story 命令应该可以正常工作了。</li><li>尝试手动使用 story 命令，并验证它是否正常工作。</li><li>在 Dog.java 中填写 saveDog，然后填写 fromFile。您还需要处理 Dog.java 顶部的 TODO。请记住，狗名是唯一的！</li><li>使用 Dog.java 中的方法，在 CapersRepository.java 中填写 makeDog 和 celebrateBirthday。您会发现 Dog 类中的 haveBirthday 方法很有用。现在 dog 和 birthday 命令应该可以正常工作了。</li><li>尝试手动使用 dog 和 birthday 命令，并验证它们是否正常工作。</li><li>运行 make check 并验证您的代码是否通过了所有测试。如果您的测试未通过且不知道原因，请参阅本实验后面的调试部分。</li><li>每个 TODO 应该最多需要大约 8 行，但许多都更少。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="1-CapersRepository-java"><a href="#1-CapersRepository-java" class="headerlink" title="1.CapersRepository.java"></a>1.<strong>CapersRepository.java</strong></h3><blockquote><p>在 CapersRepository.java 中填写 CAPERS_FOLDER，然后在 Dog.java 中填写 DOG_FOLDER，然后在 CapersRepository.java 中填写 setUpPersistence。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/** Current Working Directory. */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">File</span> <span class="variable">CWD</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(System.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Main metadata folder. */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">File</span> <span class="variable">CAPERS_FOLDER</span> <span class="operator">=</span> Utils.join(CWD,<span class="string">&quot;.capers&quot;</span>); <span class="comment">// TODO Hint: look at the `join`</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setupPersistence</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">c</span> <span class="operator">=</span> CAPERS_FOLDER;</span><br><span class="line">    <span class="type">File</span> <span class="variable">dog</span> <span class="operator">=</span> Dog.DOG_FOLDER;</span><br><span class="line">    <span class="keyword">if</span> (!c.exists()) &#123;</span><br><span class="line">        c.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!dog.exists()) &#123;</span><br><span class="line">        dog.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">File</span> <span class="variable">DOG_FOLDER</span> <span class="operator">=</span> Utils.join(CapersRepository.CAPERS_FOLDER, <span class="string">&quot;dogs&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="2-Main-java"><a href="#2-Main-java" class="headerlink" title="2.Main.java"></a>2.<strong>Main.java</strong></h3><blockquote><p>在 Main.java 中填写 main 方法。这主要应该是调用 CapersRepository 中的其他方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">        Utils.exitWithError(<span class="string">&quot;Must have at least one argument&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CapersRepository.setupPersistence();</span><br><span class="line">    String text;</span><br><span class="line">    <span class="keyword">switch</span> (args[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;story&quot;</span>:</span><br><span class="line">        <span class="comment">/* This call has been handled for you. The rest will be similar. */</span></span><br><span class="line">        validateNumArgs(<span class="string">&quot;story&quot;</span>, args, <span class="number">2</span>);</span><br><span class="line">        text = args[<span class="number">1</span>];</span><br><span class="line">        CapersRepository.writeStory(text);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;dog&quot;</span>:</span><br><span class="line">        validateNumArgs(<span class="string">&quot;dog&quot;</span>, args, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> make a dog</span></span><br><span class="line">        CapersRepository.makeDog(args[<span class="number">1</span>], args[<span class="number">2</span>], Integer.parseInt(args[<span class="number">3</span>]));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;birthday&quot;</span>:</span><br><span class="line">        validateNumArgs(<span class="string">&quot;birthday&quot;</span>, args, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> celebrate this dog&#x27;s birthday</span></span><br><span class="line">        CapersRepository.celebrateBirthday(args[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        exitWithError(String.format(<span class="string">&quot;Unknown command: %s&quot;</span>, args[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-CapersRepository-java"><a href="#3-CapersRepository-java" class="headerlink" title="3.CapersRepository.java"></a>3.<strong>CapersRepository.java</strong></h3><blockquote><p>在 CapersRepository.java 中填写 writeStory 方法。现在 story 命令应该可以正常工作了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeStory</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">story</span> <span class="operator">=</span> Utils.join(CAPERS_FOLDER, <span class="string">&quot;story&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!story.exists())&#123;</span><br><span class="line">            story.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> Utils.readContentsAsString(story);</span><br><span class="line">        <span class="keyword">if</span> (content.isEmpty())&#123;</span><br><span class="line">            Utils.writeContents(story, text);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Utils.writeContents(story, content, <span class="string">&quot;\n&quot;</span>, text);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Utils.readContentsAsString(story));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>: 我们是希望写入的时候是续写故事的，所以我们每次写入不能覆盖掉原有的内容，因此我们需要先读取原本的内容，然后在原本内容后面添加新写入的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ java capers.Main story <span class="string">&quot;Once upon a time, there was a beautiful dog.&quot;</span></span><br><span class="line">Once upon a time, there was a beautiful dog.</span><br><span class="line"></span><br><span class="line">$ java capers.Main story <span class="string">&quot;That dog was named Fjerf.&quot;</span></span><br><span class="line">Once upon a time, there was a beautiful dog.</span><br><span class="line">That dog was named Fjerf.</span><br><span class="line"></span><br><span class="line">$ java capers.Main story <span class="string">&quot;Fjerf loved to run and jump.&quot;</span></span><br><span class="line">Once upon a time, there was a beautiful dog.</span><br><span class="line">That dog was named Fjerf.</span><br><span class="line">Fjerf loved to run and jump.</span><br></pre></td></tr></table></figure><h3 id="4-Dog-java"><a href="#4-Dog-java" class="headerlink" title="4.Dog.java"></a>4.<strong>Dog.java</strong></h3><blockquote><ol><li>在 Dog.java 中填写 saveDog，然后填写 fromFile。您还需要处理 Dog.java 顶部的 TODO。请记住，狗名是唯一的！</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123; <span class="comment">// TODO</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads in and deserializes a dog from a file with name NAME in DOG_FOLDER.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name Name of dog to load</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Dog read from file</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Dog <span class="title function_">fromFile</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO (hint: look at the Utils file)</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dog</span> <span class="operator">=</span> Utils.join(DOG_FOLDER, name);</span><br><span class="line">        <span class="keyword">return</span> Utils.readObject(dog, Dog.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases a dog&#x27;s age and celebrates!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">haveBirthday</span><span class="params">()</span> &#123;</span><br><span class="line">        age += <span class="number">1</span>;</span><br><span class="line">        System.out.println(toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;Happy birthday! Woof! Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Saves a dog to a file for future use.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveDog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO (hint: don&#x27;t forget dog names are unique)</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dog</span> <span class="operator">=</span> Utils.join(Dog.DOG_FOLDER, name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dog.exists()) &#123;</span><br><span class="line">                dog.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line">            Utils.writeObject(dog, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-CapersRepository-java"><a href="#5-CapersRepository-java" class="headerlink" title="5**.CapersRepository.java**"></a>5**.CapersRepository.java**</h3><blockquote><p>使用 Dog.java 中的方法，在 CapersRepository.java 中填写 makeDog 和 celebrateBirthday。您会发现 Dog 类中的 haveBirthday 方法很有用。现在 dog 和 birthday 命令应该可以正常工作了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and persistently saves a dog using the first</span></span><br><span class="line"><span class="comment"> * three non-command arguments of args (name, breed, age).</span></span><br><span class="line"><span class="comment"> * Also prints out the dog&#x27;s information using toString().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">makeDog</span><span class="params">(String name, String breed, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(name, breed, age);</span><br><span class="line">    System.out.println(dog1.toString());</span><br><span class="line">    dog1.saveDog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Advances a dog&#x27;s age persistently and prints out a celebratory message.</span></span><br><span class="line"><span class="comment"> * Also prints out the dog&#x27;s information using toString().</span></span><br><span class="line"><span class="comment"> * Chooses dog to advance based on the first non-command argument of args.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name String name of the Dog whose birthday we&#x27;re celebrating.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">celebrateBirthday</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> Dog.fromFile(name);</span><br><span class="line">    dog.haveBirthday();</span><br><span class="line">    dog.saveDog();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/23/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-5-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab6-%E6%96%87%E4%BB%B6%E5%BA%8F%E5%88%97%E5%8C%96/image-20240323182756762.png" alt="image-20240323182756762"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ java capers.Main dog Mammoth <span class="string">&quot;German Spitz&quot;</span> <span class="number">10</span></span><br><span class="line">Woof! My name is Mammoth and I am a German Spitz! I am <span class="number">10</span> years old! Woof!</span><br><span class="line">$ java capers.Main dog Qitmir Saluki <span class="number">3</span> </span><br><span class="line">Woof! My name is Qitmir and I am a Saluki! I am <span class="number">3</span> years old! Woof!</span><br><span class="line">$ java capers.Main birthday Qitmir</span><br><span class="line">Woof! My name is Qitmir and I am a Saluki! I am <span class="number">4</span> years old! Woof!</span><br><span class="line">Happy birthday! Woof! Woof!</span><br><span class="line">$ java capers.Main birthday Qitmir</span><br><span class="line">Woof! My name is Qitmir and I am a Saluki! I am <span class="number">5</span> years old! Woof!</span><br><span class="line">Happy birthday! Woof! Woof!</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们体会下这个Lab的代码</p><ul><li>首先他是先通过Main函数读取命令符来分别调用<code>CapersRepository</code>类中的方法</li><li>而<code>CapersRepository</code>类中方法使用了<code>Dog</code>类中的方法</li><li>重要的一点是，Dog类中的方法基本上只被C类调用，因此C类是Dog类的客户端。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B项目笔记(八)-ProJ2-complish</title>
      <link href="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/"/>
      <url>/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.1point3acres.com/bbs/thread-908806-1-1.html">【超干货】CS61B 2021sp全攻略（上）|一亩三分地公开课版 (1point3acres.com)</a>的建议:</p><blockquote><p>我做proj2花了大概10天代码大概一共800行推荐到springbreak的时候做这个项目写之前要把lab6复习一遍再把Lecture12看完然后推荐先把spec读一遍再看intro视频磨刀不误砍柴这个时候终于对要写几个对象、分别实现什么功能有点概念了然后再读一遍spec对着指令一条一条实现缺少一个整体设计概念的话不建议着急写代码否则你debug40多条指令的时间会远远高于这些思考的时间我感觉merge是最复杂的可以先看助教的视频他给你总结好了7种情况分类讨论下来有点心累但提交autograde看到1600满分的时候爽爆了</p></blockquote><p>Lec12：</p><ul><li><a href="https://docs.google.com/presentation/d/1I2s5plripe4_uaOmwBWOOAzB04Cd-V0dHoDsT6Z85Ms/edit#slide=id.gbcfc5ec854_0_102">cs61b 2021 lec12 command line programming, data structures preview - Google 幻灯片</a></li><li><a href="https://www.youtube.com/watch?v=fvhqn5PeU_Q">Spring 2021: Live Lecture 12 (youtube.com)</a></li></ul><h1 id="Lec12"><a href="#Lec12" class="headerlink" title="Lec12"></a>Lec12</h1><h2 id="命令行的介绍"><a href="#命令行的介绍" class="headerlink" title="命令行的介绍"></a>命令行的介绍</h2><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240323170733016.png" alt="image-20240323170733016"></p><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><table><thead><tr><th>Approach Number</th><th>Information to use as file version number</th><th>Downside</th></tr></thead><tbody><tr><td>1, 2, and 3</td><td>Commit ID (that goes up by 1) that includes the file.</td><td>No central server to decide which commit is “next” if people are working offline.</td></tr><tr><td>4</td><td>Date and time of file.</td><td>Awkward to deal with simultaneous file changes. Not as elegant as SHA1-hash.</td></tr><tr><td>5</td><td>git-SHA1 hash of file.</td><td>???</td></tr></tbody></table><h3 id="Approach-1-3"><a href="#Approach-1-3" class="headerlink" title="Approach 1-3"></a>Approach 1-3</h3><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240323170924189.png" alt="image-20240323170924189"></p><h3 id="Approach-4"><a href="#Approach-4" class="headerlink" title="Approach 4"></a>Approach 4</h3><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240323170844113.png" alt="image-20240323170844113"></p><h3 id="Approach-5"><a href="#Approach-5" class="headerlink" title="Approach 5"></a>Approach 5</h3><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240323170954784.png" alt="image-20240323170954784"></p><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240323171539681.png" alt="image-20240323171539681"></p><p>commit后会出现3个文件夹：</p><ul><li>其中一个是以hash码前两位为名称，hash码文件的<ul><li><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240323171721402.png" alt="image-20240323171721402"></li></ul></li><li>其中一个是存储了commit消息的<ul><li><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240323171749576.png" alt="image-20240323171749576"></li></ul></li><li>另一个是读取文件的<ul><li><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240323171712871.png" alt="image-20240323171712871"></li></ul></li></ul><h2 id="序列化和储存"><a href="#序列化和储存" class="headerlink" title="序列化和储存"></a>序列化和储存</h2><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240323171447179.png" alt="image-20240323171447179"></p><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240323171431511.png" alt="image-20240323171431511"></p><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240323171235620.png" alt="image-20240323171235620"></p><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240323171136900.png" alt="image-20240323171136900"></p><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240323171215906.png" alt="image-20240323171215906"></p><p>这里没看懂…</p><h1 id="Lab6"><a href="#Lab6" class="headerlink" title="Lab6"></a>Lab6</h1><p><a href="https://www.bailog.top/2024/03/23/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-5-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab6-%E6%96%87%E4%BB%B6%E5%BA%8F%E5%88%97%E5%8C%96/">CS61B项目笔记(四)-Lab6-文件序列化 | bai的小窝 (bailog.top)</a></p><p><a href="https://sp21.datastructur.es/materials/proj/proj2/capers-example">Capers 设计文档示例 |CS 61B 2021 年春季 — Capers Design Document Example | CS 61B Spring 2021 (datastructur.es)</a></p><h1 id="Git-Intro"><a href="#Git-Intro" class="headerlink" title="Git Intro"></a>Git Intro</h1><p>视频主要介绍了<code>git init</code>、<code>git add x</code>、<code>git commit</code>、<code>git checkout</code>这四个命令</p><h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240324005322743.png" alt="image-20240324005322743"></p><p>创造两个区域，一个存储区域和确认区域</p><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240324005415911.png" alt="image-20240324005415911"></p><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240324005427015.png" alt="image-20240324005427015"></p><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240324005506920.png" alt="image-20240324005506920"></p><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240324005518632.png" alt="image-20240324005518632"></p><p>清空储存区，提交确认</p><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240324005603569.png" alt="image-20240324005603569"></p><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240324005613533.png" alt="image-20240324005613533"></p><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240324005630537.png" alt="image-20240324005630537"></p><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240324005637210.png" alt="image-20240324005637210"></p><blockquote><p>checkout的时候要保证status树是干净的</p></blockquote><h1 id="Gitlet-Intro"><a href="#Gitlet-Intro" class="headerlink" title="Gitlet Intro"></a>Gitlet Intro</h1><div class="row">    <embed src="Gitlet_Slides.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="Gitlet设计文档"><a href="#Gitlet设计文档" class="headerlink" title="Gitlet设计文档"></a>Gitlet设计文档</h1><h2 id="类以及数据结构"><a href="#类以及数据结构" class="headerlink" title="类以及数据结构"></a>类以及数据结构</h2><h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String message;</span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; parentID = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line"><span class="comment">//merge后可能有两个父提交</span></span><br><span class="line"><span class="keyword">private</span> String timestamp;</span><br><span class="line"><span class="keyword">private</span> String shaName;</span><br><span class="line"><span class="keyword">public</span> HashMap&lt;String, String&gt; version; </span><br><span class="line"><span class="comment">//存储文件名以及对应的Blob的Sha1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateVersion</span><span class="params">()</span></span><br><span class="line"><span class="comment">//更新文件版本</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">//输出log格式</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getFlieVersion</span><span class="params">(String name)</span></span><br><span class="line"><span class="comment">//获得当前版本文件的Sha1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyMapTo</span><span class="params">(Commit c)</span></span><br><span class="line"><span class="comment">//将其版本复制给c</span></span><br></pre></td></tr></table></figure><h3 id="CommitTree"><a href="#CommitTree" class="headerlink" title="CommitTree"></a>CommitTree</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Commit HEAD;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Commit Master;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String curBranchName;</span><br><span class="line"><span class="keyword">static</span> <span class="type">File</span> <span class="variable">indexFold</span> <span class="operator">=</span> StagingArea.indexFold;<span class="comment">//object的目录</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">File</span> <span class="variable">refs</span> <span class="operator">=</span> Utils.join(Repository.GITLET_DIR,<span class="string">&quot;refs&quot;</span>); <span class="comment">//folder</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">File</span> <span class="variable">heads</span> <span class="operator">=</span> Utils.join(refs, <span class="string">&quot;heads&quot;</span>); <span class="comment">//folder</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">File</span> <span class="variable">master</span> <span class="operator">=</span> Utils.join(heads, <span class="string">&quot;master&quot;</span>); <span class="comment">// file</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">File</span> <span class="variable">head</span> <span class="operator">=</span> Utils.join(Repository.GITLET_DIR, <span class="string">&quot;HEAD&quot;</span>); <span class="comment">//file</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">File</span> <span class="variable">CURBranch</span> <span class="operator">=</span> Utils.join(Repository.GITLET_DIR, <span class="string">&quot;curBranch&quot;</span>);<span class="comment">//file</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">File</span> <span class="variable">commitList</span> <span class="operator">=</span> Utils.join(refs, <span class="string">&quot;cList&quot;</span>);</span><br><span class="line"><span class="keyword">static</span> List&lt;String&gt; cList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">logSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure><h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String fileName;</span><br><span class="line">String sha1ID;</span><br><span class="line">File file;<span class="comment">//代表的文件</span></span><br><span class="line"><span class="type">byte</span>[] aByte; <span class="comment">//存储文件内容</span></span><br></pre></td></tr></table></figure><h3 id="StagingArea"><a href="#StagingArea" class="headerlink" title="StagingArea"></a>StagingArea</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">File</span> <span class="variable">CWD</span> <span class="operator">=</span> Repository.CWD;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">File</span> <span class="variable">indexFold</span> <span class="operator">=</span> Utils.join(Repository.GITLET_DIR, <span class="string">&quot;object&quot;</span>);<span class="comment">//folder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, String&gt; additionStage = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, String&gt; removalStage = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">File</span> <span class="variable">additionStageFile</span> <span class="operator">=</span> Utils.join(Repository.GITLET_DIR, <span class="string">&quot;additionStage&quot;</span>);<span class="comment">//file</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">File</span> <span class="variable">removalStageFile</span> <span class="operator">=</span> Utils.join(Repository.GITLET_DIR, <span class="string">&quot;removalStage&quot;</span>); <span class="comment">//file</span></span><br></pre></td></tr></table></figure><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote><p>对于复杂的任务，比如确定合并冲突，我们建议您将任务分解成几个部分。在单独的部分中描述每个部分的算法。从最简单的组件开始，一次构建设计的每一部分。例如，您的合并冲突的算法部分可以有以下部分：</p><ol><li>检查是否需要合并。</li><li>确定哪些文件（如果有）存在冲突。</li><li>在文件中表示冲突。 尽量清晰地使用空格或其他符号标记类的标题或名称。</li></ol></blockquote><h1 id="Gitlet编写思路"><a href="#Gitlet编写思路" class="headerlink" title="Gitlet编写思路"></a>Gitlet编写思路</h1><h2 id="前序工作"><a href="#前序工作" class="headerlink" title="前序工作"></a>前序工作</h2><p>可以把文件类比成Lab6里的Dog</p><h3 id="整体逻辑框架"><a href="#整体逻辑框架" class="headerlink" title="整体逻辑框架"></a>整体逻辑框架</h3><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240324234728616.png" alt="image-20240324234728616"></p><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240324233547054.png" alt="image-20240324233547054"></p><h3 id="init做了什么？"><a href="#init做了什么？" class="headerlink" title="init做了什么？"></a>init做了什么？</h3><p>init创建了.gitlet文件，我们可以参考下git的：</p><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240324233814127.png" alt="image-20240324233814127"></p><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240324234219622.png" alt="image-20240324234219622"></p><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240324234329272.png" alt="image-20240324234329272"></p><p>如图所示:</p><ul><li>HEAD指针指向的是一个文件，文件里存储了当前指向的文件码</li><li>objects文件夹存储的应该是<strong>blobs</strong>里的文件，而他使用的是Hash表</li></ul><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240325171441116.png" alt="image-20240325171441116"></p><h2 id="整理下全部过程"><a href="#整理下全部过程" class="headerlink" title="整理下全部过程"></a>整理下全部过程</h2><p>首先add的时候文件序列化后存储在了我的index文件夹，然后commit的时候，commit节点是包含着Blobs节点的。这里就有个需要解决的地方:</p><ul><li>commit如何指向?<ul><li>初步想法是commit的时候，在commitTree添加节点，然后每个节点有个列表，列表里包含了文件的sha1值</li></ul></li><li>如何通过sha1值找到指向的值?<ul><li>我的StagingArea应该会有一个方法，通过指定的sha1值找到其文件。</li></ul></li></ul><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/image-20240327215936968.png" alt="image-20240327215936968"></p><h3 id="Blob-1"><a href="#Blob-1" class="headerlink" title="Blob"></a>Blob</h3><p>Blob 是 Git 中用来存储文件内容的基本单位。它可以是文本文件、图像、音频或任何其他类型的文件，Git 对它们都一视同仁。每个 Blob 对象都会被分配一个唯一的 SHA-1 哈希值，该哈希值是根据 Blob 对象的内容计算得出的。</p><p>当你向 Git 添加文件时，Git 会将文件内容存储为 Blob 对象。在 Git 内部，Blob 对象被保存在 <code>.git/objects</code> 目录下，并以其哈希值命名的文件中。这样，Git 就能够非常高效地存储和检索文件内容。</p><blockquote><p>SHA1值前两位为文件名，后38位为文件名</p></blockquote><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><ul><li>首先找到CWD中的文件</li><li>将文件存为Blob</li><li>将Blob存入Hash表[SHA1-Blob]</li><li>将Blob序列化存入.index文件中</li><li>将文件对应的Blob存入additon中</li></ul><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><ul><li>根据传入的message new 一个 commit</li><li>commit的parent来自HEAD</li><li>复制文件表中的Blob</li><li>序列化?</li></ul><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><ul><li>如果文件已经被add, 那么从add区删除</li><li>如果文件已经被commit, 则标记为删除</li><li>从工作列表中删除文件</li></ul><h3 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h3><ul><li>status得干净</li></ul><h2 id="做题思路"><a href="#做题思路" class="headerlink" title="做题思路"></a>做题思路</h2><h3 id="重要的一点"><a href="#重要的一点" class="headerlink" title="重要的一点"></a>重要的一点</h3><p>为了保证程序的持续性，我们执行命令前需要读取被存储的文件，如<code>HEAD</code>、<code>AdditonStage</code>等</p><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><ul><li><strong>描述</strong>：在当前目录中创建一个新的 Gitlet 版本控制系统。该系统将自动开始一个提交：一个不包含文件且具有提交消息 <code>initial commit</code>（就是这样，没有标点符号）。它将有一个单一分支：<code>master</code>，最初指向此初始提交，并且<code>master</code>将是当前分支。此初始提交的时间戳将为 00:00:00 UTC，Thursday, 1 January 1970，以您选择的日期格式（这被称为“Unix 纪元”，内部由时间 0 表示）。由于由 Gitlet 创建的所有存储库中的初始提交都具有完全相同的内容，因此所有存储库将自动共享此提交（它们将具有相同的 UID），并且所有存储库中的所有提交都将追溯到它。</li><li><strong>失败情况</strong>：如果当前目录中已经存在 Gitlet 版本控制系统，则应中止。不应使用新系统覆盖现有系统。应打印错误消息 <code>A Gitlet version-control system already exists in the current directory.</code>。</li></ul><p>明确一下我们要做什么：</p><ul><li>首先创建一个<code>.gitlit</code>的文件夹</li><li>然后自动提交一个初始<code>commit</code></li><li>设置<code>master</code>和<code>HEAD</code>指针</li><li>初始化<code>StagingArea</code>目录</li><li>初始化<code>CommitTree</code></li></ul><p>初始化后目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.gitlet</span><br><span class="line">|--object //Folder</span><br><span class="line">||---存储commit和blob</span><br><span class="line">|</span><br><span class="line">|--refs //Folder</span><br><span class="line">||---heads //Folder</span><br><span class="line">|||--存储branch指针</span><br><span class="line">||--cList //List类, 存储commit的列表</span><br><span class="line">|</span><br><span class="line">|---additionStage //HashMap&lt;String, String&gt;, 存储添加的blob</span><br><span class="line">|---removalStage //HashMap&lt;String, String&gt;, 存储删除的blob</span><br><span class="line">|---HEAD //Commit类，存储当前分支的头指针</span><br><span class="line">|---curBranch //String类，存储当前分支的名字</span><br></pre></td></tr></table></figure><h3 id="add-1"><a href="#add-1" class="headerlink" title="add"></a>add</h3><ul><li><p><strong>描述</strong>：将文件的当前副本添加到<em>暂存区</em>（参见 <code>commit</code> 命令的描述）。因此，添加文件也称为<em>为添加而暂存</em>文件。将已经暂存的文件暂存会使用新内容覆盖暂存区中的先前条目。暂存区应该位于<code>.gitlet</code>的某个地方。如果文件的当前工作版本与当前提交中的版本相同，则不要将其暂存以添加，并且如果已经存在（当文件更改、添加，然后更改回其原始版本时可能会发生）的情况下，从暂存区删除它。文件将不再被暂存以删除（请参见 <code>gitlet rm</code>），如果在命令时处于该状态。</p></li><li><p><strong>失败情况</strong>：如果文件不存在，则打印错误消息 <code>File does not exist.</code> 并且退出而不更改任何内容。</p></li><li><p>思路</p><ul><li><p>首先读取<code>addtionStage</code>、<code>removalStage</code>和<code>HEAD</code></p></li><li><p>找到需要add的文件</p></li><li><p>为该文件创建blob快照</p></li><li><p>将blob存储到object文件夹 </p></li><li><blockquote><p>上级文件夹名为Sha1的前两位，文件名为Sha1的后38位</p></blockquote></li><li><p>特殊情况判断</p></li><li><p>将该blob添加到<code>addtionStage</code></p></li></ul></li></ul><blockquote><p>特殊情况判断:</p><ul><li>如果removalStage中有该版本，清空rS，不添加到aS</li><li>如果Head指向的commit已经包含了该版本，忽略这次提交</li></ul></blockquote><h3 id="commit-1"><a href="#commit-1" class="headerlink" title="commit"></a>commit</h3><ul><li><p><strong>描述</strong>: 在当前提交和暂存区保存已跟踪文件的快照，以便稍后可以恢复，创建一个新的提交。该提交被称为<em>跟踪</em>保存的文件。默认情况下，每个提交的文件快照将与其父提交的文件快照完全相同；它将保留文件的版本完全不变，不会更新它们。提交仅会更新在提交时已标记为要添加的文件的内容，在这种情况下，提交现在将包含已标记为要添加的文件的版本，而不是从其父提交中获取的版本。提交将保存并开始跟踪任何已标记为要添加但父提交未跟踪的文件。最后，由于被<code>rm</code>命令（下面）标记为<em>要删除</em>，当前提交中跟踪的文件可能会在新提交中被取消跟踪。</p></li><li><p><strong>失败情况</strong>: 如果没有文件被暂存，则中止。打印消息<code>No changes added to the commit.</code>。每个提交必须有一个非空消息。如果没有，则打印错误消息<code>Please enter a commit message.</code>。对于已跟踪文件在工作目录中缺失或更改的情况<em>不</em>算是失败。完全忽略<code>.gitlet</code>目录外的所有内容。</p></li><li><p>思路:分两种情况，第一种是init时提交的初始commit，另一种就是正常commit的</p></li><li><p>读取<code>HEAD</code>、<code>curBranch</code>、<code>rS</code>、<code>aS</code>、<code>CList</code></p><ul><li>首先新建commit</li><li>将该commit提交到commitTree:<ul><li><p>检查是否为初始提交，若是：</p><ul><li>将该commit直接写入HEAD，curBranch(master)指针中去</li><li>存储到object文件夹中，存储方式同blobs</li><li>将该commit的ShaName添加到CList列表中保存文件CList</li></ul></li><li><p>若非：</p><ul><li>将该commit的Parent设置为HEAD指向的commit的ShaName</li><li>拷贝父提交的version哈希表</li><li>更新version哈希表</li><li>清空所有Stage</li><li>将该commit写入HEAD，curBranch指针中去</li><li>存储到object文件夹中，存储方式同blobs</li><li>将该commit的ShaName添加到CList列表中并保存文件Clist</li></ul></li></ul></li></ul></li></ul><blockquote><p>记住，清空Stage的时候需要保存两个Stage</p></blockquote><h3 id="rm-1"><a href="#rm-1" class="headerlink" title="rm"></a>rm</h3><ul><li><p><strong>描述</strong>: 如果文件当前已暂存以添加，则取消暂存该文件。如果文件在当前提交中被跟踪，则将其标记为删除，并从工作目录中删除该文件（除非用户已经这样做，否则<em>不要</em>删除它）。</p></li><li><p><strong>失败情况</strong>: 如果文件既没有被暂存也没有被当前提交跟踪，则打印错误消息<code>No reason to remove the file.</code>。</p></li><li><p>思路</p><ul><li><p>首先读取需要用到的</p></li><li><p>如果add了，那就取消add</p></li><li><p>如果当前提交有追踪当前文件，将该文件添加到rA并删除CWD中该文件。</p></li></ul></li></ul><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><ul><li><p><strong>描述</strong>: 从当前头提交开始，沿着提交树向后显示每个提交的信息，直到初始提交，跟随第一个父提交链接，忽略合并提交中找到的任何第二父提交（在常规Git中，这就是使用<code>git log --first-parent</code>得到的）。这组提交节点称为提交的<em>历史记录</em>。对于历史记录中的每个节点，应显示的信息是提交ID、提交时间和提交消息。以下是应遵循的<em>确切</em>格式示例：</p></li><li><p>思路</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">===</span><br><span class="line">commit a0da1ea5a15ab613bf9961fd86f010cf74c7ee48</span><br><span class="line">Date: Thu Nov <span class="number">9</span> <span class="number">20</span>:<span class="number">00</span>:<span class="number">05</span> <span class="number">2017</span> -0800</span><br><span class="line">A commit message.</span><br><span class="line"></span><br><span class="line">===</span><br><span class="line">commit 3e8bf1d794ca2e9ef8a4007275acf3751c7170ff</span><br><span class="line">Date: Thu Nov <span class="number">9</span> <span class="number">17</span>:<span class="number">01</span>:<span class="number">33</span> <span class="number">2017</span> -0800</span><br><span class="line">Another commit message.</span><br><span class="line"></span><br><span class="line">===</span><br><span class="line">commit e881c9575d180a215d1a636545b8fd9abfb1d2bb</span><br><span class="line">Date: Wed Dec <span class="number">31</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">1969</span> -0800</span><br><span class="line">initial commit</span><br></pre></td></tr></table></figure><ul><li>读取需要的东西</li><li>根据实例，为commit覆写toString方法</li><li>利用StringBulider来存储信息</li><li>利用递归来添加commit的信息</li></ul><h3 id="global-log"><a href="#global-log" class="headerlink" title="global-log"></a>global-log</h3><ul><li><p><strong>描述</strong>: 类似于日志，但显示有关已经进行的所有提交的信息。提交的顺序并不重要。提示：在<code>gitlet.Utils</code>中有一个有用的方法，可以帮助您遍历目录中的文件。</p></li><li><p>思路</p><ul><li><p>读取需要的东西</p></li><li><p>也是用StringBuilder来存储信息</p></li><li><p>重要的一点是获得所有Commit的列表，我们可以直接读取我们的CList文件来获取</p></li></ul></li></ul><blockquote><p>另一个想法: 可以创建一个log文件，每次addCommit的时候就append</p></blockquote><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><ul><li><strong>描述</strong>: 打印出具有给定提交消息的所有提交的ID，每行一个。如果有多个这样的提交，它会将ID分别打印在不同的行上。提交消息是一个单独的操作数；要指示多个单词的消息，请将操作数放在引号中，如下所示的<code>commit</code>命令。提示：此命令的提示与<code>global-log</code>的提示相同。</li><li><strong>失败情况</strong>: 如果不存在这样的提交，则打印错误消息<code>Found no commit with that message.</code>。</li></ul><p>类似golbal-log，复用其代码即可</p><h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><ul><li><p><strong>描述</strong>: 显示当前存在的分支，并用<code>*</code>标记当前分支。还显示哪些文件已经被标记为添加或删除。它应该遵循的<em>确切</em>格式示例如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">=== 分支 ===</span><br><span class="line">*master</span><br><span class="line">other-branch</span><br><span class="line">  </span><br><span class="line">=== 暂存的文件 ===</span><br><span class="line">wug.txt</span><br><span class="line">wug2.txt</span><br><span class="line">  </span><br><span class="line">=== 已删除的文件 ===</span><br><span class="line">goodbye.txt</span><br><span class="line">  </span><br><span class="line">=== 未暂存的修改 ===</span><br><span class="line">junk.txt (deleted)</span><br><span class="line">wug3.txt (modified)</span><br><span class="line">  </span><br><span class="line">=== 未跟踪的文件 ===</span><br><span class="line">random.stuff</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p>思路</p></li></ul><p>最后两个我没有实现</p><ul><li>这个重点考察了持续性的使用，只要正确读取就不难</li></ul><h3 id="checkout-1"><a href="#checkout-1" class="headerlink" title="checkout"></a>checkout</h3><p>检出是一种通用命令，可以根据其参数执行几种不同的操作。下面有3种可能的用法。在每个部分下面，您会看到3个编号的点。每个对应于相应的检出用法。</p><ul><li>用法<ol><li><code>java gitlet.Main checkout -- [文件名]</code></li><li><code>java gitlet.Main checkout [提交ID] -- [文件名]</code></li><li><code>java gitlet.Main checkout [分支名]</code></li></ol></li><li>描述<ol><li>获取文件在当前分支的最新提交中的版本，并将其放入工作目录中，如果已经存在同名文件，则覆盖它。新版本的文件不会被暂存。</li><li>获取文件在具有给定ID的提交中的版本，并将其放入工作目录中，如果已经存在同名文件，则覆盖它。新版本的文件不会被暂存。</li><li>获取给定分支头部的提交中的所有文件，并将它们放入工作目录中，如果已经存在同名文件，则覆盖它们。此外，在执行此命令结束时，给定分支将被视为当前分支（HEAD）。任何在当前分支中被跟踪但在检出分支中不存在的文件将被删除。暂存区将被清空，除非检出的分支是当前分支（参见<strong>失败情况</strong>下面）。</li></ol></li><li>失败情况<ol><li>如果文件在上一个提交中不存在，则中止操作，并打印错误消息<code>File does not exist in that commit.</code> 不要更改当前工作目录。</li><li>如果不存在具有给定ID的提交，则打印<code>No commit with that id exists.</code>。否则，如果文件在给定提交中不存在，则打印与失败情况1相同的消息。不要更改当前工作目录。</li><li>如果不存在具有该名称的分支，则打印<code>No such branch exists.</code> 如果该分支是当前分支，则打印<code>No need to checkout the current branch.</code> 如果当前分支中有一个工作文件在检出时将被覆盖，则打印<code>There is an untracked file in the way; delete it, or add and commit it first.</code> 并退出；在执行任何其他操作之前执行此检查。不要更改当前工作目录。</li></ol></li></ul><h4 id="checkout-String-branch"><a href="#checkout-String-branch" class="headerlink" title="checkout(String branch)"></a>checkout(String branch)</h4><p>前两个比较容易就不讨论了</p><p>这个切换分支分为三个情况</p><ul><li><p>文件名既被<code>branch</code>追踪的文件，也被<code>head</code>追踪，那么对于相同文件名但<code>blobID</code>不同（也就是内容不同），则用<code>branch</code>中的文件来替代原来的文件；相同文件名并且<code>blobID</code>相同，不进行任何操作。</p></li><li><p>文件名不被<code>branch</code>追踪的文件，而仅被<code>head</code>追踪，那么直接删除这些文件。</p></li><li><p>文件名仅被<code>branch</code>追踪的文件，而不被<code>head</code>追踪，那么直接将这些文件写入到工作目录。</p></li><li><blockquote><p>这里有个例外，即对于第三种情况，将要直接写入的时候如果有同名文件（例如<code>1.txt</code>）已经在工作目录中了，说明工作目录中在执行<code>checkout</code>前增加了新的<code>1.txt</code>文件而没有<code>commit</code>，这时候gitlet不知道是应该保存用户新添加进来的<code>1.txt</code>还是把branch中的<code>1.txt</code>拿过来overwrite掉，为了避免出现信息丢失，gitlet就会报错，输出<code>There is an untracked file in the way; delete it, or add and commit it first.</code></p></blockquote></li></ul><p>我的做法:</p><ul><li><p>对于第一种情况</p><ul><li>首先得到一个<strong>包含</strong>在branchVersion和headVersion文件名的列表(遍历headVersion的keySet)</li><li>遍历该列表<ul><li>删除CWD中包含在该列表的文件</li><li>写入branchVersion版本的该文件到CWD中</li></ul></li></ul></li><li><p>对于第二种情况</p><ul><li>首先得到一个<strong>不包含</strong>在branchVersion但<strong>包含</strong>在headVersion文件名的列表(遍历headVersion的keySet)</li><li>遍历该列表<ul><li>删除CWD中包含在该列表的文件</li></ul></li></ul></li><li><p>对于第三种情况</p><ul><li>首先得到一个<strong>包含</strong>在branchVersion但<strong>不包含</strong>在headVersion文件名的列表(遍历headVersion的keySet)</li><li>遍历该列表<ul><li>检查特殊情况</li><li>直接写入branchVersion版本的该文件到CWD中</li></ul></li></ul><p>不要忘记保存curBranch</p></li></ul><h3 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h3><ul><li><strong>描述</strong>: 创建一个具有给定名称的新分支，并将其指向当前的头部提交。分支只是对提交节点的引用（一个SHA-1标识符）的名称。该命令不会立即切换到新创建的分支（就像真实的Git一样）。在调用分支之前，您的代码应该使用一个名为“master”的默认分支运行。</li></ul><p>增加一个Branch，即在<code>heads</code>文件夹中添加一个新的名为branchname的文件，内容为当前的commitID。此操作不改变<code>HEAD</code>指向，只是单纯增加一个Branch。改变分支依然是通过<code>checkout</code>命令来改变。</p><p><strong>失败的情况</strong>：无</p><h3 id="rm-branch"><a href="#rm-branch" class="headerlink" title="rm-branch"></a>rm-branch</h3><ul><li><strong>描述</strong>: 删除具有给定名称的分支。这只是删除与分支关联的指针；不意味着删除在该分支下创建的所有提交，或者类似的操作。</li><li><strong>失败情况</strong>: 如果具有给定名称的分支不存在，则中止。打印错误消息 <code>A branch with that name does not exist.</code> 如果尝试删除当前正在使用的分支，则中止，打印错误消息 <code>Cannot remove the current branch.</code>。</li></ul><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><ul><li><strong>用法</strong>: <code>java gitlet.Main merge [分支名称]</code></li><li><strong>描述</strong>: 将给定分支的文件合并到当前分支。这个方法有点复杂，所以这里有一个更详细的描述：<ul><li>首先考虑当前分支和给定分支的 <strong>分割点</strong>。例如，如果 <code>master</code> 是当前分支，<code>branch</code> 是给定分支：<img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/split_point.png" alt="分割点"> 分割点是当前分支和给定分支头部的<em>最新共同祖先</em>：- <em>共同祖先</em> 是一个提交，从两个分支头部都有一条路径（0个或多个父指针)。- <em>最新</em> 的共同祖先是一个不是其他任何共同祖先的共同祖先。例如，尽管上图中最左边的提交是 <code>master</code> 和 <code>branch</code> 的共同祖先，但它也是其右边紧邻的提交的祖先，因此它不是最新的共同祖先。如果分割点 <em>是</em> 与给定分支相同的提交，则我们不执行任何操作；合并已完成，并以消息 <code>Given branch is an ancestor of the current branch.。</code> 结束操作。如果分割点是当前分支，则效果是检出给定分支，并在打印消息 <code>Current branch fast-forwarded.</code> 后结束。否则，我们继续以下步骤:</li></ul></li></ul><p><img src="/2024/03/21/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-ProJ2-complish/f41d1cfa707f80bbc90f4969c3c60b0.png" alt="f41d1cfa707f80bbc90f4969c3c60b0"></p><ul><li><p><strong>失败案例</strong>: </p><ul><li>如果存在已暂存的添加或删除，则打印错误消息 <code>You have uncommitted changes.</code> 并退出。</li><li>如果给定名称的分支不存在，则打印错误消息 <code>A branch with that name does not exist.</code> </li><li>如果尝试将分支与自身合并，则打印错误消息 <code>Cannot merge a branch with itself.</code> </li><li>如果合并会生成错误，因为所做的提交中没有更改，请让此错误的常规提交消息继续进行。</li><li>如果当前提交中的一个未跟踪文件将被合并覆盖或删除，请打印 <code>There is an untracked file in the way; delete it, or add and commit it first.</code> 并退出；在执行任何其他操作之前执行此检查。</li></ul></li><li><p>思路</p><ul><li><p>错误检测</p><ul><li>检查Stage是否为空</li><li>检查给定分支是否存在</li><li>检查合并的是否为头指针</li><li>第四没看懂</li><li>同checkout中的思路</li></ul></li><li><p>特殊情况分析</p><ul><li>如果分割点是给定分支，不操作</li><li>如果分支完成，输出······</li><li>如果分割点是头指针，checkout给定分支并输出······</li></ul></li><li><p>正常情况分析</p><ul><li><em>(<code>x</code>，<code>y</code>为分支，<code>s</code>为分裂点)</em></li><li>如果文件在<code>x</code>被修改，但在<code>y</code>没有修改-&gt;版本为<code>x</code>的<ul><li>若<code>x</code>为 <strong>给定分支指针</strong>， CWD改变</li></ul></li><li>如果文件在<code>x</code>,<code>s</code>不存在，在<code>y</code>中 -&gt; 版本为<code>y</code>的<ul><li>若<code>y</code>为 <strong>给定分支指针</strong>， CWD改变</li></ul></li><li>如果文件在<code>x</code>中不存在，但没被<code>y</code>修改-&gt;删掉<ul><li>若<code>x</code>为 <strong>给定分支指针</strong>， CWD改变</li><li>在分割点处存在但在当前分支中未被修改并且在给定分支中不存在的任何文件都应该被移除（并且未被跟踪）。</li></ul></li><li>如果文件同时在<code>x, y</code>中被修改且版本相等，随便了</li><li>如果文件同时在<code>x, y</code>中被修改但版本不一样-&gt;引发冲突<ul><li>在当前分支和给定分支中以不同方式被修改的任何文件都会<em>冲突</em>。“以不同方式被修改”可以意味着两者的内容都发生了变化且不同，或者一个文件的内容发生了变化而另一个文件被删除，或者文件在分割点处不存在，并且在给定分支和当前分支中具有不同的内容。</li></ul></li></ul></li><li><p>方法编写</p><ul><li>找出分裂点</li><li>找出改变的文件集 和 未改变的文件集<br>1. 可以用HashMap来构建<br>- 根据 <code>修改</code> 、<code>未修改</code>、<code>存在</code>和 <code>不存在</code> 四个标签来标记文件<br>2. 可以用Set，利用Set的相加减</li><li>分为五个方法<ol><li>一改一不变情况的方法</li><li>一存在两不存在的方法</li><li>一不存在一未修改的方法</li><li>两改一同的方法</li><li>两改不同的方法</li></ol></li></ul></li><li><p>细节分析</p><ul><li><p>首先读取需要的文件</p></li><li><p>先错误检测</p></li><li><p>特殊情况两个if语句</p></li><li><p>开始正常情况编写</p></li><li><p>设计一个算法找到分裂点</p></li><li><p>找出用于五个方法的文件集</p><ol><li>遍历分割点的文件同两个分支文件比较<ul><li>按 <code>修改</code> 、<code>未修改</code>、<code>存在</code>和 <code>不存在</code> 四个标签来标记文件</li></ul></li><li>有Set的加减<ol><li>思考中</li><li>用集合减分裂点</li><li>集合减分支 + 直接查</li><li>思考中</li></ol></li><li>Set和遍历结合<ul><li>对于存在和不存在，用Set</li><li>对于有无修改，用遍历加标签</li></ul></li></ol></li><li><p>对应方法进行操作:</p><ol><li>对于文件集，若给定分支的提交文件修改了，当前分支的未修改，删除CWD文件，写入给定分支的版本</li><li>对于文件集，若当前分支的提交文件不存在，给定分支的文件存在，写入给定分支的版本</li><li>对于文件集，如果在分割点处存在的文件在其中一个分支不存在，另一个分支未修改，直接删掉</li><li>对于文件集，如果文件均被修改且版本相等，随便搞</li><li>对于文件集，如果文件均被修改但版本不一样，引发冲突<ol><li>两者的内容都发生了变化且不同，或者一个文件的内容发生了变化而另一个文件被删除，或者文件在分割点处不存在，并且在给定分支和当前分支中具有不同的内容</li></ol></li></ol></li><li><p>最后创建合并提交，注意：其第一个父提交为当前头指针</p><h3 id="骨架代码"><a href="#骨架代码" class="headerlink" title="骨架代码"></a>骨架代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error check</span></span><br><span class="line">    mergeErrCheck(branch);</span><br><span class="line">    <span class="type">Commit</span> <span class="variable">branchCommit</span> <span class="operator">=</span> readBranch(branch);</span><br><span class="line">    HashMap&lt;String, Integer&gt; branchAncestors = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    HashMap&lt;String, Integer&gt; masterAncestors = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    CommitTree.readHEAD();</span><br><span class="line">    findAncestors(branchCommit, branchAncestors, <span class="number">0</span>);</span><br><span class="line">    findAncestors(HEAD, masterAncestors, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// get splitPoint</span></span><br><span class="line">    <span class="type">Commit</span> <span class="variable">splitPoint</span> <span class="operator">=</span> findSplitPoint(masterAncestors, branchAncestors);</span><br><span class="line">    Set&lt;String&gt; splitSet = splitPoint.getVersion().keySet();</span><br><span class="line">    HashMap&lt;String, String&gt; curVersion = HEAD.getVersion();</span><br><span class="line">    <span class="comment">// specialSituation check</span></span><br><span class="line">    specialSituation(splitPoint, branchCommit, branch);</span><br><span class="line">    <span class="comment">// get changSet</span></span><br><span class="line">    Set&lt;String&gt; changeFileSetOfBranch = getChangeSet(branchCommit, splitPoint);</span><br><span class="line">    Set&lt;String&gt; noChangeFileSetOfBranch = opposeSet(changeFileSetOfBranch, branchCommit);</span><br><span class="line">    Set&lt;String&gt; changeFileSetOfCurBranch = getChangeSet(HEAD, splitPoint);</span><br><span class="line">    Set&lt;String&gt; noChangeFileSetOfCurBranch = opposeSet(changeFileSetOfCurBranch, HEAD);</span><br><span class="line">    <span class="comment">// get existSet</span></span><br><span class="line">    Set&lt;String&gt; existFileSetOfBranch = getCompareFile(branchCommit, splitPoint, DELETE);</span><br><span class="line">    Set&lt;String&gt; noExistFileSetOfBranch = noExistSet(splitSet, HEAD.getVersion().keySet(), branchCommit.getVersion().keySet());</span><br><span class="line">    Set&lt;String&gt; existFileSetOfCurBranch = getCompareFile(HEAD, splitPoint, DELETE);</span><br><span class="line">    Set&lt;String&gt; noExistFileSetOfCurBranch = noExistSet(splitSet, branchCommit.getVersion().keySet(), HEAD.getVersion().keySet());</span><br><span class="line">    <span class="comment">// normal situation</span></span><br><span class="line">    branchChangeHeadKeep(branchCommit, noChangeFileSetOfCurBranch, changeFileSetOfBranch, curVersion);</span><br><span class="line">    branchExistOthersNot(branchCommit, existFileSetOfBranch, existFileSetOfCurBranch, curVersion);</span><br><span class="line">    OneNotExistOneKeep(splitSet, noExistFileSetOfBranch, noChangeFileSetOfCurBranch, curVersion);</span><br><span class="line">    checkTwoChangeIfSame(branchCommit, splitSet, changeFileSetOfBranch, noExistFileSetOfBranch, changeFileSetOfCurBranch, noExistFileSetOfCurBranch,curVersion);</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Merged &quot;</span> + branch + <span class="string">&quot; into &quot;</span> + curBranchName + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    creatMergeCommmit(message, curVersion, HEAD.getShaName(), branchCommit.getShaName());</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><ul><li><p>对文件的持续性操作有了更深的理解</p></li><li><p>对文件的写入和读取有了实际操作体验</p><ul><li><pre><code class="java">String readContent = new String(byte[] fileByte);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 对函数式编程操作有了体会，面对工程量大的项目应该细化分开</span><br><span class="line"></span><br><span class="line">github仓库: [xxbaizero0/CS61B-Tutorial (github.com)](https://github.com/xxbaizero0/CS61B-Tutorial)</span><br><span class="line"></span><br><span class="line"># 有用的merge测试</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">package gitlet;</span><br><span class="line"></span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class Text &#123;</span><br><span class="line">    static String[] init = new String[]&#123;&quot;init&quot;&#125;;</span><br><span class="line">    static String[] add = new String[]&#123;&quot;add&quot;, &quot;hello.txt&quot;&#125;;</span><br><span class="line">    static String[] commit = new String[]&#123;&quot;commit&quot;, &quot;hello&quot;&#125;;</span><br><span class="line">    static String[] log = new String[]&#123;&quot;log&quot;&#125;;</span><br><span class="line">    static String[] rm = new String[]&#123;&quot;rm&quot;, &quot;hello.txt&quot;&#125;;</span><br><span class="line">    static String[] check = new String[]&#123;&quot;checkout&quot;, &quot;--&quot;, &quot;hello.txt&quot;&#125;;</span><br><span class="line">    String[] global_log = new String[]&#123;&quot;global-log&quot;&#125;;</span><br><span class="line">    static String[] status = new String[]&#123;&quot;status&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    private static void creatNewFile(String name) &#123;</span><br><span class="line">        File file = Repository.CWD;</span><br><span class="line">        File newFile = Utils.join(file, name);</span><br><span class="line">        if (!newFile.exists()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                newFile.createNewFile();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static void branch(String name) &#123;</span><br><span class="line">        String[] branch = new String[]&#123;&quot;branch&quot;, name&#125;;</span><br><span class="line">        Main.main(branch);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static void add(String name) &#123;</span><br><span class="line">        Main.main(new String[]&#123;&quot;add&quot;, name&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void log() &#123;</span><br><span class="line">        Main.main(new String[]&#123;&quot;log&quot;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void glog() &#123;</span><br><span class="line">        Main.main(new String[]&#123;&quot;global-log&quot;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void rm(String name) &#123;</span><br><span class="line">        Main.main(new String[]&#123;&quot;rm&quot;, name&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void commit(String name) &#123;</span><br><span class="line">        Main.main(new String[]&#123;&quot;commit&quot;, name&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void find(String name) &#123;</span><br><span class="line">        Main.main(new String[]&#123;&quot;find&quot;, name&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void check(String checkBranch) &#123;</span><br><span class="line">        Main.main(new String[]&#123;&quot;checkout&quot;, checkBranch&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void merge(String checkBranch) &#123;</span><br><span class="line">        Main.main(new String[]&#123;&quot;merge&quot;, checkBranch&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void status() &#123;</span><br><span class="line">        Main.main(new String[]&#123;&quot;status&quot;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void global_log() &#123;</span><br><span class="line">        Main.main(new String[]&#123;&quot;global-log&quot;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String g = &quot;g.txt&quot;;</span><br><span class="line">    static String f = &quot;f.txt&quot;;</span><br><span class="line">    static String h = &quot;h.txt&quot;;</span><br><span class="line">    static String k = &quot;k.txt&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void setup() &#123;</span><br><span class="line">        File rep = Repository.GITLET_DIR;</span><br><span class="line">        if (rep.exists()) &#123;</span><br><span class="line">            deleteFolder(rep);</span><br><span class="line">        &#125;</span><br><span class="line">        creatNewFile(g);</span><br><span class="line">        creatNewFile(f);</span><br><span class="line">        creatNewFile(h);</span><br><span class="line">        creatNewFile(k);</span><br><span class="line">        Main.main(init);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        setup();</span><br><span class="line">        HashMap&lt;String, Integer&gt; masterAncestors = new HashMap&lt;&gt;();</span><br><span class="line">        masterAncestors.put(&quot;1&quot;, 4);</span><br><span class="line">        masterAncestors.put(&quot;2&quot;, 3);</span><br><span class="line">        masterAncestors.put(&quot;3&quot;, 2);</span><br><span class="line">        masterAncestors.put(&quot;4&quot;, 1);</span><br><span class="line">        masterAncestors.put(&quot;5&quot;, 0);</span><br><span class="line">        HashMap&lt;String, Integer&gt; branchAncestors = new HashMap&lt;&gt;();</span><br><span class="line">        branchAncestors.put(&quot;1&quot;, 5);</span><br><span class="line">        branchAncestors.put(&quot;22&quot;, 4);</span><br><span class="line">        branchAncestors.put(&quot;33&quot;, 3);</span><br><span class="line">        branchAncestors.put(&quot;44&quot;, 2);</span><br><span class="line">        branchAncestors.put(&quot;55&quot;, 1);</span><br><span class="line">        branchAncestors.put(&quot;66&quot;, 0);</span><br><span class="line">        String split = findSplitPoint(masterAncestors, branchAncestors);</span><br><span class="line">        assertEquals(split, &quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        setup();</span><br><span class="line">        add(g);</span><br><span class="line">        add(f);</span><br><span class="line">        commit(&quot;1&quot;);</span><br><span class="line">        branch(&quot;other&quot;);</span><br><span class="line">        add(h);</span><br><span class="line">        rm(g);</span><br><span class="line">        commit(&quot;add h, rm g&quot;);</span><br><span class="line">        check(&quot;other&quot;);</span><br><span class="line">        rm(f);</span><br><span class="line">        add(k);</span><br><span class="line">        commit(&quot;rm f, add k&quot;);</span><br><span class="line">        check(&quot;master&quot;);</span><br><span class="line">        global_log();</span><br><span class="line">        merge(&quot;other&quot;);</span><br><span class="line">        log();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test4() &#123;</span><br><span class="line">        add(g);</span><br><span class="line">        add(f);</span><br><span class="line">        commit(&quot;2&quot;);</span><br><span class="line">        branch(&quot;other&quot;);</span><br><span class="line">        add(h);</span><br><span class="line">        rm(g);</span><br><span class="line">        commit(&quot;a h r g&quot;);</span><br><span class="line">        check(&quot;other&quot;);</span><br><span class="line">        merge(&quot;other&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void reset2() &#123;</span><br><span class="line">        add(g);</span><br><span class="line">        add(f);</span><br><span class="line">        commit(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void test5() &#123;</span><br><span class="line">        setup();</span><br><span class="line">        reset2();</span><br><span class="line">        branch(&quot;b1&quot;);</span><br><span class="line">        add(h);</span><br><span class="line">        commit(&quot;add h&quot;);</span><br><span class="line">        branch(&quot;b2&quot;);</span><br><span class="line">        rm(f);</span><br><span class="line">        commit(&quot;rm f&quot;);</span><br><span class="line">        //merge(&quot;b1&quot;);</span><br><span class="line">        check(&quot;b2&quot;);</span><br><span class="line">        merge(&quot;master&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void test3() &#123;</span><br><span class="line">        String branch = &quot;new&quot;;</span><br><span class="line">        branch(branch);</span><br><span class="line">        add(&quot;hello.txt&quot;);</span><br><span class="line">        add(&quot;hello2.txt&quot;);</span><br><span class="line">        commit(&quot;2&quot;);</span><br><span class="line">        check(branch);</span><br><span class="line">        creatNewFile(&quot;hello2.txt&quot;);</span><br><span class="line">        add(&quot;hello2.txt&quot;);</span><br><span class="line">        commit(&quot;3&quot;);</span><br><span class="line">        check(&quot;master&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void deleteFolder(File folder) &#123;</span><br><span class="line">        if (folder.isDirectory()) &#123;</span><br><span class="line">            File[] files = folder.listFiles();</span><br><span class="line">            if (files != null) &#123;</span><br><span class="line">                for (File file : files) &#123;</span><br><span class="line">                    deleteFolder(file);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        folder.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(二十一)-Tries</title>
      <link href="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/"/>
      <url>/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/</url>
      
        <content type="html"><![CDATA[<p>我们现在将学习一个名为 Tries 的新数据结构。这些将作为 Set 和 Map 的新实现（根据我们之前所学到的），该 Map 对某些类型的数据和信息具有一些特殊功能。</p><h1 id="Trie的介绍"><a href="#Trie的介绍" class="headerlink" title="Trie的介绍"></a>Trie的介绍</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>由于我们正在考虑 ADT <em>Set</em>和<em>Map</em>，让我们回顾一下到目前为止所学到的实现。过去，我们主要学习如何使用二叉搜索树或哈希表来实现这些 ADT。让我们回顾一下这两者的运行时：</p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321221008103.png" alt="image-20240321221008103"></p><ul><li>平衡搜索树：<ul><li><code>contains(x)</code>: $Θ(logN)$</li><li><code>add(x)</code>: $Θ(logN)$</li></ul></li><li>调整单独的链接哈希表的大小：<ul><li><code>contains(x)</code> ： $Θ(1) $（假设点差均匀）</li><li><code>add(x)</code> ： $Θ(1)$ （假设均匀点差和摊销）</li></ul></li></ul><p>我们可以看到，与 Sets 和 Maps 相关的操作的实现速度非常快。</p><p><strong>问题</strong>：我们能做得比这更好吗？这可能取决于我们问题的性质。如果我们<strong>知道钥匙的特殊特性</strong>会怎样？</p><p><strong>答：</strong>是的，例如，如果我们总是知道我们的键是 ASCII 字符，那么不要使用通用的 HashMap，只需使用一个数组，其中每个字符都是我们数组中的不同索引：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DataIndexedCharMap</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    private V[] items;</span><br><span class="line">    public DataIndexedCharMap(<span class="built_in">int</span> R) &#123;</span><br><span class="line">        items = (V[]) <span class="keyword">new</span> <span class="built_in">Object</span>[R];</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">void</span> put(char c, V val) &#123;</span><br><span class="line">        items[c] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    public V <span class="keyword">get</span>(char c) &#123;</span><br><span class="line">        <span class="keyword">return</span> items[c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们为一个采用字符键的映射创建了一个实现。值 R 表示可能的字符数（例如，ASCII 为 128）。好！通过了解Keys的范围以及它们将是什么类型的值，我们得到了一个简单而高效的数据结构。现在我们已经为字符创建了一些东西，那么字符串呢？</p><h2 id="发明-Trie"><a href="#发明-Trie" class="headerlink" title="发明 Trie"></a>发明 Trie</h2><p>Trie是一种非常有用的数据结构，用于可以将键分解为“字符”并与其他键（例如字符串）共享前缀的情况。</p><p>假设我们有一个包含“sam”、“sad”、“sap”、“same”、“a”和“awls”的集合。对于现有的 Set 实现，我们有以下可视化结构。我们如何使用我们已知的其他可能的数据结构来改进这一点？我们如何利用结构字符串？</p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321221008103.png" alt="image-20240321221008103"></p><p>以下是我们将使用的一些关键想法：</p><ul><li>每个节点只存储一个字母</li><li>节点可以由多个Keys共享</li></ul><p>因此，我们可以将 “sam”、“sad”、“sap”、“same”、“a” 和 “awls” 插入到包含单字符节点的树结构中。一个重要的观察结果是，这些单词中的大多数都具有相同的前缀，因此我们可以利用这些结构相似的字符串来构建我们的结构。换句话说，我们不会多次存储相同的前缀（例如“sa-”）。</p><p>看看下面的图表，看看 trie 会是什么样子：</p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321221027882.png"></p><p>尝试通过将Keys的每个“字符”存储为节点来工作。共享公共前缀的Keys共享相同的节点。要检查 trie 是否包含键，请沿着正确的节点从根部向下走。</p><p>由于我们要共享节点，我们必须想出某种方法来表示哪些字符串属于我们的集合，哪些不属于我们的集合。我们将通过将每个字符串的最后一个字符的颜色标记为蓝色来解决这个问题。请在下面观察我们的最终策略。</p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321221541527.png" alt="image-20240321221541527"></p><p>假设我们已经将字符串插入到我们的集合中，并且我们最终得到了上面的 trie，我们必须弄清楚搜索在我们当前的方案中将如何工作。为了搜索，我们将遍历我们的尝试，并在向下时与字符串的每个字符进行比较。因此，只有两种情况我们无法找到字符串;要么最后一个节点是白色的，要么我们从树上掉下来。</p><ul><li><code>contains(&quot;sam&quot;)</code> ：true，蓝色节点</li><li><code>contains(&quot;sa&quot;)</code> ：false，白色节点</li><li><code>contains(&quot;a&quot;)</code> ：true，蓝色节点</li><li><code>contains(&quot;saq&quot;)</code> ： 假的，从树上掉下来的</li></ul><p>练习 15.1.2.将字符串“ants”、“zebra”、“potato”和“sadness”添加到上面的 trie 中。绘制出生成的 trie 结构。</p><p>练习 15.1.3.想一想将 trie 用作地图与将 trie 用作集合之间的区别。（如果有的话）实现会有所不同吗？</p><p>在<a href="http://www.cs.princeton.edu/courses/archive/spring15/cos226/demo/52DemoTrie.mov">这里</a>查看创建 trie 地图的动画演示。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个关键的要点是，当我们为问题添加特异性时，我们通常可以通过添加额外的约束来改进通用数据结构。例如，我们改进了 HashMap 的实现，将键限制为只能是 ASCII 字符，从而创建了非常高效的数据结构。</p><ul><li>ADT 和特定实现之间是有区别的。例如，Disjoint Sets 是一个 ADT：任何 Disjoint Sets 都具有 和 <code>connect(x, y)</code> <code>isConnected(x, y)</code> 的方法。有四种不同的方法可以实现这些方法：快速查找、快速并集、加权 QU 和 WQUPC。</li><li>Trie 是专门用于字符串的 Sets 和 Maps 的特定实现。<ul><li>我们给每个节点一个字符，每个节点可以是 trie 中多个键的一部分。</li><li>只有当我们碰到一个未标记的节点或者从树上掉下来时，搜索才会失败</li><li>Re<strong>trie</strong>val tree的缩写，几乎每个人都将其发音为“try”，但爱德华·弗雷德金建议将其发音为“树”</li></ul></li></ul><h1 id="Trie的实现"><a href="#Trie的实现" class="headerlink" title="Trie的实现"></a>Trie的实现</h1><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>让我们实际尝试构建一个Trie。我们将采用第一种方法，即每个节点存储一个字母、其子节点和一个颜色的想法。由于我们知道每个节点键是一个字符，我们可以使用之前定义的DataIndexedCharMap类来映射所有节点的子节点。请记住，每个节点最多可以有可能字符数等于其子节点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieSet</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">128</span>; <span class="comment">// ASCII</span></span><br><span class="line">   <span class="keyword">private</span> Node root;    <span class="comment">// trie的根节点</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">char</span> ch;  </span><br><span class="line">      <span class="keyword">private</span> <span class="type">boolean</span> isKey;   </span><br><span class="line">      <span class="keyword">private</span> DataIndexedCharMap next;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">Node</span><span class="params">(<span class="type">char</span> c, <span class="type">boolean</span> blue, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">         ch = c; </span><br><span class="line">         isKey = blue;</span><br><span class="line">         next = <span class="keyword">new</span> <span class="title class_">DataIndexedCharMap</span>&lt;Node&gt;(R);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>聚焦于具有一个子节点的单个节点，我们可以观察到它的next变量，即DataIndexedCharMap对象，如果我们树中的节点具有相对较少的子节点，则将具有大多数空链接。我们将有128个链接，其中127个等于null，1个被使用。这意味着我们浪费了大量的多余空间！我们将进一步探讨替代表示方法。</p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321223837867.png" alt="image-20240321223837867"></p><p>但我们可以做出重要观察：只有当该字符存在时，每个链接才对应一个字符。因此，我们可以删除节点的字符变量，而是根据其在父DataIndexedCharMap中的位置确定字符的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieSet</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">128</span>; <span class="comment">// ASCII</span></span><br><span class="line">   <span class="keyword">private</span> Node root;    <span class="comment">// trie的根节点</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">boolean</span> isKey;   </span><br><span class="line">      <span class="keyword">private</span> DataIndexedCharMap next;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">Node</span><span class="params">(<span class="type">boolean</span> blue, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">         isKey = blue;</span><br><span class="line">         next = <span class="keyword">new</span> <span class="title class_">DataIndexedCharMap</span>&lt;Node&gt;(R);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321224738151.png" alt="image-20240321224738151"></p><p><strong>Exercise 15.2.1.</strong> 提出一种解决空间过度使用的解决方案。提示：尝试使用我们之前讨论过的一些实现。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>对于具有N个键的Trie，我们的Map&#x2F;Set操作的运行时如下：</p><ul><li>添加：<ul><li>$Θ(1)$</li></ul></li><li>包含：<ul><li>$Θ(1)$</li></ul></li></ul><p>为什么会这样？我们的trie中有多少项并不重要，运行时始终与键的数量无关。这是因为在最坏的情况下，我们只遍历一个键的长度，这与trie中的键的数量无关。因此，让我们通过可以测量的测量来查看运行时；用键的长度L表示：</p><ul><li>添加：<ul><li>$ Θ(L) $</li></ul></li><li>包含：<ul><li>$O(L)$</li></ul></li></ul><p>我们实现了恒定的运行时，而无需担心摊销调整时间或键的均匀分布，但正如我们上面提到的那样，我们当前的设计非常浪费，因为即使该字符不存在，每个节点都包含一个数组。</p><h3 id="子节点跟踪"><a href="#子节点跟踪" class="headerlink" title="子节点跟踪"></a>子节点跟踪</h3><p>我们遇到的问题是来自我们实现的DataIndexedCharMap对象的空间浪费，用于跟踪每个节点的子节点。这种方法的问题在于我们将初始化许多不包含任何子节点的空位。</p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321224839958.png" alt="image-20240321224839958"></p><p><strong>备选方案1：</strong> 基于哈希表的Trie。这不会创建128个位置的数组，而是仅在必要时初始化默认值，并根据负载因子调整数组的大小。</p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321224852484.png" alt="image-20240321224852484"></p><p><strong>备选方案2：</strong> 基于BST的Trie。同样，仅在必要时才会创建子节点指针，并且我们将在BST中存储子节点。显然，我们仍然需要担心在这个BST中搜索的运行时，但这不是一个坏的方法。</p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321224901524.png" alt="image-20240321224901524"></p><p>当我们实现Trie时，我们必须选择一个映射到我们的子节点的映射。Map是一个ADT，因此我们还必须选择映射的底层实现。这给我们重申了什么？在我们尝试创建ADT时，实现和ADT之间存在一个抽象屏障。这种抽象屏障使我们能够利用每种实现在尝试满足ADT行为时所提供的优势。让我们考虑每种优势：</p><p><strong>DataIndexedCharMap</strong></p><ul><li>空间：每个节点128个链接</li><li>运行时：$ \Theta(1) $</li></ul><p><strong>BST</strong></p><ul><li>空间：每个节点C个链接，其中C是子节点的数量</li><li>运行时：$ O(\log R) $，其中R是字母表的大小</li></ul><p><strong>哈希表</strong></p><ul><li>空间：每个节点C个链接，其中C是子节点的数量</li><li>运行时：$ O(R) $，其中R是字母表的大小</li></ul><p>注：BST和哈希表中每个链接的成本较高；R是一个固定数（这意味着我们可以将运行时视为常量）。</p><p>我们可以得出一些结论。存在轻微的内存和效率折衷（与BST&#x2F;哈希表相比DataIndexedCharMap）。Trie操作的运行时仍然是常数，没有任何注意事项。Trie将特别适用于一些特殊操作。</p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321225043141.png" alt="image-20240321225043141"></p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321225054570.png" alt="image-20240321225054570"></p><h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><p>回顾我们对Trie和其他数据结构之间的比较。我们可以看到，Trie提供了常数时间的查找和插入，但它们实际上是否比BST或哈希表表现得更好呢？可能不是。对于每个字符串，我们必须遍历每个字符，而在BST中，我们可以立即访问整个字符串。那么，Trie有什么好处呢？</p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321225202653.png" alt="image-20240321225202653"></p><h2 id="前缀匹配"><a href="#前缀匹配" class="headerlink" title="前缀匹配"></a>前缀匹配</h2><p>Trie的主要吸引力在于能够高效支持特定的字符串操作，比如前缀匹配。你可以想象为什么Trie使这个操作变得非常高效！假设我们要找到最长的前缀。只需取出你要查找的单词，将每个字符与trie中的字符进行比较，直到无法再继续。同样地，如果我们想要keyWithPrefix，我们可以遍历到前缀的末尾，并返回trie中所有剩余的键。</p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321225234086.png" alt="image-20240321225234086"></p><p>让我们尝试定义一个方法<code>collect</code>，它返回Trie中的所有键。伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">collect():</span><br><span class="line">    创建一个空结果列表x</span><br><span class="line">    对于根节点下的每个字符c：</span><br><span class="line">        调用colHelp(c, x, root.next.get(c))</span><br><span class="line">    返回x</span><br><span class="line"></span><br><span class="line">colHelp(String s, List&lt;String&gt; x, Node n):</span><br><span class="line">    如果n是键：</span><br><span class="line">        x.add(s)</span><br><span class="line">    对于n下的每个字符c：</span><br><span class="line">        调用colHelp(s + c, x, n.next.get(c))</span><br></pre></td></tr></table></figure><p>我们首先在父函数内初始化我们的值，然后创建一个递归辅助函数，以便在递归调用过程中传递更多的参数。如果当前字符串是一个键，我们只添加当前字符串，否则我们将字符连接到当前遍历的字符串&#x2F;路径，并调用下一个子节点的辅助函数。</p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321225326972.png" alt="image-20240321225326972"></p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321225353364.png" alt="image-20240321225353364"></p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321225406314.png" alt="image-20240321225406314"></p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321225416604.png" alt="image-20240321225416604"></p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321225427425.png" alt="image-20240321225427425"></p><p>现在，我们可以尝试编写<code>keysWithPrefix</code>方法，它返回包含作为参数传入的前缀的所有键。我们将大量借鉴上面的<code>collect</code>方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">keysWithPrefix(String s):</span><br><span class="line">    找到前缀的末尾，命名为alpha</span><br><span class="line">    创建一个空列表x</span><br><span class="line">    对于alpha.next中的每个字符：</span><br><span class="line">        调用colHelp(&quot;sa&quot; + c, x, alpha.next.get(c))</span><br><span class="line">    返回x</span><br></pre></td></tr></table></figure><p><strong>Exercise 15.3.1.</strong> 编写<code>longestPrefixOf</code>的伪代码。这将是一个你可以在实验室中完成的练习。确保观看关于如何实现其他方法的视频。</p><h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p>当你在任何搜索浏览器中输入文本时，例如Google，总会有关于你即将输入内容的建议。这非常有帮助和方便。比如，当我们搜索”How are you doing”时，如果我们只输入”how are”到google，我们会看到它建议这个确切的查询。</p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/F2kkT_BaBlTRCJFijRxrxVQ4rgn5Rph2YPB0pbN8F9WEhm2q5qeAiHqmwX6qJkSGXeEzvPQ5bdK41JDVkd8nmcW3yYlSmy_qLHe4WpQi65SzFePPEimxjqf7pRnOZ2WTbJpZPAh5f7Digianih0oOjgF=nw.png" alt="img"></p><p>实现这一功能的一种方法是使用Trie！我们将建立一个从字符串到值的映射。</p><ul><li>值将表示Google认为该字符串有多重要（可能是频率）</li><li>有效地存储数十亿个字符串，因为它们共享节点，减少了冗余</li><li>当用户输入查询时，我们可以调用<code>keysWithPrefix(x)</code>方法，并返回具有最高值的10个字符串</li></ul><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321225641545.png" alt="image-20240321225641545"></p><p>这个系统的一个主要缺陷是如果用户输入的是长度较短的字符串。你可以想象当实际上我们只想要10个键时，以输入作为前缀的键的数量可能达到了百万级别。解决这个问题的一个可能的方法是在每个节点中存储子字符串的最佳值。然后，我们可以按照最佳值的顺序考虑子节点。</p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321225552929.png" alt="image-20240321225552929"></p><p>另一个优化是合并多余的节点。这将给我们一个”基数Trie”，它在每个节点中保存字符以及字符串。我们不会深入讨论这个问题。</p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-21-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tries/image-20240321225602817.png" alt="image-20240321225602817"></p><p><strong>Exercise 15.3.2.</strong> 考虑将子字符串的最佳值添加到节点中将添加什么。你如何使用优先队列创建算法？</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>了解存储的数据类型可以让你在创建高效的数据结构时拥有巨大的优势。特别是对于实现Map和Set，如果我们知道所有键都是字符串，我们可以使用Trie：</p><ul><li>从理论上讲，Trie在搜索和插入方面的性能优于哈希表或平衡搜索树</li><li>有关如何存储trie的每个节点的子节点的更多实现，特别是三种。这三种方法都不错，但哈希表是最自然的方法<ul><li>DataIndexedCharMap（缺点：空间过度使用，优点：速度高效）</li><li>Bushy BST（缺点：子节点搜索较慢，优点：空间高效）</li><li>哈希表（缺点：每个链接的成本更高，优点：空间高效）</li></ul></li><li>在实践中，Trie实际上可能不会更快，但它们支持其他实现不支持的特殊字符串操作</li><li>由于Trie是按字符存储的，因此很容易实现<code>longestPrefixOf</code>和<code>keysWithPrefix</code></li><li><code>keysWithPrefix</code>允许存在诸如自动完成之类的算法，可以通过使用优先队列进行优化。</li></ul><table><thead><tr><th>key type</th><th><code>get(x)</code></th><th><code>add(x)</code></th><th></th></tr></thead><tbody><tr><td>Balanced BST</td><td>comparable</td><td>Θ(log<em>N</em>)</td><td>Θ(log<em>N</em>)</td></tr><tr><td>RSC Hash Table</td><td>hashable</td><td>Θ(1)†</td><td>Θ(1)∗†</td></tr><tr><td>Data Indexed Array</td><td>chars</td><td>Θ(1)</td><td>Θ(1)</td></tr><tr><td>Tries (BST, HT, DICM)</td><td>Strings</td><td>Θ(1)Θ(1)</td><td>Θ(1)</td></tr></tbody></table><p>*: Indicates “on average”.</p><p>†: Assuming items are evenly spread.</p><p>More generally, we can sometimes take special advantage of our key type to improve our sets and maps.</p><ul><li><p>Example: Tries handle String keys. Allow for fast string specific operations.</p></li><li><p>Note: There are many other types of string sets&#x2F;maps out there. </p></li><li><ul><li><p>Suffix Trees (<a href="https://en.wikipedia.org/wiki/Suffix_tree">Link</a>).</p></li><li><p>DAWG (<a href="https://en.wikipedia.org/wiki/Deterministic_acyclic_finite_state_automaton">Link</a>).</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(二十)-数据结构总结</title>
      <link href="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"/>
      <url>/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="The-Search-Problem"><a href="#The-Search-Problem" class="headerlink" title="The Search Problem"></a>The Search Problem</h1><p>我们面临的问题是：给定一个数据流，检索感兴趣的信息。</p><p>有哪些这样的例子？</p><ul><li>网站用户在个人页面上发帖。仅向好友提供内容。</li><li>给定数千个气象站的日志，显示指定日期和时间的天气图。</li><li>狗主人要求最好的宠物店，选择在价格、质量或氛围方面定义他们最好的商店。</li></ul><p>到目前为止，我们讨论的所有数据结构都是为了解决搜索问题。你可能会怎么问？我们学到的每个数据结构都用于将信息存储在方案中，从而在特定场景中提高搜索效率。</p><h2 id="Search-Data-Structures-搜索数据结构"><a href="#Search-Data-Structures-搜索数据结构" class="headerlink" title="Search Data Structures 搜索数据结构"></a>Search Data Structures 搜索数据结构</h2><table><thead><tr><th>Name</th><th>Store Operation(s)</th><th>Primary Retrieval Operation</th><th>Retrieve By</th></tr></thead><tbody><tr><td>List 列表</td><td><code>add(key)</code>, <code>insert(key, index)</code></td><td><code>get(index)</code></td><td>index</td></tr><tr><td>Map</td><td><code>put(key, value)</code></td><td><code>get(key)</code></td><td>key identity</td></tr><tr><td>Set</td><td><code>add(key)</code></td><td><code>containsKey(key)</code></td><td>key identity</td></tr><tr><td>PQ</td><td><code>add(key)</code></td><td><code>getSmallest()</code></td><td>key order (aka key size)</td></tr><tr><td>Disjoint Sets</td><td><code>connect(int1, int2)</code></td><td><code>isConnected(int1, int2)</code></td><td>two integer values</td></tr></tbody></table><p>请记住，这些是<strong>抽象数据</strong>类型。这意味着我们定义行为，而不是实现。我们在前面的章节中定义了许多可能的实现。让我们考虑一下这些实现和 ADT 是如何交互的：</p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240321220101385.png" alt="image-20240321220101385"></p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240321215753979.png" alt="image-20240321215753979"></p><p>这张图告诉我们什么？您会注意到的第一件事是，我们在前面的章节中设计的许多实现可用于实现许多不同的 ADT。您还会注意到红色的实现（表示性能不佳），这告诉我们并非所有实现都最适合我们试图实现的行为。</p><h1 id="Abstraction-抽象化"><a href="#Abstraction-抽象化" class="headerlink" title="Abstraction 抽象化"></a>Abstraction 抽象化</h1><p>抽象通常发生在层中。抽象数据类型通常可以包含两个抽象概念，归结为一个实现。让我们考虑一些例子：</p><ul><li>如果我们还记得优先级队列 ADT，我们就会试图找到一种对 PQ 操作有效的实现。我们决定使用堆有序树来实现我们的优先级队列，但正如我们所看到的，我们有几种方法（1A、1B、1C、2、3）来表示堆的树。</li><li>一个类似的想法是外部链接哈希表。此数据结构是使用存储桶数组实现的，但这些存储桶可以使用 ArrayList、Resizing Array、Linked List 或 BST 来完成。</li></ul><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240321215943057.png" alt="image-20240321215943057"></p><p>这两个例子告诉我们，我们通常可以通过使用另一个 ADT 来考虑 ADT。抽象数据类型具有抽象层，每个抽象层都定义了一个比之前的想法更具体的行为。</p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240321220021821.png" alt="image-20240321220021821"></p><p><img src="/2024/03/21/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240321220037489.png" alt="image-20240321220037489"></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(十九)-Rd16-QuadTrees、K-DTrees</title>
      <link href="/2024/03/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-19-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd16-QuadTrees%E3%80%81K-DTrees/"/>
      <url>/2024/03/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-19-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd16-QuadTrees%E3%80%81K-DTrees/</url>
      
        <content type="html"><![CDATA[<h1 id="Uniform-Partitioning-统一分区"><a href="#Uniform-Partitioning-统一分区" class="headerlink" title="Uniform Partitioning 统一分区"></a>Uniform Partitioning 统一分区</h1><h2 id="Motivation-赋予动机"><a href="#Motivation-赋予动机" class="headerlink" title="Motivation 赋予动机"></a>Motivation 赋予动机</h2><iframe frameborder="0" allowfullscreen src="https://www.youtube.com/embed/BV9Yi7eAEyY" style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; font-size: inherit; border: none; top: 0px; left: 0px; width: 770px; height: 458.125px;"></iframe><p>假设我们想对空间中的一组 Body 对象执行操作。例如，也许我们想问一些关于二维图像空间中的太阳体（如下图所示）的问题。</p><p><img src="/2024/03/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-19-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd16-QuadTrees%E3%80%81K-DTrees/image-20240320223311544.png" alt="image-20240320223311544"></p><h3 id="First-Question-2D-Range-Finding-第一个问题：2D-测距"><a href="#First-Question-2D-Range-Finding-第一个问题：2D-测距" class="headerlink" title="First Question: 2D Range Finding 第一个问题：2D 测距"></a>First Question: 2D Range Finding 第一个问题：2D 测距</h3><p>我们可能会问的一个问题是：一个区域中有多少个对象，例如在上面突出显示的绿色矩形中？</p><h3 id="Second-Question-Nearest-Neighbors-第二个问题：最近邻"><a href="#Second-Question-Nearest-Neighbors-第二个问题：最近邻" class="headerlink" title="Second Question: Nearest Neighbors 第二个问题：最近邻"></a>Second Question: Nearest Neighbors 第二个问题：最近邻</h3><p>我们可能会问的另一个问题是：离另一个物体最近的物体是什么，比如哪个太阳离我们的太空马最近？（通过目视检查发现的所需答案是太阳最接近其后蹄。</p><h2 id="Initial-Attempt-HashTable-初始尝试：HashTable"><a href="#Initial-Attempt-HashTable-初始尝试：HashTable" class="headerlink" title="Initial Attempt: HashTable 初始尝试：HashTable"></a>Initial Attempt: HashTable 初始尝试：HashTable</h2><p><strong>问题：</strong>如果我们的太阳集存储在 HashTable 中，那么找到最近邻问题的答案的运行时是什么？</p><p><strong>解决方案</strong>：每个物体所在的桶实际上是随机的，因此我们必须遍历所有 $N$ 物品，以检查每个太阳是否可能最接近马。 Θ(<em>N</em>) 。</p><p>让我们试着改进，这样我们就不必看我们布景中的每一个太阳来找到我们的答案。</p><h2 id="Second-Attempt-Uniform-Partitioning-第二次尝试：统一分区"><a href="#Second-Attempt-Uniform-Partitioning-第二次尝试：统一分区" class="headerlink" title="Second Attempt: Uniform Partitioning 第二次尝试：统一分区"></a>Second Attempt: Uniform Partitioning 第二次尝试：统一分区</h2><iframe frameborder="0" allowfullscreen src="https://www.youtube.com/embed/Ua7vmGcY3Qg" style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; font-size: inherit; border: none; top: 0px; left: 0px; width: 770px; height: 458.125px;"></iframe><p>哈希表的问题在于，项目的桶号实际上是随机的。哈希表绝对是无序集合。一个解决方法是确保铲斗编号仅取决于位置！</p><p>如果我们通过在图像空间上抛出一个 4x4 网格来均匀地划分图像空间，我们会得到井井有条的桶，看起来像这样（这有时也称为“空间散列”）：</p><p><img src="/2024/03/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-19-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd16-QuadTrees%E3%80%81K-DTrees/image-20240320223318286.png" alt="image-20240320223318286"></p><p>这可以通过不使用对象的 <code>hashCode()</code> 函数来实现，而是让每个对象提供 <code>getX()</code> 和 <code>getY()</code> 函数，以便它可以计算自己的存储桶编号。</p><p>现在，我们知道我们的搜索可以限制在哪些网格单元中，我们只需要查看这些特定单元中的太阳，而不是像以前那样查看整个图像空间中的所有太阳。</p><p><strong>一个区域中有多少个对象？</strong>：我们只需要查看存储桶 5、6、9 和 10。</p><p><strong>哪个太阳离马最近？</strong>：首先，我们从马所在的单元格开始：1 .然后，我们可以向外移动到0、4、5、6和2。 等等。</p><p><strong>问题</strong>：使用统一分区，假设太阳均匀分布，找到最近邻问题的答案的运行时是什么？</p><p><strong>解决方案</strong>：平均而言，运行时将比没有空间分区快 16 几倍，但不幸的是 $16&#x2F;N$ 仍然 $Θ(N)$ 如此。但是，这在实践中确实效果更好。</p><p>不过，让我们看看是否有更好的方法。</p><h1 id="QuadTrees"><a href="#QuadTrees" class="headerlink" title="QuadTrees"></a>QuadTrees</h1><h2 id="第三次尝试：QuadTrees"><a href="#第三次尝试：QuadTrees" class="headerlink" title="第三次尝试：QuadTrees"></a>第三次尝试：QuadTrees</h2><h3 id="基于X或基于Y的树"><a href="#基于X或基于Y的树" class="headerlink" title="基于X或基于Y的树"></a>基于X或基于Y的树</h3><p>搜索树相对于哈希表的一个关键优势在于树明确地跟踪项目的顺序。例如，在BST中查找最小项的时间复杂度是 Θ(logN)，但在哈希表中是 Θ(N)。让我们尝试利用这一点来为我们的目标提供更好的性能。</p><p>然而，这并不是微不足道的…为了构建一个二叉搜索树，我们需要能够比较对象。然而，在二维（或更多）空间中，一个对象在一个维度上可能是“小于”另一个对象，但在另一个维度上可能是“大于”另一个对象。那么，对于我们搜索树的目的，哪个维度应该是“较小”的和“较大”的呢？</p><p>例如，在下面的例子中，火星在x维度上“小于”地球，但在y维度上“大于”地球。</p><p><img src="/2024/03/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-19-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd16-QuadTrees%E3%80%81K-DTrees/image-20240320221951093.png" alt="image-20240320221951093"></p><p>所以我们应该使用下面显示的这两种表示中的哪一种呢？请记住，我们不想任意地进行决定，因为我们需要确切地知道一个节点是否将位于树中的特定路径下，否则，我们可能会失去我们的 Θ(logN) 时间复杂度。</p><p>假设我们使用基于X的树——也就是说——我们构建一个仅查看x坐标的BST。（在组织时忽略y坐标。）对于一个更大的例子，我们可能会得到如下结果：</p><p><img src="/2024/03/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-19-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd16-QuadTrees%E3%80%81K-DTrees/image-20240320221928361.png" alt="image-20240320221928361"></p><p><img src="/2024/03/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-19-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd16-QuadTrees%E3%80%81K-DTrees/image-20240320221902842.png" alt="image-20240320221902842"></p><p>请注意，如果我们在这棵树上执行搜索，并且我们正在寻找一个x坐标小于−1的点，当我们选择左侧路径时，我们立即就能丢弃右子树中的所有内容。这相当于说，我们能够将我们的搜索空间从整个图像空间缩小到只有绿色矩形。跳过搜索树部分的能力称为“修剪”。</p><p>然而，相反地，如果我们正在寻找具有特定y坐标的点，我们的基于X的树不适用于这种类型的搜索，我们将不得不在线性搜索所有节点。</p><p>无论我们选择基于X的树表示还是基于Y的树表示，我们总是会有次优的修剪；在优化的维度中搜索将是 Θ(logN)，但在非优化的维度中搜索将是 Θ(N) 的运行时间。</p><h3 id="QuadTree"><a href="#QuadTree" class="headerlink" title="QuadTree"></a>QuadTree</h3><div class="row">    <embed src="cs61b-quadtree-insertion-demo.pdf" width="100%" height="550" type="application/pdf"></div><p>我们可以通过同时在两个方向上进行拆分来解决这个问题。这就是QuadTree。</p><p>在这里，我们看到节点A将其周围的区域分为西北、东北、东南和西南四个区域。由于B位于A的东北象限，当我们插入B时，我们可以将其作为A的NE子节点。</p><p><img src="/2024/03/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-19-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd16-QuadTrees%E3%80%81K-DTrees/image-20240320221815789.png" alt="image-20240320221815789"></p><p>请注意，就像在BST中一样，我们插入节点的顺序决定了QuadTree的拓扑结构。</p><p>还请注意，QuadTrees是一种伪装的空间划分形式。类似于如何统一划分创建了一个完美的网格，QuadTrees通过每个节点“拥有”4个子空间来分层划分。</p><p>有效地，有许多点的空间被划分为更细分的区域，而在许多情况下，这会提供更好的性能。</p><h3 id="使用QuadTree进行范围搜索"><a href="#使用QuadTree进行范围搜索" class="headerlink" title="使用QuadTree进行范围搜索"></a>使用QuadTree进行范围搜索</h3><div class="row">    <embed src="cs61b-quadtree-range-search-demo.pdf" width="100%" height="550" type="application/pdf"></div><p>请注意，由QuadTree的每个节点施加的4向划分，我们仍然有之前在基于X和基于Y的树中如此有利的修剪效果！如果我们正在寻找绿色矩形内的点，从任何节点开始，我们可以决定绿色矩形是否位于一个或多个象限内，并且只探索与那些象限相对应的分支&#x2F;子树。所有其他象限都可以安全地被忽略和修剪掉。下面，我们看到绿色矩形仅位于东北象限，因此西北、东南和西南象限都可以被修剪掉并留待后续探索。我们可以递归进行。</p><p>Quad-Trees非常适合于二维空间，因为只有4个象限。但是，如果我们想要进入更高维度的空间，我们将在下一章中探讨另一个能够解决这个问题的数据结构。</p><h1 id="K-D-Trees"><a href="#K-D-Trees" class="headerlink" title="K-D Trees"></a>K-D Trees</h1><div class="row">    <embed src="-cs61b-kdtree-insertion-demo.pdf" width="100%" height="550" type="application/pdf"></div><p>一种将分层分区思想扩展到高于两个维度的方法是使用K-D树。它通过逐级地在所有维度之间旋转来工作。</p><p>因此，对于二维情况，它在第一级上像基于X的树一样分区，然后在下一级像基于Y的树一样，然后在第三级像基于X的树，第四级像基于Y的树，依此类推。</p><p>在第一个图中，您可以看到每个级别如何分区。在下面的图中，您可以看到树节点与二维空间中其他节点的关系。<strong>请注意</strong>当您对K-D树或四叉树运行操作时，应该考虑树结构（第一张图片）而不是二维空间（第二张图片），因为只有树包含关于级别的信息。</p><p><img src="/2024/03/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-19-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd16-QuadTrees%E3%80%81K-DTrees/image-20240320222213829.png" alt="image-20240320222213829"></p><p>对于三维情况，它在每三个级别之间轮换三个维度，对于更高维度，依此类推。在这里，您可以看到K-D树的优点在于它更容易推广到更高维度。但是，无论维度多高，K-D树始终都将是一个<strong>二叉</strong>树，因为每个级别都被分成“大于”和“小于”。</p><p>要找到最接近查询点的点，我们在K-D树中遵循以下步骤：</p><div class="row">    <embed src="cs61b-kdtree-nearest-demo.pdf" width="100%" height="550" type="application/pdf"></div><ul><li>从根节点开始，将该点存储为“到目前为止最佳”。计算其与查询点的距离，并将其保存为“要打败的分数”。在上图中，我们从距离标记点最近的A开始，其距离为4.5。</li><li>此节点将其周围的空间分成两个子空间。对于每个子空间，问：“在这个空间内可能找到更好的点吗？”这个问题可以通过计算查询点与我们子空间边缘之间的最短距离来回答（见下图中的虚线紫线）。</li><li><img src="/2024/03/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-19-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd16-QuadTrees%E3%80%81K-DTrees/image-20240320222311449.png" alt="image-20240320222311449"></li><li>对于被确定为包含可能更好点的每个子空间，继续递归。</li><li>最后，我们的“到目前为止最佳”是最佳点；最接近查询点的点。</li></ul><p>请参阅这些<a href="https://docs.google.com/presentation/d/1DNunK22t-4OU_9c-OBgKkMAdly9aZQkWuv_tBkDg1G4/edit">幻灯片</a>以逐步了解。</p><h2 id="摘要和应用"><a href="#摘要和应用" class="headerlink" title="摘要和应用"></a>摘要和应用</h2><p>请参见上面的视频，了解本章的摘要以及所提供的数据结构的一些有趣应用。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B库设置</title>
      <link href="/2024/03/20/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-0-CS61B%E5%BA%93%E8%AE%BE%E7%BD%AE/"/>
      <url>/2024/03/20/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-0-CS61B%E5%BA%93%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>设置教程:<a href="https://sp21.datastructur.es/materials/lab/lab2setup/lab2setup">Lab 2 Setup: Library Setup | CS 61B Spring 2021 (datastructur.es)</a></p><p><img src="/2024/03/20/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-0-CS61B%E5%BA%93%E8%AE%BE%E7%BD%AE/image-20240320180224899.png" alt="image-20240320180224899"></p><p><img src="/2024/03/20/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-0-CS61B%E5%BA%93%E8%AE%BE%E7%BD%AE/image-20240320180236855.png" alt="image-20240320180236855"></p><p><img src="/2024/03/20/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-0-CS61B%E5%BA%93%E8%AE%BE%E7%BD%AE/image-20240320180248345.png" alt="image-20240320180248345"></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(十八)-RD19-20-最短路径、最小生成树</title>
      <link href="/2024/03/19/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-18-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD19-20-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2024/03/19/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-18-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD19-20-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="最短路径-SPT"><a href="#最短路径-SPT" class="headerlink" title="最短路径(SPT)"></a>最短路径(SPT)</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>到目前为止，我们有以下方法可以完成以下任务：</p><ul><li>找到从给定顶点 <em>s</em> 到图中每个可到达顶点的路径。</li><li>找到从给定顶点 <em>s</em> 到图中每个可到达顶点的<strong>最短</strong>路径。（…或者我们找到了吗？）</li></ul><p>在我们回答上述神秘问题之前，让我们进一步回顾一下我们可以使用的两种搜索类型：BFS 或 DFS。</p><p>两者都始终正确吗？是的。哪一个结果更好？BFS找到了<strong>最短</strong>路径，而DFS则没有。在运行时间上，哪一个更有效率？都不是。在空间上，哪一个更有效率？</p><ul><li>对于稀疏图，DFS更糟糕。想象一下一个有10000个节点且都很稀疏的图。我们最终会进行10000次递归调用，这对空间来说是不好的。</li><li>对于“树状”图，BFS更糟糕，因为我们的队列会经常被使用。</li></ul><h2 id="回答神秘问题"><a href="#回答神秘问题" class="headerlink" title="回答神秘问题"></a>回答神秘问题</h2><p>我们是否开发了一种算法来找到从给定顶点到每个其他可到达顶点的<strong>最短</strong>路径？嗯，有点像是。我们开发了一种在没有边标签的图上运行良好的算法。这是我们做的：我们开发了一种算法，它从给定的源顶点找到了我们最短（<strong>其中最短的意思是最少的边数</strong>）的路径。</p><p>但这并不总是最短的正确定义。有时，我们的图边可能有‘权重’，如果 A-B 边的权重为5，而 A-C 边的权重只有3，那么A-B 被认为比 A-C 更远。</p><p>考虑以下图像以了解问题所在。</p><p><img src="/2024/03/19/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-18-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD19-20-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20240319234957049.png" alt="image-20240319234957049"></p><blockquote><p>右边边最少但是他并不是最短的</p></blockquote><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><div class="row">    <embed src="CS61B-Dijkstra&#39;s-Algorithm-Demo.pdf" width="100%" height="550" type="application/pdf"></div><p>执行以下两项操作。</p><ol><li>查找从标记 0 的顶点到标记的 5 顶点的路径。</li><li>从标记为 0 的顶点中查找最短路径树。（即，找到从图中 0 到每个顶点的最短路径。</li><li>尝试想出一种算法来做到这一点。</li></ol><h3 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h3><p>注意最短路径（对于带有权重的图）可能有许多许多边。我们关心的是选择路径上边的权重之和的最小化。</p><p>其次，请注意从源<strong>s</strong>到达的最短路径树可以通过以下方式创建：</p><ul><li>对于图中的每个顶点<strong>v</strong>（不是<strong>s</strong>），找到从<strong>s</strong>到<strong>v</strong>的最短路径。</li><li>“合并”所有上述找到的边。完成！</li></ul><p>第三，请注意“最短路径树”将<strong>始终是一棵树</strong>。为什么？嗯，让我们考虑一下我们的原始解决方案，其中我们维护了一个<code>edgeTo</code>数组。对于每个节点，在<code>edgeTo</code>数组中恰好有一个“父节点”。（这为什么意味着“最短路径树”将是一棵树？提示：一棵树有<strong>V-1</strong>条边，其中<strong>V</strong>是树中的节点数。）</p><p>Dijkstra算法接受输入顶点<strong>s</strong>，并输出从<strong>s</strong>出发的最短路径树。它是如何工作的呢？</p><ol><li>创建一个优先队列。</li><li>将<strong>s</strong>添加到优先队列，并将优先级设置为0。将所有其他顶点添加到优先队列，并将优先级设置为∞。</li><li>当优先队列不为空时：弹出优先队列中的一个顶点，并<strong>释放</strong>该顶点出发的所有边。</li></ol><h3 id="什么是释放？"><a href="#什么是释放？" class="headerlink" title="什么是释放？"></a>什么是<strong>释放</strong>？</h3><p>假设我们刚刚从优先队列中弹出的顶点是<strong>v</strong>。我们将查看<strong>v</strong>的所有边。假设我们正在查看边(<strong>v</strong>,<strong>w</strong>)（从<strong>v</strong>到<strong>w</strong>的边）。我们将尝试对这条边进行释放。</p><p>这意味着：查看您从源到<strong>w</strong>的当前最佳距离，称为<code>curBestDistToW</code>。现在，查看<code>curBestDistToV+weight(v, w)</code>（称为<code>potentialDistToWUsingV</code>）。</p><p><code>potentialDistToWUsingV</code>是否<strong>更好，即更小</strong>，比<code>curBestDistToW</code>？在这种情况下，将<code>curBestDistToW=potentialDistToWUsingV</code>，更新<code>edgeTo[w]</code>为<strong>v</strong>。</p><p><strong>重要说明：我们不会释放指向已访问顶点的边。</strong></p><p>计算潜在距离、检查是否更好以及可能更新的整个过程称为释放。</p><p>通过以下图像捕获了另一种定义。<img src="/2024/03/19/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-18-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD19-20-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/pz1muo.jpg" alt="img"></p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">dijkstras</span><span class="params">(source)</span>:</span><br><span class="line">    PQ.add(source, <span class="number">0</span>)</span><br><span class="line">    For all other vertices, v, PQ.add(v, infinity)</span><br><span class="line">    <span class="keyword">while</span> PQ is not empty:</span><br><span class="line">        p = PQ.removeSmallest()</span><br><span class="line">        relax(all edges from p)</span><br><span class="line">def <span class="title function_">relax</span><span class="params">(edge p,q)</span>:</span><br><span class="line">   <span class="keyword">if</span> q is <span class="title function_">visited</span> <span class="params">(i.e., q is not in PQ)</span>:</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> distTo[p] + weight(edge) &lt; distTo[q]:</span><br><span class="line">       distTo[q] = distTo[p] + w</span><br><span class="line">       edgeTo[q] = p</span><br><span class="line">       PQ.changePriority(q, distTo[q])</span><br></pre></td></tr></table></figure><h3 id="保证"><a href="#保证" class="headerlink" title="保证"></a>保证</h3><p>只要边都是非负的，迪杰斯特拉算法就保证是最优的。</p><h3 id="证明和直觉"><a href="#证明和直觉" class="headerlink" title="证明和直觉"></a>证明和直觉</h3><p>假设所有边都是非负的。</p><ul><li><p>在开始时，<code>distTo[source]</code> &#x3D; 0。这是最优的。</p></li><li><p>在从源开始释放所有边之后，让顶点<strong>v1</strong>是权重最小的顶点（即距离源最近的顶点）。</p><p>声明：<code>distTo[v1]</code>是最优的，即在此时刻，<code>distTo[v1]</code>的值是从<strong>s</strong>到<strong>v1</strong>的最短距离。为什么？</p><ul><li>让我们尝试理解为什么<strong>必须</strong>如此。</li><li>假设不是这种情况。那意味着从<strong>s</strong>到<strong>v1</strong>存在一条比直接路径(<strong>s</strong>,<strong>v1</strong>)更短的路径。好的，那么让我们考虑这条假设中更短的路径…它将会是(<strong>s</strong>,<strong>va</strong>,<strong>vb</strong>,…,<strong>v1</strong>)这样的路径。但是…(<strong>s</strong>,<strong>va</strong>)已经比(<strong>s</strong>,<strong>v1</strong>)大了。（请注意，这是因为<strong>v1</strong>是上面最接近<strong>s</strong>的顶点。）那么如何可能存在一条实际上更短的路径呢？不可能！</li></ul></li><li><p>现在，下一个弹出的顶点将是<strong>v1</strong>。（为什么？请注意，它目前在优先队列中的优先级最低！）</p></li><li><p>所以现在，我们可以为<strong>v1</strong>及其进行的所有释放做出同样的论证。（这称为“归纳证明”。这有点像证明的递归。）就是这样；我们完成了。</p></li></ul><h3 id="负边？"><a href="#负边？" class="headerlink" title="负边？"></a>负边？</h3><p>当负边出现时，情况可能会变得非常糟糕。考虑以下图像。</p><p>假设您在标记为34的顶点。现在，您将尝试释放所有您的边。您只有一条从自己到标记为33的顶点的出边，权重为−67。啊，但是请注意：顶点33已经被访问（用白色标记）。所以…我们不会对其进行释放。（回顾一下relax方法的伪代码。）</p><p>现在我们回家，认为到33的最短距离是82（用粉色标记）。但实际上，我们应该走<strong>通过</strong>34的路径，因为这会给我们34−67&#x3D;34的距离。糟糕。</p><p><strong>对于负边，Dijkstra算法不能保证正确。它可能有效…但不能保证有效。</strong></p><p>试一试：假设您的图具有负边，但所有负边都只从您传入的源顶点<strong>s</strong>出发。迪杰斯特拉算法有效吗？为什么&#x2F;为什么不？</p><h3 id="一个值得注意的不变性"><a href="#一个值得注意的不变性" class="headerlink" title="一个值得注意的不变性"></a>一个值得注意的不变性</h3><p>请注意，一旦顶点从优先队列中弹出，它就永远不会被重新添加。它的距离永远不会被更新。因此，换句话说，一旦顶点从优先队列中弹出，我们<strong>知道</strong>到该顶点的真正最短距离。</p><p>这个事实的一个好处是“短路”。假设…我不关心最短路径树，而只想找到从某个源到某个其他目标的最短路径。假设您想要在世界各城市上构建一个图，并找到从伯克利到奥克兰的最短路径。运行<code>dijkstra(Berkeley)</code>将意味着您无法停止这个强大的算法…您必须让它运行…直到它找到到洛杉矶、休斯顿、纽约市和所有可能的地方的最短路径！</p><p>好吧。一旦算法中的<code>Oakland</code>从优先队列中弹出，我们就可以停止。我们只需返回此时的距离和路径，它将是正确的。因此，<strong>有时</strong><code>dijkstra</code>不仅接受源，还接受目标。这是为了短路的目的。</p><h2 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h2><div class="row">    <embed src="A_Algorithm-Demo.pdf" width="100%" height="550" type="application/pdf"></div><p>我们通过讨论一种可能的方法来结束Dijkstra算法部分，即使其在碰到给定目标后就停止。这样做足够好吗？</p><p>要回答上面的问题，我们需要坐下来思考Dijkstra算法的实际工作原理。以图形方式表示，Dijkstra从源节点开始（想象源节点是圆心）。然后，Dijkstra算法围绕这一点以递增的半径绘制同心圆，并“扫描”这些圆，捕捉点。</p><p>因此…Dijkstra首先访问的节点是距离源点最近的城市，然后是次最近的城市，依此类推。这听起来是个好主意。Dijkstra首先访问距离1个单位的所有城市，然后是距离2个单位的城市，依此类推，形成同心圆。</p><p>现在想象一下以下情况：在美国地图上，从中心某处开始，比如丹佛。现在我想让你用Dijkstra找到一条到纽约的路径。你将按照“最接近的同心圆”的顺序遍历节点。</p><p>你将首先绘制一个小圆，就在丹佛附近，访问该圆内的所有城市。最终，你的圆将变大，你将绘制一个通过拉斯维加斯的圆（到目前为止，该圆将访问所有其他位于圆内的城市）。然后，你的圆将足够大，能够覆盖洛杉矶和达拉斯…但你离纽约还差得远。所有这些努力，所有这些圆，但是…离目标还很远。短路帮助了，但只有在你快速到达目标节点时才有效。</p><p>如果我们能有一种方法利用你的先验知识：纽约在东边，这样你就可以“提示”你的算法更喜欢东边的节点，而不是西边的节点。</p><h3 id="引入：A"><a href="#引入：A" class="headerlink" title="引入：A*"></a>引入：A*</h3><p>不，不是太阳。这是一种叫做A*的算法。</p><p>观察以下事实：Dijkstra是从源到节点的距离的“真实”（即不是估计）度量。因此，假设你访问了伊利诺伊州的一个城市，你的源是丹佛，那么在那时，你已经得到了到丹佛的距离的真实度量。我们缺少的是：从节点到目标节点纽约的距离的一些粗略估计。这将完整地呈现出整个图景。因为如果你把这两个因素相加（从源到节点的度量+从节点到目标的估计），你得到（从源到目标的估计）。当然，你原始的从节点到目标的估计越好，你从源到目标的估计就越好，你的A*算法就越好。</p><p>因此，让我们稍微修改我们的Dijkstra算法。在Dijkstra中，我们使用<code>bestKnownDistToV</code>作为我们算法中的优先级。这次，我们将使用<code>bestKnownDistToV+estimateFromVToGoal</code>作为我们的启发式。</p><p>这里有一个<a href="https://docs.google.com/presentation/d/177bRUTdCa60fjExdr9eO04NHm0MRfPtCzvEup1iMccM/edit#slide=id.g771336078_0_180">演示</a>！</p><h3 id="鸡和蛋"><a href="#鸡和蛋" class="headerlink" title="鸡和蛋"></a>鸡和蛋</h3><p>我们有一个问题。我们怎么知道估计值是多少？我的意思是，估计值本身是一种<strong>距离</strong>，而我们正在使用A*来<strong>找到</strong>从某个节点到另一个节点的距离。</p><p>这似乎像是一个经典的鸡和蛋问题实例。“先有鸡还是先有蛋？”顺便说一下，有个Reddit用户对此有了一个<a href="https://www.reddit.com/r/dadjokes/comments/97768x/i_ordered_a_chicken_and_an_egg_from_amazon_ill/">想法</a>。</p><p>嗯，它被称为估计，因为它确实是这样。我们使用A*来得到从源到目标的<strong>真实</strong>最短路径，但估计值是我们近似的。有时候得到好的估计是困难的。</p><p>但是，让我们以丹佛 - 纽约的例子来举例说明。我们可以做的是查找这些城市的GPS坐标，并计算其中的直线距离。当然，这可能不正确，因为从丹佛到纽约可能没有直线可走，但这是一个相当好的估计！</p><h3 id="不好的启发式"><a href="#不好的启发式" class="headerlink" title="不好的启发式"></a>不好的启发式</h3><p>假设从丹佛到纽约的最短路径经过某个城市<em>C</em>。假设我的GPS坏了，因此我认为这个城市<em>C</em>离一切都是无限远的，所以我将从图中的每个其他节点到城市<em>C</em>的估计距离设置为∞。</p><p>会发生什么？嗯，A*基本上永远不想访问这个城市。 （记住我们在优先级队列中的优先级是什么；对于这个城市，优先级将始终为∞，即使</p><h1 id="最小生成树-MST"><a href="#最小生成树-MST" class="headerlink" title="最小生成树(MST)"></a>最小生成树(MST)</h1><p>最小生成树（MST）是图中可能的最轻的边集，使得所有顶点都连接在一起。由于它是一棵树，它必须是连通的且无环的。而且它被称为“生成”，因为所有顶点都包括在内。</p><p><img src="/2024/03/19/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-18-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD19-20-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20240320172133841.png" alt="image-20240320172133841"></p><blockquote><ul><li><p>条件</p><ul><li><p>连接的</p></li><li><p>非闭环的</p></li><li><p>包括了所有顶点</p></li></ul></li></ul></blockquote><p>在这一章中，我们将看两个算法，它们将帮助我们从一个图中找到一个最小生成树。</p><p>在我们开始之前，让我们介绍一下割属性，这是一个有助于找到最小生成树的工具。</p><h2 id="割属性"><a href="#割属性" class="headerlink" title="割属性"></a>割属性</h2><p>我们可以将一个割定义为对图的节点分配给两个非空集合（即我们将每个节点分配给第一个集合或第二个集合）。</p><p>我们可以将一个横跨的边定义为连接一个集合中的节点到另一个集合中的节点的边。</p><p>有了这两个定义，我们就可以理解割属性了：给定任何一个割，最小权重的横跨边都在最小生成树中。</p><p>割属性的证明如下：假设（为了推导矛盾）最小横跨边 e 不在最小生成树中。由于它不是最小生成树的一部分，如果我们添加该边，就会创建一个循环。因为有一个循环，这意味着另一个边 f 也必须是一个横跨边（对于一个循环，如果 e 从一个集合穿过到另一个集合，就必须有另一条边穿过回到第一个集合）。因此，我们可以移除 f 并保留 e，这将给我们一个更低权重的生成树。但这是一个矛盾，因为我们假设开始时有一个最小生成树，但现在我们有了一个权重更小的生成树，因此原始的最小生成树实际上并不是最小的。因此，割属性必须成立。</p><p>下面是一张图示，说明了上述证明的一些论点：</p><p><img src="/2024/03/19/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-18-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD19-20-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20240320172407081.png" alt="image-20240320172407081"></p><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><div class="row">    <embed src="CS61B-Prim&#39;s-Demo.pdf" width="100%" height="550" type="application/pdf"></div><p>这是一种从图中找到最小生成树（MST）的算法。它的步骤如下：</p><ol><li>从任意起始节点开始。</li><li>反复添加具有一个节点在正在构建的MST内的最短边。</li><li>重复直到有$V-1$条边。</li></ol><p>Prim算法之所以有效，是因为在算法的所有阶段，如果我们将所有节点都作为我们正在构建的MST的一部分，而将所有其他节点视为第二个集合，那么这个算法总是添加横跨此割的最轻的边，根据割属性，这个边必然是最终MST的一部分。</p><p>从本质上讲，该算法通过与Dijkstra算法相同的机制运行，但是Dijkstra算法考虑的是候选节点距离源节点的距离，而Prim算法则查看每个候选节点距离正在构建的MST的距离。</p><p>因此，如果使用与Dijkstra算法相同的机制进行Prim算法，其运行时间将与Dijkstra算法相同，即 </p><p>$O((|V| + |E|) \log |V|)$。请记住，这是因为我们需要为每条边添加到优先级队列中的外围，并且我们需要为每个顶点从中出队一次。</p><p><img src="/2024/03/19/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-18-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD19-20-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/2024-03-20-17-19-38.gif" alt="2024-03-20-17-19-38"></p><blockquote><ul><li><p>区别: </p><ul><li><p>SPT: 从源顶点出发，所以在哪里开始很重要</p></li><li><p>MSP: 全局属性，与源顶点无关</p></li></ul></li></ul></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><img src="/2024/03/19/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-18-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD19-20-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20240320172951394.png" alt="image-20240320172951394"></p><p><img src="/2024/03/19/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-18-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD19-20-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20240320173004710.png" alt="image-20240320173004710"></p><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><div class="row">    <embed src="kruskals-realistic-implementation-demo.pdf" width="100%" height="550" type="application/pdf"></div><p>这是另一种从图中找到最小生成树（MST）的算法。Kruskal返回的最小生成树可能与Prim返回的不同，但是这两个算法都将始终返回一个MST；因为两者都是最小的（最优的），它们都将给出有效的最优解（它们在最小&#x2F;总权重相同的情况下一样优，而且这是尽可能低的）。</p><p>该算法步骤如下：</p><ol><li>将所有边从最轻到最重排序。</li><li>逐个考虑边（按排序顺序），如果添加该边不会形成循环，则将其添加到我们正在构建的MST中。</li><li>重复直到有 $V-1$ 条边。</li></ol><p>Kruskal算法有效的原因是我们添加的任何边都将连接一个节点，我们可以说这个节点是一个集合的一部分，以及第二个节点，我们可以说是第二个集合的一部分。我们添加的这条边不是循环的一部分，因为我们只有在不会形成循环的情况下才会添加一条边。此外，我们按照从最轻到最重的顺序查看候选边。因此，我们要添加的这条边必须是横跨此割的最轻的边（如果存在一条更轻的边，那么它将在此之前被添加，添加这条边将导致出现循环）。因此，该算法也是通过割属性工作的。</p><p>Kruskal算法运行时间为$O(|E| \log |E|)$，因为算法的瓶颈是开始时对所有边进行排序（例如，我们可以使用堆排序，其中我们将所有边插入堆中，并逐个删除最小边）。如果我们已经给出了预先排序的边并且不需要为此付出代价，那么运行时间是 $O(∣E∣log ^∗  ∣V∣)$。这是因为每当我们提出要添加的边时，我们都需要检查它是否会引入循环。我们知道如何做到这一点的一种方法是使用带路径压缩的加权快速并查集；这将有效地告诉我们两个节点是否已经连接在一起。这将花费$∣E∣$ 次调用 <code>isConnected</code>，每次调用的成本为$ O(log ^∗  ∣V∣)$，其中$log^*$是阿克曼函数。</p><p><img src="/2024/03/19/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-18-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD19-20-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/2024-03-20-17-17-07.gif" alt="2024-03-20-17-17-07"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p><img src="/2024/03/19/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-18-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD19-20-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20240320173029921.png" alt="image-20240320173029921"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2024/03/19/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-18-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD19-20-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20240320173106199.png" alt="image-20240320173106199"></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Puzzle</title>
      <link href="/2024/03/17/Flutter-%E6%B8%B8%E6%88%8F-Puzzle/"/>
      <url>/2024/03/17/Flutter-%E6%B8%B8%E6%88%8F-Puzzle/</url>
      
        <content type="html"><![CDATA[<p>github仓库:<a href="https://github.com/xxbaizero0/PuzzleFlutterGame">xxbaizero0&#x2F;PuzzleFlutterGame: A flutter game (github.com)</a></p><p>AspectRatio参考文章</p><p>- <a href="https://juejin.cn/post/6844903856988487693#heading-1">Flutter 约束宽高比的控件 AspectRatio - 掘金 (juejin.cn)</a></p><p>- <a href="https://juejin.cn/post/7112017871949004807#heading-1">flutter系列之:按比例缩放的AspectRatio和FractionallySizedBox - 掘金 (juejin.cn)</a></p><p>GridView参考文章<a href="https://juejin.cn/post/6844903889502732295#heading-1">Flutter网格型布局 - GridView篇 - 掘金 (juejin.cn)</a></p><p>对话框参考文章: <a href="https://juejin.cn/post/6844903773198893070?searchId=20240317172222E33C0EED28126222B1ED">Flutter之Dialog使用和踩坑 - 掘金 (juejin.cn)</a></p><p>privide参考文章</p><p>- <a href="https://juejin.cn/post/7015887922117214238#heading-9">Flutter Provider状态管理—八种提供者使用分析 - 掘金 (juejin.cn)</a></p><p>- <a href="https://flyingstudio.feishu.cn/wiki/E2TSwTtZ9ik92EkCLpHcjAvbnRu?from=from_copylink">https://flyingstudio.feishu.cn/wiki/E2TSwTtZ9ik92EkCLpHcjAvbnRu?from=from_copylink</a></p><p>预览</p><p><img src="/2024/03/17/Flutter-%E6%B8%B8%E6%88%8F-Puzzle/2024-03-17-15-11-36.gif" alt="2024-03-17-15-11-36"></p><ul><li>UI界面<ul><li>Header部分</li><li>Panel部分</li></ul></li><li>游戏逻辑<ul><li>数据源与游戏初始化</li><li>图片切割</li><li>滑动手势识别</li><li>图片的移动与合并</li><li>判断游戏结束</li><li>重新开始游戏</li><li>设置难度</li></ul></li></ul><h1 id="初始设置"><a href="#初始设置" class="headerlink" title="初始设置"></a>初始设置</h1><p>文件结构</p><p><img src="/2024/03/17/Flutter-%E6%B8%B8%E6%88%8F-Puzzle/image-20240317173710807.png" alt="image-20240317173710807"></p><p><code>pubspec.yaml</code>文件</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line"></span><br><span class="line">  image: ^<span class="number">4.1</span><span class="number">.7</span></span><br><span class="line">  provider: ^<span class="number">6.1</span><span class="number">.2</span></span><br><span class="line">      </span><br><span class="line">flutter:</span><br><span class="line">  assets:</span><br><span class="line">    - assets/imgs/</span><br></pre></td></tr></table></figure><p><img src="/2024/03/17/Flutter-%E6%B8%B8%E6%88%8F-Puzzle/image-20240317173621834.png" alt="image-20240317173621834"></p><p><img src="/2024/03/17/Flutter-%E6%B8%B8%E6%88%8F-Puzzle/image-20240317173649101.png" alt="image-20240317173649101"></p><h1 id="UI界面"><a href="#UI界面" class="headerlink" title="UI界面"></a>UI界面</h1><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>Header界面比较容易，分析一下就是一个Row接两个Column就好了，代码如下</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> Row(</span><br><span class="line">      mainAxisAlignment: MainAxisAlignment.spaceBetween,</span><br><span class="line">      crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">      children: [</span><br><span class="line">        Container(</span><br><span class="line">          padding: <span class="keyword">const</span> EdgeInsets.fromLTRB(<span class="number">20</span>, <span class="number">40</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">          child: Column(</span><br><span class="line">            children: [</span><br><span class="line">              <span class="keyword">const</span> Text(<span class="string">&quot;拼图&quot;</span>,</span><br><span class="line">                style: TextStyle(</span><br><span class="line">                    fontSize: <span class="number">75</span>,</span><br><span class="line">                    color: Color.fromARGB(<span class="number">255</span>, <span class="number">119</span>, <span class="number">110</span>, <span class="number">101</span>),</span><br><span class="line">                    fontWeight: FontWeight.bold</span><br><span class="line">                ),),</span><br><span class="line">              SizedBox(height: <span class="number">12</span>,),</span><br><span class="line">              newGame()</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        Container(</span><br><span class="line">          padding: <span class="keyword">const</span> EdgeInsets.fromLTRB(<span class="number">0</span>, <span class="number">40</span>, <span class="number">25</span>, <span class="number">0</span>),</span><br><span class="line">          child: Image.asset(</span><br><span class="line">            Assets.img1,</span><br><span class="line">            fit: BoxFit.fill,</span><br><span class="line">            width: <span class="number">170</span>,</span><br><span class="line">            height: <span class="number">170</span>,</span><br><span class="line">          )</span><br><span class="line">        ),</span><br><span class="line">      ]</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Container newGame() &#123;</span><br><span class="line">  <span class="keyword">return</span> Container(</span><br><span class="line">    height: <span class="number">60</span>,</span><br><span class="line">    width: <span class="number">160</span>,</span><br><span class="line">    decoration: BoxDecoration(</span><br><span class="line">        borderRadius: BorderRadius.circular(<span class="number">5</span>),</span><br><span class="line">        color: Color.fromARGB(<span class="number">255</span>, <span class="number">147</span>, <span class="number">131</span>, <span class="number">117</span>)</span><br><span class="line">    ),</span><br><span class="line">    child: InkWell(</span><br><span class="line">      onTap: () &#123;</span><br><span class="line">        Provider.of&lt;GameMap&gt;(context, listen: <span class="keyword">false</span>).init();</span><br><span class="line">      &#125;,</span><br><span class="line">      child: <span class="keyword">const</span> Column(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">        children: [</span><br><span class="line">          Text(<span class="string">&#x27;NEW GAME&#x27;</span>, style: TextStyle(</span><br><span class="line">              color: Color.fromARGB(<span class="number">255</span>, <span class="number">246</span>, <span class="number">240</span>, <span class="number">229</span>), fontSize: <span class="number">18</span>, fontWeight: FontWeight.bold)),</span><br><span class="line">          SizedBox(height: <span class="number">1</span>,)</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Panel"><a href="#Panel" class="headerlink" title="Panel"></a>Panel</h2><p>分析一下，这个Panel有一个正方形的组件，正方形组件下面有个按钮</p><h3 id="正方形组件"><a href="#正方形组件" class="headerlink" title="正方形组件"></a>正方形组件</h3><p>AspectRatio参考文章</p><p>- <a href="https://juejin.cn/post/6844903856988487693#heading-1">Flutter 约束宽高比的控件 AspectRatio - 掘金 (juejin.cn)</a></p><p>- <a href="https://juejin.cn/post/7112017871949004807#heading-1">flutter系列之:按比例缩放的AspectRatio和FractionallySizedBox - 掘金 (juejin.cn)</a></p><p>首先大框架是AspectRatio，设置正方形宽高比是1:1</p><p>然后使用GridView这个组件，将我们的拼图块一一网状排布。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">AspectRatio Frame(BuildContext context, Widget child) &#123;</span><br><span class="line">  <span class="built_in">double</span> minSize = min(</span><br><span class="line">      MediaQuery.of(context).size.width, MediaQuery.of(context).size.height);</span><br><span class="line">  <span class="keyword">return</span> AspectRatio(</span><br><span class="line">    aspectRatio: <span class="number">1.0</span>,</span><br><span class="line">    child: Container(</span><br><span class="line">      key: _redKey,</span><br><span class="line">      color: Color.fromRGBO(<span class="number">182</span>,<span class="number">173</span>,<span class="number">156</span>,<span class="number">1</span>),</span><br><span class="line">      width: minSize,</span><br><span class="line">      height: minSize,</span><br><span class="line">      margin: EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">      child: Container(</span><br><span class="line">          child: MediaQuery.removePadding(</span><br><span class="line">              removeTop: <span class="keyword">true</span>,</span><br><span class="line">              context: context,</span><br><span class="line">              child: GridView.builder(</span><br><span class="line">                  physics: <span class="keyword">const</span> NeverScrollableScrollPhysics(),</span><br><span class="line">                  gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">                      crossAxisCount: Provider.of&lt;GameMap&gt;(context, listen: <span class="keyword">false</span>).SIZE,</span><br><span class="line">                      childAspectRatio: <span class="number">1</span>,</span><br><span class="line">                      mainAxisSpacing: <span class="number">3</span>,</span><br><span class="line">                      crossAxisSpacing: <span class="number">3</span></span><br><span class="line">                  ),</span><br><span class="line">                  itemCount: SIZE * SIZE,</span><br><span class="line">                  itemBuilder: (context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">                    <span class="keyword">return</span> PuzzlePart(Provider.of&lt;GameMap&gt;(context, listen: <span class="keyword">true</span>).<span class="keyword">get</span>(index), index);</span><br><span class="line">                  &#125;)</span><br><span class="line">          ),</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>按钮主要用来控制游戏难度的</p><p>参考文章:<a href="https://juejin.cn/post/6844903773198893070?searchId=20240317172222E33C0EED28126222B1ED">Flutter之Dialog使用和踩坑 - 掘金 (juejin.cn)</a></p><p>主要通过按钮唤起对话框。</p><ul><li><strong>对话框是路由的页面（Route）</strong>：<ul><li>在 Flutter 中，页面被称为路由（Route）。对话框本质上也是一个页面，但它通常是在当前页面的上层以浮动的形式显示的。</li><li>路由是应用程序中页面的抽象，它们负责管理页面之间的导航、堆栈和状态。</li></ul></li><li><strong>由 Navigator 进行管理</strong>：<ul><li>Navigator 是用于管理路由的类，它负责路由的添加、移除和切换。</li><li>对话框是由 Navigator 来管理的，它负责在屏幕上正确地显示和隐藏对话框。</li></ul></li><li><strong>控制对话框的显示和隐藏</strong>：<ul><li>控制对话框的显示和隐藏是通过调用 Navigator 的 <code>push</code> 和 <code>pop</code> 方法来实现的。</li><li>当您想要显示对话框时，您可以使用 <code>Navigator.of(context).push()</code> 方法将对话框路由推入路由堆栈。这将导致对话框显示在屏幕上。</li><li>当您想要隐藏对话框时，您可以使用 <code>Navigator.of(context).pop()</code> 方法将对话框路由从堆栈中弹出。这将导致对话框被移除并隐藏。</li></ul></li><li>在Flutter中，对话框会有两种风格，调用showDialog()方法展示的是material风格的对话框，调用showCupertinoDialog()方法展示的是ios风格的对话框。 而这两个方法其实都会去调用showGeneralDialog()方法，可以从源码中看到最后是利用Navigator.of(context, rootNavigator: true).push()一个页面。</li></ul><p>基本要传的参数:context上下文,builder用于创建显示的widget,barrierDismissible可以控制点击对话框以外的区域是否隐藏对话框。</p><ul><li>你会注意到，showDialog()方法返回的是一个Future对象,可以通过这个future对象来获取对话框所传递的数据。 比如我们想知道想知道用户是点击了对话框的确认按钮还是取消按钮,那就在退出对话框的时候，利用Navigator.of(context).pop(“一些数据”);</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> _selectedDifficulty = <span class="string">&#x27;简单&#x27;</span>;</span><br><span class="line">ElevatedButton DifficultyButton() &#123;</span><br><span class="line">  <span class="keyword">return</span> ElevatedButton(</span><br><span class="line">        style: ElevatedButton.styleFrom(</span><br><span class="line">          backgroundColor: Color.fromARGB(<span class="number">255</span>, <span class="number">147</span>, <span class="number">131</span>, <span class="number">117</span>)<span class="comment">// 设置按钮背景颜色为蓝色</span></span><br><span class="line">        ),</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          _showDifficultyDialog();</span><br><span class="line">        &#125;,</span><br><span class="line">        child: Text(<span class="string">&#x27;设置难度 (<span class="subst">$_selectedDifficulty</span>)&#x27;</span>),</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; _showDifficultyDialog() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">String?</span> selectedDifficulty = <span class="keyword">await</span> showDialog&lt;<span class="built_in">String</span>&gt;(</span><br><span class="line">      context: context,</span><br><span class="line">      builder: (BuildContext context) &#123;</span><br><span class="line">        <span class="keyword">return</span> SimpleDialog(</span><br><span class="line">          title: Text(<span class="string">&#x27;设置难度&#x27;</span>),</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            SimpleDialogOption(</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                Provider.of&lt;GameMap&gt;(context, listen: <span class="keyword">false</span>).SIZE = <span class="number">3</span>;</span><br><span class="line">                Provider.of&lt;GameMap&gt;(context, listen: <span class="keyword">false</span>).init();</span><br><span class="line">                Navigator.pop(context, <span class="string">&#x27;简单&#x27;</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">              child: Text(<span class="string">&#x27;简单&#x27;</span>),</span><br><span class="line">            ),</span><br><span class="line">            SimpleDialogOption(</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                Provider.of&lt;GameMap&gt;(context, listen: <span class="keyword">false</span>).SIZE = <span class="number">4</span>;</span><br><span class="line">                Provider.of&lt;GameMap&gt;(context, listen: <span class="keyword">false</span>).init();</span><br><span class="line">                Navigator.pop(context, <span class="string">&#x27;中等&#x27;</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">              child: Text(<span class="string">&#x27;中等&#x27;</span>),</span><br><span class="line">            ),</span><br><span class="line">            SimpleDialogOption(</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                Provider.of&lt;GameMap&gt;(context, listen: <span class="keyword">false</span>).SIZE = <span class="number">5</span>;</span><br><span class="line">                Provider.of&lt;GameMap&gt;(context, listen: <span class="keyword">false</span>).init();</span><br><span class="line">                Navigator.pop(context, <span class="string">&#x27;困难&#x27;</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">              child: Text(<span class="string">&#x27;困难&#x27;</span>),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (selectedDifficulty != <span class="keyword">null</span>) &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        _selectedDifficulty = selectedDifficulty;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Navigator.pop的context作用:</p><p><code>BuildContext</code>对象是通过<code>builder</code>函数的参数传递的，即<code>builder(BuildContext context)</code>。因此，<code>context</code>参数指定了在哪个页面弹出对话框，并且在对话框关闭时，返回的结果将传递给该页面。</p></blockquote><h1 id="游戏逻辑"><a href="#游戏逻辑" class="headerlink" title="游戏逻辑"></a>游戏逻辑</h1><h2 id="基础骨架"><a href="#基础骨架" class="headerlink" title="基础骨架"></a>基础骨架</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isgameOver) &#123;</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      children: [</span><br><span class="line">        Stack(</span><br><span class="line">          children: [</span><br><span class="line">            _gamePanel(context),<span class="comment">//主游戏界面</span></span><br><span class="line">            _gameReset(context)<span class="comment">//蒙版</span></span><br><span class="line">          ],</span><br><span class="line">        ),DifficultyButton(),<span class="comment">//设置按钮</span></span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      children: [</span><br><span class="line">        _gamePanel(context),<span class="comment">//主游戏界面</span></span><br><span class="line">        DifficultyButton(),<span class="comment">//设置按钮</span></span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据源与游戏初始化"><a href="#数据源与游戏初始化" class="headerlink" title="数据源与游戏初始化"></a>数据源与游戏初始化</h2><h3 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h3><p>数据源是一个<code>Future&lt;List&lt;imglib.Image&gt;&gt;</code>类型的列表，他存放着将图片切割成n块的数据</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">final</span> Future&lt;<span class="built_in">List</span>&lt;imglib.Image&gt;&gt; _pieces = splitImage(Assets.img1, n : SIZE);</span><br><span class="line">    _pieces.then((_pieces) &#123;</span><br><span class="line">    result = <span class="built_in">List</span>.from(_pieces);</span><br><span class="line">    <span class="comment">//首先复制切割后的图片列表，用于检查最终是否拼好</span></span><br><span class="line">    pieces = <span class="built_in">List</span>.from(_pieces);</span><br><span class="line">    <span class="comment">//游戏操作时所改变的列表</span></span><br><span class="line">    pieces.shuffle(Random());</span><br><span class="line">    <span class="comment">//将列表打乱</span></span><br><span class="line">    notifyListeners();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图片切割"><a href="#图片切割" class="headerlink" title="图片切割"></a>图片切割</h2><p>代码来源:<a href="https://stackoverflow.com/questions/58363167/how-to-split-divide-image-in-parts-in-flutter">How to split&#x2F;divide image in parts in Flutter - Stack Overflow</a></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:typed_data&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:image/image.dart&#x27;</span> <span class="keyword">as</span> imglib;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">List</span>&lt;imglib.Image&gt;&gt; splitImage(<span class="built_in">String</span> path, &#123;<span class="built_in">int</span> n = <span class="number">3</span>&#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">  imglib.Image? image = <span class="keyword">await</span> decodeAsset(path);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;imglib.Image&gt; pieces = [];</span><br><span class="line">  <span class="built_in">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">int</span> width = (image!.width / n).floor();</span><br><span class="line">  <span class="built_in">int</span> height = (image.height / n).floor();</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      imglib.Image croppedImage = imglib.copyCrop(image, x: x, y: y, width: width, height: height);</span><br><span class="line">      pieces.add(croppedImage);</span><br><span class="line">      x += width;</span><br><span class="line">    &#125;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y += height;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pieces;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;imglib.Image?&gt; decodeAsset(<span class="built_in">String</span> path) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> ByteData data = <span class="keyword">await</span> rootBundle.load(path);</span><br><span class="line">  <span class="keyword">final</span> Uint8List bytes = data.buffer.asUint8List();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> imglib.Image? image = imglib.decodeImage(bytes);</span><br><span class="line">  <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图片显示"><a href="#图片显示" class="headerlink" title="图片显示"></a>图片显示</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Widget PuzzlePart(imglib.Image img, <span class="built_in">int</span> index) &#123;</span><br><span class="line">  <span class="keyword">return</span> Builder(</span><br><span class="line">    builder: (BuildContext context) &#123;</span><br><span class="line">      ObjectKey key = ObjectKey(index); <span class="comment">// 创建一个ObjectKey作为该组件的key</span></span><br><span class="line">      Widget puzzleWidget = Container(</span><br><span class="line">        key: key,</span><br><span class="line">        child: Image.memory(imglib.encodeJpg(img)),</span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// 获取拼图组件的中心位置</span></span><br><span class="line">      WidgetsBinding.instance!.addPostFrameCallback((timeStamp) &#123;</span><br><span class="line">        RenderBox renderBox = context.findRenderObject() <span class="keyword">as</span> RenderBox;</span><br><span class="line">        Offset center = renderBox.localToGlobal(</span><br><span class="line">            renderBox.size.center(Offset.zero));</span><br><span class="line">        <span class="comment">// 将拼图组件的中心位置存储到Map中</span></span><br><span class="line">        puzzleCenterPositions[key] = center;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> puzzleWidget;</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动手势识别"><a href="#滑动手势识别" class="headerlink" title="滑动手势识别"></a>滑动手势识别</h2><p>GridView参考文章<a href="https://juejin.cn/post/6844903889502732295#heading-1">Flutter网格型布局 - GridView篇 - 掘金 (juejin.cn)</a></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GestureDetector(</span><br><span class="line">      onPanDown: (DragDownDetails details) &#123;</span><br><span class="line">        lastPositon = details.globalPosition;</span><br><span class="line">        _firstTouch = <span class="keyword">true</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      onPanUpdate: (details) &#123;</span><br><span class="line">        <span class="keyword">final</span> curPosition = details.globalPosition;</span><br><span class="line">        <span class="built_in">double</span> min = (puzzleCenterPositions[ObjectKey(<span class="number">0</span>)]! - puzzleCenterPositions[ObjectKey(<span class="number">1</span>)]!).distance/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ((curPosition - lastPositon).distance &gt; min)</span><br><span class="line">        moveJudge(lastPositon, curPosition);</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      child: ...略</span><br><span class="line">      ),</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h2 id="图片的移动与合并"><a href="#图片的移动与合并" class="headerlink" title="图片的移动与合并"></a>图片的移动与合并</h2><p>我的想法是，首先第一个<code>for</code>循环找到你想拖动的方块，第二个<code>for</code>循环找到你想拖动的位置，最后交互两个方块的位置</p><p>这里的关键就这样对<code>min</code>的设置和手势识别中<code>curPosition</code>传入的设置</p><ul><li>如果min太大，容易造成移动混乱</li><li>如果min太小，容易造成移动敏感度过低</li><li>curPosition同理</li></ul><p>我的解决方案就是</p><ul><li>通过拼图间的距离来调试最佳的<code>min</code>和<code>cur</code>传入条件</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> moveJudge(Offset last, Offset cur) &#123;</span><br><span class="line">  <span class="built_in">int</span> SIZE = Provider.of&lt;GameMap&gt;(context, listen: <span class="keyword">false</span>).SIZE;</span><br><span class="line">  <span class="built_in">double</span> min = (puzzleCenterPositions[ObjectKey(<span class="number">0</span>)]! - puzzleCenterPositions[ObjectKey(<span class="number">1</span>)]!).distance/<span class="number">1.5</span>;</span><br><span class="line">  <span class="keyword">if</span> (_firstTouch)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; SIZE * SIZE; i++) &#123;</span><br><span class="line">      <span class="comment">//print((puzzleCenterPositions[ObjectKey(i)]! - cur).distance);</span></span><br><span class="line">      <span class="keyword">if</span> (puzzleCenterPositions[ObjectKey(i)] != <span class="keyword">null</span> &amp;&amp;(puzzleCenterPositions[ObjectKey(i)]! - last).distance &lt; min) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt;SIZE*SIZE;j++) &#123;</span><br><span class="line">          <span class="comment">//print((puzzleCenterPositions[ObjectKey(j)]! - cur).distance);</span></span><br><span class="line">          <span class="keyword">if</span>(puzzleCenterPositions[ObjectKey(j)] != <span class="keyword">null</span> &amp;&amp;(puzzleCenterPositions[ObjectKey(j)]! - cur).distance &lt; min ) &#123;</span><br><span class="line">            Provider.of&lt;GameMap&gt;(context, listen: <span class="keyword">false</span>).move(i, j);</span><br><span class="line">            isgameOver = Provider.of&lt;GameMap&gt;(context, listen: <span class="keyword">false</span>).checkEnd(SIZE * SIZE);</span><br><span class="line">            setState(() &#123;</span><br><span class="line">              _firstTouch = <span class="keyword">false</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断游戏结束"><a href="#判断游戏结束" class="headerlink" title="判断游戏结束"></a>判断游戏结束</h2><p>每次移动都会调用GameMap的checkEnd方法检查是否游戏结束，若结束蒙版覆盖</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isgameOver) &#123;</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      children: [</span><br><span class="line">        Stack(</span><br><span class="line">          children: [</span><br><span class="line">            _gamePanel(context),</span><br><span class="line">            _gameReset(context)</span><br><span class="line">          ],</span><br><span class="line">        ),DifficultyButton(),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      children: [</span><br><span class="line">        _gamePanel(context),</span><br><span class="line">        DifficultyButton(),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Widget _gameReset(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> AspectRatio(</span><br><span class="line">      aspectRatio: <span class="number">1.0</span>,</span><br><span class="line">      child: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: [</span><br><span class="line">            <span class="keyword">const</span> Text(<span class="string">&quot;Game Over&quot;</span>,style: TextStyle(</span><br><span class="line">              fontSize: <span class="number">50</span>,</span><br><span class="line">              color: Colors.white70</span><br><span class="line">            ),),</span><br><span class="line">            InkWell(</span><br><span class="line">                onTap: () &#123;</span><br><span class="line">                  resetGame();</span><br><span class="line">                &#125;,</span><br><span class="line">                child: <span class="keyword">const</span> Text(<span class="string">&quot;Reset&quot;</span>,style: TextStyle(</span><br><span class="line">                    fontSize: <span class="number">30</span>,</span><br><span class="line">                    color: Colors.white70</span><br><span class="line">                ),),)</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重新开始游戏"><a href="#重新开始游戏" class="headerlink" title="重新开始游戏"></a>重新开始游戏</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> resetGame() &#123;</span><br><span class="line">   setState(() &#123;</span><br><span class="line">     Provider.of&lt;GameMap&gt;(context, listen: <span class="keyword">false</span>).init();</span><br><span class="line">     isgameOver = <span class="keyword">false</span>;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">final</span> Future&lt;<span class="built_in">List</span>&lt;imglib.Image&gt;&gt; _pieces = splitImage(Assets.img1, n : SIZE);</span><br><span class="line">    _pieces.then((_pieces) &#123;</span><br><span class="line">    result = <span class="built_in">List</span>.from(_pieces);</span><br><span class="line">    pieces = <span class="built_in">List</span>.from(_pieces);</span><br><span class="line">    pieces.shuffle(Random());</span><br><span class="line">    notifyListeners();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统一状态管理"><a href="#统一状态管理" class="headerlink" title="统一状态管理"></a>统一状态管理</h2><p>privide参考文章</p><p>- <a href="https://juejin.cn/post/7015887922117214238#heading-9">Flutter Provider状态管理—八种提供者使用分析 - 掘金 (juejin.cn)</a></p><p>- <a href="https://flyingstudio.feishu.cn/wiki/E2TSwTtZ9ik92EkCLpHcjAvbnRu?from=from_copylink">https://flyingstudio.feishu.cn/wiki/E2TSwTtZ9ik92EkCLpHcjAvbnRu?from=from_copylink</a></p><p>首先main方法改为<code>ChangeNotifierProvider</code>组件</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(ChangeNotifierProvider(</span><br><span class="line">      create: (_) =&gt; GameMap(),</span><br><span class="line">      child: MaterialApp(</span><br><span class="line">        home: MyGame(),</span><br><span class="line">      )</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后<code>GameMap</code>加上<code>ChangeNotifier</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameMap</span> <span class="title">with</span> <span class="title">ChangeNotifier</span></span>&#123;</span><br><span class="line">     <span class="built_in">int</span> SIZE = <span class="number">3</span>;</span><br><span class="line">  Future&lt;imglib.Image?&gt; _none = decodeAsset(Assets.none);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> firstTouch = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">List</span> result = [];</span><br><span class="line">  <span class="built_in">List</span> pieces = [];</span><br><span class="line">  <span class="built_in">int</span> one = <span class="number">1</span>;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">final</span> Future&lt;<span class="built_in">List</span>&lt;imglib.Image&gt;&gt; _pieces = splitImage(Assets.img1, n : SIZE);</span><br><span class="line">    _pieces.then((_pieces) &#123;</span><br><span class="line">    result = <span class="built_in">List</span>.from(_pieces);</span><br><span class="line">    pieces = <span class="built_in">List</span>.from(_pieces);</span><br><span class="line">    pieces.shuffle(Random());</span><br><span class="line">    notifyListeners();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  setTouch() &#123;</span><br><span class="line">    firstTouch = !firstTouch;</span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  checkEnd(<span class="built_in">int</span> size) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (result[i] != pieces[i]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  imglib.Image <span class="keyword">get</span>(<span class="built_in">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (one == <span class="number">1</span>) &#123;</span><br><span class="line">      init();</span><br><span class="line">      one = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> pieces[i];</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      imglib.Image img = imglib.Image.empty();</span><br><span class="line">      <span class="keyword">return</span> img;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  move(<span class="built_in">int</span> pre, <span class="built_in">int</span> next) &#123;</span><br><span class="line">    imglib.Image pre1 = pieces[pre];</span><br><span class="line">    pieces[pre] = pieces[next];</span><br><span class="line">    pieces[next] = pre1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Panel调用GameMap方法的时候加上<code>Provide.of&lt;GameMap&gt;(context, listen:false)</code></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2048</title>
      <link href="/2024/03/10/Flutter-%E6%B8%B8%E6%88%8F-2048/"/>
      <url>/2024/03/10/Flutter-%E6%B8%B8%E6%88%8F-2048/</url>
      
        <content type="html"><![CDATA[<p>GitHub仓库:<a href="https://github.com/xxbaizero0/game_2048">xxbaizero0&#x2F;game_2048: Flutter game (github.com)</a></p><p>AspectRatio参考文章</p><ul><li><a href="https://juejin.cn/post/6844903856988487693#heading-1">Flutter 约束宽高比的控件 AspectRatio - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/7112017871949004807#heading-1">flutter系列之:按比例缩放的AspectRatio和FractionallySizedBox - 掘金 (juejin.cn)</a></li></ul><p>GridView参考文章<a href="https://juejin.cn/post/6844903889502732295#heading-1">Flutter网格型布局 - GridView篇 - 掘金 (juejin.cn)</a></p><p>GestureDetector参考文章 <a href="https://juejin.cn/post/7009859979096096804#heading-16">Flutter 手势系列教程—GestureDetector - 掘金 (juejin.cn)</a></p><p>shared_preferences参考文章 <a href="https://juejin.cn/post/7012840579964862471">Flutter shared_preferences的基本使用、源码分析、封装 - 掘金 (juejin.cn)</a></p><p>privide参考文章</p><ul><li><a href="https://juejin.cn/post/7015887922117214238#heading-9">Flutter Provider状态管理—八种提供者使用分析 - 掘金 (juejin.cn)</a></li><li><a href="https://flyingstudio.feishu.cn/wiki/E2TSwTtZ9ik92EkCLpHcjAvbnRu?from=from_copylink">https://flyingstudio.feishu.cn/wiki/E2TSwTtZ9ik92EkCLpHcjAvbnRu?from=from_copylink</a></li></ul><p>预览</p><p><img src="/2024/03/10/Flutter-%E6%B8%B8%E6%88%8F-2048/2024-03-14-22-16-04.gif" alt="2024-03-14-22-16-04"></p><ul><li>UI界面<ul><li>Header部分</li><li>Panel部分</li></ul></li><li>游戏逻辑<ul><li>数据源与游戏初始化</li><li>滑动手势识别</li><li>数字块的移动与合并</li><li>产生新的数字块</li><li>判断游戏结束</li><li>重新开始游戏</li></ul></li></ul><h1 id="UI界面"><a href="#UI界面" class="headerlink" title="UI界面"></a>UI界面</h1><p><img src="/2024/03/10/Flutter-%E6%B8%B8%E6%88%8F-2048/image-20240313211804961.png"></p><h2 id="Header部分"><a href="#Header部分" class="headerlink" title="Header部分"></a>Header部分</h2><p>简单分析:</p><ul><li>主要是Row结构，children左右均为Column结构</li><li>代码:</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Row(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.spaceBetween,</span><br><span class="line">        crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">        children: [</span><br><span class="line">          Container(</span><br><span class="line">            padding: <span class="keyword">const</span> EdgeInsets.fromLTRB(<span class="number">20</span>, <span class="number">40</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">            child: Column(</span><br><span class="line">              children: [</span><br><span class="line">                <span class="keyword">const</span> Text(<span class="string">&quot;2048&quot;</span>,</span><br><span class="line">                  style: TextStyle(</span><br><span class="line">                    fontSize: <span class="number">75</span>,</span><br><span class="line">                    color: numColor,</span><br><span class="line">                    fontWeight: FontWeight.bold</span><br><span class="line">                ),),</span><br><span class="line">                SizedBox(height: <span class="number">12</span>,),</span><br><span class="line">                newGame()</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          Container(</span><br><span class="line">            padding: <span class="keyword">const</span> EdgeInsets.fromLTRB(<span class="number">0</span>, <span class="number">40</span>, <span class="number">25</span>, <span class="number">0</span>),</span><br><span class="line">            child: Column(</span><br><span class="line">                crossAxisAlignment: CrossAxisAlignment.end,</span><br><span class="line">                children: [</span><br><span class="line">                  NumCard(text:<span class="string">&#x27;SCORE&#x27;</span>, score:currentScore),</span><br><span class="line">                  <span class="keyword">const</span> SizedBox(height: <span class="number">10</span>,),</span><br><span class="line">                  NumCard(text:<span class="string">&#x27;HIGHEST&#x27;</span>, score:highestScore),</span><br><span class="line">                ]</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ]</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Container newGame() &#123;</span><br><span class="line">  <span class="keyword">return</span> Container(</span><br><span class="line">    height: <span class="number">60</span>,</span><br><span class="line">    width: <span class="number">160</span>,</span><br><span class="line">    decoration: BoxDecoration(</span><br><span class="line">        borderRadius: BorderRadius.circular(<span class="number">5</span>),</span><br><span class="line">        color: newGameColor</span><br><span class="line">    ),</span><br><span class="line">    child: InkWell(</span><br><span class="line">      onTap: () &#123;</span><br><span class="line">        <span class="comment">// 重新开始游戏，这里的逻辑之后再实现</span></span><br><span class="line">      &#125;,</span><br><span class="line">      child: <span class="keyword">const</span> Column(</span><br><span class="line">      mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">      children: [</span><br><span class="line">        Text(<span class="string">&#x27;NEW GAME&#x27;</span>, style: TextStyle(</span><br><span class="line">            color: whiteText, fontSize: <span class="number">18</span>, fontWeight: FontWeight.bold)),</span><br><span class="line">        SizedBox(height: <span class="number">1</span>,)</span><br><span class="line">      ],</span><br><span class="line">    ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Container NumCard(&#123;<span class="built_in">String?</span> text, <span class="built_in">int?</span> score&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> Container(</span><br><span class="line">      height: <span class="number">80</span>,</span><br><span class="line">      width: <span class="number">130</span>,</span><br><span class="line">      decoration: BoxDecoration(</span><br><span class="line">          borderRadius: BorderRadius.circular(<span class="number">5</span>),</span><br><span class="line">          color: numCardColor</span><br><span class="line">      ),</span><br><span class="line">      child: Column(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">        children: [</span><br><span class="line">          Text(text!, style: <span class="keyword">const</span> TextStyle(</span><br><span class="line">              color: whiteText, fontSize: <span class="number">22</span>, fontWeight: FontWeight.bold)),</span><br><span class="line">          <span class="keyword">const</span> SizedBox(height: <span class="number">1</span>,),</span><br><span class="line">          Text(score!.toString(), style: <span class="keyword">const</span> TextStyle(color: Colors.white,</span><br><span class="line">              fontSize: <span class="number">26</span>,</span><br><span class="line">              fontWeight: FontWeight.bold),)</span><br><span class="line">        ],</span><br><span class="line">      )</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Panel部分"><a href="#Panel部分" class="headerlink" title="Panel部分"></a>Panel部分</h2><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><ul><li>首先实现底部的深色背景，接着数组映射到每一个小方块，其中映射通过<code>GridView</code>组件快速的构建出4x4的网格，而<code>GridView</code>常与<code>AspectRatio</code>组件一起搭配(GridView作为AR的child)</li></ul><blockquote><p>在GridView 中，要控制住每一张图片或方块的宽高比。</p><p>如果没有AspectRatio 控件则比较难实现，因为要算间距之类的。</p><p>但是有了 AspectRatio，我们的代码就会简单很多</p></blockquote><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>AspectRatio参考文章</p><ul><li><a href="https://juejin.cn/post/6844903856988487693#heading-1">Flutter 约束宽高比的控件 AspectRatio - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/7112017871949004807#heading-1">flutter系列之:按比例缩放的AspectRatio和FractionallySizedBox - 掘金 (juejin.cn)</a></li></ul><p>GridView参考文章<a href="https://juejin.cn/post/6844903889502732295#heading-1">Flutter网格型布局 - GridView篇 - 掘金 (juejin.cn)</a></p><h4 id="AspectRatio-控件"><a href="#AspectRatio-控件" class="headerlink" title="AspectRatio 控件"></a>AspectRatio 控件</h4><p>AspectRatio构造函数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AspectRatio(&#123;</span><br><span class="line">  Key? key,</span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">this</span>.aspectRatio,</span><br><span class="line">  Widget? child,</span><br><span class="line">&#125;) : <span class="keyword">assert</span>(aspectRatio != <span class="keyword">null</span>),</span><br><span class="line">     <span class="keyword">assert</span>(aspectRatio &gt; <span class="number">0.0</span>),</span><br><span class="line">     <span class="comment">// can&#x27;t test isFinite because that&#x27;s not a constant expression</span></span><br><span class="line">     <span class="keyword">super</span>(key: key, child: child);</span><br></pre></td></tr></table></figure><p>AspectRatio属性和说明</p><table><thead><tr><th>字段</th><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>aspectRatio</td><td>double</td><td>纵横比例</td></tr><tr><td>child</td><td>Widget</td><td>子组件</td></tr></tbody></table><p> aspectRatio、child</p><p><code>aspectRatio</code> 主要用来设定子组件的纵横比例，而<code>child</code>就是需要被设定纵横比例的子组件。</p><h4 id="GridView组件"><a href="#GridView组件" class="headerlink" title="GridView组件"></a>GridView组件</h4><p><code>GridView</code>一共有5个构造函数：<code>GridView</code>，<code>GridView.builder</code>，<code>GridView.count</code>，<code>GridView.extent</code>和<code>GridView.custom</code></p><p>我在游戏里用的是<code>GridView.builder</code></p><p>来看下<code>GridView</code>构造函数（已省略不常用属性）：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GridView(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  Axis scrollDirection = Axis.vertical,</span><br><span class="line">  <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span><br><span class="line">  ScrollController controller,</span><br><span class="line">  ScrollPhysics physics,</span><br><span class="line">  <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span><br><span class="line">  EdgeInsetsGeometry padding,</span><br><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.gridDelegate,</span><br><span class="line">  <span class="built_in">double</span> cacheExtent,</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>重点关注下<code>gridDelegate</code>这个参数，它其实是<code>GridView</code>组件如何控制排列子元素的一个委托。跟踪源码我们可以在<a href="https://link.juejin.cn/?target=https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/scroll_view.dart%23L1531">scroll_view.dart</a>中看到，<code>gridDelegate</code>的类型是<code>SliverGridDelegate</code>，进一步跟踪进<a href="https://link.juejin.cn/?target=https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/rendering/sliver_grid.dart%23L252">sliver_grid.dart</a>可以看到<code>SliverGridDelegate</code>其实是一个抽象类，而且一共有两个实现类：</p><ul><li><code>SliverGridDelegateWithFixedCrossAxisCount</code>：用于固定列数的场景；</li><li><code>SliverGridDelegateWithMaxCrossAxisExtent</code>：用于子元素有最大宽度限制的场景；</li></ul><p>来看下其构造函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">复制代码SliverGridDelegateWithFixedCrossAxisCount(&#123;</span><br><span class="line">  @required this.crossAxisCount,</span><br><span class="line">  this.mainAxisSpacing = 0.0,</span><br><span class="line">  this.crossAxisSpacing = 0.0,</span><br><span class="line">  this.childAspectRatio = 1.0,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>crossAxisCount</code>：列数，即一行有几个子元素；</li><li><code>mainAxisSpacing</code>：主轴方向上的空隙间距；</li><li><code>crossAxisSpacing</code>：次轴方向上的空隙间距；</li><li><code>childAspectRatio</code>：子元素的宽高比例。</li></ul><p><img src="/2024/03/10/Flutter-%E6%B8%B8%E6%88%8F-2048/16befc29ae31df16tplv-t2oaga2asx-jj-mark3024000q75.webp" alt="参数含义解释"></p><p>想必看到上面的示例图，你就秒懂其中各个参数的含义了。不过，这里有一点需要特别注意：<strong>如果你的子元素宽高比例不为1，那么你一定要设置<code>childAspectRatio</code>属性</strong>。</p><p>还记得之前<code>GridView</code>的各种构造函数吗？其实：</p><ol><li><code>GridView</code>默认构造函数可以类比于<code>ListView</code>默认构造函数，适用于<strong>有限个数子元素</strong>的场景，因为<code>GridView</code>组件会一次性全部渲染<code>children</code>中的子元素组件；</li><li><code>GridView.builder</code>构造函数可以类比于<code>ListView.builder</code>构造函数，适用于<strong>长列表</strong>的场景，因为<code>GridView</code>组件会根据子元素是否出现在屏幕内而动态创建销毁，减少内存消耗，更高效渲染；</li><li><code>GridView.count</code>构造函数是<code>GrdiView</code>使用<code>SliverGridDelegateWithFixedCrossAxisCount</code>的简写（语法糖），效果完全一致；</li><li><code>GridView.extent</code>构造函数式<code>GridView</code>使用<code>SliverGridDelegateWithMaxCrossAxisExtent</code>的简写（语法糖），效果完全一致。</li></ol><p>先来看一个简单的例子，它使用到<code>GridView.count</code>构造函数模仿美团外卖首页服务列表（服务菜单项的代码可以看<a href="https://link.juejin.cn/?target=https://github.com/SmallStoneSK/flutter_training_app/blob/master/lib/grid_view/service_item.dart">这里</a>，也算是对基础组件使用的进一步巩固）：</p><p><strong>代码（<a href="https://link.juejin.cn/?target=https://github.com/SmallStoneSK/flutter_training_app/blob/master/lib/grid_view/service_categories.dart">文件地址</a>）</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GridView.count(</span><br><span class="line">  crossAxisCount: <span class="number">5</span>,</span><br><span class="line">  padding: EdgeInsets.symmetric(vertical: <span class="number">0</span>),</span><br><span class="line">  children: serviceList.map((item) =&gt; ServiceItem(data: item)).toList(),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="emphasis">*/</span></span></span></span><br><span class="line"><span class="comment">/* 完全等同于 */</span></span><br><span class="line"><span class="comment"><span class="language-markdown"><span class="emphasis">/<span class="strong">****</span><span class="strong">****</span><span class="strong">****</span>/</span></span></span></span><br><span class="line"></span><br><span class="line">GridView(</span><br><span class="line">  padding: EdgeInsets.symmetric(vertical: <span class="number">0</span>),</span><br><span class="line">  gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">    crossAxisCount: <span class="number">5</span>,</span><br><span class="line">  ),</span><br><span class="line">  children: serviceList.map((item) =&gt; ServiceItem(data: item)).toList(),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>预览</strong></p><p>  <img src="/2024/03/10/Flutter-%E6%B8%B8%E6%88%8F-2048/16befc32ce4e1b8btplv-t2oaga2asx-jj-mark3024000q75.webp" alt="img"></p><p>再来看一个模仿喜马拉雅中相声列表用到<code>GridView.builder</code>创建网格布局的具体例子（相声卡片的代码可以看<a href="https://link.juejin.cn/?target=https://github.com/SmallStoneSK/flutter_training_app/blob/master/lib/grid_view/programme.dart">这里</a>）：</p><p><strong>代码（<a href="https://link.juejin.cn/?target=https://github.com/SmallStoneSK/flutter_training_app/blob/master/lib/grid_view/guess_like_list.dart">文件地址</a>）</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">GridView.builder(</span><br><span class="line">  <span class="comment">// 让 GridView 的大小自动适应子项的大小</span></span><br><span class="line">  shrinkWrap: <span class="keyword">true</span>,</span><br><span class="line">  <span class="comment">// 设置子项的数量为 programmeList 的长度</span></span><br><span class="line">  itemCount: programmeList.length,</span><br><span class="line">  <span class="comment">// 禁用滚动功能</span></span><br><span class="line">  physics: NeverScrollableScrollPhysics(),</span><br><span class="line">  <span class="comment">// 设置子项的内边距</span></span><br><span class="line">  padding: EdgeInsets.symmetric(horizontal: <span class="number">16</span>),</span><br><span class="line">  <span class="comment">// 设置网格布局的参数</span></span><br><span class="line">  gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">    <span class="comment">// 每行显示的列数</span></span><br><span class="line">    crossAxisCount: <span class="number">3</span>,</span><br><span class="line">    <span class="comment">// 主轴方向（垂直方向）上的间距</span></span><br><span class="line">    mainAxisSpacing: <span class="number">10</span>,</span><br><span class="line">    <span class="comment">// 交叉轴方向（水平方向）上的间距</span></span><br><span class="line">    crossAxisSpacing: <span class="number">10</span>,</span><br><span class="line">    <span class="comment">// 子项的纵横比</span></span><br><span class="line">    childAspectRatio: <span class="number">0.7</span>,</span><br><span class="line">  ),</span><br><span class="line">  <span class="comment">// 构建子项的方法</span></span><br><span class="line">  itemBuilder: (context, index) &#123;</span><br><span class="line">    <span class="comment">// 返回一个 Programme 组件，传入相应的数据</span></span><br><span class="line">    <span class="keyword">return</span> Programme(data: programmeList[index]);</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>预览</strong></p><p>  <img src="/2024/03/10/Flutter-%E6%B8%B8%E6%88%8F-2048/16befc39b52fd061tplv-t2oaga2asx-jj-mark3024000q75.webp" alt="img"></p><h3 id="我的实现："><a href="#我的实现：" class="headerlink" title="我的实现："></a>我的实现：</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">AspectRatio(</span><br><span class="line">        aspectRatio: <span class="number">1.0</span>,</span><br><span class="line">        child: Container(</span><br><span class="line">          child: _buildGameFrame(</span><br><span class="line">              context,</span><br><span class="line">              Container(</span><br><span class="line">                padding: EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">                decoration: BoxDecoration(</span><br><span class="line">                  color: bgColor2,</span><br><span class="line">                  borderRadius: BorderRadius.circular(<span class="number">10</span>),</span><br><span class="line">                ),</span><br><span class="line">                child: MediaQuery.removePadding(</span><br><span class="line">                  removeTop: <span class="keyword">true</span>,</span><br><span class="line">                  <span class="comment">/// <span class="language-markdown">GridView 默认顶部会有 padding，通过这个删除顶部 padding</span></span></span><br><span class="line">                  context: context,</span><br><span class="line">                  child: GridView.builder(</span><br><span class="line">                    physics: <span class="keyword">const</span> NeverScrollableScrollPhysics(),</span><br><span class="line">                    <span class="comment">/// <span class="language-markdown">禁用 GridView 的滑动</span></span></span><br><span class="line">                    gridDelegate: <span class="keyword">const</span> SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">                      crossAxisCount: SIZE,</span><br><span class="line">                      childAspectRatio: <span class="number">1</span>,</span><br><span class="line">                      mainAxisSpacing: <span class="number">10</span>,</span><br><span class="line">                      crossAxisSpacing: <span class="number">10</span>,</span><br><span class="line">                    ),</span><br><span class="line">                    itemCount: SIZE * SIZE,</span><br><span class="line">                    itemBuilder: (context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">                      <span class="built_in">int</span> indexI = index ~/ SIZE;</span><br><span class="line">                      <span class="built_in">int</span> indexJ = index % SIZE;</span><br><span class="line">                      <span class="keyword">return</span> _buildGameCell(_gameMap.tile(indexI, indexJ));</span><br><span class="line">                    &#125;,</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br></pre></td></tr></table></figure><h1 id="游戏逻辑"><a href="#游戏逻辑" class="headerlink" title="游戏逻辑"></a>游戏逻辑</h1><h2 id="颜色配置"><a href="#颜色配置" class="headerlink" title="颜色配置"></a>颜色配置</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:ui&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> cornerRadius = <span class="number">8.0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> moveInterval = <span class="number">.5</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">背景颜色</span></span></span><br><span class="line"><span class="keyword">const</span> Color bgColor1 = Color(<span class="number">0xFFFAF8EF</span>);</span><br><span class="line"><span class="keyword">const</span> Color bgColor2 = Color.fromRGBO(<span class="number">182</span>,<span class="number">173</span>,<span class="number">156</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> Color bgColor3 = Color(<span class="number">0xFF8F7B65</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Color whiteText = Color.fromARGB(<span class="number">255</span>, <span class="number">246</span>, <span class="number">240</span>, <span class="number">229</span>);</span><br><span class="line"><span class="keyword">const</span> Color lightBrown = Color.fromARGB(<span class="number">255</span>, <span class="number">236</span>, <span class="number">224</span>, <span class="number">208</span>);</span><br><span class="line"><span class="keyword">const</span> Color numCardColor = Color.fromRGBO(<span class="number">187</span>,<span class="number">176</span>,<span class="number">160</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> Color newGameColor = Color.fromARGB(<span class="number">255</span>, <span class="number">147</span>, <span class="number">131</span>, <span class="number">117</span>);</span><br><span class="line"><span class="keyword">const</span> Color orange = Color.fromARGB(<span class="number">255</span>, <span class="number">245</span>, <span class="number">149</span>, <span class="number">99</span>);</span><br><span class="line"><span class="keyword">const</span> Color tileColor = Color.fromRGBO(<span class="number">203</span>,<span class="number">197</span>,<span class="number">178</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Color tan = Color.fromARGB(<span class="number">255</span>, <span class="number">238</span>, <span class="number">235</span>, <span class="number">218</span>);</span><br><span class="line"><span class="keyword">const</span> Color numColor = Color.fromARGB(<span class="number">255</span>, <span class="number">119</span>, <span class="number">110</span>, <span class="number">101</span>);</span><br><span class="line"><span class="keyword">const</span> Color greyText = Color.fromARGB(<span class="number">255</span>, <span class="number">119</span>, <span class="number">110</span>, <span class="number">101</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Map</span>&lt;<span class="built_in">int</span>, Color&gt; numTileColor = &#123;</span><br><span class="line">  <span class="number">0</span>: Color.fromRGBO(<span class="number">203</span>,<span class="number">197</span>,<span class="number">178</span>,<span class="number">1</span>),</span><br><span class="line">  <span class="number">2</span>: tan,</span><br><span class="line">  <span class="number">4</span>: tan,</span><br><span class="line">  <span class="number">8</span>: Color.fromARGB(<span class="number">255</span>, <span class="number">242</span>, <span class="number">177</span>, <span class="number">121</span>),</span><br><span class="line">  <span class="number">16</span>: Color.fromARGB(<span class="number">255</span>, <span class="number">245</span>, <span class="number">149</span>, <span class="number">99</span>),</span><br><span class="line">  <span class="number">32</span>: Color.fromARGB(<span class="number">255</span>, <span class="number">246</span>, <span class="number">124</span>, <span class="number">95</span>),</span><br><span class="line">  <span class="number">64</span>: <span class="keyword">const</span> Color.fromARGB(<span class="number">255</span>, <span class="number">246</span>, <span class="number">95</span>, <span class="number">64</span>),</span><br><span class="line">  <span class="number">128</span>: <span class="keyword">const</span> Color.fromARGB(<span class="number">255</span>, <span class="number">235</span>, <span class="number">208</span>, <span class="number">117</span>),</span><br><span class="line">  <span class="number">256</span>: <span class="keyword">const</span> Color.fromARGB(<span class="number">255</span>, <span class="number">237</span>, <span class="number">203</span>, <span class="number">103</span>),</span><br><span class="line">  <span class="number">512</span>: <span class="keyword">const</span> Color.fromARGB(<span class="number">255</span>, <span class="number">236</span>, <span class="number">201</span>, <span class="number">85</span>),</span><br><span class="line">  <span class="number">1024</span>: <span class="keyword">const</span> Color.fromARGB(<span class="number">255</span>, <span class="number">229</span>, <span class="number">194</span>, <span class="number">90</span>),</span><br><span class="line">  <span class="number">2048</span>: <span class="keyword">const</span> Color.fromARGB(<span class="number">255</span>, <span class="number">232</span>, <span class="number">192</span>, <span class="number">70</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Map</span>&lt;<span class="built_in">int</span>, Color&gt; numTextColor = &#123;</span><br><span class="line">  <span class="number">0</span>: Color.fromRGBO(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="number">2</span>: greyText,</span><br><span class="line">  <span class="number">4</span>: greyText,</span><br><span class="line">  <span class="number">8</span>: Colors.white,</span><br><span class="line">  <span class="number">16</span>: Colors.white,</span><br><span class="line">  <span class="number">32</span>: Colors.white,</span><br><span class="line">  <span class="number">64</span>: Colors.white,</span><br><span class="line">  <span class="number">128</span>: Colors.white,</span><br><span class="line">  <span class="number">256</span>: Colors.white,</span><br><span class="line">  <span class="number">512</span>: Colors.white,</span><br><span class="line">  <span class="number">1024</span>: Colors.white,</span><br><span class="line">  <span class="number">2048</span>: Colors.white,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用字典将数字与数字背景色和数字字体色对应起来，方便映射渲染。</p><h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">if</span> (_isGameOver) &#123;</span><br><span class="line">    <span class="keyword">return</span> Stack(</span><br><span class="line">      children: [</span><br><span class="line">        _buildGamePanel(context),</span><br><span class="line">        _buildGameOverMask(context),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _buildGamePanel(context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据源与游戏初始化"><a href="#数据源与游戏初始化" class="headerlink" title="数据源与游戏初始化"></a>数据源与游戏初始化</h2><p>本游戏二维列表为数据源，通过<code>_buildGameCell</code>方法映射渲染</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Widget _buildGameCell(<span class="built_in">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      decoration: BoxDecoration(</span><br><span class="line">        color: numTileColor[value],</span><br><span class="line">        borderRadius: BorderRadius.circular(<span class="number">5</span>)</span><br><span class="line">      ),</span><br><span class="line">      child: Center(</span><br><span class="line">        child: Text(</span><br><span class="line">          value == <span class="number">0</span> ? <span class="string">&#x27;&#x27;</span> : value.toString(),</span><br><span class="line">          style: TextStyle(</span><br><span class="line">            color: numTextColor[value],</span><br><span class="line">            fontSize: <span class="number">40</span></span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    logic.reset(_gameMap);</span><br><span class="line">      <span class="comment">//数组清0，gameover设为false;</span></span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _initGameMap();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">初始化数据</span></span></span><br><span class="line"><span class="keyword">void</span> _initGameMap() &#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">执行两次随机</span></span></span><br><span class="line">  _randomNewCellData(<span class="number">2</span>);</span><br><span class="line">  _randomNewCellData(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动手势识别"><a href="#滑动手势识别" class="headerlink" title="滑动手势识别"></a>滑动手势识别</h2><p>GestureDetector参考文章 <a href="https://juejin.cn/post/7009859979096096804#heading-16">Flutter 手势系列教程—GestureDetector - 掘金 (juejin.cn)</a></p><p>其分为</p><ul><li>单击手势</li><li>双击手势</li><li>长按手势</li><li>垂直滑动手势</li><li>水平滑动手势</li><li>拖动手势</li><li>缩放手势</li><li>其他手势</li></ul><p>本来我是使用垂直滑动和水平滑动手势的，但是一次手势只能对应一次滑动，索性直接用拖动手势判断了</p><p>拖动手势总共有五种，分别如下：</p><table><thead><tr><th>字段</th><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>onPanDown</td><td>GestureDragDownCallback</td><td>手指按下时的回调函数</td></tr><tr><td>onPanStart</td><td>GestureDragStartCallback</td><td>手指开始拖动时的回调函数</td></tr><tr><td>onPanUpdate</td><td>GestureDragUpdateCallback</td><td>手指移动时的回调函数</td></tr><tr><td>onPanEnd</td><td>GestureDragEndCallback</td><td>手指抬起时的回调函数</td></tr><tr><td>onPanCancel</td><td>GestureDragCancelCallback</td><td>手指取消拖动时的回调函数</td></tr></tbody></table><h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Offset lastPosition = Offset.zero;</span><br><span class="line">    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">      onPanDown: (DragDownDetails details) &#123;</span><br><span class="line">        lastPosition = details.globalPosition;</span><br><span class="line">        _firstTouch = <span class="keyword">true</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      onPanUpdate: (details) &#123;</span><br><span class="line">        <span class="keyword">final</span> curPosition = details.globalPosition;</span><br><span class="line">        <span class="keyword">if</span> ((curPosition.dx - lastPosition.dx).abs() &gt; _mainAxisMinLimit &amp;&amp;</span><br><span class="line">            (curPosition.dy - lastPosition.dy).abs() &lt; _crossAxisMaxLimit) &#123;</span><br><span class="line">          <span class="comment">// 水平</span></span><br><span class="line">          <span class="keyword">if</span> (_firstTouch) &#123;</span><br><span class="line">            _firstTouch = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> ((curPosition.dx - lastPosition.dx).abs() &gt; _crossAxisMaxLimit) &#123;</span><br><span class="line">              <span class="keyword">if</span>(curPosition.dx - lastPosition.dx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                setMoveState(Side.EAST);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setMoveState(Side.WEST);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>((curPosition.dy - lastPosition.dy).abs() &gt;</span><br><span class="line">            _mainAxisMinLimit &amp;&amp;</span><br><span class="line">            (curPosition.dx - lastPosition.dx).abs() &lt; _crossAxisMaxLimit)&#123;</span><br><span class="line">          <span class="comment">//垂直</span></span><br><span class="line">          <span class="keyword">if</span> ((curPosition.dy - lastPosition.dy).abs() &gt; _mainAxisMinLimit) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_firstTouch) &#123;</span><br><span class="line">              _firstTouch = <span class="keyword">false</span>;</span><br><span class="line">              <span class="keyword">if</span>(curPosition.dy - lastPosition.dy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                setMoveState(Side.SOUTH);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setMoveState(Side.NORTH);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line">      child: AspectRatio( 省略 ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> setMoveState(Side side) &#123;</span><br><span class="line">  <span class="keyword">return</span> setState(() &#123;</span><br><span class="line">    <span class="keyword">switch</span> (side) &#123;</span><br><span class="line">      <span class="keyword">case</span> Side.NORTH:</span><br><span class="line">        _joinGameMapDataToTop();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Side.SOUTH:</span><br><span class="line">        _joinGameMapDataToBottom();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Side.EAST:</span><br><span class="line">        _joinGameMapDataToRight();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Side.WEST:</span><br><span class="line">        _joinGameMapDataToLeft();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> Exception(<span class="string">&#x27;Invalid side: <span class="subst">$this</span>&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!_noMoveInSwipe) &#123;</span><br><span class="line">        <span class="comment">//_noMoveInSwipe是检查移动时是不是属于有效移动，若是，则随机添加。</span></span><br><span class="line">      <span class="keyword">var</span> a = Random().nextDouble();</span><br><span class="line">      <span class="keyword">if</span> (a &lt; <span class="number">0.75</span>) _randomNewCellData(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">else</span> _randomNewCellData(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    checkEnd();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数字块的移动与合并"><a href="#数字块的移动与合并" class="headerlink" title="数字块的移动与合并"></a>数字块的移动与合并</h2><h3 id="失败的构想"><a href="#失败的构想" class="headerlink" title="失败的构想"></a>失败的构想</h3><p>我们可以设置一个Side类，它枚举四个方位，初始方向是北</p><p>我们只需要实现向上滑的逻辑，然后通过改变视角，即数组的旋转，使其套用之前实现好的向上滑的逻辑，就可以实现一套代码多次使用。但是改变视角的逻辑我没写出来。。。。</p><p>移动合并的逻辑</p><p><img src="/2024/03/10/Flutter-%E6%B8%B8%E6%88%8F-2048/image-20240118213830819.png" alt="image-20240118213830819"></p><p><img src="/2024/03/10/Flutter-%E6%B8%B8%E6%88%8F-2048/image-20240118213851546.png" alt="image-20240118213851546"></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">bool</span> tilt(Side side) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;tilt work&quot;</span>);</span><br><span class="line">    <span class="built_in">bool</span> changed;</span><br><span class="line">    changed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Modify this._gameMap (and perhaps this.score) to account</span></span><br><span class="line">    <span class="comment">// for the tilt to the Side SIDE. If the _gameMap changed, set the</span></span><br><span class="line">    <span class="comment">// changed local variable to true.</span></span><br><span class="line">    _gameMap.setViewingPerspective(side);</span><br><span class="line"></span><br><span class="line">    移动合并的逻辑;</span><br><span class="line">     </span><br><span class="line">   _gameMap.setViewingPerspective(Side.NORTH);</span><br><span class="line">    checkEnd();</span><br><span class="line">    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        _noMoveInSwipe = <span class="keyword">true</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      setState(() =&gt; _noMoveInSwipe = <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> moveTilesUp() &#123;</span><br><span class="line">  <span class="built_in">bool</span> changed = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//假设tile(c, r)是以左下角为原点的坐标轴计算的。</span></span><br><span class="line">  <span class="comment">// 遍历每一列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> c = <span class="number">0</span>; c &lt; _gameMap.size(); c++) &#123;</span><br><span class="line">    <span class="comment">// 从上往下开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> r = _gameMap.size() - <span class="number">1</span>; r &gt;= <span class="number">0</span>; r--) &#123;</span><br><span class="line">      <span class="built_in">int</span> t = _gameMap.tile(c, r); <span class="comment">// 获取当前位置上的数字方块的值</span></span><br><span class="line">      <span class="built_in">int</span> row = r; <span class="comment">// 初始化行数</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (_gameMap.tile(c, r) != <span class="number">0</span>) &#123; <span class="comment">// 如果当前位置有数字方块</span></span><br><span class="line">        <span class="comment">// 向上搜索空格，以便移动数字方块</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = _gameMap.size() - <span class="number">1</span>; i &gt; r; i--) &#123;</span><br><span class="line">          <span class="keyword">if</span> (_gameMap.tile(c, i) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将数字方块移动到空格所在的行，并更新行数</span></span><br><span class="line">            setState(() =&gt; _gameMap.move(c, i, c, r));</span><br><span class="line">            row = i;</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下搜索相同数字方块，以便合并</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = row - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          <span class="keyword">if</span> (_gameMap.tile(c, i) != <span class="number">0</span> &amp;&amp; t != _gameMap.tile(c, i)) &#123;</span><br><span class="line">            <span class="comment">// 如果找到了不同的数字方块，停止搜索</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_gameMap.tile(c, i) != <span class="number">0</span> &amp;&amp; t == _gameMap.tile(c, i)) &#123;</span><br><span class="line">            <span class="comment">// 如果找到了相同的数字方块，进行合并操作</span></span><br><span class="line">            setState(() =&gt; _gameMap.move(c, row, c, i));</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line">            logic.currentScore += _gameMap.tile(c, row); <span class="comment">// 更新分数</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 标记状态已经改变</span></span><br><span class="line">  <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">    <span class="comment">// 更新游戏状态</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分数的更新"><a href="#分数的更新" class="headerlink" title="分数的更新"></a>分数的更新</h2><p>privide参考文章</p><ul><li><a href="https://juejin.cn/post/7015887922117214238#heading-9">Flutter Provider状态管理—八种提供者使用分析 - 掘金 (juejin.cn)</a></li><li><a href="https://flyingstudio.feishu.cn/wiki/E2TSwTtZ9ik92EkCLpHcjAvbnRu?from=from_copylink">https://flyingstudio.feishu.cn/wiki/E2TSwTtZ9ik92EkCLpHcjAvbnRu?from=from_copylink</a></li></ul><p>因为我Header和Panel是分开的，导致分数的传递很麻烦，于是我用了Flutter的Provider状态管理</p><p>首先我在main函数添加了ChangeNotifierProvider组件</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(ChangeNotifierProvider(</span><br><span class="line">    create: (_) =&gt; Score(),</span><br><span class="line">    child: MaterialApp(</span><br><span class="line">      home: MyGame(),</span><br><span class="line">    )</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模组Score为:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Score</span> <span class="title">with</span> <span class="title">ChangeNotifier</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">当前分数</span></span></span><br><span class="line">  <span class="built_in">int</span>  currentScore = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">历史最高分</span></span></span><br><span class="line">  <span class="built_in">int</span> highestScore = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  getCur() =&gt; currentScore;</span><br><span class="line">  getHigh() =&gt; highestScore;</span><br><span class="line"></span><br><span class="line">  clearScore() &#123;</span><br><span class="line">    currentScore = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> setScore(<span class="built_in">int</span> s) &#123;</span><br><span class="line">    currentScore += s;</span><br><span class="line">    <span class="keyword">if</span> (currentScore &gt; highestScore) &#123;</span><br><span class="line">      highestScore = currentScore;</span><br><span class="line">    &#125;</span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    ....省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子在Panel中合并时，调用<code>setScore</code>,这样子<code>notifyListeners()</code>就会通知Hearder中的分数更新</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">            padding: <span class="keyword">const</span> EdgeInsets.fromLTRB(<span class="number">0</span>, <span class="number">40</span>, <span class="number">25</span>, <span class="number">0</span>),</span><br><span class="line">            child: Column(</span><br><span class="line">                crossAxisAlignment: CrossAxisAlignment.end,</span><br><span class="line">                children: [</span><br><span class="line">                  Consumer&lt;Score&gt;(builder:(context, currentScore, child) &#123;</span><br><span class="line">                    <span class="keyword">return</span> NumCard(text:<span class="string">&#x27;SCORE&#x27;</span>, score:Provider.of&lt;Score&gt;(context, listen: <span class="keyword">false</span>).currentScore);</span><br><span class="line">                  &#125;),</span><br><span class="line">                  <span class="keyword">const</span> SizedBox(height: <span class="number">10</span>,),</span><br><span class="line">                  Consumer&lt;Score&gt;(builder:(context, highestScore, child) &#123;</span><br><span class="line">                    <span class="keyword">return</span> NumCard(text:<span class="string">&#x27;HIGHEST&#x27;</span>, score:Provider.of&lt;Score&gt;(context, listen: <span class="keyword">false</span>).highestScore);</span><br><span class="line">                  &#125;)</span><br><span class="line">                ]</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br></pre></td></tr></table></figure><h2 id="最高分数的导入"><a href="#最高分数的导入" class="headerlink" title="最高分数的导入"></a>最高分数的导入</h2><p>shared_preferences参考文章 <a href="https://juejin.cn/post/7012840579964862471">Flutter shared_preferences的基本使用、源码分析、封装 - 掘金 (juejin.cn)</a></p><p>导入插件<code>shared_preferences: ^2.0.7</code></p><h3 id="获取实例对象"><a href="#获取实例对象" class="headerlink" title="获取实例对象"></a>获取实例对象</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences? sharedPreferences = <span class="keyword">await</span> SharedPreferences.getInstance();</span><br></pre></td></tr></table></figure><h3 id="设置持久化数据"><a href="#设置持久化数据" class="headerlink" title="设置持久化数据"></a>设置持久化数据</h3><p>我们可以通过<code>sharedPreferences</code>的实例化对象调用对应的<code>set</code>方法设置持久化数据</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences? sharedPreferences;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置持久化数据</span></span><br><span class="line"><span class="keyword">void</span> _setData() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// 实例化</span></span><br><span class="line">  sharedPreferences = <span class="keyword">await</span> SharedPreferences.getInstance();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置string类型</span></span><br><span class="line">  <span class="keyword">await</span> sharedPreferences?.setString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jimi&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置int类型</span></span><br><span class="line">  <span class="keyword">await</span> sharedPreferences?.setInt(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置bool类型</span></span><br><span class="line">  <span class="keyword">await</span> sharedPreferences?.setBool(<span class="string">&quot;isTeacher&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置double类型</span></span><br><span class="line">  <span class="keyword">await</span> sharedPreferences?.setDouble(<span class="string">&quot;height&quot;</span>, <span class="number">1.88</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置string类型的数组</span></span><br><span class="line">  <span class="keyword">await</span> sharedPreferences?.setStringList(<span class="string">&quot;action&quot;</span>, [<span class="string">&quot;吃饭&quot;</span>, <span class="string">&quot;睡觉&quot;</span>, <span class="string">&quot;打豆豆&quot;</span>]);</span><br><span class="line"></span><br><span class="line">  setState(() &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取持久化数据"><a href="#读取持久化数据" class="headerlink" title="读取持久化数据"></a>读取持久化数据</h3><p>我们可以通过<code>sharedPreferences</code>的实例化对象调用对应的<code>get</code>方法读取持久化数据</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Text(<span class="string">&quot;名字: <span class="subst">$&#123;sharedPreferences?.getString(<span class="string">&quot;name&quot;</span>) ?? <span class="string">&quot;&quot;</span>&#125;</span>&quot;</span>,</span><br><span class="line">     style: TextStyle(</span><br><span class="line">       color: Colors.blue,</span><br><span class="line">       fontSize: <span class="number">20</span></span><br><span class="line">     ),</span><br><span class="line">    ),</span><br><span class="line">SizedBox(height: <span class="number">20</span>,),</span><br><span class="line">Text(<span class="string">&quot;年龄: <span class="subst">$&#123;sharedPreferences?.getInt(<span class="string">&quot;age&quot;</span>) ?? <span class="string">&quot;&quot;</span>&#125;</span>&quot;</span>,</span><br><span class="line">     style: TextStyle(</span><br><span class="line">       color: Colors.red,</span><br><span class="line">       fontSize: <span class="number">20</span></span><br><span class="line">     ),</span><br><span class="line">    ),</span><br><span class="line">SizedBox(height: <span class="number">20</span>,),</span><br><span class="line">Text(<span class="string">&quot;是老师吗?: <span class="subst">$&#123;sharedPreferences?.getBool(<span class="string">&quot;isTeacher&quot;</span>) ?? <span class="string">&quot;&quot;</span>&#125;</span>&quot;</span>,</span><br><span class="line">     style: TextStyle(</span><br><span class="line">       color: Colors.orange,</span><br><span class="line">       fontSize: <span class="number">20</span></span><br><span class="line">     ),</span><br><span class="line">    ),</span><br><span class="line">SizedBox(height: <span class="number">20</span>,),</span><br><span class="line">Text(<span class="string">&quot;身高: <span class="subst">$&#123;sharedPreferences?.getDouble(<span class="string">&quot;height&quot;</span>) ?? <span class="string">&quot;&quot;</span>&#125;</span>&quot;</span>,</span><br><span class="line">     style: TextStyle(</span><br><span class="line">       color: Colors.pink,</span><br><span class="line">       fontSize: <span class="number">20</span></span><br><span class="line">     ),</span><br><span class="line">    ),</span><br><span class="line">SizedBox(height: <span class="number">20</span>,),</span><br><span class="line">Text(<span class="string">&quot;我正在: <span class="subst">$&#123;sharedPreferences?.getStringList(<span class="string">&quot;action&quot;</span>) ?? <span class="string">&quot;&quot;</span>&#125;</span>&quot;</span>,</span><br><span class="line">     style: TextStyle(</span><br><span class="line">       color: Colors.purple,</span><br><span class="line">       fontSize: <span class="number">20</span></span><br><span class="line">     ),</span><br><span class="line">    ),</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> GAME_2048_HIGHEST_SCORE = <span class="string">&quot;game_2048_highest_score&quot;</span>;</span><br><span class="line"></span><br><span class="line">Future&lt;SharedPreferences&gt; _spFuture = SharedPreferences.getInstance();</span><br><span class="line"></span><br><span class="line">  _GameHeader() &#123;</span><br><span class="line">    initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    readHighestScoreFromSp();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> readHighestScoreFromSp() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> SharedPreferences sp = <span class="keyword">await</span> _spFuture;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      <span class="comment">//Score.setScore(sp.getInt(GAME_2048_HIGHEST_SCORE) ?? 0);</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> storeHighestScoreToSp() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> SharedPreferences sp = <span class="keyword">await</span> _spFuture;</span><br><span class="line">    <span class="comment">//await sp.setInt(GAME_2048_HIGHEST_SCORE, Score.getHigh());</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="判断游戏结束"><a href="#判断游戏结束" class="headerlink" title="判断游戏结束"></a>判断游戏结束</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">bool</span> checkEnd(GameMap b) &#123;</span><br><span class="line">  <span class="keyword">return</span> maxTileExists(b) || !atLeastOneMoveExists(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">bool</span> maxTileExists(GameMap b) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> r = <span class="number">0</span>; r &lt; b.size(); r++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> c = <span class="number">0</span>; c &lt; b.size(); c++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (b.tile(c, r) == MAX_PIECE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">bool</span> atLeastOneMoveExists(GameMap b) &#123;</span><br><span class="line">  <span class="keyword">if</span> (b.hasEmptySpace()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> r = <span class="number">0</span>; r &lt; b.size(); r++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> c = <span class="number">0</span>; c &lt; b.size(); c++) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; c + <span class="number">1</span> &lt; b.size()) &amp;&amp;</span><br><span class="line">          (b.tile(c - <span class="number">1</span>, r) == b.tile(c, r) ||</span><br><span class="line">              b.tile(c + <span class="number">1</span>, r) == b.tile(c, r))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; r + <span class="number">1</span> &lt; b.size()) &amp;&amp;</span><br><span class="line">          (b.tile(c, r - <span class="number">1</span>) == b.tile(c, r) ||</span><br><span class="line">              b.tile(c, r + <span class="number">1</span>) == b.tile(c, r))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重新开始游戏"><a href="#重新开始游戏" class="headerlink" title="重新开始游戏"></a>重新开始游戏</h2><p>privide参考文章</p><ul><li><a href="https://juejin.cn/post/7015887922117214238#heading-9">Flutter Provider状态管理—八种提供者使用分析 - 掘金 (juejin.cn)</a></li><li><a href="https://flyingstudio.feishu.cn/wiki/E2TSwTtZ9ik92EkCLpHcjAvbnRu?from=from_copylink">https://flyingstudio.feishu.cn/wiki/E2TSwTtZ9ik92EkCLpHcjAvbnRu?from=from_copylink</a></li></ul><p>因为我Header和Panel是分开的，所以又有一个头疼的问题：NEW GAME按钮按下后，列表被清零了，但是 Panel页面并不会得到更新的通知，所以为了解决这个问题，我又使用了Provider</p><p>Header</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onTap: () &#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    Provider.of&lt;Score&gt;(context, listen: <span class="keyword">false</span>).currentScore = <span class="number">0</span>;</span><br><span class="line">    Provider.of&lt;Score&gt;(context, listen: <span class="keyword">false</span>).NewGame();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>Panel</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NewGame() &#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    Provider.of&lt;Score&gt;(context, listen: <span class="keyword">false</span>).currentScore = <span class="number">0</span>;</span><br><span class="line">    Provider.of&lt;Score&gt;(context, listen: <span class="keyword">false</span>).NewGame();</span><br><span class="line">    _isGameOver = <span class="keyword">false</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AspectRatio(</span><br><span class="line">        ...省略</span><br><span class="line">        itemBuilder: (context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">          <span class="built_in">int</span> indexI = index ~/ SIZE;</span><br><span class="line">          <span class="built_in">int</span> indexJ = index % SIZE;</span><br><span class="line">          <span class="keyword">return</span> _buildGameCell(Provider.of&lt;Score&gt;(context, listen: <span class="keyword">true</span>).tile1(indexI, indexJ));</span><br><span class="line">        &#125;,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p><strong>不知道为什么只有listen设为true后才有用</strong></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(十七)-RD17、18、19-树遍历与图</title>
      <link href="/2024/03/05/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-17-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD17%E3%80%8118%E3%80%8119-%E6%A0%91%E9%81%8D%E5%8E%86%E4%B8%8E%E5%9B%BE/"/>
      <url>/2024/03/05/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-17-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD17%E3%80%8118%E3%80%8119-%E6%A0%91%E9%81%8D%E5%8E%86%E4%B8%8E%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><h2 id="树的回顾"><a href="#树的回顾" class="headerlink" title="树的回顾"></a>树的回顾</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p>回想一下，一棵树由以下部分组成：</p><ul><li>一组节点（或顶点）。</li><li>连接这些节点的一组边。<ul><li><strong>约束</strong>：任意两个节点之间只有一条路径。</li></ul></li></ul><p><img src="/2024/03/05/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-17-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD17%E3%80%8118%E3%80%8119-%E6%A0%91%E9%81%8D%E5%8E%86%E4%B8%8E%E5%9B%BE/image-20240305235803647.png" alt="image-20240305235803647"></p><h3 id="树有什么用？"><a href="#树有什么用？" class="headerlink" title="树有什么用？"></a>树有什么用？</h3><p>到目前为止，我们已经了解了搜索树、尝试、堆、不相交集等。这些在我们创建高效算法的过程中非常有用：加快搜索项、允许添加前缀、检查连通性等。</p><p>但事实是它们比我们意识到的更加普遍。考虑一个组织结构图。在这里，总统是“根”。 “VP”是根的子代，依此类推。</p><p><img src="/2024/03/05/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-17-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD17%E3%80%8118%E3%80%8119-%E6%A0%91%E9%81%8D%E5%8E%86%E4%B8%8E%E5%9B%BE/org-chart-software-maker.png" alt="img"></p><p>另一个树结构是桌面上的 <code>61b/</code> 目录（它就在您的桌面上，不是吗？）。正如我们所看到的，当您遍历到子文件夹时，它会转到后续子文件夹，依此类推。这简直就像树一样！</p><p><img src="/2024/03/05/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-17-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD17%E3%80%8118%E3%80%8119-%E6%A0%91%E9%81%8D%E5%8E%86%E4%B8%8E%E5%9B%BE/image-20240305235854969.png" alt="image-20240305235854969"></p><h2 id="Tree-Iteration-Traversal"><a href="#Tree-Iteration-Traversal" class="headerlink" title="Tree Iteration Traversal"></a>Tree <del>Iteration</del> Traversal</h2><p>回想一下我们如何学会遍历列表的？有一种遍历列表的方式感觉很自然。就是从开头开始…然后继续往下走。</p><p>或者也许我们做了一些有点奇怪的事情，比如遍历列表的反向。回想一下，我们还在讨论中编写了迭代器，以跳过没有在 Office Hours 排队中写描述的学生。</p><p>现在如何遍历一棵树呢？什么是正确的“顺序”？</p><p>在回答这个问题之前，我们不能使用迭代这个词。相反，我们将称之为“遍历树”或“树遍历”。为什么呢？除了每个人都称通过树进行迭代为“遍历”之外，没有真正的理由。也许是因为世界喜欢头韵。</p><p>那么，通过树“遍历”的一些自然方法是什么？事实证明，有一些方法——与列表基本上只有一种自然的迭代方式不同：</p><ol><li>层次遍历。</li><li>深度优先遍历——其中有三种：前序、中序和后序。</li></ol><p>让我们在下面的树上测试上述遍历方法。</p><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><p>我们将按层次从左到右进行迭代。第 0 层？D。第 1 层？B，然后是 F。第 2 层？A，C，E 和 G。</p><p>这给我们 D B F A C E G。</p><p>想象每一层都是英语中的一个句子，我们只需逐行阅读它。</p><p><strong>练习 17.2.1.</strong> 编写执行层次遍历的代码（警告，这比编写其他遍历更难）。提示：您将需要跟踪您所在的层级。</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>前序遍历的思想很简单。从根开始。访问根（也就是，执行你想要的操作）。这里的操作是“打印”。</p><p>所以，我们将打印根。D。就这样。</p><p>现在，向左走，然后递归。然后，向右走并递归。</p><p>所以现在我们已经向左走了。我们在 B 节点。打印它。B。我们在打印后向左走。（记住，当我们完成了 B 的左分支后，我们会回来访问 B 的右分支。）</p><p>继续遵循这个逻辑，你会得到 D B A C F E G。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">preOrder(BSTNode x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    print(x.key)</span><br><span class="line">    preOrder(x.left)</span><br><span class="line">    preOrder(x.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>稍微不同，但大体思路相同。这里，我们首先访问（也就是打印）左分支，然后我们打印。然后我们访问右分支。</p><p>所以我们从 D 开始。我们不打印。我们向左走。</p><p>我们从 B 开始。我们不打印。我们向左走。</p><p>我们从 A 开始。我们不打印。我们向左走。我们什么也没找到。我们回来，打印 A。</p><p>然后去 A 的右边。找不到任何东西。返回。现在我们在 B。记住，在访问左边和访问右边之前打印，所以现在我们将打印 B，然后我们将访问右边。</p><p>继续遵循这个逻辑，你会得到 A B C D E F G。</p><p>另一种思考方法是：</p><p>首先，我们在 D。我们知道我们将先打印左边的项目，然后是 D，然后是右边的项目。</p><p>[左边的项目] D [右边的项目]。</p><p>现在左边的项目等于什么？我们从 B 开始，打印左边，然后打印 B，然后打印 B 的右边的东西。</p><p>[左边的项目] &#x3D; [B 的左边的项目] B [B 的右边的项目] &#x3D; A B C。</p><p>A B C D [右边的东西] &#x3D; A B C D E F G。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inOrder(BSTNode x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span>;    </span><br><span class="line">    inOrder(x.left)</span><br><span class="line">    print(x.key)</span><br><span class="line">    inOrder(x.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>同样的大体思路，但现在我们将打印左分支，然后右分支，然后是自己。</p><p>使用我们之前设计的方法，结果如下：</p><p>[左边的项目] [右边的项目] D。</p><p>左边的项目是什么？它是 B 子树的输出。</p><p>如果我们在 B，我们会得到 B 的左边的项目 B 的右边的项目 B，等于 A C B。</p><p>按照这个思路，我们得到：A C B E G F D</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postOrder(BSTNode x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span>;    </span><br><span class="line">    postOrder(x.left)</span><br><span class="line">    postOrder(x.right)</span><br><span class="line">    print(x.key)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆栈思路思考"><a href="#堆栈思路思考" class="headerlink" title="堆栈思路思考"></a>堆栈思路思考</h3><p><a href="https://blog.csdn.net/qq_61959780/article/details/127690872?ops_request_misc=%7B%22request_id%22:%22170965464016800215076432%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170965464016800215076432&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-127690872-null-null.142%5Ev99%5Epc_search_result_base8&utm_term=%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86&spm=1018.2226.3001.4187">二叉树遍历方法——前、中、后序遍历（图解）_前序遍历-CSDN博客</a></p><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>树很棒，不是吗？但正如我们所看到的，我们可以使用节点和边来绘制一些不是树的东西。具体来说，我们之前的限制，即任何两个节点之间只能有一条路径，不适用于所有情况。让我们看看当我们取消了这个限制会发生什么。</p><h2 id="什么是图？"><a href="#什么是图？" class="headerlink" title="什么是图？"></a>什么是图？</h2><p>图由以下组成：</p><ul><li>一组节点（或顶点）</li><li>一组零个或多个边，每条边连接两个节点。</li></ul><p>就是这样！没有其他限制。</p><p>下面以绿色显示的所有结构？都是有效的图！第二个也是一棵树，但其他都不是。</p><p><img src="/2024/03/05/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-17-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD17%E3%80%8118%E3%80%8119-%E6%A0%91%E9%81%8D%E5%8E%86%E4%B8%8E%E5%9B%BE/image-20240306173801174.png" alt="image-20240306173801174"></p><p>一般来说，需要注意的是所有树也都是图，但并非所有图都是树。</p><h2 id="仅有简单图"><a href="#仅有简单图" class="headerlink" title="仅有简单图"></a>仅有简单图</h2><p>图可以分为两类：简单图和多重图（或复杂图）。幸运的是，在这门课程中（以及几乎所有的应用和研究中），我们只关注简单图。所以在这门课程中，当我们说“图”时，你应该始终将其视为“简单图”（除非另有说明）。</p><p>好了，现在是解决问题的时候了。什么是简单图？</p><p>看一下红色的图。中间的图从&#x2F;到底部的下一个节点和&#x2F;或从&#x2F;到底部的左侧节点有2个不同的边。换句话说，两个节点之间存在多条边。这不是一个简单图，除非另有说明，我们将忽略它们的存在。类似这样的图被称为多重图。</p><p>再看第三张图。它有一个环！一个从一个节点到自身的边！我们也不允许这种情况。类似这样的图有时被归类为多重图，有时甚至明确禁止自环。</p><p><img src="/2024/03/05/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-17-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD17%E3%80%8118%E3%80%8119-%E6%A0%91%E9%81%8D%E5%8E%86%E4%B8%8E%E5%9B%BE/image-20240306173858995.png" alt="image-20240306173858995"></p><h2 id="更多分类"><a href="#更多分类" class="headerlink" title="更多分类"></a>更多分类</h2><p>除非另有说明，否则以下文本中的图都是简单图。但还有更多的分类。</p><ul><li>无向图，其中一条边（u，v）可能意味着从节点 u 到节点 v 的边，也可能意味着从节点 v 到节点 u 的边。有向图，其中边（u，v）表示从 u 开始的边，到达 v（反之则不成立，除非还存在边（v，u））。有向图中的边带有箭头。</li><li>还有无环图。这些是没有任何环的图。然后有环图，即存在一种方法从一个节点开始，沿着一些唯一的边返回到与起始节点相同的节点。</li></ul><p><img src="/2024/03/05/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-17-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD17%E3%80%8118%E3%80%8119-%E6%A0%91%E9%81%8D%E5%8E%86%E4%B8%8E%E5%9B%BE/image-20240306173933436.png" alt="image-20240306173933436"></p><p>在上面的图片中，我们可以清楚地看到如何绘制有向和无向边之间的差异。</p><p>看一下循环图。如果你从 a 开始，你可以沿着仅使用不同边的路径回到 a。因此，该图是有环的。</p><p>看一下左上角的图。有没有任何节点 n，如果你从 n 开始，你可以沿着一些不同的边，回到 n？没有！（记住对于有向边，你必须遵循方向。你可以从 a 到 b，但不能从 b 到 a。）</p><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="深度搜索-Depth-First-Traversal"><a href="#深度搜索-Depth-First-Traversal" class="headerlink" title="深度搜索(Depth-First Traversal)"></a><strong>深度搜索(Depth-First Traversal</strong>)</h2><p><img src="/2024/03/05/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-17-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD17%E3%80%8118%E3%80%8119-%E6%A0%91%E9%81%8D%E5%8E%86%E4%B8%8E%E5%9B%BE/image-20240306174606154.png" alt="image-20240306174606154"></p><p>让我们先解决列表中的第一个问题。给定源顶点 s 和目标顶点 t，是否存在两者之间的路径？</p><p>换句话说，编写一个名为 connected(s, t) 的函数，该函数接受两个顶点，并返回两者之间是否存在路径。</p><p>首先，让我们假设我们有以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s == t):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> child in <span class="title function_">neighbors</span><span class="params">(s)</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">isconnected</span><span class="params">(child, t)</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>但是这个存在一个问题:</p><p>我们从 connected(0, 7) 开始, 这将递归调用 connected(1, 7)，然后 connected(0, 7)。<strong>无限循环发生了。</strong></p><p>为了解决这个问题，我们需要<strong>标记已经递归过的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mark s  <span class="comment">// 记住你已经访问过 s 了</span></span><br><span class="line"><span class="keyword">if</span> (s == t):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> child in <span class="title function_">unmarked_neighbors</span><span class="params">(s)</span>: <span class="comment">// 如果邻居已经被标记，就忽略！</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">isconnected</span><span class="params">(child, t)</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><blockquote><p>我们标记了自己。然后我们访问了我们的第一个子节点。然后我们的第一个子节点标记了自己，并访问了它的子节点。然后我们的第一个子节点的第一个子节点标记了自己，并访问了它的子节点。</p><p>直观地说，我们会深入（即，沿着我们的家族树向下走到我们的第一个子节点，我们的第一个子节点的第一个子节点，也就是我们的第一个孙子，我们的第一个孙子的第一个子节点，依此类推……访问整个谱系），然后再去触摸我们的第二个孩子。</p></blockquote><div class="row">    <embed src="cs61b_s-t_connectivity_demo.pdf" width="100%" height="550" type="application/pdf"></div><div class="row">    <embed src="61B_depth_first_paths_demo.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="树遍历和深搜的对比"><a href="#树遍历和深搜的对比" class="headerlink" title="树遍历和深搜的对比"></a>树遍历和深搜的对比</h3><p><img src="/2024/03/05/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-17-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD17%E3%80%8118%E3%80%8119-%E6%A0%91%E9%81%8D%E5%8E%86%E4%B8%8E%E5%9B%BE/image-20240306175152450.png" alt="image-20240306175152450"></p><h2 id="广度优先搜索-Breadth-First-Search"><a href="#广度优先搜索-Breadth-First-Search" class="headerlink" title="广度优先搜索(Breadth First Search)"></a><strong>广度优先搜索(Breadth First Search)</strong></h2><p>也称为层序遍历</p><p>在 BFS 中，我们会先拜访所有的直系子女，然后再继续拜访我们的任何孙辈。换句话说，我们访问距源 1 个边的所有节点。然后，所有节点距我们的源有 2 个边，等等。</p><p>BFS的伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Initialize the fringe (a queue with the starting vertex) and mark that vertex.</span><br><span class="line">Repeat until fringe is empty:</span><br><span class="line">Remove vertex v from the fringe.</span><br><span class="line">For each unmarked neighbor n of v:</span><br><span class="line">Mark n.</span><br><span class="line">Add n to fringe.</span><br><span class="line">Set edgeTo[n] = v.</span><br><span class="line">Set distTo[n] = distTo[v] + 1.</span><br></pre></td></tr></table></figure><p><em>fringe</em>只是我们用于存储遍历发现过程边界上的节点（它正在等待查看的下一个节点）的数据结构的术语。对于 BFS，我们使用队列作为<em>fringe</em>。</p><p><code>edgeTo[...]</code> 是一个map，可以帮助我们跟踪如何到达节点 <code>n</code> ；我们沿着从 <code>v</code> 到 <code>n</code> 的边缘到达了它。</p><p><code>distTo[...]</code> 是一个map，可以帮助我们跟踪 <code>n</code> 距起始顶点的距离。假设每条边的距离为 <code>1</code> ，那么到 <code>n</code> 的距离仅比到 <code>v</code> 的距离多一。为什么？我们可以使用我们知道如何到达 <code>v</code> 的方式，然后再支付一次费用，通过 <code>v</code> 和 <code>n</code> （它必须存在，因为在 <code>for</code> 循环头中， <code>n</code> 被定义为 <code>v</code> 的邻居）。</p><div class="row">    <embed src="cs61b_Breadth_First_Paths_Demo(2019).pdf" width="100%" height="550" type="application/pdf"></div><h3 id="深搜与广搜对比"><a href="#深搜与广搜对比" class="headerlink" title="深搜与广搜对比"></a>深搜与广搜对比</h3><p>需要注意的是，深度优先搜索（DFS）和广度优先搜索（BFS）不仅在它们的 fringe 数据结构上有所不同，它们在标记节点的顺序上也有所不同。对于DFS，我们只有在访问到一个节点时才标记它 - 也就是说，从 fringe 中弹出它。因此，如果某个节点已经被添加到队列中但尚未被访问，那么在栈上同时存在多个相同节点的实例是可能的。而对于BFS，我们在将节点添加到 fringe 时立即标记节点，因此不可能出现这种情况。</p><blockquote><p>在DFS中，当遍历到一个节点时，首先将其标记为已访问，然后探索该节点的所有相邻节点。这意味着节点只有在被访问到并从遍历队列中弹出时才被标记。因此，在DFS中，如果一个节点已经被加入到遍历队列中但尚未被访问到，那么它可以被多次加入到栈中，形成多个实例。</p><p>相比之下，在BFS中，当一个节点被加入到遍历队列中时，立即将其标记为已访问。这样就不会出现同一节点的多个实例同时存在于队列中的情况，因为每个节点在被添加到队列时就已经被标记过了。</p><p>这种不同的节点标记方式导致DFS和BFS在搜索顺序和空间复杂度方面表现出不同的特点。DFS更加深入地搜索图的分支，可能会沿着一条路径一直向下搜索，而BFS则更加广泛地搜索图的各个分支，逐层向外扩展。</p></blockquote><p>递归 DFS 通过递归堆栈帧自然地实现了这一点；迭代DFS手动实现它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Initialize the fringe, an empty stack</span><br><span class="line">    push the starting vertex on the fringe</span><br><span class="line">    while fringe is not empty:</span><br><span class="line">        pop a vertex off the fringe</span><br><span class="line">        if vertex is not marked:</span><br><span class="line">            mark the vertex</span><br><span class="line">            visit vertex</span><br><span class="line">            for each neighbor of vertex:</span><br><span class="line">                if neighbor not marked:</span><br><span class="line">                    push neighbor to fringe</span><br></pre></td></tr></table></figure><h1 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h1><p>现在让我们花点时间来讨论如何在代码中实现这些图和图算法。</p><p>我们将讨论我们的 API 选择，以及用于表示图的底层数据结构。我们的决定可能会对我们的运行时、内存使用情况以及实现各种图算法的难度产生深远的影响。</p><h2 id="图-API"><a href="#图-API" class="headerlink" title="图 API"></a>图 API</h2><p>API（应用程序编程接口）是我们类的用户可以使用的方法列表，包括方法签名（每个函数接受的参数&#x2F;参数是什么）以及有关它们行为的信息。你已经见过来自Java开发者的API，比如他们提供的类，比如 Deque。</p><p>对于我们的图 API，让我们使用将每个唯一节点分配给一个整数编号的常见约定。这可以通过维护一个映射来实现，该映射可以告诉我们每个原始节点标签分配的整数。这样做可以让我们定义我们的 API 专门与整数一起工作，而不是引入对泛型类型的需求。</p><p>然后，我们可以定义我们的 API 看起来可能是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> V)</span>:               <span class="comment">// 创建具有 v 个顶点的空图</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span>: <span class="comment">// 添加一条 v-w 的边</span></span><br><span class="line">  Iterable&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> v)</span>:      <span class="comment">// 与 v 相邻的顶点</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">V</span><span class="params">()</span>:                           <span class="comment">// 顶点数</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">E</span><span class="params">()</span>:                           <span class="comment">// 边数</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>客户端（希望使用我们的图数据结构的人）可以使用我们提供的任何函数来实现自己的算法。我们提供的方法可能会对我们的客户实现特定算法的难易程度产生重大影响。</p><h2 id="图的表示-1"><a href="#图的表示-1" class="headerlink" title="图的表示"></a>图的表示</h2><p>接下来，我们将讨论可以用于表示我们的图的底层数据结构。</p><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>一种方法是使用二维数组。当且仅当对应的单元格为 1 时（表示为 true），存在从顶点 s 到 t 的边。注意，如果图是无向的，则邻接矩阵将在其对角线上对称（从左上角到右下角的对角线）。</p><h3 id="边集"><a href="#边集" class="headerlink" title="边集"></a>边集</h3><p>另一种方法是存储所有边的单个集合。</p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>第三种方法是维护一个由顶点编号索引的列表数组。当且仅当从 s 到 t 存在一条边时，数组索引为 s 的列表将包含 t。</p><p>实际上，邻接表是最常见的，因为图往往是稀疏的（每个桶中没有太多的边）。</p><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>您选择的底层数据结构可以影响图的运行时和内存使用情况。幻灯片中的这张表总结了每种表示形式对各种操作的效率。在将此内容复制到您的备忘单上之前，请先花时间了解这些边界是从何而来的。讲座包含了解释其中几个单元格背后原理的步骤。</p><p>此外，基于邻接表的图上的DFS&#x2F;BFS的运行时间为 </p><p>O(V+E)，而基于邻接矩阵的图上的运行时间为 </p><p> )。请参考幻灯片以帮助理解为什么。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B项目笔记(七)-proj2</title>
      <link href="/2024/03/04/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-6-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-proj2/"/>
      <url>/2024/03/04/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-6-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-proj2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://sp21.datastructur.es/materials/proj/proj2/proj2">项目2：Gitlet | CS 61B 2021 年春季 — Project 2: Gitlet | CS 61B Spring 2021 (datastructur.es)</a>要求介绍</p><h1 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h1><h2 id="项目-2-Gitlet"><a href="#项目-2-Gitlet" class="headerlink" title="项目 2: Gitlet"></a>项目 2: Gitlet</h2><h2 id="关于此规范的说明"><a href="#关于此规范的说明" class="headerlink" title="关于此规范的说明"></a>关于此规范的说明</h2><p>此规范相当长。前半部分详细描述了您将支持的每个命令，另一半是测试详细信息和一些建议。为了帮助您理解，我们准备了许多高质量的视频，描述了规范的各个部分，并提供建议。所有视频都链接在本规范的相关位置，但我们也将在此列出它们以方便您查看。请注意：这些视频中的一些是在 2020 年春季创建的，当时 Gitlet 是项目 3，Capers 是 Lab 12，并且一些视频简要提及了 Hilfinger 教授的 CS 61B 设置（包括名为 <code>shared</code> 的远程，名为 <code>repo</code> 的存储库等）。请忽略这些内容，因为它们对本学期的您没有任何有用的信息。任务的实际内容没有改变。</p><ul><li><a href="https://www.youtube.com/watch?v=yWBzCAY_5UI">Git 介绍 - 第 1 部分</a></li><li><a href="https://www.youtube.com/watch?v=CnMpARAOhFg">Git 介绍 - 第 2 部分</a></li><li><a href="https://youtu.be/fvhqn5PeU_Q">直播讲座 12</a></li><li>Gitlet 介绍播放列表<ul><li><a href="https://www.youtube.com/watch?v=-1gE2cNFhPA">第 1 部分</a></li><li><a href="https://www.youtube.com/watch?v=GfmH9_8tM5w">第 2 部分</a></li><li><a href="https://www.youtube.com/watch?v=dv5VdbIZKF8">第 3 部分</a></li><li><a href="https://www.youtube.com/watch?v=k8jwbG8bE7Y">第 4 部分</a></li><li><a href="https://cdn-uploads.piazza.com/attach/k5eevxebzpj25b/jqr7jm9igtc7l5/k97ipfmgmb3n/Gitlet_Slides.pdf">Itai 使用的幻灯片</a></li></ul></li><li><a href="https://www.youtube.com/watch?v=JR3OYCMv9b4&t=929s">合并概述和示例</a></li><li><a href="https://youtu.be/desB3AS6aZg">分支概述和示例</a></li><li><a href="https://www.youtube.com/watch?v=uMYpuQuHGu0&t=752s">测试</a></li><li><a href="https://paper.dropbox.com/doc/Gitlet-Persistence--AyM0lOEaezWrTi7gG_Pt~bXcAg-zEnTGJhtUMtGr8ILYhoab">设计持久性（书面笔记）</a></li><li>2021 年春季办公时间演示：<ul><li>开始 Gitlet<ul><li><a href="https://youtu.be/6JVdbNZm0cM">第 1 部分</a></li><li><a href="https://youtu.be/1d1yOSoTVAM">第 2 部分</a></li></ul></li><li>设计 Gitlet<ul><li><a href="https://sp21.datastructur.es/materials/proj/proj2/gitlet-design-notes.pdf">笔记</a></li></ul></li><li><a href="https://youtu.be/l0X5NgzAWYQ">合并</a></li></ul></li></ul><p>随着更多资源的创建，我们将在此处添加它们，因此请经常刷新！</p><h2 id="Gitlet-概述"><a href="#Gitlet-概述" class="headerlink" title="Gitlet 概述"></a>Gitlet 概述</h2><p><strong>警告：</strong>确保您在进行此项目之前已完成<a href="https://sp21.datastructur.es/materials/lab/lab6/lab6">实验 6: Canine Capers</a>。实验 6 旨在介绍此项目，并将非常有助于启动和确保您已做好准备。您还应该观看<a href="https://youtu.be/fvhqn5PeU_Q">直播讲座 12: Gitlet</a>，该讲座介绍了此项目的许多有用想法。</p><p>在此项目中，您将实现一个版本控制系统，模仿了流行系统 Git 的一些基本功能。但我们的系统更小更简单，因此我们将其命名为 Gitlet。</p><p>版本控制系统本质上是一种相关文件集的备份系统。Gitlet 支持的主要功能包括：</p><ol><li>保存整个文件目录的内容。在 Gitlet 中，这称为<em>提交</em>，保存的内容本身称为<em>提交</em>。</li><li>恢复一个或多个文件或整个提交的版本。在 Gitlet 中，这称为<em>检出</em>这些文件或该提交。</li><li>查看备份历史。在 Gitlet 中，您可以在称为<em>日志</em>的内容中查看此历史记录。</li><li>维护相关的提交序列，称为<em>分支</em>。</li><li>将在一个分支中进行的更改合并到另一个分支中。</li></ol><p>版本控制系统的目的是帮助您创建复杂（甚至不那么复杂）的项目，或者与他人共同在项目上合作。您会定期保存项目的版本。如果以后某个时刻意外地搞乱了您的代码，那么您可以将源代码恢复到之前提交的版本（而不会丢失此后所做的任何更改）。如果您的合作者做了一些更改并体现在提交中，则可以将这些更改合并到自己的版本中。</p><p>在 Gitlet 中，您不仅可以一次提交单个文件。相反，您可以同时提交一组相关文件。我们喜欢将每个提交视为您项目在某个时间点的<em>快照</em>。但为简单起见，本文档剩余部分中的许多示例涉及每次更改一个文件。只需记住，您可以在每次提交中更改多个文件。</p><p>在此项目中，我们将可视化随时间进行的提交。假设我们有一个项目，只包含文件 wug.txt，我们向其中添加了一些文本并提交了它。然后我们修改了文件并提交了这些</p><p>更改。然后我们再次修改了文件，并再次提交了更改。现在我们已保存了这个文件的三个版本，每个版本都晚于之前的版本。我们可以像这样可视化这些提交：</p><p><img src="/2024/03/04/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-6-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-proj2/three_commits.png" alt="三次提交"></p><p>在这里，我们绘制了一个箭头，指示每个提交包含对之前提交的某种引用。我们将前面的提交称为<em>父提交</em>——这在后面会很重要。但是现在，这个图看起来熟悉吗？没错；这是一个链表！</p><p>Gitlet 的重要思想是，我们可以在这样的列表中可视化我们文件的不同版本的历史。然后，我们可以很容易地恢复文件的旧版本。您可以想象制作一个命令：“Gitlet，请恢复到提交＃2时的文件状态”，它会转到链表中的第二个节点，并恢复在那里找到的文件的副本，同时删除第一个节点中的任何文件，但不删除第二个节点中不存在的文件。</p><p>如果我们告诉 Gitlet 恢复到旧提交，那么链表的前面将不再反映文件的当前状态，这可能有点误导。为了解决这个问题，我们引入了一个称为<em>头指针</em>（也称为 HEAD 指针）的东西。头指针跟踪我们当前所在的链表中的位置。通常，当我们进行提交时，头指针将保留在链表的前端，表示最新的提交反映了文件的当前状态：</p><p><img src="/2024/03/04/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-6-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-proj2/simple_head.png" alt="简单的头部"></p><p>然而，假设我们恢复到提交＃2时的文件状态（严格来说，这是 <em>重置</em> 命令，您稍后会看到）。我们将头指针移回以显示此：</p><p><img src="/2024/03/04/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-6-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-proj2/reverted_head.png" alt="恢复的头部"></p><p>这里我们说我们处于<em>分离的头状态</em>，您可能之前遇到过这个。这就是它的含义！</p><p>编辑 3&#x2F;5：请注意，在 Gitlet 中，由于没有 <code>checkout</code> 命令会将 HEAD 指针移动到特定提交，因此不可能处于分离 HEAD 状态。<code>reset</code> 命令会执行此操作，尽管它也会移动分支指针。因此，在 Gitlet 中，您永远不会处于分离的 HEAD 状态。</p><p>好了，现在，如果这就是 Gitlet 所能做的一切，那么它将是一个相当简单的系统。但是 Gitlet 还有一个更聪明的功能：它不仅维护文件的旧版本和新版本，还可以维护<em>不同的</em>版本。想象一下，您正在编写一个项目，您对如何进行以下两种想法：让我们称其中一种为计划 A，另一种为计划 B。Gitlet 允许您保存这两个版本，并随时在它们之间切换。这可能看起来像这样：</p><p><img src="/2024/03/04/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-6-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-proj2/two_versions.png" alt="两个版本"></p><p>它不再是一个链表。它更像是一棵树。我们将这个东西称为<em>提交树</em>。保持这个隐喻，各个单独的版本称为树的<em>分支</em>。您可以单独开发每个版本：</p><p><img src="/2024/03/04/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-6-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-proj2/two_developed_versions.png" alt="两个开发版本"></p><p>树中有两个指针，表示每个分支的最远点。在任何给定时间，只有一个是当前活动指针，这就是所谓的头指针。头指针是当前分支前端的指针。</p><p>这就是我们对 Gitlet 系统的简要概述！如果您还不完全了解，请不要担心；上面的部分只是为了给您一个高层次的图片，说明它的目的是做什么。接下来的详细规范将在此部分后面。</p><p>但是在这里最后一句话：提交树是<em>不可变的</em>：一旦创建了提交节点，就无法销毁（或者根本无法更改）。我们只能向提交树添加新内容，而不能修改现有内容。这是 Gitlet 的一个重要特性！Gitlet 的一个目标是允许我们保存东西，以免意外删除它们。</p><h2 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h2><p>真正的 Git 区分了几种不同的<em>对象</em>。就我们的目的而言，重要的对象包括</p><ul><li><strong>blobs</strong>：文件的保存内容。由于 Gitlet 保存文件的多个版本，因此单个文件可能对应于多个 blobs：每个 blobs 在不同提交中被跟踪。</li><li><strong>trees</strong>：将名称映射到 blobs 和其他树（子目录）的目录结构。</li><li><strong>commits</strong>：包含日志消息、其他元数据（提交日期、作者等）、对树的引用以及对父提交的引用的组合。存储库还维护从<em>分支头</em>到对提交的引用的映射，以便某些重要的提交具有符号名称。</li></ul><p>Gitlet 进一步简化了 Git，具体包括</p><ul><li>将树结构合并到提交中，而不处理子目录（因此每个存储库将有一个“平面”目录，其中包含普通文件）。</li><li>限制我们将合并与两个</li></ul><p>父亲联系起来（在真实的 Git 中，可以有任意数量的父亲。）</p><ul><li>我们的元数据仅包含时间戳和日志消息。因此，提交将由日志消息、时间戳、文件名到 blob 引用的映射、父引用以及（对于合并）第二父引用组成。</li></ul><p>我们的每个对象——我们的每个 blob 和每个提交，在我们的情况下——都有一个唯一的整数 id，它作为对该对象的引用。Git 的一个有趣的特性是这些 id 是<em>全局</em>的：与典型的 Java 实现不同，具有完全相同内容的两个对象在所有系统上（即我的计算机、您的计算机和任何其他人的计算机）上都具有相同的 id（即两个对象在不同计算机上具有相同的 id）。在 blobs 的情况下，“相同内容”意味着相同的文件内容。在提交的情况下，这意味着相同的元数据、名称到引用的映射和父引用。存储库中的对象因此被称为<em>内容寻址</em>。</p><p>Git 和 Gitlet 通过使用一个名为 SHA-1（Secure Hash 1）的<em>加密散列函数</em>实现了这一点，该函数可以从任意字节序列产生一个 160 位整数哈希。加密哈希函数的特性是极难找到具有相同哈希值的两个不同的字节流（或者在仅给出其哈希值的情况下找到<em>任何</em>字节流），因此从本质上讲，我们可以假设任何两个具有不同内容的对象具有相同的 SHA-1 哈希值的概率是 2-160 或约为 10-48。基本上，我们简单地忽略了哈希碰撞的可能性，因此原则上系统具有一个基本的缺陷，但在实践中从未发生！</p><p>幸运的是，有用于计算 SHA-1 值的库类，因此您不必处理实际算法。您需要做的一切就是确保正确地标记所有对象。特别是，这包括</p><ul><li>在计算提交的哈希值时包括所有元数据和引用。</li><li>在 blobs 和提交的哈希之间某种区分。通过 <code>.gitlet</code> 目录内部的一种精心考虑的目录结构是一个很好的方法。另一种方法是为每个对象添加一个额外的字，该字对于 blobs 和提交具有一个值。</li></ul><p>顺便说一下，SHA-1 哈希值，表示为 40 字符的十六进制字符串，是将数据存储在 <code>.gitlet</code> 目录中的方便文件名（稍后会详细介绍）。它还提供了一种比较两个文件（blobs）以查看它们是否具有相同内容的方便方法：如果它们的 SHA-1 相同，则我们简单地假设这些文件是相同的。</p><p>对于远程（例如我们整个学期都在使用的 <code>skeleton</code>），我们将只是使用其他 Gitlet 存储库。推送意味着将远程存储库尚未拥有的所有提交和 blobs 复制到远程存储库，并重置分支引用。拉取也是如此，但方向相反。在本项目中，远程是额外的学分，不是必须的。</p><p>读取和写入内部对象到文件其实相当容易，这要归功于Java的<em>序列化</em>功能。接口<code>java.io.Serializable</code>没有方法，但如果一个类实现了它，那么Java运行时将自动提供一种将对象转换为字节流的方法，然后您可以使用I&#x2F;O类<code>java.io.ObjectOutputStream</code>将其写入文件，并使用<code>java.io.ObjectInputStream</code>读取（反序列化）。术语“序列化”指的是将某种任意结构（数组、树、图等）转换为字节序列的过程。你应该在实验6中已经见过并练习了序列化。你将在这里使用一个非常类似的方法，因此在持久性和序列化方面请使用你的lab6作为参考。</p><p>下面是本节讨论的结构的摘要示例。正如你所看到的，每个提交（矩形）指向一些Blob（圆圈），其中包含文件内容。提交包含文件名和对这些Blob的引用，以及父链接。这些引用，表示为箭头，在<code>.gitlet</code>目录中使用它们的SHA-1哈希值表示（在提交上方和Blob下方的小十六进制数值）。更新的提交包含<code>wug1.txt</code>的更新版本，但与旧提交相同版本的<code>wug2.txt</code>。你的提交类将以某种方式存储此图表显示的所有信息：仔细选择内部数据结构将使实现变得更容易或更难，因此你应该花时间计划和考虑最佳存储方式。</p><p><img src="/2024/03/04/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-6-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-proj2/commits-and-blobs.png" alt="两个提交及其Blob"></p><h2 id="行为的详细规范"><a href="#行为的详细规范" class="headerlink" title="行为的详细规范"></a>行为的详细规范</h2><h3 id="总体规范"><a href="#总体规范" class="headerlink" title="总体规范"></a>总体规范</h3><p>我们唯一给你的结构要求是你必须有一个名为<code>gitlet.Main</code>的类，并且它必须有一个主方法。</p><p>我们还为您提供了一些用于执行许多与文件系统相关的任务的实用方法，以便您可以集中精力于项目的逻辑，而不是处理操作系统的特殊性。</p><p>我们还添加了两个建议的类：<code>Commit</code>和<code>Repository</code>以帮助您入门。当然，您可以编写其他Java类来支持您的项目，或者如果您愿意，可以删除我们建议的类。但是不要使用任何外部代码（除了JUnit），也不要使用除Java之外的任何编程语言。您可以使用您希望使用的所有Java标准库，以及我们提供的实用程序。</p><p><strong>你不应该在Main类中做所有事情。</strong>您的Main类应该主要调用<code>Repository</code>类中的辅助方法。查看实验6的<code>CapersRepository</code>和<code>Main</code>类，以了解我们建议的结构示例。</p><p>这份规范的大部分内容将描述当<code>Gitlet.java</code>的主方法收到各种gitlet命令作为命令行参数时必须如何反应。但在我们逐条分解命令之前，这里有一些整体指南整个项目都应该满足的：</p><ul><li>为了使Gitlet正常工作，它将需要一个存储旧文件副本和其他元数据的地方。所有这些东西<strong>必须</strong>存储在名为<code>.gitlet</code>的目录中，就像实际的git系统中的信息存储在名为<code>.git</code>的目录中一样（以<code>.</code>开头的文件是隐藏文件。您无法在大多数操作系统上默认看到它们。在Unix上，命令<code>ls -a</code>将显示它们。）如果在一个位置有一个<code>.gitlet</code>目录，那么就认为Gitlet系统在那里“初始化”了。大多数Gitlet命令（除了<code>init</code>命令）只需要在初始化了Gitlet系统的目录中使用时才能工作——也就是说，在包含<code>.gitlet</code>目录的目录中。不在您的<code>.gitlet</code>目录中的文件（它们是您使用和编辑的仓库中的文件的副本，以及您计划添加到仓库中的文件）被称为您<em>工作目录</em>中的文件。</li><li>大多数命令有运行时或内存使用要求。您必须遵循这些要求。其中一些运行时描述为常量“相对于任何重要度量”。重要度量包括：文件的数量或大小的任何度量，提交数量的任何度量。您可以忽略序列化或反序列化所需的时间，<em>但有一个例外，即您的序列化时间不能以任何方式依赖已添加、提交等文件的总大小</em>（什么是序列化？如果您不知道，请回顾实验6！）。您还可以假设从哈希表中获取是常量时间。</li><li>一些命令具有带有指定错误消息的失败情况。这些错误消息的确切格式稍后在规范中指定。所有错误消息都以句号结尾；由于我们的自动分级是文字性的，请务必包括它。如果您的程序曾遇到其中一种失败情况，则必须打印错误消息并不更改任何其他内容。<em>您不需要处理除列出为失败情况之外的任何其他错误情况</em>。</li><li>有一些失败情况您需要处理，这些失败情况不适用于特定命令。这里它们是：<ul><li>如果用户没有输入任何参数，请打印消息 <code>Please enter a command.</code> 并退出。</li><li>如果用户输入一个不存在的命令，请打印消息 <code>No command with that name exists.</code> 并退出。</li><li>如果用户输入具有错误数量或格式的操作数的命令，请打印消息 <code>Incorrect operands.</code> 并退出。</li><li>如果用户输入一个需要在初始化的 Gitlet 工作目录中（即包含 <code>.gitlet</code> 子目录的目录）的命令，但不在这样的目录中，则打印消息 <code>Not in an initialized Gitlet directory.</code></li><li>一些命令与真实的 Git 有所不同。规范没有详尽列出与 Git 的 <em>所有</em> 不同之处，但它确实列出了一些较大或潜在混淆和误导的差异。</li><li><strong>不要</strong> 输出除了规范中所说的之外的任何内容。我们的自动评分测试中可能会有一些打印不必要信息的测试会出错。</li><li>若要立即退出程序，您可以调用 <code>System.exit(0)</code>。例如，如果在辅助函数中发生错误，并且您希望 gitlet 立即终止，则应调用此函数。<strong>注意：您应该始终为 <code>System.exit(0)</code> 命令提供参数 0</strong>。在 61C 中，您将了解参数（称为错误代码）的含义。</li><li>规范将一些命令分类为“危险”。危险命令是那些可能覆盖文件（不仅仅是元数据）的命令 - 例如，如果用户告诉 Gitlet 将文件恢复到旧版本，Gitlet 可能会覆盖文件的当前版本。请注意。因此，在测试这些命令之前，请戴上头盔 :)</li></ul></li></ul><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>我们现在将详细介绍您必须支持的每个命令。请记住，优秀的程序员始终关心他们的数据结构：当您阅读这些命令时，您应该首先考虑如何存储您的数据以便轻松支持这些命令，并其次考虑是否有机会重用您已经实现的命令（提示：在项目2的后续部分中，您已经在项目2的较早部分中编写的代码可以得到充分的重用机会）。我们在一些我们发现有用的方法中列出了讲座，但您不必使用这些讲座中的概念。一些更加复杂的命令上有概念性的测验，您应该使用它们来检查您的理解。<strong>这些测验不计入成绩</strong>，它们只是帮助您在尝试实现命令之前检查您的理解。</p><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><ul><li><strong>用法</strong>：<code>java gitlet.Main init</code></li><li><strong>描述</strong>：在当前目录中创建一个新的 Gitlet 版本控制系统。该系统将自动开始一个提交：一个不包含文件且具有提交消息 <code>initial commit</code>（就是这样，没有标点符号）。它将有一个单一分支：<code>master</code>，最初指向此初始提交，并且<code>master</code>将是当前分支。此初始提交的时间戳将为 00:00:00 UTC，Thursday, 1 January 1970，以您选择的日期格式（这被称为“Unix 纪元”，内部由时间 0 表示）。由于由 Gitlet 创建的所有存储库中的初始提交都具有完全相同的内容，因此所有存储库将自动共享此提交（它们将具有相同的 UID），并且所有存储库中的所有提交都将追溯到它。</li><li><strong>运行时间</strong>：相对于任何重要指标，应该是恒定的。</li><li><strong>失败情况</strong>：如果当前目录中已经存在 Gitlet 版本控制系统，则应中止。不应使用新系统覆盖现有系统。应打印错误消息 <code>A Gitlet version-control system already exists in the current directory.</code>。</li><li><strong>危险吗</strong>：否</li><li><strong>我们的代码行数</strong>：~15</li></ul><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><ul><li><strong>用法</strong>：<code>java gitlet.Main add [文件名]</code></li><li><strong>描述</strong>：将文件的当前副本添加到<em>暂存区</em>（参见 <code>commit</code> 命令的描述）。因此，添加文件也称为<em>为添加而暂存</em>文件。将已经暂存的文件暂存会使用新内容覆盖暂存区中的先前条目。暂存区应该位于<code>.gitlet</code>的某个地方。如果文件的当前工作版本与当前提交中的版本相同，则不要将其暂存以添加，并且如果已经存在（当文件更改、添加，然后更改回其原始版本时可能会发生）的情况下，从暂存区删除它。文件将不再被暂存以删除（请参见 <code>gitlet rm</code>），如果在命令时处于该状态。</li><li><strong>运行时间</strong>：在最坏的情况下，应相对于要添加的文件的大小和 lgNlg⁡� 运行，其中 N� 是提交中的文件数量。</li><li><strong>失败情况</strong>：如果文件不存在，则打印错误消息 <code>File does not exist.</code> 并且退出而不更改任何内容。</li><li><strong>危险吗</strong>：否</li><li><strong>我们的代码行数</strong>：~20</li><li><strong>与真实 git 的区别</strong>：在真实的 git 中，可以一次添加多个文件。在 gitlet 中，一次只能添加一个文件。</li><li><strong>建议的讲座</strong>：讲座16（集合、映射、ADTs）、讲座19（哈希）</li></ul><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><ul><li><p><strong>用法</strong>: <code>java gitlet.Main commit [消息]</code></p></li><li><p><strong>描述</strong>: 在当前提交和暂存区保存已跟踪文件的快照，以便稍后可以恢复，创建一个新的提交。该提交被称为<em>跟踪</em>保存的文件。默认情况下，每个提交的文件快照将与其父提交的文件快照完全相同；它将保留文件的版本完全不变，不会更新它们。提交仅会更新在提交时已标记为要添加的文件的内容，在这种情况下，提交现在将包含已标记为要添加的文件的版本，而不是从其父提交中获取的版本。提交将保存并开始跟踪任何已标记为要添加但父提交未跟踪的文件。最后，由于被<code>rm</code>命令（下面）标记为<em>要删除</em>，当前提交中跟踪的文件可能会在新提交中被取消跟踪。</p><p>要点总结：默认情况下，提交的文件内容与其父提交相同。标记为要添加和删除的文件是提交的更新内容。当然，日期（以及可能是消息）也与父提交不同。</p><p>关于提交的一些附加说明：</p><ul><li>提交区在提交后被清除。</li><li>提交命令永远不会在工作目录中添加、更改或删除文件（除了<code>.gitlet</code>目录中的文件）。<code>rm</code>命令<em>将</em>删除这些文件，并将它们标记为要删除，以便在<code>commit</code>后它们将不再被跟踪。</li><li>在添加或删除之后对文件进行的任何更改都将被<code>commit</code>命令忽略，它<em>只</em>修改<code>.gitlet</code>目录的内容。例如，如果您使用Unix的<code>rm</code>命令（而不是Gitlet的同名命令）删除一个已跟踪的文件，那么它对下一个提交没有影响，下一个提交仍将包含（现在已删除的）文件版本。</li><li>提交命令后，新提交将作为提交树中的新节点添加。</li><li>刚刚进行的提交将成为“当前提交”，并且头指针现在指向它。先前的头提交是此提交的父提交。</li><li>每个提交应包含其制作时间和日期。</li><li>每个提交都有一个与之关联的日志消息，描述提交中文件的更改。这是由用户指定的。整个消息应仅占用传递给<code>main</code>的<code>args</code>数组中的一个条目。要包含多个单词的消息，您必须将其用引号括起来。</li><li>每个提交由其SHA-1 id标识，该id必须包括其文件（blob）引用、父引用、日志消息和提交时间。</li></ul></li><li><p><strong>运行时间</strong>: 运行时间应与提交数量的任何度量相关的常量。运行时必须不会比跟踪的文件总大小的线性差。此外，此命令具有内存要求：提交必须将<code>.gitlet</code>目录的大小增加的量不得超过提交时暂存要添加的文件的总大小，不包括附加元数据。这意味着不要存储提交从其父项接收的文件版本的冗余副本（提示：请记住blob是内容可寻址的，并利用SHA1优势）。您<em>可以</em>保存完整的附加文件副本；不要担心仅保存差异或类似的事情。</p></li><li><p><strong>失败情况</strong>: 如果没有文件被暂存，则中止。打印消息<code>No changes added to the commit.</code>。每个提交必须有一个非空消息。如果没有，则打印错误消息<code>Please enter a commit message.</code>。对于已跟踪文件在工作目录中缺失或更改的情况<em>不</em>算是失败。完全忽略<code>.gitlet</code>目录外的所有内容。</p></li><li><p><strong>危险性</strong>: 没有</p></li><li><p><strong>与真实Git的不同之处</strong>: 在真实的Git中，提交可能有多个父提交（由于合并）并且还具有更多元数据。</p></li><li><p><strong>我们的代码行数</strong>: ~35</p></li><li><p><strong>建议的讲座</strong>: 讲座19（集合、映射、ADTs）、讲座19（哈希）</p></li></ul><p>这是提交之前和之后的图片：</p><p><img src="/2024/03/04/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-6-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-proj2/before_and_after_commit.png" alt="Before and after commit"></p><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><ul><li><strong>用法</strong>: <code>java gitlet.Main rm [文件名]</code></li><li><strong>描述</strong>: 如果文件当前已暂存以添加，则取消暂存该文件。如果文件在当前提交中被跟踪，则将其标记为删除，并从工作目录中删除该文件（除非用户已经这样做，否则<em>不要</em>删除它）。</li><li><strong>运行时间</strong>: 相对于任何重要度量的常量时间运行。</li><li><strong>失败情况</strong>: 如果文件既没有被暂存也没有被当前提交跟踪，则打印错误消息<code>No reason to remove the file.</code>。</li><li><strong>危险性</strong>: 是的（尽管如果使用我们的实用方法，您只会损害您的存储库文件，而不是您目录中的所有其他文件。）</li><li><strong>我们的代码行数</strong>: ~20</li></ul><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><ul><li><strong>用法</strong>: <code>java gitlet.Main log</code></li><li><strong>描述</strong>: 从当前头提交开始，沿着提交树向后显示每个提交的信息，直到初始提交，跟随第一个父提交链接，忽略合并提交中找到的任何第二父提交（在常规Git中，这就是使用<code>git log --first-parent</code>得到的）。这组提交节点称为提交的<em>历史记录</em>。对于历史记录中的每个节点，应显示的信息是提交ID、提交时间和提交消息。以下是应遵循的<em>确切</em>格式示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">===</span><br><span class="line">commit a0da1ea5a15ab613bf9961fd86f010cf74c7ee48</span><br><span class="line">Date: Thu Nov 9 20:00:05 2017 -0800</span><br><span class="line">A commit message.</span><br><span class="line"></span><br><span class="line">===</span><br><span class="line">commit 3e8bf1d794ca2e9ef8a4007275acf3751c7170ff</span><br><span class="line">Date: Thu Nov 9 17:01:33 2017 -0800</span><br><span class="line">Another commit message.</span><br><span class="line"></span><br><span class="line">===</span><br><span class="line">commit e881c9575d180a215d1a636545b8fd9abfb1d2bb</span><br><span class="line">Date: Wed Dec 31 16:00:00 1969 -0800</span><br><span class="line">initial commit</span><br></pre></td></tr></table></figure><p>每个提交之前都有一个<code>===</code>，并且在其后有一个空行。与真实Git一样，每个条目显示提交对象的唯一SHA-1 ID。提交中显示的时间戳反映当前时区，而不是UTC；因此，初始提交的时间戳不是<code>Thursday, January 1st, 1970, 00:00:00</code>，而是相应的太平洋标准时间。您所在的时区可能因您的居住地而异，这没关系。</p><p>将最新的提交显示在顶部。顺便说一下，您会发现Java类<code>java.util.Date</code>和<code>java.util.Formatter</code>对于获取和格式化时间非常有用。查看它们，而不是尝试手动构造它们！</p><p>当然，SHA1标识符将是不同的，因此不要担心这些。我们的测试将确保您有一些“看起来像”SHA1标识符（有关测试部分的更多信息，请参见下文）。</p><p>对于合并提交（具有两个父提交），请在第一个父提交的下方添加一行，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">===</span><br><span class="line">commit 3e8bf1d794ca2e9ef8a4007275acf3751c7170ff</span><br><span class="line">Merge: 4975af1 2c1ead1</span><br><span class="line">Date: Sat Nov 11 12:30:00 2017 -0800</span><br><span class="line">Merged development into master.</span><br></pre></td></tr></table></figure><p>“Merge:”后面的两个十六进制数字由第一个和第二个父提交的提交ID的前七位数字组成，顺序如上所述。第一个父提交是合并时所在的分支；第二个是合并进来的分支。这与常规Git相同。</p><ul><li><strong>运行时间</strong>: 应与头部历史中节点数量的线性有关。</li><li><strong>失败情况</strong>: 无</li><li><strong>危险性</strong>: 否</li><li><strong>我们的代码行数</strong>: ~20</li></ul><p>这是特定提交的历史记录图片。如果当前分支的头指针恰好指向该提交，日志将打印有关圈中提交的信息：</p><p><img src="/2024/03/04/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-6-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-proj2/history.png" alt="History"></p><p>该历史记录忽略了其他分支和未来。既然我们已经介绍了历史记录的概念，让我们进一步完善我们之前关于提交树是不可变的说法。它的不可变性确切地体现在<em>具有特定ID的提交的历史记录可能永远不会改变</em>。如果您将提交树视为不可变的历史记录集合，那么我们实际上是在说每个历史记录都是不可变的。</p><h3 id="global-log"><a href="#global-log" class="headerlink" title="global-log"></a>global-log</h3><ul><li><strong>用法</strong>: <code>java gitlet.Main global-log</code></li><li><strong>描述</strong>: 类似于日志，但显示有关已经进行的所有提交的信息。提交的顺序并不重要。提示：在<code>gitlet.Utils</code>中有一个有用的方法，可以帮助您遍历目录中的文件。</li><li><strong>运行时间</strong>: 相对于已经进行的提交数量的线性时间。</li><li><strong>失败情况</strong>: 无</li><li><strong>危险性</strong>: 否</li><li><strong>我们的代码行数</strong>: ~10</li></ul><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><ul><li><strong>用法</strong>: <code>java gitlet.Main find [提交消息]</code></li><li><strong>描述</strong>: 打印出具有给定提交消息的所有提交的ID，每行一个。如果有多个这样的提交，它会将ID分别打印在不同的行上。提交消息是一个单独的操作数；要指示多个单词的消息，请将操作数放在引号中，如下所示的<code>commit</code>命令。提示：此命令的提示与<code>global-log</code>的提示相同。</li><li><strong>运行时间</strong>: 相对于提交数量的线性时间。</li><li><strong>失败情况</strong>: 如果不存在这样的提交，则打印错误消息<code>Found no commit with that message.</code>。</li><li><strong>危险性</strong>: 否</li><li><strong>与真实git的不同</strong>: 在真实的git中不存在。可以通过搜索日志的输出来达到类似的效果。</li><li><strong>我们的代码行数</strong>: ~15</li></ul><h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><ul><li><p><strong>用法</strong>: <code>java gitlet.Main status</code></p></li><li><p><strong>描述</strong>: 显示当前存在的分支，并用<code>*</code>标记当前分支。还显示哪些文件已经被标记为添加或删除。它应该遵循的<em>确切</em>格式示例如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">=== 分支 ===</span><br><span class="line">*master</span><br><span class="line">other-branch</span><br><span class="line">  </span><br><span class="line">=== 暂存的文件 ===</span><br><span class="line">wug.txt</span><br><span class="line">wug2.txt</span><br><span class="line">  </span><br><span class="line">=== 已删除的文件 ===</span><br><span class="line">goodbye.txt</span><br><span class="line">  </span><br><span class="line">=== 未暂存的修改 ===</span><br><span class="line">junk.txt (deleted)</span><br><span class="line">wug3.txt (modified)</span><br><span class="line">  </span><br><span class="line">=== 未跟踪的文件 ===</span><br><span class="line">random.stuff</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>最后两个部分（未暂存的修改和未跟踪的文件）是额外加分项，价值32分。可以将它们留空（只保留标题）。</p><p>每个部分之间有一个空行，并且整个状态以一个空行结束。条目应按字典顺序列出，使用Java字符串比较顺序（星号不计）。如果工作目录中的文件是“修改但未暂存”，则为以下情况之一：</p><ul><li>在当前提交中跟踪，在工作目录中已更改，但未暂存；或</li><li>已标记为添加，但内容与工作目录中的内容不同；或</li><li>已标记为添加，但在工作目录中已删除；或</li><li>未标记为删除，但在当前提交中已跟踪并已从工作目录中删除。</li></ul><p>最后一类（“未跟踪的文件”）是指存在于工作目录中但既未标记为添加也未跟踪的文件。这包括已标记为删除但在Gitlet不知情的情况下重新创建的文件。忽略可能已引入的任何子目录，因为Gitlet不处理它们。</p></li><li><p><strong>运行时间</strong>: 确保这仅取决于工作目录中的数据量加上已标记为添加或删除的文件的数量加上分支的数量。</p></li><li><p><strong>失败情况</strong>: 无</p></li><li><p><strong>危险性</strong>: 否</p></li><li><p><strong>我们的代码行数</strong>: ~45</p></li><li><p><a href="https://forms.gle/LSgBK5RAdRwhAqKK8"><strong>概念测验（不涉及分支）</strong></a></p></li><li><p><a href="https://forms.gle/RHUiRkSrtgysC6En8"><strong>概念测验（涉及分支）</strong></a></p></li></ul><h3 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h3><p>检出是一种通用命令，可以根据其参数执行几种不同的操作。下面有3种可能的用法。在每个部分下面，您会看到3个编号的点。每个对应于相应的检出用法。</p><ul><li><strong>用法</strong>：<ol><li><code>java gitlet.Main checkout -- [文件名]</code></li><li><code>java gitlet.Main checkout [提交ID] -- [文件名]</code></li><li><code>java gitlet.Main checkout [分支名]</code></li></ol></li><li><strong>描述</strong>：<ol><li>获取文件在当前分支的最新提交中的版本，并将其放入工作目录中，如果已经存在同名文件，则覆盖它。新版本的文件不会被暂存。</li><li>获取文件在具有给定ID的提交中的版本，并将其放入工作目录中，如果已经存在同名文件，则覆盖它。新版本的文件不会被暂存。</li><li>获取给定分支头部的提交中的所有文件，并将它们放入工作目录中，如果已经存在同名文件，则覆盖它们。此外，在执行此命令结束时，给定分支将被视为当前分支（HEAD）。任何在当前分支中被跟踪但在检出分支中不存在的文件将被删除。暂存区将被清空，除非检出的分支是当前分支（参见<strong>失败情况</strong>下面）。</li></ol></li><li><strong>运行时间</strong>：<ol><li>相对于正在检出的文件的大小，应该是线性的。</li><li>相对于提交快照中文件的总大小，应该是线性的。对于涉及提交数量的任何度量，应该是常数。对于分支数量的任何度量，应该是常数。</li></ol></li><li><strong>失败情况</strong>：<ol><li>如果文件在上一个提交中不存在，则中止操作，并打印错误消息<code>File does not exist in that commit.</code> 不要更改当前工作目录。</li><li>如果不存在具有给定ID的提交，则打印<code>No commit with that id exists.</code>。否则，如果文件在给定提交中不存在，则打印与失败情况1相同的消息。不要更改当前工作目录。</li><li>如果不存在具有该名称的分支，则打印<code>No such branch exists.</code> 如果该分支是当前分支，则打印<code>No need to checkout the current branch.</code> 如果当前分支中有一个工作文件在检出时将被覆盖，则打印<code>There is an untracked file in the way; delete it, or add and commit it first.</code> 并退出；在执行任何其他操作之前执行此检查。不要更改当前工作目录。</li></ol></li><li><strong>与真实git的不同</strong>：真实的git不会清除暂存区，并将检出的文件暂存。此外，它不会执行可能覆盖或撤消您已暂存的更改（添加或删除）的检出操作。</li></ul><p>一个<code>[提交ID]</code>就像前面描述的，是一个十六进制数。真实Git的一个方便的特性是，可以使用唯一前缀来缩写提交。例如，可以将</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a0da1ea5a15ab613bf9961fd86f010cf74c7ee48</span><br></pre></td></tr></table></figure><p>缩写为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a0da1e</span><br></pre></td></tr></table></figure><p>在（可能）没有其他以相同六个数字开头的SHA-1标识符的对象存在的情况下。您应该安排相同的事情发生在包含少于40个字符的提交ID中。不幸的是，使用缩短的ID可能会导致查找对象的速度变慢，如果实现得不好（使查找文件的时间与对象数量成线性关系），因此我们不会担心使用缩短的ID的命令的时间。但我们建议您在<code>.git</code>目录（特别是<code>.git/objects</code>）中查看它是如何加速搜索的。您可能会发现一个熟悉的数据结构实现在文件系统中而不是指针。</p><p>只有版本3（完整分支的检出）会修改暂存区：</p><ul><li><strong>危险性?</strong>: Yes!</li><li><strong>行数</strong>:<ul><li>~15</li><li>~5</li><li>~15</li></ul></li><li><a href="https://forms.gle/mfHLnrU9VX349jnr7"><strong>Conceptual Quiz (without branching)</strong></a></li><li><a href="https://forms.gle/tbZuqDz7x3u41JhM6"><strong>Conceptual Quiz (with branching)</strong></a></li></ul><h3 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h3><ul><li><strong>用法</strong>: <code>java gitlet.Main branch [分支名称]</code></li><li><strong>描述</strong>: 创建一个具有给定名称的新分支，并将其指向当前的头部提交。分支只是对提交节点的引用（一个SHA-1标识符）的名称。该命令不会立即切换到新创建的分支（就像真实的Git一样）。在调用分支之前，您的代码应该使用一个名为“master”的默认分支运行。</li><li><strong>运行时间</strong>: 相对于任何重要度量，应该是常量。</li><li><strong>失败情况</strong>: 如果已经存在具有给定名称的分支，则打印错误消息<code>A branch with that name already exists.</code>。</li><li><strong>危险性</strong>: 否</li><li><strong>我们的行数</strong>: ~10</li></ul><p>好的，让我们详细看看分支命令的作用。假设我们的状态如下所示：</p><p><img src="/2024/03/04/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-6-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-proj2/simple_history.png" alt="简单的历史"></p><p>现在我们调用 <code>java gitlet.Main branch cool-beans</code>。然后我们得到这个：</p><p><img src="/2024/03/04/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-6-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-proj2/just_called_branch.png" alt="刚刚调用分支"></p><p>嗯… 没什么大不了的。让我们切换到名为 <code>java gitlet.Main checkout cool-beans</code> 的分支：</p><p><img src="/2024/03/04/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-6-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-proj2/just_switched_branch.png" alt="刚刚切换的分支"></p><p>又什么都没发生？！好吧，假设我们现在进行一次提交。修改一些文件，然后 <code>java gitlet.Main add...</code> 然后 <code>java gitlet.Main commit...</code></p><p><img src="/2024/03/04/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-6-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-proj2/commit_on_branch.png" alt="分支上的提交"></p><p>我被告知会有分支。但我看到的只是一条直线。发生了什么？也许我应该回到我的另一个分支 <code>java gitlet.Main checkout master</code>：</p><p><img src="/2024/03/04/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-6-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-proj2/checkout_master.png" alt="切换到master"></p><p>现在我做一个提交…</p><p><img src="/2024/03/04/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-6-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-proj2/branched.png" alt="分支"></p><p>呼！这就是分支的整个理念。你明白发生了什么了吗？创建分支的所有操作只是为我们提供了一个新的指针。在任何给定时间，这些指针中的一个被认为是当前活动的指针，也称为HEAD指针（用 * 标记）。我们可以使用 <code>checkout [分支名称]</code> 切换当前活动的HEAD指针。每当我们提交时，这意味着我们将一个子提交添加到当前活动的HEAD提交中，即使已经存在一个子提交。这自然地创建了分支行为，因为现在一个提交可以有多个子提交。</p><p>可以在<a href="https://youtu.be/desB3AS6aZg">这里</a>找到关于分支的视频示例和概述。</p><p><em>确保</em>您的<code>branch</code>、<code>checkout</code>和<code>commit</code>的行为与我们上面描述的一致。这是Gitlet的核心功能，许多其他命令都将依赖于它。如果任何核心功能出现问题，我们的自动化测试中的很多测试将无法正常工作！</p><h3 id="rm-branch"><a href="#rm-branch" class="headerlink" title="rm-branch"></a>rm-branch</h3><ul><li><strong>Usage</strong>: <code>java gitlet.Main rm-branch [branch name]</code></li><li><strong>Description</strong>: 删除具有给定名称的分支。这只是删除与分支关联的指针；不意味着删除在该分支下创建的所有提交，或者类似的操作。</li><li><strong>运行时间</strong>: 相对于任何重要度量，应该是常量。</li><li><strong>失败情况</strong>: 如果具有给定名称的分支不存在，则中止。打印错误消息 <code>A branch with that name does not exist.</code> 如果尝试删除当前正在使用的分支，则中止，打印错误消息 <code>Cannot remove the current branch.</code>。</li><li><strong>危险性</strong>: 否</li><li><strong>我们的行数</strong>: ~15</li></ul><h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><ul><li><p><strong>Usage</strong>: <code>java gitlet.Main reset [commit id]</code></p></li><li><p><strong>Description</strong>: 检出给定提交跟踪的所有文件。删除不在该提交中的跟踪文件。还将当前分支的头指针移动到该提交节点。有关在使用 reset 后头指针的变化示例，请参见简介。<code>[commit id]</code> 可以像 <code>checkout</code> 一样缩写。暂存区被清除。该命令实质上是将当前分支头切换到任意提交的 <code>checkout</code> 命令。</p></li><li><p><strong>运行时间</strong>: 相对于给定提交快照中跟踪的文件总大小，应该是线性的。相对于涉及提交数量的任何度量，应该是常量的。</p></li><li><p>失败情况</p><p>: 如果不存在具有给定 id 的提交，则打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No commit with that id exists.</span><br></pre></td></tr></table></figure><p>如果当前分支中存在一个未跟踪的工作文件，并且将被重置覆盖，则打印</p><p><code>There is an untracked file in the way; delete it, or add and commit it first.</code></p><p>并退出；在执行任何其他操作之前执行此检查。</p></li><li><p><strong>危险性</strong>: 是的！</p></li><li><p><strong>与真实 git 的差异</strong>: 此命令最接近使用 <code>--hard</code> 选项，如 <code>git reset --hard [commit hash]</code>。</p></li><li><p><strong>我们的行数</strong>: ~10 我们是如何得到如此小的行数的？请回想一下，你应该重用你的代码 :)</p></li></ul><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><ul><li><p><strong>Usage</strong>: <code>java gitlet.Main merge [branch name]</code></p></li><li><p><strong>Description</strong>: 将给定分支中的文件合并到当前分支中。这个方法有点复杂，所以这里有一个更详细的描述：</p><ul><li>首先考虑当前分支和给定分支的<strong>分割点</strong>。例如，如果 <code>master</code> 是当前分支，<code>branch</code> 是给定分支：<img src="/2024/03/04/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-6-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-proj2/split_point.png" alt="Split point"> 分割点是当前分支和给定分支头部的 <em>最新公共祖先</em>：- 一个 <em>公共祖先</em> 是一个从两个分支头部到达的路径（有0个或更多个父指针）。- 一个 <em>最新</em> 公共祖先是不是其他公共祖先的祖先的公共祖先。例如，尽管上图中最左边的提交是 <code>master</code> 和 <code>branch</code> 的公共祖先，但它也是右侧紧邻的提交的祖先，因此它不是最新的公共祖先。如果分割点 <em>是</em> 与给定分支相同的提交，则我们不执行任何操作；合并已完成，并以消息 <code>Given branch is an ancestor of the current branch.</code> 结束。如果分割点是当前分支，则效果是检出给定分支，并在打印消息 <code>Current branch fast-forwarded.</code> 后结束。否则，我们继续执行下面的步骤。</li></ul><ol><li>自分割点以来在给定分支中被 <em>修改</em>，但在当前分支中自分割点以来未被修改的任何文件都应更改为给定分支中它们的版本（从给定分支前端的提交中检出）。然后，这些文件应自动进入暂存区。为了澄清，如果一个文件“在给定分支中自分割点以来被修改”，这意味着文件的版本如同在给定分支前端的提交中存在，内容与分割点处的文件版本不同。记住：blob 是内容可寻址的！</li><li>在当前分支中被修改但在给定分支自分割点以来未被修改的任何文件都应保持不变。</li><li>在当前分支和给定分支中以相同方式被修改的任何文件（即，这些文件现在都具有相同的内容或都被移除）都会被合并后保持不变。如果一个文件在当前分支和给定分支中都被移除，但是工作目录中存在同名文件，则该文件将被保持不变，并继续在合并中处于缺失状态（未被跟踪也未被暂存）。</li><li>在分割点处未出现但仅在当前分支中出现的任何文件都应保持不变。</li><li>在分割点处未出现但仅在给定分支中出现的任何文件都应被检出并暂存。</li><li>在分割点处存在但在当前分支中未被修改并且在给定分支中不存在的任何文件都应该被移除（并且未被跟踪）。</li><li>在分割点处存在但在给定分支中未被修改并且在当前分支中不存在的任何文件都应保持不存在。</li><li>在当前分支和给定分支中以不同方式被修改的任何文件都会<em>冲突</em>。“以不同方式被修改”可以意味着两者的内容都发生了变化且不同，或者一个文件的内容发生了变化而另一个文件被删除，或者文件在分割点处不存在，并且在给定分支和当前分支中具有不同的内容。在这种情况下，使用以下内容替换冲突文件的内容：</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">current branch 中文件的内容</span><br><span class="line">=======</span><br><span class="line">given branch 中文件的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>（用指定文件的内容替换“current branch 中文件的内容”和“given branch 中文件的内容”）。并暂存结果。在这里使用直接连接。在文件末尾没有换行符的情况下，你可能会得到类似这样的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">current branch 中文件的内容=======</span><br><span class="line">given branch 中文件的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>这没问题；那些因为不知道换行符和行分隔符的区别而产生非标准、病态文件的人应该得到他们所得到的。</p><p>一旦根据上述更新文件，并且分割点不是当前分支或给定分支，合并将自动提交，并使用日志消息 <code>Merged [given branch name] into [current branch name].</code>。然后，如果合并遇到冲突，打印消息 <code>Encountered a merge conflict.</code> 在终端上（而不是日志上）。合并提交与其他提交不同：它们记录了当前分支头部（称为<em>第一个父节点</em>）和传递给合并命令行的分支头部两者作为父节点。</p><p>  有关该命令的视频演示可以在<a href="https://www.youtube.com/watch?v=JR3OYCMv9b4&t=929s">此处</a>找到。</p><ul><li><p><strong>运行时间</strong>: O(NlgN+D)，其中 N 是两个分支的祖先提交的总数，D 是这些提交下所有文件中的数据总量。</p></li><li><p><strong>失败情况</strong>: 如果存在已暂存的添加或删除，打印错误消息 <code>You have uncommitted changes.</code> 并退出。如果不存在具有给定名称的分支，打印错误消息 <code>A branch with that name does not exist.</code> 如果尝试合并自身的分支，打印错误消息 <code>Cannot merge a branch with itself.</code> 如果合并会生成错误，因为所做的提交中没有更改</p></li></ul><h2 id="骨架"><a href="#骨架" class="headerlink" title="骨架"></a>骨架</h2><p>骨架相当简陋，大部分类都是空的。我们提供了有用的 javadoc 注释，暗示了每个文件中可能想要包含的内容。<strong>您应该遵循类似于 Capers 的方法</strong>，其中您的 <code>Main</code> 类本身不做太多工作，而是根据 <code>args</code> 简单地调用其他方法。您完全可以删除其他类或添加自己的类，<strong>但是 <code>Main</code> 类应该保留</strong>，否则我们的测试将无法找到您的代码。</p><p>如果您不确定从何处开始，我们建议查看<a href="https://sp21.datastructur.es/materials/lab/lab6/lab6">Lab 6: Canine Capers</a>。</p><h2 id="设计文档"><a href="#设计文档" class="headerlink" title="设计文档"></a>设计文档</h2><p>由于这次您不是从一个实质性的骨架中工作，<strong>我们要求每个人提交一个描述其实现策略的设计文档</strong>。这不是评分标准，但在我们的办公时间或 Gitbug 上提供帮助之前，您必须有一个最新和完整的设计文档。如果您没有或者它不是最新的&#x2F;不完整的，我们将无法帮助您。这是为了我们双方考虑的：通过编写设计文档，您已经为如何解决任务制定了一条路线图。如果您需要帮助创建设计文档，我们可以帮忙：）这里有<a href="https://sp21.datastructur.es/materials/proj/proj2/design.html">一些指导方针</a>，以及来自 Capers 实验的<a href="https://sp21.datastructur.es/materials/proj/proj2/capers-example">示例</a>。</p><h2 id="关于项目的杂项事项"><a href="#关于项目的杂项事项" class="headerlink" title="关于项目的杂项事项"></a>关于项目的杂项事项</h2><p>哇！刚才那些命令真是够多的。但别担心，不是所有的命令都同样困难。对于每个命令，你可以看到我们在每个部分所用的大致行数（这仅计算与该命令相关的代码 - 不会重复计算在多个命令中重复使用的代码）。你不必担心与我们的解决方案完全匹配，但希望它能让你了解每个命令相对消耗的时间。合并是一个比其他命令更长的命令，所以不要把它留到最后一刻！</p><p>这是一个雄心勃勃的项目，如果你感到不知从何处开始，也不足为奇。因此，请随意比平常更密切地与他人合作，但需要注意以下几点：</p><ul><li>在你的 <code>gitlet/Main.java</code> 文件的开头附近的注释中承认所有合作者。</li><li>不要分享具体的代码；所有合作者必须生成自己的算法版本，以便我们可以看到它们的不同。</li></ul><p>Ed的讨论串通常在Gitlet中变得非常长，但它们充满了关于特定提交方法的非常好的对话和讨论。在这个项目中，你应该利用课程规模的大小，看看是否可以找到与你在讨论串上有类似问题的人。你的问题很有可能不是那么独特，以至于没有其他人遇到过（除非它是与你的设计相关的错误，在这种情况下，你应该提交一个 Gitbug）。</p><p>到目前为止，这个规范已经给了你足够的信息来开始项目了。但为了帮助你更多一点，还有一些你应该知道的事情：</p><h2 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h2><p>该项目需要读写文件。为了执行这些操作，你可能会发现 <code>java.io.File</code> 和 <code>java.nio.file.Files</code> 类有所帮助。实际上，你可能会发现 <code>java.io</code> 和 <code>java.nio</code> 包中的各种东西都很有用。确保阅读我们为你编写的 <code>gitlet.Utils</code> 包中的其他内容。如果你通过所有这些内容进行一些挖掘，你可能会找到一些可以使该项目的 I&#x2F;O 部分<em>大大</em>简化的方法！一个警告：如果你发现自己在使用读取器、写入器、扫描器或流，那么你正在使事情变得比必要的更复杂。</p><h2 id="序列化细节"><a href="#序列化细节" class="headerlink" title="序列化细节"></a>序列化细节</h2><p>如果你考虑一下 Gitlet，你会注意到每次运行程序时只能运行一个命令。为了成功完成你的版本控制系统，你需要记住跨多个程序运行的 commit 树。这意味着你不仅需要设计一组在执行期间代表内部 Gitlet 结构的类，还需要一种类似的表示方式作为你的 <code>.gitlet</code> 目录中的文件，这些文件将跨多次程序运行。</p><p>正如前面所示，这样做的方便方法是对你将永久存储在文件中的运行时对象进行序列化。Java 运行时会完成所有工作，找出需要转换为字节的字段以及如何进行转换。</p><p>你已经在 lab6 中做过序列化了，所以我们不会在这里重复信息。如果你对序列化的某些方面仍然感到困惑，请重新阅读 lab6 规范的相关部分，并检查一下你的代码。</p><p>然而，有一个令人讨厌的细微之处需要注意：Java 序列化遵循指针。也就是说，不仅传递给 <code>writeObject</code> 的对象被序列化和写入，它指向的任何对象也被序列化和写入。例如，如果你的提交的内部表示将父提交表示为指向其他提交对象的指针，那么写入分支的头部将会写入整个提交子图中的所有提交（和 blob）到一个文件中，这通常不是你想要的。为了避免这种情况，不要在你的运行时对象中使用 Java 指针来引用提交和 blob，而是使用 SHA-1 哈希字符串。在这些字符串和运行时对象之间保持一个运行时映射。你在 Gitlet 运行时创建并填充这个映射，但永远不会将其读取或写入文件中。</p><p>为了避免这种情况，不要在你的运行时对象中使用 Java 指针来引用提交和 blob，而是使用 SHA-1 哈希字符串。在这些字符串和运行时对象之间保持一个运行时映射。你在 Gitlet 运行时创建并填充这个映射，但永远不会将其读取或写入文件中。</p><p>你可能会发现有一些便利，对提交进行多余的指针，以避免每次查找时所需的麻烦和执行时间。你可以将这样的指针存储在你的对象中，同时避免将它们写出去，方法是声明它们为“瞬态”，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient MyCommitType parent1;</span><br></pre></td></tr></table></figure><p>这样的字段将不会被序列化，并且在反序列化时，将被设置为它们的默认值（对于引用类型为 null）。当读取包含瞬态字段的对象时，你必须小心地将瞬态字段设置为适当的值</p><p>。</p><p>不幸的是，用文本编辑器查看你的程序产生的序列化文件（用于调试目的）会非常没有启示性；内容以 Java 的私有序列化编码进行编码。因此，我们提供了一个简单的调试工具程序，你可能会觉得有用：<code>gitlet.DumpObj</code>。详细信息请参阅 <code>gitlet/DumpObj.java</code> 的 Javadoc 注释。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>你应该阅读整个这个部分，尽管 <a href="https://www.youtube.com/watch?v=uMYpuQuHGu0&t=752s">视频</a> 也是可用的，方便你查看。</p><p>像往常一样，测试是项目的一部分。确保为每个命令提供自己的集成测试，覆盖所有指定的功能。此外，随意添加任何单元测试。我们没有提供任何单元测试，因为单元测试高度依赖于你的实现。</p><p>我们提供了一个测试程序，可以相对容易地编写集成测试：<code>testing/tester.py</code>。这个程序会解释带有 <code>.in</code> 扩展名的测试文件。你可以使用以下命令运行所有测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make check</span><br></pre></td></tr></table></figure><p>如果你想要有关失败测试的其他信息，比如你的程序输出了什么，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make check TESTER_FLAGS=&quot;--verbose&quot;</span><br></pre></td></tr></table></figure><p>如果你想要运行单个测试，在 <code>testing</code> 子目录中运行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 tester.py --verbose FILE.in ...</span><br></pre></td></tr></table></figure><p>其中 <code>FILE.in ...</code> 是你想要检查的特定 <code>.in</code> 文件列表。</p><p><strong>小心运行此命令</strong>，因为它不会重新编译你的代码。每次运行 <code>python</code> 命令之前，你都必须先编译你的代码（通过 <code>make</code>）。</p><p>命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 tester.py --verbose --keep FILE.in</span><br></pre></td></tr></table></figure><p>将在测试脚本检测到错误的地方保留 <code>tester.py</code> 产生的目录，以便你可以检查它的文件。如果你的测试没有出错，那么该目录仍然会保留下来，其中包含所有东西的最终内容。</p><p>实际上，测试程序实现了一个非常简单的<em>特定领域语言（DSL）</em>，其中包含以下命令：</p><ul><li>设置或从测试目录中删除文件；</li><li>运行 <code>java gitlet.Main</code>；</li><li>检查 Gitlet 的输出与特定输出或描述可能输出的正则表达式；</li><li>检查文件的存在、不存在和内容。运行命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 testing/tester.py</span><br></pre></td></tr></table></figure><p>（没有操作数，如所示）将提供一条消息，记录此语言的内容。我们在 <code>testing/samples</code> 目录中提供了一些示例。不要将你自己的测试放在该子目录中；将它们放在与我们的测试不同的地方，这样你就不会混淆我们的测试和你的测试（后者可能有错误！）。将所有你的 <code>.in</code> 文件放在 <code>testing</code> 目录下的另一个名为 <code>student_tests</code> 的文件夹中。在骨架中，该文件夹为空。</p><p>我们已经在 Makefile 中添加了一些内容，以调整人们的设置之间的差异。如果你的系统调用 Python 3 的命令只是 <code>python</code>，你仍然可以使用我们的 Makefile，方法是使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make PYTHON=python check</span><br></pre></td></tr></table></figure><p>你可以使用额外的标志向 <code>tester.py</code> 传递额外的标志，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make TESTER_FLAGS=&quot;--keep --verbose&quot;</span><br></pre></td></tr></table></figure><h2 id="对员工解决方案进行测试"><a href="#对员工解决方案进行测试" class="headerlink" title="对员工解决方案进行测试"></a>对员工解决方案进行测试</h2><p>截至 2 月 28 日星期日，现在你可以使用员工解决方案来验证你对命令的理解以及验证你自己的测试！<a href="https://sp21.datastructur.es/materials/guides/staff-gitlet">这里</a>有一个指南。</p><h2 id="理解集成测试"><a href="#理解集成测试" class="headerlink" title="理解集成测试"></a>理解集成测试</h2><p>在 Gitbugs 上向我们请求帮助，或者在办公时间来接受帮助时，我们将首先要求你提供一个失败的测试，因此你学会在这个项目中编写测试非常重要。我们已经做了很多工作，使这一过程尽可能轻松，请花时间阅读本节，以便理解提供的测试并自己编写良好的测试。</p><p>集成测试的格式与 Capers 的测试类似。如果你不知道 Capers 的集成测试（即 <code>.in</code> 文件）是如何工作的，请先阅读 <a href="https://sp21.datastructur.es/materials/lab/lab6/lab6">capers 规范</a> 中的该部分。</p><p>提供的测试远非全面，你肯定需要编写自己的测试才能获得项目的满分。为了编写测试，让我们首先了解一下这一切是如何工作的。</p><p>这是 <code>testing</code> 目录的结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── student_tests                    &lt;==== 你的 .in 文件将放在这里</span><br><span class="line">├── samples                          &lt;==== 我们提供的示例 .in 文件</span><br><span class="line">│   ├── test01-init.in               &lt;==== 一个示例测试</span><br><span class="line">│   ├── test02-basic-checkout.in</span><br><span class="line">│   ├── test03-basic-log.in</span><br><span class="line">│   ├── test04-prev-checkout.in</span><br><span class="line">│   └── definitions.inc</span><br><span class="line">├── src                              &lt;==== 包含用于测试的文件</span><br><span class="line">│   ├── notwug.txt</span><br><span class="line">│   └── wug.txt</span><br><span class="line">├── runner.py                        &lt;==== 用于帮助调试你的程序的脚本</span><br><span class="line">└── tester.py                        &lt;==== 测试你的程序的脚本</span><br></pre></td></tr></table></figure><p>就像 Capers 一样，这些测试通过在 <code>testing</code> 目录内创建临时目录并运行 <code>.in</code> 文件中指定的命令来工作。如果使用 <code>--keep</code> 标志，则该临时目录将在测试完成后保留，以便你可以检查它。</p><p>与 Capers 不同，我们需要处理工作目录中文件的 <em>内容</em>。因此，在这个 <code>testing</code> 文件夹中，我们有一个名为 <code>src</code> 的额外文件夹。该目录存储了许多预先填充的 <code>.txt</code> 文件，其中包含我们需要的特定内容。稍后我们会回到这一点，但现在只需知道 <code>src</code> 存储了实际的文件内容。<code>samples</code> 包含示例测试的 <code>.in</code> 文件（即检查点测试）。当你创建自己的测试时，应将它们添加到最初为空的 <code>student_tests</code> 文件夹中。</p><p><code>.in</code> 文件在 Gitlet 中有更多的功能。下面是来自 <code>tester.py</code> 文件的说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># ...  一个注释，没有任何效果。</span><br><span class="line">I FILE 包含。用 FILE 的内容替换此语句，</span><br><span class="line">      相对于包含 .in 文件的目录进行解释。</span><br><span class="line">C DIR  创建一个子目录 DIR（如有必要），并切换到此目录下，</span><br><span class="line">      该目录位于此测试的主目录下。如果 DIR 不存在，则返回</span><br><span class="line">      默认目录。此命令主要用于设置远程存储库。</span><br><span class="line">T N    设置后续测试中 gitlet 命令的超时时间为 N</span><br><span class="line">      秒。</span><br><span class="line">+ NAME F</span><br><span class="line">      将 src/F 的内容复制到名为 NAME 的文件中。</span><br><span class="line">- NAME</span><br><span class="line">      删除名为 NAME 的文件。</span><br><span class="line">&gt; COMMAND OPERANDS</span><br><span class="line">LINE1</span><br><span class="line">LINE2</span><br><span class="line">...</span><br><span class="line">&lt;&lt;&lt;</span><br><span class="line">      使用 COMMAND 参数作为参数运行 gitlet.Main。将其输出与</span><br><span class="line">      LINE1、LINE2 等进行比较，如果存在足够的差异则报告</span><br><span class="line">      错误。&lt;&lt;&lt; 分隔符后面可以跟一个星号 (*)，</span><br><span class="line">      这样，前面的行将被视为 Python 正则表达式并相应匹配。</span><br><span class="line">      假定包含 gitlet.Main 程序的目录或 JAR 文件在</span><br><span class="line">      --progdir 指定的目录中（默认为 ..）。</span><br><span class="line">= NAME F</span><br><span class="line">      检查名为 NAME 的文件是否与 src/F 相同，如果不同则报告</span><br><span class="line">      错误。</span><br><span class="line">* NAME</span><br><span class="line">      检查名为 NAME 的文件是否不存在，如果存在则报告</span><br><span class="line">      错误。</span><br><span class="line">E NAME</span><br><span class="line">      检查文件或目录 NAME 是否存在，如果不存在则报告</span><br><span class="line">      错误。</span><br><span class="line">D VAR &quot;VALUE&quot;</span><br><span class="line">      将变量 VAR 定义为字面值 VALUE。VALUE 被视为原始 Python 字符串</span><br><span class="line">      （例如 r&quot;VALUE&quot;）。首先对 VALUE 进行替换。</span><br></pre></td></tr></table></figure><p>不必担心上述说明中提到的 Python 正则表达式的东西：我们将向你展示它很简单，甚至会通过一个例子演示如何使用它。</p><p>让我们走一遍测试，看看从头到尾发生了什么。让我们检查 <code>test02-basic-checkout.in</code>。</p><h4 id="示例测试"><a href="#示例测试" class="headerlink" title="示例测试"></a>示例测试</h4><p>当我们第一次运行此测试时，将创建一个最初为空的临时目录。我们的目录结构现在是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── student_tests</span><br><span class="line">├── samples</span><br><span class="line">│   ├── test01-init.in</span><br><span class="line">│   ├── test02-basic-checkout.in</span><br><span class="line">│   ├── test03-basic-log.in</span><br><span class="line">│   ├── test04-prev-checkout.in</span><br><span class="line">│   └── definitions.inc</span><br><span class="line">├── src</span><br><span class="line">│   ├── notwug.txt</span><br><span class="line">│   └── wug.txt</span><br><span class="line">├── test02-basic-checkout_0          &lt;==== 刚创建</span><br><span class="line">├── runner.py</span><br><span class="line">└── tester.py</span><br></pre></td></tr></table></figure><p>这个临时目录是用于此测试执行的 Gitlet 仓库，因此我们将在那里添加东西并运行所有的 Gitlet 命令。如果第二次运行测试而不删除目录，则会创建一个名为 <code>test02-basic-checkout_1</code> 的新目录，依此类推。每次测试的执行都使用它</p><p>自己的目录，因此不必担心测试之间的干扰。</p><p>测试的第一行是一个注释，所以我们忽略它。</p><p>接下来的部分是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; init</span><br><span class="line">&lt;&lt;&lt;</span><br></pre></td></tr></table></figure><p>这不应该有任何输出，因为我们可以通过此部分的第一行与带有 <code>&gt;</code> 的行和带有 <code>&lt;&lt;&lt;</code> 的行之间没有文本来判断。但是，正如我们所知道的，这应该创建一个 <code>.gitlet</code> 文件夹。因此，我们的目录结构现在是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── student_tests</span><br><span class="line">├── samples</span><br><span class="line">│   ├── test01-init.in</span><br><span class="line">│   ├── test02-basic-checkout.in</span><br><span class="line">│   ├── test03-basic-log.in</span><br><span class="line">│   ├── test04-prev-checkout.in</span><br><span class="line">│   └── definitions.inc</span><br><span class="line">├── src</span><br><span class="line">│   ├── notwug.txt</span><br><span class="line">│   └── wug.txt</span><br><span class="line">├── test02-basic-checkout_0</span><br><span class="line">│   └── .gitlet                     &lt;==== 刚创建</span><br><span class="line">├── runner.py</span><br><span class="line">└── tester.py</span><br></pre></td></tr></table></figure><p>接下来的部分是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ wug.txt wug.txt</span><br></pre></td></tr></table></figure><p>这一行使用 <code>+</code> 命令。它将右侧的文件从 <code>src</code> 目录复制其内容到临时目录中的左侧文件（如果不存在，则创建）。它们的名字相同，但由于它们位于不同的目录中，这并不重要。在执行此命令后，我们的目录结构现在是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── student_tests</span><br><span class="line">├── samples</span><br><span class="line">│   ├── test01-init.in</span><br><span class="line">│   ├── test02-basic-checkout.in</span><br><span class="line">│   ├── test03-basic-log.in</span><br><span class="line">│   ├── test04-prev-checkout.in</span><br><span class="line">│   └── definitions.inc</span><br><span class="line">├── src</span><br><span class="line">│   ├── notwug.txt</span><br><span class="line">│   └── wug.txt</span><br><span class="line">├── test02-basic-checkout_0</span><br><span class="line">│   ├── .gitlet</span><br><span class="line">│   └── wug.txt                     &lt;==== 刚创建</span><br><span class="line">├── runner.py</span><br><span class="line">└── tester.py</span><br></pre></td></tr></table></figure><p>现在我们看到了 <code>src</code> 目录的用途：它包含测试可以使用的文件内容，以便设置 Gitlet 仓库。如果你想要向文件添加特殊内容，你应该将这些内容添加到 <code>src</code> 中的一个命名合适的文件中，然后使用与此处相同的 <code>+</code> 命令。很容易混淆参数的顺序，所以确保右侧引用 <code>src</code> 目录中的文件，而左侧引用临时目录中的文件。</p><p>接下来的部分是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; add wug.txt</span><br><span class="line">&lt;&lt;&lt;</span><br></pre></td></tr></table></figure><p>正如你所看到的，这应该没有任何输出。<code>wug.txt</code> 文件现在在临时目录中准备添加。此时，你的目录结构可能会在 <code>.gitlet</code> 目录内部发生变化，因为你需要以某种方式持久保存 <code>wug.txt</code> 准备添加的事实。</p><p>接下来的部分是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; commit &quot;added wug&quot;</span><br><span class="line">&lt;&lt;&lt;</span><br></pre></td></tr></table></figure><p>同样，没有输出，你的目录结构可能会在 <code>.gitlet</code> 中发生变化。</p><p>接下来的部分是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ wug.txt notwug.txt</span><br></pre></td></tr></table></figure><p>由于 <code>wug.txt</code> 已经存在于我们的临时目录中，其内容将更改为 <code>src/notwug.txt</code> 中的任何内容。</p><p>接下来是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; checkout -- wug.txt</span><br><span class="line">&lt;&lt;&lt;</span><br></pre></td></tr></table></figure><p>同样，没有输出。然而，它应该将我们临时目录中的 <code>wug.txt</code> 的内容更改回原始内容，即 <code>src/wug.txt</code> 的内容。下一个命令是断言：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">= wug.txt wug.txt</span><br></pre></td></tr></table></figure><p>这是一个断言：如果左侧的文件（再次强调，这是在临时目录中）与右侧的文件（来自 <code>src</code> 目录）的内容不完全相同，则测试脚本将报错并说你的文件内容不正确。</p><p>还有两种其他可用于断言的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E NAME</span><br></pre></td></tr></table></figure><p>将断言临时目录中存在一个名为 <code>NAME</code> 的文件&#x2F;文件夹。它不检查内容，只检查它是否存在。如果不存在具有该名称的文件&#x2F;文件夹，则测试将失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* NAME</span><br></pre></td></tr></table></figure><p>断言临时目录中不存在名为 <code>NAME</code> 的文件&#x2F;文件夹。如果存在具有该名称的文件&#x2F;文件夹，则测试将失败。</p><p>这恰好是测试的最后一行，所以测试结束了。如果提供了 <code>--keep</code> 标志，则临时目录将保留，否则将被删除。如果你怀疑你的 <code>.gitlet</code> 目录没有被正确设置或者存在一些持久性问题，你可能会希望保留它。</p><h4 id="测试准备"><a href="#测试准备" class="headerlink" title="测试准备"></a>测试准备</h4><p>正如你很快会发现的，测试一个特定命令可能需要很多重复的设置：例如，如果你正在测试 <code>checkout</code> 命令，你需要：</p><ol><li>初始化一个 Gitlet 仓库</li><li>使用某个版本（v1）在提交中创建一个文件</li><li>使用该文件的另一个版本（v2）在另一个提交中创建一个文件</li><li>将该文件检出到 v1</li></ol><p>如果你想测试在第二个提交中未跟踪但在第一个提交中已跟踪的文件，可能还需要更多的设置。</p><p>因此，你可以通过在一个文件中添加所有这些设置，并使用 <code>I</code> 命令来节省时间。假设我们在这里这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 初始化，添加并提交一个文件。</span><br><span class="line">&gt; init</span><br><span class="line">&lt;&lt;&lt;</span><br><span class="line">+ a.txt wug.txt</span><br><span class="line">&gt; add a.txt</span><br><span class="line">&lt;&lt;&lt;</span><br><span class="line">&gt; commit &quot;a is a wug&quot;</span><br><span class="line">&lt;&lt;&lt;</span><br></pre></td></tr></table></figure><p>我们应该将此文件与其他测试一起放在 <code>samples</code> 目录中，但是将文件扩展名设置为 <code>.inc</code>，</p><p>所以也许我们命名为 <code>samples/commit_setup.inc</code>。如果我们给它的文件扩展名是 <code>.in</code>，那么我们的测试脚本将错误地将其视为一个测试并尝试单独运行它。在我们的实际测试中，我们简单地使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I commit_setup.inc</span><br></pre></td></tr></table></figure><p>这将使测试脚本运行该文件中的所有命令，并保留它创建的临时目录。这样可以使你的测试相对较短，因此更容易阅读。</p><p>我们包含了一个名为 <code>definitions.inc</code> 的 <code>.inc</code> 文件，它将为你设置方便的模式。让我们了解一下模式是什么。</p><h4 id="匹配模式输出"><a href="#匹配模式输出" class="headerlink" title="匹配模式输出"></a>匹配模式输出</h4><p>测试最令人困惑的部分是 <code>log</code> 输出。有几个原因：</p><ol><li>提交 SHA 将随着修改代码和哈希更多内容而更改，因此你必须不断修改测试以跟上 SHA 的变化。</li><li>你的日期将每次更改，因为时间只会向前推移。</li><li>它会使测试变得很长。</li></ol><p>我们实际上并不在乎精确的文本：只要有一些 SHA 和正确的日期格式的东西即可。基于这个原因，我们的测试使用模式匹配。</p><p>这不是你需要理解的概念，但在高层次上，我们为一些文本（例如提交 SHA）定义一个模式，然后仅检查输出是否具有该模式（不关心实际的字母和数字）。</p><p>下面是你如何为 <code>log</code> 输出创建预期输出并检查它是否匹配模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 首先从我们的设置中“导入”模式定义</span><br><span class="line">I definitions.inc</span><br><span class="line"># 在这里添加你的行，用于创建具有指定消息的提交。我们将省略这个例子。</span><br><span class="line">&gt; log</span><br><span class="line">===</span><br><span class="line">$&#123;COMMIT_HEAD&#125;</span><br><span class="line">added wug</span><br><span class="line"></span><br><span class="line">===</span><br><span class="line">$&#123;COMMIT_HEAD&#125;</span><br><span class="line">initial commit</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;*</span><br></pre></td></tr></table></figure><p>我们看到的部分与正常的 Gitlet 命令相同，除了它以 <code>&lt;&lt;&lt;*</code> 结尾，这告诉测试脚本使用模式。模式被包含在 <code>$&#123;PATTERN_NAME&#125;</code> 中。</p><p>所有模式都定义在 <code>samples/definitions.inc</code> 中。你不需要理解实际模式，只需知道它匹配的内容。例如，<code>HEADER</code> 匹配提交的头部，应该类似于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit fc26c386f550fc17a0d4d359d70bae33c47c54b9</span><br></pre></td></tr></table></figure><p>这只是一个随机的提交 SHA。</p><p>因此，当我们为此测试创建预期输出时，我们需要知道日志中有多少条目以及提交消息是什么。</p><p>你可以使用类似的方法来进行 <code>status</code> 命令的测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">I definitions.inc</span><br><span class="line"># 在这里添加设置状态的命令。我们将在这里省略它们。</span><br><span class="line">&gt; status</span><br><span class="line">=== Branches ===</span><br><span class="line">\*master</span><br><span class="line"></span><br><span class="line">=== Staged Files ===</span><br><span class="line">g.txt</span><br><span class="line"></span><br><span class="line">=== Removed Files ===</span><br><span class="line"></span><br><span class="line">=== Modifications Not Staged For Commit ===</span><br><span class="line"></span><br><span class="line">=== Untracked Files ===</span><br><span class="line">$&#123;ARBLINES&#125;</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;*</span><br></pre></td></tr></table></figure><p>我们在这里使用的模式是 <code>ARBLINES</code>，它是任意行。如果你确实关心哪些文件未跟踪，那么你可以在这里添加，而不使用模式，但也许我们更感兴趣的是看到 <code>g.txt</code> 被准备添加。</p><p>注意分支 <code>master</code> 上的 <code>\*</code>。回想一下，在 <code>status</code> 命令中，应该使用 <code>*</code> 来标记 HEAD 分支。如果你使用模式，你需要在预期输出中将这个 <code>*</code> 替换为 <code>\*</code>。这是在课程范围之外的事情，但它被称为“转义”星号。如果你不使用模式（即你的命令以 <code>&lt;&lt;&lt;</code> 而不是 <code>&lt;&lt;&lt;*</code> 结尾），那么你可以使用没有 <code>\</code> 的 <code>*</code>。</p><p>对于这些模式，你可以进行最后一件事是“保存”匹配的部分。<strong>警告</strong>：这似乎像是魔法，我们根本不关心你是否理解这是如何工作的，只知道它可以并且对你可用。你可以从我们提供的测试中复制并粘贴相关部分，因此你不需要太担心从头开始制作这些。说完了，让我们看看这是什么。</p><p>如果你正在执行 <code>checkout</code> 命令，你需要使用 SHA 标识符来指定要检出到&#x2F;从哪个提交。但是记住，我们使用了模式，所以在创建测试时我们实际上不知道 SHA 标识符。这是有问题的。我们将使用 <code>test04-prev-checkout.in</code> 来看看你如何“捕获”或“保存”SHA：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">I definitions.inc</span><br><span class="line"># 每个 $&#123;COMMIT_HEAD&#125; 都捕获其提交 UID。</span><br><span class="line"># 这里没有显示，但是测试通过制作了许多具有特定消息的提交记录来设置日志。</span><br><span class="line">&gt; log</span><br><span class="line">===</span><br><span class="line">$&#123;COMMIT_HEAD&#125;</span><br><span class="line">version 2 of wug.txt</span><br><span class="line"></span><br><span class="line">===</span><br><span class="line">$&#123;COMMIT_HEAD&#125;</span><br><span class="line">version 1 of wug.txt</span><br><span class="line"></span><br><span class="line">===</span><br><span class="line">$&#123;COMMIT_HEAD&#125;</span><br><span class="line">initial commit</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;*</span><br></pre></td></tr></table></figure><p>这将设置 UID（SHA）在 <code>log</code> 命令后被捕获。因此，在运行此命令后，我们可以使用 <code>D</code> 命令将 UID 定义为变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 第二个版本的 UID</span><br><span class="line">D UID2 &quot;$&#123;1&#125;&quot;</span><br><span class="line"># 第一个版本的 UID</span><br><span class="line">D UID1 &quot;$&#123;2&#125;&quot;</span><br></pre></td></tr></table></figure><p>注意编号是反向的：编号从 1 开始，并从日志的顶部开始。这就是为什么当前版本（即第二个版本）被定义为 <code>&quot;$&#123;1&#125;&quot;</code>。我们不关心初始提交，所以我们不会费心捕获</p><p>它的 SHA。</p><p>这里我们保存了两个 UID，因为我们知道第一个版本有内容，第二个版本的内容被我们更改了。在实际测试中，这可能是一个更复杂的操作，但这是一个示例。我们通过在 <code>$&#123;&#125;</code> 中引用 UID 来使用 UID。我们可以将 UID 直接传递给 Gitlet 命令，而无需知道它是什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; checkout $&#123;UID1&#125; -- wug.txt</span><br><span class="line">&lt;&lt;&lt;</span><br></pre></td></tr></table></figure><p>这将检出到第一个版本，我们知道这是第一个版本，因为我们已经捕获了它的 UID。同样，我们可以使用模式匹配来确定这一切是否正确。</p><p>这就是所有关于测试的全部。请确保每个测试都是自包含的，并且应该在没有任何依赖关系的情况下运行。每个测试应该设置它自己的仓库，并假设没有之前的测试。毫无疑问，测试脚本和测试文件中的注释将是你的好朋友，所以不要犹豫去添加它们。</p><h3 id="一些额外的技巧"><a href="#一些额外的技巧" class="headerlink" title="一些额外的技巧"></a>一些额外的技巧</h3><p>你会发现在测试中有些模式的使用频率更高。例如 <code>UID</code>，因为它用于检出命令。另一个常见的模式是日期和时间戳。这些在 <code>log</code> 输出中出现，以及当你创建提交时，它们将被包含在输出中。这是一个处理日期的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D DATE &quot;Wed Apr 10 12:00:00 2024 -0700&quot;</span><br></pre></td></tr></table></figure><p>它将日期设置为指定的日期。这将允许你在测试中创建提交，并检查它们的日期是否正确。同样，如果你想要检查 SHA 以确保每个提交具有唯一的 SHA，你可以使用模式匹配来匹配提交 SHA。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D COMMIT_HEAD &quot;[0-9a-f]&#123;40&#125;&quot;</span><br></pre></td></tr></table></figure><p>然后，将它放在你的 <code>log</code> 输出中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">===</span><br><span class="line">$&#123;COMMIT_HEAD&#125;</span><br><span class="line">added wug</span><br><span class="line"></span><br><span class="line">===</span><br><span class="line">$&#123;COMMIT_HEAD&#125;</span><br><span class="line">initial commit</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;*</span><br></pre></td></tr></table></figure><p>最后，我要强调测试文件的封闭性和自包含性。一个测试应该是独立于其他测试的，这意味着你的测试应该是互相独立的，不应该依赖于其他测试的结果。这是因为在运行测试套件时，测试的顺序可能会发生变化，这样可以确保你的测试可以单独运行，而不必担心它们所依赖的其他测试。</p><h2 id="远程操作（额外学分）"><a href="#远程操作（额外学分）" class="headerlink" title="远程操作（额外学分）"></a>远程操作（额外学分）</h2><p>这个项目的主要目标是模仿 git 的本地功能。这些功能很有用，因为它们允许你备份自己的文件并维护它们的多个版本。然而，git 的真正强大之处在于它的<em>远程</em>功能，允许与其他人通过互联网进行协作。关键在于你和你的朋友都可以在一个代码库上进行协作。如果你对文件进行了更改，你可以将它们发送给你的朋友，反之亦然。你们两个都可以访问所有你们所做更改的共享历史记录。</p><p>为了获得额外学分，实现一些基本的远程命令：即 <code>add-remote</code>、<code>rm-remote</code>、<code>push</code>、<code>fetch</code> 和 <code>pull</code>。完成它们将获得 64 分额外学分。在完成项目的其余部分之前，请不要尝试或计划额外学分。</p><p>根据你设计项目的灵活性，64 分额外学分可能不值得去做这一部分所需的努力。我们并不期望每个人都去做。我们的重点将是帮助学生完成主要项目；如果你在做额外学分，我们希望你能够比大多数学生更独立一些。</p><h2 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h2><p>关于远程命令有几点说明：</p><ul><li>不会对执行时间进行评分。为了你自己的提高，请不要做任何荒谬的事情。</li><li>所有命令都是从它们的 git 等效版本大幅简化的，因此通常不注明与 git 的具体区别。但要注意它们的存在。</li></ul><p>现在让我们来看看这些命令：</p><h3 id="add-remote"><a href="#add-remote" class="headerlink" title="add-remote"></a>add-remote</h3><ul><li><strong>用法</strong>：<code>java gitlet.Main add-remote [远程名称] [远程目录名称]/.gitlet</code></li><li><strong>描述</strong>：将给定的登录信息保存在给定的远程名称下。尝试从给定的远程名称推送或拉取将尝试使用此<code>.gitlet</code>目录。通过编写，例如，<code>java gitlet.Main add-remote other ../testing/otherdir/.gitlet</code>，你可以提供从所有位置（在你的家用计算机上或评分程序的软件中）工作的远程测试。在这些命令中始终使用正斜杠。让你的程序将所有正斜杠转换为路径分隔符（Unix 上的正斜杠和 Windows 上的反斜杠）。Java 友好地定义了类变量 <code>java.io.File.separator</code> 作为此字符。</li><li><strong>失败情况</strong>：如果已经存在具有给定名称的远程，则打印错误消息：<code>已经存在该名称的远程。</code>你不必检查用户名和服务器信息是否合法。</li><li><strong>危险吗？</strong>：不。</li></ul><h3 id="rm-remote"><a href="#rm-remote" class="headerlink" title="rm-remote"></a>rm-remote</h3><ul><li><strong>用法</strong>：<code>java gitlet.Main rm-remote [远程名称]</code></li><li><strong>描述</strong>：删除与给定远程名称关联的信息。这里的想法是，如果你曾经想要更改你添加的远程，你必须首先删除它，然后重新添加它。</li><li><strong>失败情况</strong>：如果具有给定名称的远程不存在，则打印错误消息：<code>不存在具有该名称的远程。</code></li><li><strong>危险吗？</strong>：不。</li></ul><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><ul><li><p><strong>用法</strong>：<code>java gitlet.Main push [远程名称] [远程分支名称]</code></p></li><li><p><strong>描述</strong>：尝试将当前分支的提交追加到给定远程的给定分支的末尾。细节：</p><p>此命令仅在远程分支的头部在当前本地头部的历史记录中时才起作用，这意味着本地分支包含一些在远程分支未来的提交。在这种情况下，将未来的提交追加到远程分支。然后，远程应该重置到附加的提交的前端（因此其头部将与本地头部相同）。这称为快进。</p><p>如果远程机器上的 Gitlet 系统存在但没有输入分支，则简单地将该分支添加到远程 Gitlet。</p></li><li><p><strong>失败情况</strong>：如果远程分支的头部不在当前本地头部的历史记录中，则打印错误消息 <code>请在推送之前拉取远程更改。</code>如果远程<code>.gitlet</code>目录不存在，则打印 <code>未找到远程目录。</code></p></li><li><p><strong>危险吗？</strong>：不。</p></li></ul><h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><ul><li><strong>用法</strong>：<code>java gitlet.Main fetch [远程名称] [远程分支名称]</code></li><li><strong>描述</strong>：将远程 Gitlet 仓库中的提交下载到本地 Gitlet 仓库中。基本上，这将从远程仓库中的给定分支复制所有提交和 blob（在当前仓库中尚不存在的）到本地<code>.gitlet</code>中的名为<code>[远程名称]/[远程分支名称]</code>的分支中（与真实的 Git 一样），将<code>[远程名称]/[远程分支名称]</code>指向头提交（因此将分支的内容从远程仓库复制到当前仓库）。如果此分支之前不存在，则在本地仓库中创建此分支。</li><li><strong>失败情况</strong>：如果远程 Gitlet 仓库没有给定的分支名称，则打印错误消息 <code>该远程没有该分支。</code>如果远程<code>.gitlet</code>目录不存在，则打印 <code>未找到远程目录。</code></li><li>**危险</li></ul><p>吗？**：不。</p><h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><ul><li><strong>用法</strong>：<code>java gitlet.Main pull [远程名称] [远程分支名称]</code></li><li><strong>描述</strong>：像<code>fetch</code>命令一样获取分支<code>[远程名称]/[远程分支名称]</code>，然后将该获取合并到当前分支。</li><li><strong>失败情况</strong>：<code>fetch</code>和<code>merge</code>命令的失败情况。</li><li><strong>危险吗？</strong>：是的！</li></ul><h2 id="I-避免的事情"><a href="#I-避免的事情" class="headerlink" title="I. 避免的事情"></a>I. 避免的事情</h2><p>根据经验，有一些做法会导致程序不工作，难以找到的错误，有时不可重复（“Heisenbugs”）。</p><ol><li>由于你可能会在文件中保存各种信息（例如提交），你可能会倾向于使用显然方便的文件系统操作（例如列出目录）来对它们进行排序。要小心。例如，<code>File.list</code>和<code>File.listFiles</code>等方法以未定义的顺序生成文件名。如果你使用它们来实现<code>log</code>命令，特别是，你可能会得到随机结果。</li><li>特别是 Windows 用户应该注意，文件分隔符字符是 Unix（或 MacOS）上的<code>/</code>，在 Windows 上是‘\’。因此，如果你通过将一些目录名称和文件名与显式的<code>/</code>或<code>\</code>连接起来来形成文件名，在你的程序中，你可以确保它不会在一个系统或另一个系统上工作。Java 提供了一个系统相关的文件分隔符字符（<code>System.getProperty(&quot;file.separator&quot;)</code>），或者你可以使用多参数构造函数来创建<code>File</code>。</li><li>在序列化时要小心使用<code>HashMap</code>！<code>HashMap</code>内部的事物顺序是不确定的。解决方案是使用<code>TreeMap</code>，它将始终具有相同的顺序。更多详情<a href="https://stackoverflow.com/questions/5993752/hashmap-serialization-and-deserialization-changes">在这里</a></li></ol><h2 id="J-致谢"><a href="#J-致谢" class="headerlink" title="J. 致谢"></a>J. 致谢</h2><p>感谢 Alicia Luengo、Josh Hug、Sarah Kim、Austin Chen、Andrew Huang、Yan Zhao、Matthew Chow，特别是 Alan Yao、Daniel Nguyen 和 Armani Ferrante，提供了此项目的反馈。感谢 git 的强大。</p><p>此项目在很大程度上受到 [这篇][Nilsson Article] 由 Philip Nilsson 撰写的优秀文章的启发。</p><p>此项目由 Joseph Moghadam 创建。Paul Hilfinger 分别在 2015 年秋季、2017 年秋季和 2019 年秋季进行了修改。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B项目笔记(六)-Lab8-哈希表</title>
      <link href="/2024/03/04/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-5-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab8-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2024/03/04/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-5-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab8-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>代码介绍在<a href="https://sp21.datastructur.es/materials/lab/lab8/lab8">Lab8</a></p><p>起始代码在<a href="https://github.com/Berkeley-CS61B/skeleton-sp21/tree/master/lab8">skeleton-sp21&#x2F;lab8 at master · Berkeley-CS61B&#x2F;skeleton-sp21 (github.com)</a>仓库中</p><h1 id="收获点"><a href="#收获点" class="headerlink" title="收获点"></a>收获点</h1><p>本次Lab主要介绍了工厂化代码的思想</p><p>启动文件的继承结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map61B.java</span><br><span class="line">└── MyHashMap.java</span><br><span class="line">    ├── MyHashMapALBuckets.java</span><br><span class="line">    ├── MyHashMapHSBuckets.java</span><br><span class="line">    ├── MyHashMapLLBuckets.java</span><br><span class="line">    ├── MyHashMapPQBuckets.java</span><br><span class="line">    └── MyHashMapTSBuckets.java</span><br></pre></td></tr></table></figure><p>在这个哈希表中，有一个工厂方法 <code>createBucket()</code> 和 <code>createTable(int tableSize)</code>。</p><ul><li><code>createBucket()</code> 方法用于创建一个存储 <code>Node</code> 的桶。在下面的实现中，使用 <code>LinkedList</code> 作为桶的数据结构，因此这个工厂方法返回了一个 <code>LinkedList&lt;Node&gt;</code>。你可以通过重写这个方法来选择其他数据结构作为桶的实现。</li><li><code>createTable(int tableSize)</code> 方法用于创建底层数组，即哈希表的主要存储结构。这个方法会创建一个长度为 <code>tableSize</code> 的数组，然后遍历数组，为每个位置创建一个桶，调用 <code>createBucket()</code> 方法创建桶对象。最后返回创建好的数组，作为哈希表的底层存储结构。这个方法允许你灵活地选择数组的长度，以及每个桶的具体实现方式。</li></ul><p>在 <code>MyHashMap</code> 的构造函数中，通过调用 <code>createTable(capacity)</code> 方法来初始化 <code>buckets</code>，这样就创建了一个指定容量的哈希表。在哈希表的 <code>resize(int newCapacity)</code> 方法中，同样会使用 <code>createTable(newCapacity)</code> 来创建新的更大容量的哈希表，并将原有的键值对重新哈希到新的数组中。</p><p>这种工厂方法的设计允许了灵活性和可扩展性，可以方便地修改和替换哈希表的内部数据结构，以满足不同的需求和性能要求。</p><h1 id="哈希表API"><a href="#哈希表API" class="headerlink" title="哈希表API"></a>哈希表API</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hashmap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your implementation hashmap.MyHashMap should implement this interface. To do so,</span></span><br><span class="line"><span class="comment"> * append &quot;implements hashmap.Map61B&lt;K, V&gt;&quot; to the end of your &quot;public class...&quot;</span></span><br><span class="line"><span class="comment"> * declaration, though you can use other formal type parameters if you&#x27;d like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map61B</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;K&gt; &#123;</span><br><span class="line">    <span class="comment">/** Removes all of the mappings from this map. */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns true if this map contains a mapping for the specified key. */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(K key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped, or null if this</span></span><br><span class="line"><span class="comment">     * map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(K key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns the number of key-value mappings in this map. */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">     * If the map previously contained a mapping for the key,</span></span><br><span class="line"><span class="comment">     * the old value is replaced.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns a Set view of the keys contained in this map. */</span></span><br><span class="line">    Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the mapping for the specified key from this map if present.</span></span><br><span class="line"><span class="comment">     * Not required for Lab 8. If you don&#x27;t implement this, throw an</span></span><br><span class="line"><span class="comment">     * UnsupportedOperationException.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">remove</span><span class="params">(K key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the entry for the specified key only if it is currently mapped to</span></span><br><span class="line"><span class="comment">     * the specified value. Not required for Lab 8. If you don&#x27;t implement this,</span></span><br><span class="line"><span class="comment">     * throw an UnsupportedOperationException.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">remove</span><span class="params">(K key, V value)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hashmap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  A hash table-backed Map implementation. Provides amortized constant time</span></span><br><span class="line"><span class="comment"> *  access to elements via get(), remove(), and put() in the best case.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Assumes null keys will never be inserted, and does not resize down upon remove().</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span> YOUR NAME HERE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHashMap</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map61B</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line"></span><br><span class="line">        Node(K k, V v) &#123;</span><br><span class="line">            key = k;</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Instance Variables */</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;Node&gt;[] buckets;</span><br><span class="line">    <span class="comment">// You should probably define some more!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> loadFactor;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructors */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">16</span>, <span class="number">0.75</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyHashMap</span><span class="params">(<span class="type">int</span> initialSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(initialSize, <span class="number">0.75</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MyHashMap constructor that creates a backing array of initialSize.</span></span><br><span class="line"><span class="comment">     * The load factor (# items / # buckets) should always be &lt;= loadFactor</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialSize initial size of backing array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxLoad maximum load factor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyHashMap</span><span class="params">(<span class="type">int</span> initialSize, <span class="type">double</span> maxLoad)</span> &#123;</span><br><span class="line">        capacity = initialSize;</span><br><span class="line">        buckets = createTable(capacity);</span><br><span class="line">        loadFactor = maxLoad;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a new node to be placed in a hash table bucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">createNode</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a data structure to be a hash table bucket</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The only requirements of a hash table bucket are that we can:</span></span><br><span class="line"><span class="comment">     *  1. Insert items (`add` method)</span></span><br><span class="line"><span class="comment">     *  2. Remove items (`remove` method)</span></span><br><span class="line"><span class="comment">     *  3. Iterate through items (`iterator` method)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Each of these methods is supported by java.util.Collection,</span></span><br><span class="line"><span class="comment">     * Most data structures in Java inherit from Collection, so we</span></span><br><span class="line"><span class="comment">     * can use almost any data structure as our buckets.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Override this method to use different data structures as</span></span><br><span class="line"><span class="comment">     * the underlying bucket type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * BE SURE TO CALL THIS FACTORY METHOD INSTEAD OF CREATING YOUR</span></span><br><span class="line"><span class="comment">     * OWN BUCKET DATA STRUCTURES WITH THE NEW OPERATOR!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Collection&lt;Node&gt; <span class="title function_">createBucket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a table to back our hash table. As per the comment</span></span><br><span class="line"><span class="comment">     * above, this table can be an array of Collection objects</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * BE SURE TO CALL THIS FACTORY METHOD WHEN CREATING A TABLE SO</span></span><br><span class="line"><span class="comment">     * THAT ALL BUCKET TYPES ARE OF JAVA.UTIL.COLLECTION</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableSize the size of the table to create</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;Node&gt;[] createTable(<span class="type">int</span> tableSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> (Collection&lt;Node&gt;[]) <span class="keyword">new</span> <span class="title class_">Collection</span>[tableSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Implement the methods of the Map61B Interface below</span></span><br><span class="line">    <span class="comment">// Your code won&#x27;t compile until you do so!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes all of the mappings from this map.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        MyHashMap&lt;K, V&gt; newTable = <span class="keyword">new</span> <span class="title class_">MyHashMap</span>&lt;&gt;();</span><br><span class="line">        size = newTable.size();</span><br><span class="line">        capacity = newTable.capacity;</span><br><span class="line">        loadFactor = newTable.loadFactor;</span><br><span class="line">        buckets = newTable.buckets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if this map contains a mapping for the specified key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;key is null in containsKey() function&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> get(key) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped, or null if this</span></span><br><span class="line"><span class="comment">     * map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;the key is null in get() function&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Collection&lt;Node&gt; bucket = getBucket(key);</span><br><span class="line">        <span class="keyword">if</span> (bucket != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node node : bucket) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.key.equals(key)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> node.value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of key-value mappings in this map.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(K num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(num.hashCode()) % capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Collection&lt;Node&gt; <span class="title function_">getBucket</span><span class="params">(K k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hashCode(k);</span><br><span class="line">        <span class="keyword">return</span> buckets[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">     * If the map previously contained a mapping for the key,</span></span><br><span class="line"><span class="comment">     * the old value is replaced.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        Collection&lt;Node&gt; bucket = getBucket(key);</span><br><span class="line">        <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// if bucket dont exist</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hashCode(key);</span><br><span class="line">            buckets[index] = createBucket();</span><br><span class="line">            bucket = buckets[index];</span><br><span class="line">        &#125;</span><br><span class="line">        putIn(bucket, key, value);</span><br><span class="line">        <span class="type">double</span> <span class="variable">load</span> <span class="operator">=</span> (<span class="type">double</span>) size() /capacity;</span><br><span class="line">        <span class="keyword">if</span> (load &gt; loadFactor) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * capacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        capacity = size;</span><br><span class="line">        Collection&lt;Node&gt;[] newBuckets = createTable(size);</span><br><span class="line">        <span class="keyword">for</span> (Collection&lt;Node&gt; bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node node : bucket) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hashCode(node.key);</span><br><span class="line">                    <span class="keyword">if</span> (newBuckets[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                        newBuckets[index] = createBucket();</span><br><span class="line">                    &#125;</span><br><span class="line">                    newBuckets[index].add(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        buckets = newBuckets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">putIn</span><span class="params">(Collection&lt;Node&gt; bucket, K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node x : bucket) &#123; <span class="comment">// iterate the bucket</span></span><br><span class="line">            <span class="keyword">if</span> (x.key.equals(key)) &#123; <span class="comment">// find the exact key</span></span><br><span class="line">                x.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bucket.add(<span class="keyword">new</span> <span class="title class_">Node</span>(key, value));</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a Set view of the keys contained in this map.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">        Set&lt;K&gt; keySet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Collection&lt;Node&gt; bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node node : bucket) &#123;</span><br><span class="line">                    keySet.add(node.key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keySet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the mapping for the specified key from this map if present.</span></span><br><span class="line"><span class="comment">     * Not required for Lab 8. If you don&#x27;t implement this, throw an</span></span><br><span class="line"><span class="comment">     * UnsupportedOperationException.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the entry for the specified key only if it is currently mapped to</span></span><br><span class="line"><span class="comment">     * the specified value. Not required for Lab 8. If you don&#x27;t implement this,</span></span><br><span class="line"><span class="comment">     * throw an UnsupportedOperationException.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an iterator over elements of type &#123;<span class="doctag">@code</span> T&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an Iterator.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Protected helper class to store key/value pairs</span></span><br><span class="line"><span class="comment">     * The protected qualifier allows subclass access</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(十六)-RD13-堆和优先级队列</title>
      <link href="/2024/03/03/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-16-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD13-%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
      <url>/2024/03/03/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-16-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD13-%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要使用PQ？"><a href="#为什么要使用PQ？" class="headerlink" title="为什么要使用PQ？"></a>为什么要使用PQ？</h1><p>我们学到的最后一个 ADT 是二叉搜索树，它使我们能够高效搜索，只需要 log<em>N</em> 时间。这是因为我们可以在搜索的每一步中剔除一半的元素。如果我们更关心快速找到最小或最大元素而不是快速搜索怎么办？</p><p>同时，二叉树中，我们不允许存在两个具有相同的值的情况重新，因此就有了PQ。</p><h1 id="优先级队列接口"><a href="#优先级队列接口" class="headerlink" title="优先级队列接口"></a>优先级队列接口</h1><p>要理解这个抽象数据类型，请考虑一袋物品。您可以向这个袋子中添加物品，也可以从中移除物品等等。唯一的限制是您只能与这个袋子中的最小的物品进行交互。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** (Min) Priority Queue: Allowing tracking and removal of </span></span><br><span class="line"><span class="comment">  * the smallest item in a priority queue. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MinPQ</span>&lt;Item&gt; &#123;</span><br><span class="line">    <span class="comment">/** Adds the item to the priority queue. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Item x)</span>;</span><br><span class="line">    <span class="comment">/** Returns the smallest item in the priority queue. */</span></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">getSmallest</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/** Removes the smallest item from the priority queue. */</span></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">removeSmallest</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/** Returns the size of the priority queue. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用优先级"><a href="#使用优先级" class="headerlink" title="使用优先级"></a>使用优先级</h2><p>我们何时会真正使用或需要这种结构？</p><p>下面是一个简单的例子，演示了如何使用优先队列来解决任务调度的问题：</p><p>假设有一个任务调度系统，有多个任务需要执行，每个任务都有一个优先级。我们希望按照任务的优先级来执行任务，优先级高的任务优先执行，但是如果有多个优先级相同的任务，我们希望按照它们的到达时间先后来执行。</p><p>在这种情况下，可以使用优先队列来管理待执行的任务队列。每次从优先队列中取出优先级最高的任务来执行，如果有多个优先级相同的任务，则按照它们的到达时间先后来执行。</p><p><img src="/2024/03/03/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-16-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD13-%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/image-20240303012318646.png" alt="image-20240303012318646"></p><h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><ul><li><p>使用这种专门的数据结构可以带来空间&#x2F;内存方面的好处。</p></li><li><p>我们目前所知的 ADT 实现并不能为 PQ 操作提供高效的运行时。</p><ul><li>在其他结构中，二叉搜索树是最有效的</li></ul></li></ul><h1 id="堆结构"><a href="#堆结构" class="headerlink" title="堆结构"></a>堆结构</h1><p><strong>注意:这个堆并不是我们所熟知的堆栈</strong></p><p>我们之前已经看到，我们所知的数据结构中对于优先队列操作的运行时最好的是二叉搜索树。通过修改其结构和约束条件，我们可以进一步提高这些操作的运行时和效率。</p><p>我们将定义我们的二叉最小堆为完全堆，并遵守最小堆性质：</p><ul><li><strong>最小堆：</strong> 每个节点都小于或等于其两个子节点。</li><li><strong>完全堆：</strong> 底层（如果有）仅缺少项，所有节点都尽可能靠左。</li></ul><p><img src="/2024/03/03/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-16-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD13-%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/image-20240303012625523.png" alt="image-20240303012625523"></p><p>正如我们在上面的图中所看到的，绿色的堆是有效的，而红色的堆则不是。后两个不是有效的，因为它们违反了我们上面定义的至少一个属性。</p><p>现在让我们考虑这种结构如何适用于我们在前一章中描述的抽象数据类型。我们将通过分析我们期望的操作来做到这一点。</p><p><strong>练习 13.2.1.</strong> 在给定的堆结构下，确定我们的优先队列接口的每种方法将如何实现。不要编写实际代码，只需伪代码！</p><h2 id="堆操作"><a href="#堆操作" class="headerlink" title="堆操作"></a>堆操作</h2><p>对于优先队列 ADT，我们关心的三种方法是 <code>add</code>、<code>getSmallest</code> 和 <code>removeSmallest</code>。我们将从概念上描述如何根据我们给定的堆模式实现这些方法。</p><ul><li><p><code>add</code>：</p><p> 暂时添加到堆的末尾。向上游到适当位置。</p><ul><li>上游涉及交换节点，如果子节点小于父节点。</li></ul></li><li><p><strong><code>getSmallest</code>：</strong> 返回堆的根（根据我们的最小堆属性，这是最小值）。</p></li><li><p><code>removeSmallest</code>：</p><p> 将堆中的最后一个项目与根交换。向下沉到适当的位置。</p><ul><li>下沉涉及交换节点，如果父节点大于子节点。与最小子节点交换以保持最小堆属性。</li></ul></li></ul><p>我们已经确定了我们将如何以有效的方式处理 <code>PriorityQueue</code> 接口指定的操作。但我们如何实际编写代码呢？</p><p><strong>练习 13.2.2.</strong> 给出上述每种方法的运行时。最坏情况和最佳情况。</p><h2 id="树表示"><a href="#树表示" class="headerlink" title="树表示"></a>树表示</h2><p>有许多方法可以用来表示树。</p><h3 id="方法-1a、1b-和-1c"><a href="#方法-1a、1b-和-1c" class="headerlink" title="方法 1a、1b 和 1c"></a><strong>方法 1a、1b 和 1c</strong></h3><p>我们考虑对树最直观和之前使用的表示方法。我们将创建节点和其子节点之间的映射。我们将探索几种方法。</p><p>在 Tree1A 方法中，我们考虑创建指向子节点的指针，并将值存储在节点对象中。这些是硬连线，给我们固定宽度的节点。我们可以观察到以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree1A</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key k;</span><br><span class="line">  Tree1A left;</span><br><span class="line">  Tree1A middle;</span><br><span class="line">  Tree1A right;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/03/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-16-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD13-%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/image-20240303012921276.png" alt="image-20240303012921276"></p><p>或者，在 Tree1B 中，我们探索使用数组来表示子节点和节点之间的映射。这将给我们可变宽度的节点，但遍历会更加笨拙，性能会更差。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree1B</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key k;</span><br><span class="line">  Tree1B[] children;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/03/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-16-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD13-%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/image-20240303012939472.png" alt="image-20240303012939472"></p><p>最后，我们可以使用 Tree1C 方法。这与我们以前见过的常规方法略有不同。与仅表示节点的子节点不同，我们说节点也可以保持对它们的兄弟的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree1C</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key k;</span><br><span class="line">  Tree1C favoredChild;</span><br><span class="line">  Tree1C sibling;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/03/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-16-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD13-%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/image-20240303012952386.png" alt="image-20240303012952386"></p><p>在所有这些方法中，我们存储了谁在下面的显式引用。这些显式引用采用指向实际树对象的指针的形式。让我们考虑一些不存储对子节点的显式引用的更奇特的方法。</p><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a><strong>方法 2</strong></h3><p>回顾一下不相交集 ADT。我们表示这种加权快速联合结构的方式是通过数组。对于表示树，我们可以存储键数组以及父数组。键数组表示哪个索引映射到哪个键，父数组表示另一个键是另一个键的子节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree2</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key[] keys;</span><br><span class="line">  <span class="type">int</span>[] parents;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/03/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-16-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD13-%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/image-20240303013018033.png" alt="image-20240303013018033"></p><p>花点时间确保左侧的树对应于右侧数组中的表示。</p><p>是时候做出非常重要的观察了！基于树的结构和数组表示之间的关系，我们可以看到：</p><ul><li>树是完全的。这是我们之前定义的一个属性。</li><li>父数组具有一种冗余模式，其中元素只是双倍的。</li><li>阅读树的层序，我们看到它与键数组中的键的顺序完全匹配。</li></ul><p>这一切意味着什么呢？我们知道父数组是多余的，因此我们可以忽略它，我们知道树可以用数组中的层序表示。</p><h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法 3"></a><strong>方法 3</strong></h3><p>在这种方法中，我们假设我们的树是完全的。这是为了确保我们的数组表示中没有“间隙”。因此，我们将这个树的复杂的二维结构压缩成一个数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeC</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key[] keys;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/03/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-16-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD13-%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/image-20240303013042035.png" alt="image-20240303013042035"></p><p>根据上面的持续图表：</p><p>这将类似于书中对堆的实现方案，这是优先队列 ADT 的基础实现。</p><h3 id="方法3b"><a href="#方法3b" class="headerlink" title="方法3b"></a><strong>方法3b</strong></h3><p><img src="/2024/03/03/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-16-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RD13-%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/image-20240303013345336.png" alt="image-20240303013345336"></p><h2 id="上浮"><a href="#上浮" class="headerlink" title="上浮"></a>上浮</h2><p>给定这个实现，我们定义了在堆操作部分中描述的“上浮”代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (keys[parent(k)] ≻ keys[k]) &#123;</span><br><span class="line">       swap(k, parent(k));</span><br><span class="line">       swim(parent(k));              </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">parent</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (k - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><table><thead><tr><th>Methods</th><th>Ordered Array</th><th>Bushy BST</th><th>Hash Table</th><th>Heap</th></tr></thead><tbody><tr><td><code>add</code></td><td>Θ(<em>N</em>)</td><td>Θ(log<em>N</em>)</td><td>Θ(1)</td><td>Θ(log<em>N</em>)</td></tr><tr><td><code>getSmallest</code></td><td>Θ(1)</td><td>Θ(log<em>N</em>)</td><td>Θ(<em>N</em>)</td><td>Θ(1)</td></tr><tr><td><code>removeSmallest</code></td><td>Θ(<em>N</em>)</td><td>Θ(log<em>N</em>)</td><td>Θ(<em>N</em>)</td><td>Θ(log<em>N</em>)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>坍塌的沙发法则</title>
      <link href="/2024/02/28/%E5%A5%BD%E6%96%87%E7%AB%A0-%E7%A0%B4%E7%A2%8E%E7%9A%84%E8%A2%AB%E8%A4%A5%E6%B3%95%E5%88%99/"/>
      <url>/2024/02/28/%E5%A5%BD%E6%96%87%E7%AB%A0-%E7%A0%B4%E7%A2%8E%E7%9A%84%E8%A2%AB%E8%A4%A5%E6%B3%95%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>本文由GPT翻译，原文链接为:</p><a href="https://mathwithbaddrawings.com/2015/04/08/the-math-ceiling-wheres-your-cognitive-breaking-point/" title target>原文</a><span id="more"></span><h1 id="数学天花板：你的认知瓶颈在哪里？"><a href="#数学天花板：你的认知瓶颈在哪里？" class="headerlink" title="数学天花板：你的认知瓶颈在哪里？"></a>数学天花板：你的认知瓶颈在哪里？</h1><p><a href="https://mathwithbaddrawings.com/author/mathwithbaddrawings/">本·奥林</a> <a href="https://mathwithbaddrawings.com/category/reflections/">思考</a> 2015年4月8日 4分钟</p><p>某天下午，我的系主任在教职工休息室里碰到了我，提出了一个发人深思的问题。</p><p><img src="/2024/02/28/%E5%A5%BD%E6%96%87%E7%AB%A0-%E7%A0%B4%E7%A2%8E%E7%9A%84%E8%A2%AB%E8%A4%A5%E6%B3%95%E5%88%99/20150326082040_00001.jpg" alt="20150326082040_00001"></p><p>（他后来承认，他只是好奇是否能够在这个博客上玩傀儡。答案是一个响亮的“是的”：我像一个傀儡一样跳舞。）</p><p><img src="/2024/02/28/%E5%A5%BD%E6%96%87%E7%AB%A0-%E7%A0%B4%E7%A2%8E%E7%9A%84%E8%A2%AB%E8%A4%A5%E6%B3%95%E5%88%99/20150324074539_00006.jpg" alt="20150324074539_00006"></p><p>那么，我们有天花板吗？</p><p>传统的正统说：“绝对有。”有高智商和低智商。有“数学人”和“非数学人”。有些孩子就是“懂得了”；而其他人则不是。</p><p>试着问问成年人有关他们的数学教育：他们把它看作是某种NCAA锦标赛。每个人都会被淘汰，问题只是你能在游戏中坚持多久。“我处理不了代数”意味着第一轮的淘汰。“我在多元微积分停下了”意味着“嘿，我没赢，但我为进入最后四强而自豪。”</p><p>但是教师们中间有一个新的正统观念，那就是“绝对没有”。</p><p><img src="/2024/02/28/%E5%A5%BD%E6%96%87%E7%AB%A0-%E7%A0%B4%E7%A2%8E%E7%9A%84%E8%A2%AB%E8%A4%A5%E6%B3%95%E5%88%99/20150326082040_00002.jpg" alt="20150326082040_00002"></p><p><img src="/2024/02/28/%E5%A5%BD%E6%96%87%E7%AB%A0-%E7%A0%B4%E7%A2%8E%E7%9A%84%E8%A2%AB%E8%A4%A5%E6%B3%95%E5%88%99/20150326082040_00003.jpg" alt="20150326082040_00003"></p><p><img src="/2024/02/28/%E5%A5%BD%E6%96%87%E7%AB%A0-%E7%A0%B4%E7%A2%8E%E7%9A%84%E8%A2%AB%E8%A4%A5%E6%B3%95%E5%88%99/20150326082040_00004.jpg" alt="20150326082040_00004"></p><p><img src="/2024/02/28/%E5%A5%BD%E6%96%87%E7%AB%A0-%E7%A0%B4%E7%A2%8E%E7%9A%84%E8%A2%AB%E8%A4%A5%E6%B3%95%E5%88%99/20150326082040_00005.jpg" alt="20150326082040_00005"></p><p><img src="/2024/02/28/%E5%A5%BD%E6%96%87%E7%AB%A0-%E7%A0%B4%E7%A2%8E%E7%9A%84%E8%A2%AB%E8%A4%A5%E6%B3%95%E5%88%99/20150326082040_00006.jpg" alt="20150326082040_00006"></p><p>你得欣赏这种乐观主义，这种大众主义。（看看你椅子下面——<em>每个人</em>都得到了一本范畴论教材！）但我认为你也得像我的朋友Karen一样怀疑。</p><p>Karen，我们有天花板吗？</p><p><img src="/2024/02/28/%E5%A5%BD%E6%96%87%E7%AB%A0-%E7%A0%B4%E7%A2%8E%E7%9A%84%E8%A2%AB%E8%A4%A5%E6%B3%95%E5%88%99/20150326082040_00007.jpg" alt="20150326082040_00007"></p><p><img src="/2024/02/28/%E5%A5%BD%E6%96%87%E7%AB%A0-%E7%A0%B4%E7%A2%8E%E7%9A%84%E8%A2%AB%E8%A4%A5%E6%B3%95%E5%88%99/20150326082040_00008.jpg" alt="20150326082040_00008"></p><p>Karen很努力。Karen会问问题。Karen相信自己。但Karen仍然觉得某些数学超出了她的能力范围，超出了她的天花板。</p><p>学生（“每个人都有极限”）和老师（“任何人都可以做任何事！”）之间的鸿沟似乎是不可逾越的。老师可能会说“你能做到！”作为鼓励，但一个沮丧的学生可能会听到这些话作为对他们努力的谴责（或者作为一种妄想的虚假）。有没有办法调和这些矛盾？</p><p>我相信有：<strong>破损沙发定律</strong>。</p><p><img src="/2024/02/28/%E5%A5%BD%E6%96%87%E7%AB%A0-%E7%A0%B4%E7%A2%8E%E7%9A%84%E8%A2%AB%E8%A4%A5%E6%B3%95%E5%88%99/20150324074539_00010.jpg" alt="20150324074539_00010"></p><p>在大学里，我的室友和我从一些朋友那里买了一张二手沙发（只有几个月的历史）。他们住在一楼；我们住在四楼。他们友好地帮我们把它搬上了楼。</p><p>当他们走到三楼的楼梯口时，他们听到了一声爆裂声。一个小的金属条从沙发上掉了下来。我们所有人都检查了一下，但甚至找不到这块零件从哪里掉下来的。由于沙发看起来很好，我们只是耸了耸肩。</p><p><img src="/2024/02/28/%E5%A5%BD%E6%96%87%E7%AB%A0-%E7%A0%B4%E7%A2%8E%E7%9A%84%E8%A2%AB%E8%A4%A5%E6%B3%95%E5%88%99/20150324074539_00007.jpg" alt="20150324074539_00007"></p><p>一个星期后，沙发开始下垂。“它一直都是这样吗？”我们</p><p>彼此问道。</p><p><img src="/2024/02/28/%E5%A5%BD%E6%96%87%E7%AB%A0-%E7%A0%B4%E7%A2%8E%E7%9A%84%E8%A2%AB%E8%A4%A5%E6%B3%95%E5%88%99/20150324074539_00008.jpg" alt="20150324074539_00008"></p><p>一个月后，它尴尬地下垂。坐在尽头，沙发的弯曲会把你（和其他人）倒在一个中心的一堆里。</p><p><img src="/2024/02/28/%E5%A5%BD%E6%96%87%E7%AB%A0-%E7%A0%B4%E7%A2%8E%E7%9A%84%E8%A2%AB%E8%A4%A5%E6%B3%95%E5%88%99/20150324074539_00009.jpg" alt="20150324074539_00009"></p><p>到学期结束时，它已经在灰尘的宿舍地板上崩溃成了一堆，曾经繁荣的沙发的残骸。</p><p><img src="/2024/02/28/%E5%A5%BD%E6%96%87%E7%AB%A0-%E7%A0%B4%E7%A2%8E%E7%9A%84%E8%A2%AB%E8%A4%A5%E6%B3%95%E5%88%99/20150324074539_00010.jpg" alt="20150324074539_00010"></p><p>现在，宜家家具是客厅的果蝇：以寿命短暂而著称。我们沙发的寿命无疑有一个上限，也许是三年或四年。但这个沙发仅仅活了不到八个月。</p><p>事后看来，这个损坏的零件绝对至关重要。沙发没有它看起来是完好无损的。但是每一天，随着每个新的屁股，重量都会压在结构的某些部分上，这些部分本来不应该独自承受负荷。框架变得扭曲。压力无法持续。沙发的内部时钟悄悄地滴答作响，直到支撑不足变得不堪承受，整个东西都崩溃了。</p><p>可悲的是，在数学课上也是如此。</p><p>假设你在八年级表现出色。你可以完美流畅而精确地绘制线性方程的图形。你可以计算它们的斜率，识别点，并生成平行和垂直线。</p><p><img src="/2024/02/28/%E5%A5%BD%E6%96%87%E7%AB%A0-%E7%A0%B4%E7%A2%8E%E7%9A%84%E8%A2%AB%E8%A4%A5%E6%B3%95%E5%88%99/20150324074539_00011.jpg" alt="20150324074539_00011"></p><p>但是如果你缺少一个简单的理解——这些图形只是满足方程的x-y对——那么你就是一个破损的沙发。你缺少了一个未来学习至关重要的部分。二次函数会困扰你；正弦曲线永远不会让你感到满意；你可能会在微积分后退出，安慰自己：“嘿，至少我的天花板比一些人的高。”</p><p>你可能会问：“既然我现在没事，难道我不能在真正需要的时候补上那块缺失的部分吗？”有时候，是的。但这要困难得多。你现在已经没有了那个关键部分。你已经花了几年时间去做那个关键部分。你已经发展出了一些临时的方法和片段式的方法来应付。这些方法有一段时间是有效的，但它们扭曲了框架，现在你不够用了。要想前进，你必须先放弃你的权宜之计——有效地把沙发弯回原来的形状——然后才能继续前进。但放弃已经得到你这么远的策略是非常困难的。</p><p>以后补上缺失的部分意味着等待损害已经开始，而且非常难以撤消。</p><p>我相信，这就是许多学生经历的天花板。这不是他们神经元固有的限制。这是我们创造的。我们通过言语或行动说：“你不理解没关系。只需按照这些步骤进行并在后面检查答案即可。”我们通过说：“只有聪明人才能<em>理解</em>；至于其他人，我只是想确保他们能<em>做</em>。”我们通过说：“好吧，他们现在不理解，但他们以后会自己搞明白的。”</p><p>这样做，我们可能成功地把沙发搬上了楼。但在这个过程中失去了一些东西。把我们的学生没有关键的理解送出去就像把他们 marching 进入战场没有备用弹药一样。当然，他们会射击几发子弹，但到他们意识到缺少了什么时候，已经太迟了，无法挽回。</p><p>一个能够回答问题而不理解的学生就是一个有过期日期的学生。</p><p>编辑，2015年4月15日：这真是一个响应啊！下面的评论区就像是我梦中的咖啡店里的偷听者。我希望我有时间逐个回复；请知道我读过并享受了你们思想深沉的回复和讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 有趣の文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 有趣の文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(十五)-Rd12-哈希表</title>
      <link href="/2024/02/28/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-15-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd12-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2024/02/28/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-15-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd12-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="目前的问题"><a href="#目前的问题" class="headerlink" title="目前的问题"></a>目前的问题</h1><p>到目前为止，我们已经了解了一些数据结构，以便有效地搜索数据结构中是否存在项目。我们研究了二叉搜索树，然后使用 2-3 棵树使它们平衡。</p><p>然而，这些结构存在一些限制（是的，甚至是 2-3 棵树）</p><ol><li><p>他们要求项目具有可比性。您如何决定新项目在 BST 中的位置？你必须回答“你比根小还是大”的问题？对于某些对象来说，这个问题可能没有意义。</p></li><li><p>它们给出的复杂度为 <code>Θ(logN)</code> 。这个好吗？绝对地。但也许我们可以做得更好。</p></li></ol><h2 id="第一次尝试：-DataIndexedIntegerSet"><a href="#第一次尝试：-DataIndexedIntegerSet" class="headerlink" title="第一次尝试： DataIndexedIntegerSet"></a>第一次尝试： <code>DataIndexedIntegerSet</code></h2><p>目前，我们只尝试改进上面的问题#2（将复杂性从 <code>Θ(logN)</code> 提高到 <code>Θ(1)</code> 。我们不会担心问题#1（可比性）事实上，我们只会考虑存储和搜索 <code>int</code> 。</p><p>这里有一个想法：让我们创建一个类型为 <code>boolean</code> 且大小为 20 亿的 ArrayList。让一切默认为假。</p><ul><li><code>add(int x)</code> 方法只是将 ArrayList 中的 <code>x</code> 位置设置为 true。这需要 Θ(1)Θ(1) 时间。</li><li><code>contains(int x)</code> 方法只是返回 ArrayList 中的 <code>x</code> 位置是 <code>true</code> 还是 <code>false</code> 。这也需要 <code>Θ(1) </code>时间！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataIndexedIntegerSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] present;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataIndexedIntegerSet</span><span class="params">()</span> &#123;</span><br><span class="line">        present = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2000000000</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        present[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> present[i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/02/28/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-15-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd12-%E5%93%88%E5%B8%8C%E8%A1%A8/image-20240228174821879.png" alt="image-20240228174821879"></p><p>这种方法有哪些<strong>潜在问题</strong>？</p><ul><li>极其浪费。如果我们假设 <code>boolean</code> 需要 1 个字节来存储，则上面的每个 <code>new DataIndexedIntegerSet()</code> 需要 <code>2GB</code> 空间。此外，用户只能插入少量项目……</li><li>如果有人想插入 <code>String</code> 我们该怎么办？</li></ul><h1 id="解决单词插入问题"><a href="#解决单词插入问题" class="headerlink" title="解决单词插入问题"></a>解决单词插入问题</h1><p>我们的 <code>DataIndexedIntegerSet</code> 只允许使用整数，但现在我们想要将 <code>String</code> <code>&quot;cat&quot;</code> 插入其中。我们将可以插入字符串的数据结构称为 <code>DataIntexedEnglishWordSet</code> 这是一个疯狂的想法：让我们给每个字符串一个数字。也许“cat”可以是 <code>1</code> ，“dog”可以是 <code>2</code> ，“turtle”可以是 <code>3</code> 。</p><p>（这样做的方式是——如果有人想在我们的数据结构中添加一只“猫”，我们会“算出”“猫”的数字是 1，然后将 <code>present[1]</code> 设置为是 <code>true</code> 。如果有人想问我们“cat”是否在我们的数据结构中，我们会“找出”“cat”是 1，并检查 <code>present[1]</code> 是否为 true .)</p><p>但如果有人试图插入“potatocactus”这个词，我们就不知道该怎么办了。我们需要制定一个通用策略，以便给定一个字符串，我们可以找出它的数字表示形式。</p><h2 id="策略-1：使用第一个字母。"><a href="#策略-1：使用第一个字母。" class="headerlink" title="策略 1：使用第一个字母。"></a>策略 1：使用第一个字母。</h2><p>一个简单的想法是仅使用任何给定字符串的第一个字符将其转换为其数字表示形式。所以“cat”-&gt;“c”-&gt; 3。“Dog”-&gt;“d”-&gt; 4。而且，“drum”-&gt;“d”-&gt; 4。</p><p>如果有人想在我们的 <code>DataIntexedEnglishWordSet</code> 中插入“dog”和“drum”怎么办？所有的赌注都落空了，我们不知道该怎么做。</p><p>请注意，当两个不同的输入（“dog”和“drum”）映射到同一整数时，我们称之为<strong>碰撞</strong>。我们还不知道如何处理碰撞，所以让我们想办法避免它们。</p><h2 id="策略-2：避免碰撞"><a href="#策略-2：避免碰撞" class="headerlink" title="策略 2：避免碰撞"></a>策略 2：避免碰撞</h2><p>我们知道英语小写字母中有26个独特的字符，我们可以先将其编号：a &#x3D; 1, b &#x3D; 2, …, z &#x3D; 26，我们可以将单词每个字母进行加权。</p><ul><li><img src="/2024/02/28/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-15-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd12-%E5%93%88%E5%B8%8C%E8%A1%A8/image-20240228172338363.png" alt="image-20240228172338363"></li></ul><p><strong>这种表示形式为每个包含小写字母的英语单词提供了一个唯一的整数，就像使用基数 10 为每个数字提供了唯一的表示形式一样。我们保证不会发生碰撞。</strong></p><h2 id="我们的数据结构-DataIndexedEnglishWordSet"><a href="#我们的数据结构-DataIndexedEnglishWordSet" class="headerlink" title="我们的数据结构 DataIndexedEnglishWordSet"></a>我们的数据结构 <code>DataIndexedEnglishWordSet</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataIndexedEnglishWordSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] present;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataIndexedEnglishWordSet</span><span class="params">()</span> &#123;</span><br><span class="line">        present = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2000000000</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        present[englishToInt(s)] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        resent present[englishToInt(s)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用辅助方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">letterNum</span><span class="params">(String s, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">/** Converts ith character of String to a letter number.</span></span><br><span class="line"><span class="comment">    * e.g. &#x27;a&#x27; -&gt; 1, &#x27;b&#x27; -&gt; 2, &#x27;z&#x27; -&gt; 26 */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ithChar</span> <span class="operator">=</span> s.charAt(i)</span><br><span class="line">    <span class="keyword">if</span> ((ithChar &lt; <span class="string">&#x27;a&#x27;</span>) || (ithChar &gt; <span class="string">&#x27;z&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ithChar - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">englishToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">intRep</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0l</span> i &lt; s.length(); i += <span class="number">1</span>) &#123;</span><br><span class="line">        intRep = intRep * <span class="number">26</span>;</span><br><span class="line">        intRep += letterNum(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intRep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="目前进度"><a href="#目前进度" class="headerlink" title="目前进度"></a>目前进度</h2><ul><li>我们的方法仍然非常浪费内存。我们还没有解决这个问题！</li><li>只局限于整数和英语小写字母</li><li>比 Θ(log<em>N</em>) 更好。现在我们已经对整数和单个英语单词进行了此操作。</li><li>无法存储<code>2pac</code>这样的字符串</li></ul><h1 id="在单个英文单词之外插入-String"><a href="#在单个英文单词之外插入-String" class="headerlink" title="在单个英文单词之外插入 String"></a>在单个英文单词之外插入 <code>String</code></h1><p>有一种称为 ASCII 的字符格式，每个字符都有一个整数。在这里，我们看到最大值（即我们需要使用的基数&#x2F;乘数）是 126。让我们这样做。与 <code>DataIndexedEnglishWordSet</code> 相同，但只是使用基础 <code>126</code> 。</p><p><img src="/2024/02/28/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-15-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd12-%E5%93%88%E5%B8%8C%E8%A1%A8/image-20240228174935269.png" alt="image-20240228174935269"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static int asciiToInt(String s) &#123;</span><br><span class="line">    int intRep = 0;</span><br><span class="line">    for (int i = 0; i &lt; s.length(); i += 1) &#123;           </span><br><span class="line">        intRep = intRep * 126;</span><br><span class="line">        intRep = intRep + s.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return intRep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加对中文的支持怎么样？最大可能的表示形式是 40959，因此我们需要使用它作为基础。这是一个例子：</p><p><img src="/2024/02/28/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-15-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd12-%E5%93%88%E5%B8%8C%E8%A1%A8/image-20240228175013247.png" alt="image-20240228175013247"></p><p>所以…为了存储一个 3 个字符的中文单词，我们需要一个大小大于 39 万亿（带 T）的数组！这已经失控了……所以让我们探讨一下我们能做什么。</p><h1 id="处理整数溢出和哈希码"><a href="#处理整数溢出和哈希码" class="headerlink" title="处理整数溢出和哈希码"></a>处理整数溢出和哈希码</h1><p>Java 中整数的最大可能值为 2,147,483,647。最小值为-2,147,483,648。</p><p>如果你尝试取最大值并加 1，你会得到最小值！</p><p>因此，即使只使用 ASCII 字符（记住，以 126 为基数），我们也会遇到问题。</p><p>对于<em>omens</em><del>126</del>&#x3D;28,196,917,171 .<code>asciiToInt(omens)</code> 返回 <code>-1,867,853,901</code>.</p><p>由于溢出， <code>melt banana</code> 和 <code>subterresetrial anticosmetic</code> 实际上根据 <code>asciiToInt</code> 具有相同的表示。因此，如果我们添加 <code>melt banana</code> 然后尝试询问 <code>contains(subterrestrial anticosmetic)</code> ，我们会得到 <code>true</code> 。</p><h2 id="不可避免的事实。"><a href="#不可避免的事实。" class="headerlink" title="不可避免的事实。"></a>不可避免的事实。</h2><p>从最小到最大可能的整数，Java 中总共有 4,294,967,296 个整数。然而，Java 中可以创建的对象总数远不止于此，因此冲突是不可避免的。抵抗是徒劳的。我们必须弄清楚如何正面处理碰撞，而不是试图解决它。</p><blockquote><p>（如果您不相信在 Java 中可以创建超过 40 亿个对象，只需考虑一下：“一”、“二”、…、“五万亿”——每个都是一个唯一的字符串。 ）</p></blockquote><p><strong>我们必须处理碰撞。</strong></p><h2 id="哈希码"><a href="#哈希码" class="headerlink" title="哈希码"></a>哈希码</h2><p>在计算机科学中，获取一个对象并将其转换为某个整数称为“计算该对象的哈希码”。例如，“meltbanana”的哈希码是839099497。</p><blockquote><p><a href="https://mathworld.wolfram.com/HashFunction.html">哈希函数——来自 Wolfram MathWorld — Hash Function – from Wolfram MathWorld</a></p></blockquote><p>我们研究了如何计算字符串的哈希码。对于其他对象，我们执行以下两件事之一：</p><ul><li>Java中的每个对象都有一个默认的 <code>.hashcode()</code> 方法，我们可以使用它。 Java 通过计算 <code>Object</code> 在内存中的位置（计算机内存的每个部分都有一个地址！）来计算此值，并使用该内存地址执行类似于我们对 <code>String</code> s。该方法为每个 Java 对象提供唯一的哈希码。</li><li>有时，我们编写自己的 <code>hashcode</code> 方法。例如，给定一个 <code>Dog</code> ，我们可以使用它的 <code>name</code> 、 <code>age</code> 和 <code>breed</code> 的组合来生成 <code>hashcode</code></li></ul><h2 id="哈希码的属性"><a href="#哈希码的属性" class="headerlink" title="哈希码的属性"></a>哈希码的属性</h2><p>哈希码具有三个必要的属性，这意味着哈希码必须具有以下属性才能有效：</p><ol><li>它必须是一个整数</li><li>如果我们在一个对象上运行 <code>.hashCode()</code> 两次，它应该返回相同的数字</li><li>被视为 <code>.equal()</code> 的两个对象必须具有相同的哈希码。</li></ol><p>然而，并非所有哈希码都是一样的。如果你希望你的哈希码被认为是一个好的哈希码，它应该：</p><ol><li>均匀分配物品</li></ol><p><strong>请注意，此时，我们知道如何向数据结构添加任意对象，而不仅仅是字符串。</strong></p><h2 id="未决问题"><a href="#未决问题" class="headerlink" title="未决问题"></a>未决问题</h2><ul><li>空间：我们还没有弄清楚如何使用更少的空间。</li><li>处理碰撞：我们已经确定需要处理碰撞，但我们还没有真正处理它们。</li></ul><h1 id="处理碰撞"><a href="#处理碰撞" class="headerlink" title="处理碰撞"></a>处理碰撞</h1><p>最重要的想法是稍微改变我们的数组，使其不只包含项目，而是包含项目的 LinkedList（或任何其他列表）。所以…</p><p>数组中的所有内容原本都是空的。<br>如果我们得到一个新项目，它的哈希码是 $h$：</p><ul><li>如果索引 $h$ 目前没有任何内容，我们将为索引 $h$ 创建一个新的 <code>LinkedList</code> ，将其放置在那里，然后将新项目添加到新创建的 <code>LinkedList</code></li><li>如果索引 $h$ 处已经有一些东西，那么那里已经有一个 <code>LinkedList</code> 。我们只需将新项目添加到 <code>LinkedList</code> 中即可。<strong>注意：我们的数据结构不允许有任何重复的项&#x2F;键。因此，我们必须首先检查我们要插入的项是否已经在此 LinkedList 中。如果是的话，我们什么也不做！这也意味着我们将插入到链表的末尾，因为无论如何我们都需要检查所有元素。</strong></li></ul><h2 id="具体工作流程"><a href="#具体工作流程" class="headerlink" title="具体工作流程"></a>具体工作流程</h2><ul><li><p><code>add</code> 项目</p><ul><li><p>获取项目的哈希码（即索引）。</p></li><li><p>如果索引没有项目，则创建新列表，并将项目放置在那里。</p></li><li><p>如果索引已经有一个列表，请检查列表以查看项目是否已在其中。如果没有，请将项目添加到列表中。</p></li></ul></li><li><p><code>contains</code>项目</p><ul><li>获取项目的哈希码（即索引）。</li><li>如果索引为空，则返回 <code>false</code> 。</li><li>否则，检查列表中该索引处的所有项目，如果该项目存在，则返回 <code>true</code> 。</li></ul></li></ul><h2 id="运行时复杂性"><a href="#运行时复杂性" class="headerlink" title="运行时复杂性"></a>运行时复杂性</h2><p>由于我们需要通过哈希码（即索引）查看 LinkedList 中的所有项目。所以<code>contains</code>的复杂度是Θ(<em>Q</em>)</p><p>因为我们必须检查以确保该项目尚未位于链接列表中，所以<code>add</code>的复杂度是Θ(<em>Q</em>)</p><h2 id="解决空间"><a href="#解决空间" class="headerlink" title="解决空间"></a>解决空间</h2><p>让我们创建一个大小为 100 的 ArrayList。我们不要更改 <code>hashcode</code> 函数的行为方式（让它返回一个疯狂的大整数。）但是在获得 <code>hashcode</code> 后，我们将对其取模 100 以获得我们想要的 0…990…99 范围内的索引。</p><p><img src="/2024/02/28/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-15-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd12-%E5%93%88%E5%B8%8C%E8%A1%A8/image-20240228175450133.png" alt="image-20240228175450133"></p><h2 id="目前进度-1"><a href="#目前进度-1" class="headerlink" title="目前进度"></a>目前进度</h2><ul><li>空间：已解决。</li><li>处理碰撞：完成！</li><li>运行时复杂度？我们之前在 Θ(�)Θ(<em>Q</em>) 处为 <code>add</code> 和 <code>contains</code> 丢失了一些，然后在 <code>解决空间</code> 部分，我们意识到我们丢失了更多，因为我们的 LinkedList 可能会更大（因此 <code>Q</code> 会更大。）</li></ul><h1 id="我们最终的数据结构：-HashTable"><a href="#我们最终的数据结构：-HashTable" class="headerlink" title="我们最终的数据结构： HashTable"></a>我们最终的数据结构： <code>HashTable</code></h1><p>我们现在创建的称为 <code>HashTable</code> 。</p><ul><li>输入由哈希函数 ( <code>hashcode</code> ) 转换为整数。然后，使用模运算符将它们转换为有效索引。然后，它们被添加到该索引处（使用 LinkedList 处理冲突）。</li><li><code>contains</code> 通过找出有效索引并在相应的 LinkedList 中查找该项目以类似的方式工作。</li></ul><h2 id="处理运行时间"><a href="#处理运行时间" class="headerlink" title="处理运行时间"></a>处理运行时间</h2><p>唯一需要解决的问题是运行时间问题。如果我们有 100 个项目，并且 ArrayList 的大小为 5，那么</p><ul><li>在最好的情况下，所有项目都会均匀地发送到不同的索引。也就是说，我们有 5 个 linkedList，每个 linkedList 包含 20 个项目。</li><li>在最坏的情况下，所有项目都会发送到同一个索引！也就是说，我们只有 1 个 LinkedList，但它包含全部 100 个项目。</li></ul><p>有两种方法可以尝试解决此问题：</p><ul><li>动态增长我们的哈希表。</li><li>改进我们的哈希码</li></ul><h3 id="动态增长哈希表"><a href="#动态增长哈希表" class="headerlink" title="动态增长哈希表"></a>动态增长哈希表</h3><p>假设我们有 <em>M</em> 个桶（索引）和 <em>N</em> 个项。我们说我们的<strong>装载因子</strong>是 <em>N</em>&#x2F;<em>M</em>。</p><p>（注意，<strong>装载因子</strong>等同于我们上面的<strong>最佳</strong>情况运行时间。）</p><p>所以…我们有动机保持我们的装载因子低（毕竟，这是我们可能实现的最佳运行时间！）。</p><p>注意，如果我们保持 <em>M</em>（桶的数量）固定，而 <em>N</em> 不断增加，装载因子会不断增加。</p><p>策略？每隔一段时间，将 <em>M</em> 加倍。我们这样做的方式如下：</p><ul><li>创建一个具有 2<em>M</em> 个桶的新哈希表。</li><li>遍历旧哈希表中的所有项，逐个将它们添加到这个新哈希表中。<ul><li>我们需要再次逐个添加元素，因为由于数组的大小变化，模数也会变化，因此该项可能属于新哈希表中的不同桶而不是旧哈希表中的桶。</li></ul></li></ul><p>我们通过设置<strong>装载因子阈值</strong>来执行此操作。一旦装载因子大于此阈值，我们就会调整大小。</p><p>看一下下面的例子。”helmet” 的哈希码是 13。在第一个哈希表中，它被发送到桶 13%4&#x3D;1。在第二个哈希表中，它被发送到桶 13%8&#x3D;5。<strong>请注意，调整哈希表的大小也有助于打乱哈希表中的项</strong>！ </p><p><img src="/2024/02/28/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-15-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd12-%E5%93%88%E5%B8%8C%E8%A1%A8/image-20240228175534697.png" alt="image-20240228175534697"></p><p>在这一点上，<em>假设项目均匀分布</em>，所有列表大约都会是 <em>N</em>&#x2F;<em>M</em> 个项目长，导致 Θ(<em>N</em>&#x2F;<em>M</em>) 运行时间。请记住，<em>N</em>&#x2F;<em>M</em> 只允许在一个常数<strong>装载因子阈值</strong>下，因此， Θ(<em>N</em>&#x2F;<em>M</em>)&#x3D;Θ(1)。</p><p>还要注意，调整大小需要 Θ(<em>N</em>) 时间。为什么？因为我们需要将 <em>N</em> 个项目添加到哈希表中，并且每次添加都需要 Θ(1) 时间。</p><p>一个小细节：当进行调整大小时，我们实际上不需要检查项是否已经存在于链表中（因为我们知道没有重复项），因此我们可以确保将每个项都在 Θ(1) 时间内添加到链表的前面。（回想一下，通常情况下，我们必须搜索链表以确保项不在那里…但是当调整大小时，我们可以跳过该步骤。）</p><p>当然，我们需要重新审视假设项目均匀分布的假设。如果项目不均匀分布，我们的运行时间将是 Θ(<em>N</em>)，因为可能会存在一个大小为 <em>N</em> 的单个链表。</p><h3 id="假设物品均匀分布？"><a href="#假设物品均匀分布？" class="headerlink" title="假设物品均匀分布？"></a>假设物品均匀分布？</h3><p>如果我们有好的哈希码（即为不同项目提供相当随机的值的哈希码），项目将均匀分布。）一般来说，这样做是……嗯……很难。</p><p>一些通用的好的经验法则：</p><ul><li>使用与我们之前开发的策略类似的“基本”策略。</li><li>使用一个小质数的“基数”。<ul><li>Base 126 实际上并不是很好，因为使用 Base 126 意味着以相同的最后 32 个字符结尾的任何字符串都具有相同的哈希码。</li><li>发生这种情况是因为溢出。</li><li>使用素数有助于避免溢出问题（即由于溢出而导致的冲突）。</li><li>为什么是小素数？因为它更容易计算。</li></ul></li></ul><h1 id="哈希表的普及"><a href="#哈希表的普及" class="headerlink" title="哈希表的普及"></a>哈希表的普及</h1><p>哈希表是集合和映射的最流行实现。</p><ul><li>在实践中性能出色。 </li><li>不需要项可比较。 </li><li>实现通常相对简单。 </li><li>Python 字典实际上就是哈希表。</li></ul><p>在 Java 中，它们以 java.util.HashMap 和 java.util.HashSet 实现</p><ul><li>HashMap 如何知道如何计算每个对象的哈希码？ <ul><li>好消息是：不是“implements Hashable”。 </li><li>相反，在 Java 中，所有对象必须实现一个 .hashCode() 方法。</li></ul></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>代码介绍在<a href="https://sp21.datastructur.es/materials/lab/lab8/lab8">Lab8</a>中</p><p>起始代码在<a href="https://github.com/Berkeley-CS61B/skeleton-sp21/tree/master/lab8">skeleton-sp21&#x2F;lab8 at master · Berkeley-CS61B&#x2F;skeleton-sp21 (github.com)</a>仓库中</p><p>具体实现在博客(项目笔记五)[<a href="https://www.bailog.top/2024/03/04/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-5-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab8-%E5%93%88%E5%B8%8C%E8%A1%A8/]">https://www.bailog.top/2024/03/04/JAVA-CS61B-项目笔记-5-CS61B项目笔记-Lab8-哈希表/]</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(十四)-Rd11-树</title>
      <link href="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
      <url>/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>Reading: <a href="https://joshhug.gitbooks.io/hug61b/content/chap11/">11. 平衡树 ·拥抱61B — 11. Balanced Trees · Hug61B (gitbooks.io)</a></p><p>当我们随机插入 BST 时，平均深度和高度预计为<code>Θ(*logN*)</code> .</p><p>但是，我们并不总是能够以随机顺序插入 BST。如果我们的数据是实时的呢？然后，我们将被迫按照数据到达我们的顺序进行插入。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209082942966.png" alt="image-20240209082942966"></p><p>下面我们将了解一棵始终保持平衡的树！</p><h1 id="B-trees-2-3-trees-2-3-4-trees"><a href="#B-trees-2-3-trees-2-3-4-trees" class="headerlink" title="B-trees &#x2F; 2-3 trees &#x2F; 2-3-4 trees"></a>B-trees &#x2F; 2-3 trees &#x2F; 2-3-4 trees</h1><p><a href="https://docs.google.com/presentation/d/1zhQDvbcDZ9RJgJl0bmqwFFlHP8ExbDFo36Q9ZWH9EgU/edit#slide=id.g4fe50d0bd7_0_381">cs61b 2019 lec17 ds3 2-3 trees, 2-3-4 trees - Google 幻灯片</a></p><p>BST 的问题在于我们总是插入叶节点。这就是导致高度增加的原因。</p><p>当我们开始插入节点时，我们可能会破坏平衡结构。所以，让我们想出一种方法，在添加新节点时保持树的平衡！</p><p><strong>疯狂的想法</strong>：我们永远不要添加叶子节点！当我们插入时，让我们只添加到当前的叶节点。这样，高度永远不会增加。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209074328974.png" alt="image-20240209074328974"></p><p>但是，您能看到这种插入方案的潜在问题吗？如果我们搜索 19，那么我们将向下遍历到包含它的节点，我们仍然必须像查看数组一样查看该节点才能到达 19 元素。这将导致 <em>N</em>  的运行时！</p><p><strong>解决方案</strong>：设置单个节点中元素数量的限制。比方说 4.如果我们需要在节点已经有 4 个元素的情况下向节点添加一个新元素，我们会将节点分成两半。通过向上凸起左中间的节点。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209074359730.png" alt="image-20240209074359730"></p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209074429994.png" alt="image-20240209074429994"></p><p>通过在中间拆分节点，我们保持了完美的平衡！这些树被称为 B 树或 2-3-4&#x2F;2-3 树。2-3-4 和 2-3 是指每个节点可以拥有的子节点数。因此，一棵 2-3-4 棵树可以有 2、3 或 4 个孩子，而一棵 2-3 棵树可以有 2 或 3 个孩子。这意味着当 2-3-4 棵树有 3 个节点时，它们会拆分节点，并且需要再添加一个节点。2-3 棵树在有 2 个节点后分裂，需要再添加一个。</p><h2 id="Insertion-Process-插入过程"><a href="#Insertion-Process-插入过程" class="headerlink" title="Insertion Process 插入过程"></a>Insertion Process 插入过程</h2><p>The process of adding a node to a 2-3-4 tree is:<br>将节点添加到 2-3-4 树的过程是：</p><ol><li>我们仍然总是插入到叶子节点中，所以拿你要插入的节点，用它沿着树向下遍历，根据要插入的节点是大于还是小于每个节点中的项目来左右移动。</li><li>将节点添加到叶节点后，如果新节点有 4 个节点，则弹出左侧中间的节点并相应地重新排列子节点。</li><li>如果这导致父节点有 4 个节点，则再次弹出左中间节点，相应地重新排列子节点。</li><li>重复此过程，直到父节点可以容纳或您到达根节点。</li></ol><h2 id="B树不变量"><a href="#B树不变量" class="headerlink" title="B树不变量"></a>B树不变量</h2><p>练习 11.3.1：按此顺序将 1-7 插入到 B 树中。树的高度是多少？我们可以改变插入的顺序，以便降低高度吗？这里有一个 <a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html/">很酷的 B 树可视化工具</a> 可能会有所帮助！</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209074745016.png" alt="image-20240209074745016"></p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209074805752.png" alt="image-20240209074805752"></p><blockquote><p>根据您插入节点的顺序，B 树的高度可能会发生变化。然而，这棵树将永远是浓密的。</p><p>高度为1的B-Tree需要先添加2-6，最后添加1和7实现。</p></blockquote><p>B 树具有以下有用的不变量：</p><ul><li>所有叶子与源的距离必须相同。</li><li>包含 <em>k</em> 项的非叶节点必须具有<em>k</em>+1 的子节点。</li></ul><p>同时，这些不变量导致树总是浓密的。</p><h2 id="B-Tree运行时分析"><a href="#B-Tree运行时分析" class="headerlink" title="B-Tree运行时分析"></a>B-Tree运行时分析</h2><p>在 B 树中搜索的最坏情况是，如果每个节点中都有最大数量的元素，我们必须一直遍历到底部。我们将用于 L 表示每个节点中的元素数量。这意味着需要探索节点（因为最大高度是 log<em>N</em> 由于灌木丛不变），并且在每个节点上，我们需要探索 <em>L</em>log<em>N</em> 元素。总的来说，我们需要运行 <em>L</em>log<em>N</em> 操作。但是，我们知道 <em>L</em> 是一个常数，因此我们的总运行时间是 O*(log*N) 。</p><h2 id="B-Tree-删除-（Extra）"><a href="#B-Tree-删除-（Extra）" class="headerlink" title="B-Tree 删除 （Extra）"></a>B-Tree 删除 （Extra）</h2><p>如果您好奇，请看 <a href="https://docs.google.com/presentation/d/1zhQDvbcDZ9RJgJl0bmqwFFlHP8ExbDFo36Q9ZWH9EgU/edit#slide=id.g508ece10b0_1_1305">these extra slides</a> 。我们不会在这里讨论它们。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>BST 有最佳情况高度 Θ(log<em>N</em>) 和最坏情况高度 Θ(<em>N</em>) 。</p><ul><li>大O与最坏的情况不是一回事！</li></ul><p>B 树是对二叉搜索树的修改，可避免 Θ(<em>N</em>) 最坏的情况。</p><ul><li>节点可以包含从1 到 <em>L</em>个 项目。</li><li>包含的工作原理几乎与普通 BST 完全相同。</li><li>通过向现有叶节点添加项目来添加工作。<ul><li>如果节点太满，它们就会分裂。</li></ul></li><li>由此产生的树具有完美的平衡。操作的运行时为: O*(log<em>N</em>) 。</li><li>没有讨论删除。如果您好奇，请参阅其他幻灯片。</li><li>没有讨论过拆分是如何工作的 <em>L</em>&gt;3 （参见其他类）。</li><li>B 树更复杂，但它们可以有效地处理任何插入顺序。</li></ul><blockquote><p>目前问题:</p><ul><li>分裂的实现过于复杂</li><li>删除的操作必须保证包含 <em>k</em> 项的非叶节点必须具有<em>k</em>+1 的子节点，因此删除会变得更加困难，可能需要添加额外的节点。</li></ul></blockquote><h1 id="旋转树"><a href="#旋转树" class="headerlink" title="旋转树"></a>旋转树</h1><p><a href="https://docs.google.com/presentation/d/1S27xlCPX0Up8WAHZPBqmbcrcKo4FNbyG6eTHamOxzgA/edit#slide=id.g7582c86fb_0984">cs61b 2020 lec18 ds4 balanced search trees - Google 幻灯片</a></p><p><a href="https://docs.google.com/presentation/d/1pfkQENfIBwiThGGFVO5xvlVp7XAUONI2BwBqYxib0A4/edit#slide=id.g465b5392c_00">rotation balancing demo - Google 幻灯片</a></p><h2 id="BST-结构"><a href="#BST-结构" class="headerlink" title="BST 结构"></a>BST 结构</h2><p>对于任何 BST，有多种方式可以构建它以保持 BST 不变性。在第 11.1 章中，我们讨论了如何以不同顺序插入元素将导致不同的 BST。以下 BST 都包含元素 1、2 和 3，但结构各异。</p><p>然而，插入并不是产生相同 BST 不同结构的唯一方法。我们可以通过一种称为<strong>旋转</strong>的过程改变已经放置节点的树。</p><h2 id="树的旋转"><a href="#树的旋转" class="headerlink" title="树的旋转"></a>树的旋转</h2><p>旋转的形式定义为：</p><ul><li><code>rotateLeft(G)</code>: 令 x 为 G 的右子节点。将 G 设为 x 的新左子节点。</li><li><code>rotateRight(G)</code>: 令 x 为 G 的左子节点。将 G 设为 x 的新右子节点。</li></ul><p>在接下来的几段文字中，我们将慢慢揭示这个过程。下面是对节点 G 进行左旋转时所发生的情况的图形描述。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209081017071.png" alt="image-20240209081017071"></p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209081034821.png" alt="image-20240209081034821"></p><p>G 的右子节点 P 与 G 合并，带着它的子节点一起。然后 P 将其左子节点传递给 G，并且 G 向左下移动成为 P 的左子节点。您可以看到树的结构以及级别数量发生了变化。我们也可以在非根节点上旋转。我们只需暂时断开节点与父节点的连接，旋转节点处的子树，然后重新连接新的根。</p><p>以下是 <code>rotateRight</code> 和 <code>rotateLeft</code> 的实现，由 <a href="https://algs4.cs.princeton.edu/33balanced/RedBlackBST.java.html">普林斯顿文档</a> 提供，为简单起见省略了一些代码行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">rotateRight</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    <span class="comment">// assert (h != null) &amp;&amp; isRed(h.left);</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> h.left;</span><br><span class="line">    h.left = x.right;</span><br><span class="line">    x.right = h;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make a right-leaning link lean to the left</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">rotateLeft</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    <span class="comment">// assert (h != null) &amp;&amp; isRed(h.right);</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> h.right;</span><br><span class="line">    h.right = x.left;</span><br><span class="line">    x.left = h;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过旋转，我们实际上可以完全平衡一棵树。在这些幻灯片中查看演示：<a href="https://docs.google.com/presentation/d/1pfkQENfIBwiThGGFVO5xvlVp7XAUONI2BwBqYxib0A4/edit#slide=id.g465b5392c_00">点击这里</a></p><p>在下一章中，我们将学习一种特定的树数据结构，通过使用旋转保持平衡。</p><h1 id="黑白树"><a href="#黑白树" class="headerlink" title="黑白树"></a>黑白树</h1><p><a href="https://docs.google.com/presentation/d/1S27xlCPX0Up8WAHZPBqmbcrcKo4FNbyG6eTHamOxzgA/edit#slide=id.g4694c9844_01030">cs61b 2020 lec18 ds4 balanced search trees - Google 幻灯片</a></p><p>在前一节中，我们说我们真的很喜欢 2-3 树，因为它们始终保持平衡，但我们也不喜欢它们，因为它们很难实现。但为什么不两者兼得呢？为什么不创建一棵使用 BST 实现的树，但在结构上与 2-3 树相同，因此保持平衡？（请注意，在本章中，我们将专注于 2-3 树，而不是 2-3-4 树）</p><h2 id="红黑树的介绍"><a href="#红黑树的介绍" class="headerlink" title="红黑树的介绍"></a>红黑树的介绍</h2><p>我们将通过查看 2-3 树来创建这棵树，并问自己我们可以进行什么样的修改来将其转换为 BST。</p><p>对于仅具有 2 个子节点（具有 2 个子节点的节点）的 2-3 树，我们已经有了一个 BST，因此我们不需要进行任何修改！</p><p>然而，当我们遇到 3 个节点时会发生什么呢？</p><p>我们可以创建一个“粘合”节点，该节点不包含任何信息，只用于显示其 2 个子节点实际上是一个节点的一部分。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209081406566.png" alt="image-20240209081406566"></p><p>然而，这是一个非常不优雅的解决方案，因为我们占用了更多的空间，并且代码会变得丑陋。因此，我们不使用粘合节点，而是使用粘合链接！</p><p>我们任意选择将左侧元素设为右侧元素的子节点。这导致了左倾树。我们通过将其标记为<strong>红色</strong>来显示链接为<strong>粘合链接</strong>。正常的链接是黑色的。由于这一点，我们将这些结构称为左倾红黑树（LLRB）。我们将在 61B 中使用左倾树。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209081418640.png" alt="image-20240209081418640"></p><p>左倾红黑树与 2-3 树具有一一对应的关系。每个 2-3 树都有与之关联的唯一 LLRB 红黑树。至于 2-3-4 树，它们与标准红黑树保持对应关系。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209081433983.png" alt="image-20240209081433983"></p><h2 id="LLRB-的属性"><a href="#LLRB-的属性" class="headerlink" title="LLRB 的属性"></a>LLRB 的属性</h2><p>LLRB(<strong>Left-Leaning Red Black Binary Search Tree</strong>)左倾黑白搜索树</p><p>以下是 LLRB 的属性：</p><ul><li>与 2-3 树具有一一对应的关系。</li><li>没有节点有 2 条红色链接。</li><li>没有红色右链接。</li><li>从根到叶的每条路径具有相同数量的黑色链接（因为 2-3 树到每个叶子的链接数相同）。</li><li>高度不超过相应 2-3 树的高度的 2 倍 + 1。</li></ul><blockquote><p>注意，当我们对应到2-3树的时候需要考虑2-3树的两个不变量:</p><ul><li>所有叶子与源的距离必须相同。</li><li>包含 <em>k</em> 项的非叶节点必须具有<em>k</em>+1 的子节点。</li></ul></blockquote><h2 id="LLRB-的插入"><a href="#LLRB-的插入" class="headerlink" title="LLRB 的插入"></a>LLRB 的插入</h2><p>我们可以通过向 2-3 树插入并使用上述方案转换来随时插入到 LLRB 树。但是，这与我们最初创建 LLRB 的目的相违背，即避免复杂的 2-3 树代码！相反，我们将像对待普通 BST 一样插入到 LLRB 中。然而，这可能会破坏它与 2-3 树的一一映射，因此我们将使用旋转将树调整回正确的结构。</p><p>在插入 LLRB 时，我们需要解决的不同任务如下。</p><p><strong>任务 1：插入颜色：</strong>因为在 2-3 树中，我们总是通过向叶节点添加来插入，所以我们添加的链接的颜色应始终为红色。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209081859814.png" alt="image-20240209081859814"></p><p><strong>任务 2：右侧插入：</strong> 回想一下，我们使用左倾红黑树，这意味着我们<strong>永远不能有右侧的红色链接</strong>。如果我们在右侧插入，我们将需要使用旋转来维护 LLRB 不变式。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209081919590.png" alt="image-20240209081919590"></p><p>但是，如果我们在右侧插入时有一个红色链接，且左子节点也是红色链接，则出于在任务 3 中将会更清楚的目的，我们将暂时允许它。</p><p><strong>任务 3：左侧双重插入：</strong> 如果存在 2 个连续的左链接，则我们有一个非法的 4 节点。首先，我们将旋转以创建在任务 2 中看到的相同树。然后，在这两种情况下，我们将翻转所有接触 S 的边的颜色。这相当于在 2-3 树中推动中间节点上升。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209081940480.png" alt="image-20240209081940480"></p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209082031744.png" alt="image-20240209082031744"></p><p>您可能需要经过一系列旋转才能完成转换。过程是：在 LLRB 树不满足与 2-3 树的一一对应或破坏 LLRB 不变式时，执行任务 1、2 或 3，具体取决于树的条件，直到您获得合法的 LLRB。</p><p><strong>任务4：分离临时的4节点</strong></p><p>如果存在具有两个红色子节点的任何节点，反转颜色。</p><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209082102708.png" alt="image-20240209082102708"></p><p>以下是所有操作的摘要：</p><ul><li>插入时：使用红色链接。</li><li>如果存在右倾的“3 节点”，我们有一个左倾违例<ul><li>旋转适当的节点向左以修复。</li></ul></li><li>如果有两个连续的左链接，我们有一个不正确的 4 节点违例！<ul><li>旋转适当的节点向右以修复。</li></ul></li><li>如果存在具有两个红色子节点的任何节点，我们有一个临时的 4 节点。<ul><li>颜色翻转节点以模拟拆分操作。</li></ul></li></ul><h2 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h2><p><img src="/2024/02/09/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-14-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd11-%E5%B9%B3%E8%A1%A1%E6%A0%91/image-20240209082331745.png" alt="image-20240209082331745"></p><p>由于左倾红黑树与 2-3 树具有一一对应的关系，并且始终保持在其 2-3 树的 2 倍高度之内，操作的运行时将花费<code> logN</code> 时间。</p><p>以下是插入 LLRB 的抽象代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">put</span><span class="params">(Node h, Key key, Value val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, val, RED); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(h.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)      &#123; h.left  = put(h.left,  key, val); &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123; h.right = put(h.right, key, val); &#125;</span><br><span class="line">    <span class="keyword">else</span>              &#123; h.val   = val;                    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left))      &#123; h = rotateLeft(h);  &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.left.left)) &#123; h = rotateRight(h); &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.right))     &#123; flipColors(h);      &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>二叉搜索树很简单，但易受不平衡的影响，导致糟糕的运行时。</li><li>2-3 树（B 树）是平衡的，但实现起来痛苦，而且相对较慢。</li><li>LLRB 的插入简单易行（但删除困难）。</li><li>通过与 2-3 树保持数学双射来工作。</li><li>Java 的 <a href="%5BTreeMap%5D(https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/999dbd4192d0f819cb5224f26e9e7fa75ca6f289/src/java.base/share/classes/java/util/TreeMap.java)">TreeMap</a> 是一棵红黑树（但不是左倾的）。</li><li>LLRB 与 2-3 树保持一致，标准红黑树与 2-3-4 树保持一致。</li><li>允许在任一侧使用粘合链接（请参阅<a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red-Black Tree</a>）。</li><li>实现更复杂，但速度明显更快。</li></ul><blockquote><p>删除过于复杂，暂不讨论</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B项目笔记(五)-Lab7-二叉查找树</title>
      <link href="/2024/02/07/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-4-CS61b%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab7-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
      <url>/2024/02/07/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-4-CS61b%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab7-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://sp21.datastructur.es/materials/lab/lab7/lab7">Lab 7: BSTMap | CS 61B Spring 2021 (datastructur.es)</a></p><p><img src="/2024/02/07/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-4-CS61b%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab7-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/image-20240207100309645.png" alt="image-20240207100309645"></p><p>创建一个 BSTMap 类，它使用 BST（二叉搜索树）作为其核心数据结构来实现 Map61B 接口。您必须在名为 <code>BSTMap.java</code> 的文件中执行此操作。您的实现需要实现 Map61B 中给出的所有方法，但 <code>remove</code> 、 <code>iterator</code> 和 <code>keySet</code> 除外。对于这些方法，您应该抛出一个 <code>UnsupportedOperationException</code> </p><p>在创建 <code>BSTMap</code> 类并实现 Map61B 的所有方法之前，您的代码不会编译。您可以一次实现一个方法，方法是编写所有必需方法的方法签名，但为实现抛出 <code>UnsupportedOperationExceptions</code> ，直到您真正开始编写它们。</p><p>您的 <code>BSTMap</code> 还应该添加一个附加方法 <code>printInOrder()</code> （Map61B 接口中未给出），该方法按 Key 递增的顺序打印出 BSTMap。我们不会测试此方法的结果，但您会发现这对测试您的实现很有帮助！</p><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ul><li>Lecture 16 <a href="https://docs.google.com/presentation/d/1Bl-PTBfa5sp1vM1l0OSMpK_0JFQ-MT6je4O26-9ffpg/edit#slide=id.g50738e5fde_0_0">slides</a>. 讲座 16 幻灯片。</li><li>BST 代码来自我们的课程资源页面的<a href="http://www-inst.eecs.berkeley.edu/~cs61b/fa14/book2/data-structures.pdf">Data Structures Into Java</a> 第 109 和 111 页。</li><li>来自我们<a href="https://algs4.cs.princeton.edu/32bst/BST.java.html">our optional textbook</a>.的 BST 代码。</li><li><code>ULLMap.java</code> （已提供），一个基于 Map61B 实现的工作<strong>无序链接列表。</strong></li></ul><h1 id="BSTMap"><a href="#BSTMap" class="headerlink" title="BSTMap"></a>BSTMap</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bstmap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSTMap</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt; <span class="keyword">implements</span> <span class="title class_">Map61B</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;             <span class="comment">// root of BST</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> K key;           <span class="comment">// sorted by key</span></span><br><span class="line">        <span class="keyword">private</span> V val;         <span class="comment">// associated data</span></span><br><span class="line">        <span class="keyword">private</span> Node left, right;  <span class="comment">// left and right subtrees</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> size;          <span class="comment">// number of nodes in subtree</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V val, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.size = size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes an empty symbol table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTMap</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        root.size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        clear(root);</span></span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private Node clear(Node node) &#123;</span></span><br><span class="line"><span class="comment">//        if (node == null) &#123;</span></span><br><span class="line"><span class="comment">//            return null;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if (node.left != null) &#123;</span></span><br><span class="line"><span class="comment">//            node.left = clear(node.left);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if (node.right != null) &#123;</span></span><br><span class="line"><span class="comment">//            node.right = clear(node.right);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return null;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to contains() is null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> conainsKey(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">conainsKey</span><span class="params">(Node n, K key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(n.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> conainsKey(n.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> conainsKey(n.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> V <span class="title function_">get</span><span class="params">(Node n, K key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to contains() is null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(n.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> get(n.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> get(n.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">(Node x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to contains() is null&quot;</span>);</span><br><span class="line">        root = put(root, key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">put</span><span class="params">(Node node, K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.right = put(node.right, key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.left = put(node.left, key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.val = value;</span><br><span class="line">        &#125;</span><br><span class="line">        node.size = <span class="number">1</span> + size(node.right) + size(node.left);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printInOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to contains() is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to contains() is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to contains() is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to contains() is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to contains() is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private class MapIterator implements Iterator&lt;K&gt; &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        /**</span></span><br><span class="line"><span class="comment">//         * Returns &#123;@code true&#125; if the iteration has more elements.</span></span><br><span class="line"><span class="comment">//         * (In other words, returns &#123;@code true&#125; if &#123;@link #next&#125; would</span></span><br><span class="line"><span class="comment">//         * return an element rather than throwing an exception.)</span></span><br><span class="line"><span class="comment">//         *</span></span><br><span class="line"><span class="comment">//         * @return &#123;@code true&#125; if the iteration has more elements</span></span><br><span class="line"><span class="comment">//         */</span></span><br><span class="line"><span class="comment">//        int size = size();</span></span><br><span class="line"><span class="comment">//        MapIterator() &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        @Override</span></span><br><span class="line"><span class="comment">//        public boolean hasNext() &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        /**</span></span><br><span class="line"><span class="comment">//         * Returns the next element in the iteration.</span></span><br><span class="line"><span class="comment">//         *</span></span><br><span class="line"><span class="comment">//         * @return the next element in the iteration</span></span><br><span class="line"><span class="comment">//         */</span></span><br><span class="line"><span class="comment">//        @Override</span></span><br><span class="line"><span class="comment">//        public K next() &#123;</span></span><br><span class="line"><span class="comment">//            return null;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="ULLMap"><a href="#ULLMap" class="headerlink" title="ULLMap"></a>ULLMap</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bstmap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** A data structure that uses a linked list to store pairs of keys and values.</span></span><br><span class="line"><span class="comment"> *  Any key must appear at most once in the dictionary, but values may appear multiple</span></span><br><span class="line"><span class="comment"> *  times. Key operations are get(key), put(key, value), and contains(key) methods. The value</span></span><br><span class="line"><span class="comment"> *  associated to a key is the value in the last call to put with that key. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ULLMap</span>&lt;K, V&gt;  <span class="keyword">implements</span> <span class="title class_">Map61B</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns the value corresponding to KEY or null if no such value exists. */</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">lookup</span> <span class="operator">=</span> list.get(key);</span><br><span class="line">        <span class="keyword">if</span> (lookup == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lookup.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes all of the mappings from this map. */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        list = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts the key-value pair of KEY and VALUE into this dictionary,</span></span><br><span class="line"><span class="comment">     *  replacing the previous value associated to KEY, if any. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Entry</span> <span class="variable">lookup</span> <span class="operator">=</span> list.get(key);</span><br><span class="line">            <span class="keyword">if</span> (lookup == <span class="literal">null</span>) &#123;</span><br><span class="line">                list = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, val, list);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lookup.val = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, val, list);</span><br><span class="line">            size = size + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns true if and only if this dictionary contains KEY as the</span></span><br><span class="line"><span class="comment">     *  key of some key-value pair. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(key) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ULLMapIter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Keys and values are stored in a linked list of Entry objects.</span></span><br><span class="line"><span class="comment">     *  This variable stores the first pair in this linked list. */</span></span><br><span class="line">    <span class="keyword">private</span> Entry list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Represents one node in the linked list that stores the key-value pairs</span></span><br><span class="line"><span class="comment">     *  in the dictionary. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Stores KEY as the key in this key-value pair, VAL as the value, and</span></span><br><span class="line"><span class="comment">         *  NEXT as the next node in the linked list. */</span></span><br><span class="line">        Entry(K k, V v, Entry n) &#123;</span><br><span class="line">            key = k;</span><br><span class="line">            val = v;</span><br><span class="line">            next = n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Returns the Entry in this linked list of key-value pairs whose key</span></span><br><span class="line"><span class="comment">         *  is equal to KEY, or null if no such Entry exists. */</span></span><br><span class="line">        Entry <span class="title function_">get</span><span class="params">(K k)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k != <span class="literal">null</span> &amp;&amp; k.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> next.get(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Stores the key of the key-value pair of this node in the list. */</span></span><br><span class="line">        K key;</span><br><span class="line">        <span class="comment">/** Stores the value of the key-value pair of this node in the list. */</span></span><br><span class="line">        V val;</span><br><span class="line">        <span class="comment">/** Stores the next Entry in the linked list. */</span></span><br><span class="line">        Entry next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** An iterator that iterates over the keys of the dictionary. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ULLMapIter</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;K&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Create a new ULLMapIter by setting cur to the first node in the</span></span><br><span class="line"><span class="comment">         *  linked list that stores the key-value pairs. */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ULLMapIter</span><span class="params">()</span> &#123;</span><br><span class="line">            cur = list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cur != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> K <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">ret</span> <span class="operator">=</span> cur.key;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Stores the current key-value pair. */</span></span><br><span class="line">        <span class="keyword">private</span> Entry cur;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Map61B接口"><a href="#Map61B接口" class="headerlink" title="Map61B接口"></a>Map61B接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bstmap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Your implementation BSTMap should implement this interface. To do so,</span></span><br><span class="line"><span class="comment"> * append &quot;implements Map61B&lt;K,V&gt;&quot; to the end of your &quot;public class...&quot;</span></span><br><span class="line"><span class="comment"> * declaration, though you can use other formal type parameters if you&#x27;d like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map61B</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;K&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes all of the mappings from this map. */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns true if this map contains a mapping for the specified key. */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(K key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns the value to which the specified key is mapped, or null if this</span></span><br><span class="line"><span class="comment">     * map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(K key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns the number of key-value mappings in this map. */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Associates the specified value with the specified key in this map. */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns a Set view of the keys contained in this map. Not required for Lab 7.</span></span><br><span class="line"><span class="comment">     * If you don&#x27;t implement this, throw an UnsupportedOperationException. */</span></span><br><span class="line">    Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Removes the mapping for the specified key from this map if present.</span></span><br><span class="line"><span class="comment">     * Not required for Lab 7. If you don&#x27;t implement this, throw an</span></span><br><span class="line"><span class="comment">     * UnsupportedOperationException. */</span></span><br><span class="line">    V <span class="title function_">remove</span><span class="params">(K key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Removes the entry for the specified key only if it is currently mapped to</span></span><br><span class="line"><span class="comment">     * the specified value. Not required for Lab 7. If you don&#x27;t implement this,</span></span><br><span class="line"><span class="comment">     * throw an UnsupportedOperationException.*/</span></span><br><span class="line">    V <span class="title function_">remove</span><span class="params">(K key, V value)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(十三)-Rd10-ADP、树</title>
      <link href="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/"/>
      <url>/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>Slides:<a href="https://docs.google.com/presentation/d/1Bl-PTBfa5sp1vM1l0OSMpK_0JFQ-MT6je4O26-9ffpg/edit#slide=id.g50738e5fde_0_6">cs61b 2020 lec16 ds2 adts, sets, maps, binary search trees - Google 幻灯片</a></p><p>Reading:<a href="https://joshhug.gitbooks.io/hug61b/content/chap10/chap102.html">10.2 Trees · Hug61B (gitbooks.io)</a></p><h1 id="ADTs"><a href="#ADTs" class="headerlink" title="ADTs"></a>ADTs</h1><iframe frameborder="0" allowfullscreen src="https://www.youtube.com/embed/aFOSePlOExw" style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; font-size: inherit; border: none; top: 0px; left: 0px; width: 770px; height: 458.125px;"></iframe><p>抽象数据类型（ADT）仅通过其操作进行定义，而不是通过其实现。</p><blockquote><p>这意味着ADT定义了一组操作或行为，而不涉及具体的实现细节。</p></blockquote><p>例如，在proj1a中，我们开发了一个<code>ArrayDeque</code>和一个<code>LinkedListDeque</code>，它们具有<strong>相同的方法</strong>，但这些方法的编写方式非常不同。在这种情况下，我们说<code>ArrayDeque</code>和<code>LinkedListDeque</code>是Deque ADT的<em>实现</em>。从这个描述中，我们可以看出ADT和接口在某种程度上是相关的。</p><blockquote><p>ADT强调的是数据和操作的抽象描述，而接口强调的是行为和操作的规范定义。</p></blockquote><p>在概念上，Deque是一个接口，<code>ArrayDeque</code>和<code>LinkedListDeque</code>是其实现。在代码中，为了表达这种关系，我们让<code>ArrayDeque</code>和<code>LinkedListDeque</code>类从Deque接口继承。</p><p>一些常用的ADT包括：</p><ul><li><p>栈(Stack)：支持后进先出检索元素的结构</p><ul><li><code>push(int x)</code>: 将x放在栈顶</li><li><code>int pop()</code>: 取出栈顶元素</li></ul></li><li><p>列表(List)</p><p>: 一组有序的元素</p><ul><li><code>add(int i)</code>: 添加一个元素</li><li><code>int get(int i)</code>: 获取索引为i的元素</li></ul></li><li><p>集合(Set)</p><p>: 一组无序的唯一元素（不重复）</p><ul><li><code>add(int i)</code>: 添加一个元素</li><li><code>contains(int i)</code>: 返回集合中是否包含该值的布尔值</li></ul></li><li><p>映射(Map)</p><p>: 一组键&#x2F;值对</p><ul><li><code>put(K key, V value)</code>: 将一个键值对放入映射</li><li><code>V get(K key)</code>: 获取与键对应的值</li></ul></li></ul><p><strong>加粗的ADT是一个名为<code>Collections</code>的更大的总体接口的子接口</strong></p><p>下面我们展示接口和类之间的关系。接口为白色，类为蓝色。</p><p>ADT使我们能够以高效而优雅的方式利用面向对象编程。您在proj1b中看到了我们如何交换<code>OffByOne</code>和<code>OffByN</code>比较器，因为它们都实现了相同的接口！同样，您可以交替使用ArrayDeque或LinkedListArrayDeque，因为它们都是Deque ADT的一部分。</p><p>在接下来的章节中，我们将致力于定义一些更多的ADT并列举它们的不同实现。</p><h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>现在我们要学习可能是有史以来最重要的数据结构之一。</p><iframe width="475" height="292" src="https://www.youtube.com/embed/AcRKQOe0zYg" title="[ADTs, Sets, Maps, BSTs, Video 2] - Inventing the BST" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>链表很棒，但是查找项需要很长时间，即使列表是排序的！如果项目在列表的末尾怎么办？那将花费线性时间！看一下下面的链表，并让自己相信这是真的。</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095104937.png" alt="image-20240207095104937"></p><blockquote><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095200910.png" alt="image-20240207095200910"></p><p><a href="https://en.wikipedia.org/wiki/Skip_list">跳过列表 - 维基百科 — Skip list - Wikipedia</a></p></blockquote><p>我们知道，对于数组，我们可以使用二分查找来更快地找到元素。具体地说，时间复杂度是<code>log(*n*)</code>。关于二分查找的简短解释，请查看此<a href="https://www.geeksforgeeks.org/binary-search/">链接</a>。</p><p>TL;DR：在二分查找中，我们知道列表是排序的，因此我们可以利用这一信息来缩小搜索范围。首先，我们查看中间元素。如果它大于我们要查找的元素，则向左查找。如果它小于我们要查找的元素，则向右查找。然后，我们查看各自一半的中间元素，并重复此过程，直到找到我们要查找的元素（或因为列表不包含它而找不到）。</p><p>但是，我们如何在链表中运行二分查找呢？我们需要遍历到中间位置才能检查那里的元素，这本身就需要线性时间！</p><p>我们可以实现一种优化，即具有对中间节点的引用。这样，我们可以在常数时间内到达中间位置。然后，如果我们翻转节点的指针，这样就可以遍历到左右两半，从而将运行时间减半！</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095039828.png" alt="image-20240207095039828"></p><p>但是，我们可以做得更好。我们可以通过像下面这样在每个递归半部分的中间添加指针来进一步优化。</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095020256.png" alt="image-20240207095020256"></p><p>现在，如果你垂直拉伸这个结构，你会看到一棵树！</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095026028.png" alt="image-20240207095026028"></p><p>这棵具体的树称为<strong>二叉树</strong>，因为每个交叉点分为两个。</p><h3 id="树的属性"><a href="#树的属性" class="headerlink" title="树的属性"></a>树的属性</h3><p>让我们更加正式地定义树数据结构。</p><iframe width="770" height="458" src="https://www.youtube.com/embed/slOxliXDV-s" title="[ADTs, Sets, Maps, BSTs, Video 3] - BST Definitions" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>树由以下组成：</p><ul><li>节点</li><li>将这些节点连接起来的边。<ul><li><strong>约束</strong>：任何两个节点之间只有一条路径。</li></ul></li></ul><p>在某些树中，我们选择一个<strong>根</strong>节点，这是一个没有父节点的节点。</p><p>树还有<strong>叶子节点</strong>，它们是没有子节点的节点。</p><p>下面的结构是有效的树：<img src="https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-02-28%20at%209.25.43%20AM.png" alt="img"></p><p><strong>练习 10.2.1：</strong>你能想出一个非有效的树的例子吗？</p><p>将这与我们之前提出的原始树结构联系起来，我们现在可以对已有的约束引入新的约束。这创建了更具体的树类型，其中两个示例是二叉树和二叉搜索树。</p><ul><li><strong>二叉树</strong>：除了上述要求外，还满足二进制属性约束。即每个节点只有0、1或2个子节点。</li><li><strong>二叉搜索树</strong>：除了所有上述要求外，还具有以下属性：对于树中的每个节点X：<ul><li>左子树中的每个键都小于X的键。</li><li>右子树中的每个键都大于X的键。<strong>记住这个属性！！</strong>我们在本模块和61B的整个持续时间中将引用它很多次。</li></ul></li></ul><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095307884.png" alt="image-20240207095307884"></p><blockquote><p>满足对称性和传递性</p></blockquote><p>这是我们在本模块中将使用的BST类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">BST</span>&lt;Key&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Key key;</span><br><span class="line">    <span class="keyword">private</span> BST left;</span><br><span class="line">    <span class="keyword">private</span> BST right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BST</span><span class="params">(Key key, BST left, BST Right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BST</span><span class="params">(Key key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树操作"><a href="#二叉搜索树操作" class="headerlink" title="二叉搜索树操作"></a>二叉搜索树操作</h2><iframe width="770" height="458" src="https://www.youtube.com/embed/PLyDf3_J7Cc" title="[ADTs, Sets, Maps, BSTs, Video 4] - BST Search" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>要搜索某个元素，我们使用二分查找，这在很大程度上是由于前一节中描述的BST属性的便利！</p><p>我们知道BST被构造得使得节点的右侧所有元素都大于节点，并且左侧所有元素都小于节点。基于此，我们可以从根节点开始，将其与我们正在查找的元素X进行比较。如果X大于根，则我们转向根的右子节点。如果X小于根，则我们转向根的左子节点。我们递归地重复这个过程，直到我们找到项目或者我们到达一个叶子节点，在这种情况下，树不包含该项目。</p><p><strong>练习 10.2.2：</strong>尝试自己编写此方法。这是方法头：<code>static BST find(BST T, Key key)</code>。它应返回以与键参数匹配的键根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> BST <span class="title function_">find</span><span class="params">(BST T, Key sk)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (T == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (sk.equals(T.key))</span><br><span class="line">      <span class="keyword">return</span> T;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (sk ≺ T.key)</span><br><span class="line">      <span class="keyword">return</span> find(T.left, sk);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> find(T.right, sk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们的树相对“茂密”，那么find操作将在log(�)log(<em>n</em>)时间内运行，因为树的高度是logn，这相当快！</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><iframe width="770" height="458" src="https://www.youtube.com/embed/otDvoMb8UqE" title="[ADTs, Sets, Maps, BSTs, Video 5] - BST Insert" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>我们<strong>总是</strong>在叶子节点插入！</p><p>首先，我们在树中搜索节点。如果我们找到它，则不做任何操作。如果我们找不到它，则我们已经在叶子节点上。此时，我们只需将新元素添加到叶子的左侧或右侧，保持BST属性不变。</p><p><strong>练习 10.2.3：</strong>尝试自己编写此方法。这是方法头：<code>static BST insert(BST T, Key ik)</code>。它应返回插入了正确位置的新节点的完整BST。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BST <span class="title function_">insert</span><span class="params">(BST T, Key ik)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (T == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BST</span>(ik);</span><br><span class="line">  <span class="keyword">if</span> (ik ≺ T.key)</span><br><span class="line">    T.left = insert(T.left, ik);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ik ≻ T.key)</span><br><span class="line">    T.right = insert(T.right, ik);</span><br><span class="line">  <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习 10.2.4：</strong>想出一种插入顺序，会导致树的高度不同。尝试找到树高度的两种极端情况。提示：您的第一个插入将决定随后插入的行为。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><iframe width="770" height="458" src="https://www.youtube.com/embed/vPzB6svl4rc" title="[ADTs, Sets, Maps, BSTs, Video 6] - BST Deletion" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>从二叉树中删除节点稍微复杂一些，因为每当我们删除时，我们都需要确保重构树并仍然保持其BST属性。</p><p>让我们将此问题分为三个类别：</p><ul><li>我们尝试删除的节点没有子节点</li><li>有一个子节点</li><li>有两个子节点</li></ul><h4 id="没有子节点"><a href="#没有子节点" class="headerlink" title="没有子节点"></a>没有子节点</h4><p>如果节点没有子节点，则它是一个叶子，我们可以只删除其父节点指针，节点最终会被<a href="https://stackoverflow.com/questions/3798424/what-is-the-garbage-collector-in-java">垃圾回收器</a>清除。</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095555283.png" alt="image-20240207095555283"></p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095604465.png" alt="image-20240207095604465"></p><h4 id="一个子节点"><a href="#一个子节点" class="headerlink" title="一个子节点"></a>一个子节点</h4><p>如果节点只有一个子节点，我们知道该子节点与节点的父节点保持BST属性，因为该属性对右和左子树是递归的。因此，我们只需重新分配父节点的子节点指针到节点的子节点，节点最终将被垃圾回收。</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095614371.png" alt="image-20240207095614371"></p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095632829.png" alt="image-20240207095632829"></p><h4 id="两个子节点"><a href="#两个子节点" class="headerlink" title="两个子节点"></a>两个子节点</h4><p>如果节点有两个子节点，则该过程变得稍微复杂，因为我们不能简单地将一个子节点指定为新根。这可能会破坏BST属性。</p><p>相反，我们选择一个新节点来替换删除的节点。</p><p>我们知道新节点必须：</p><ul><li>大于左子树中的所有内容。</li><li>小于右子树中的所有内容。</li></ul><p>在下面的树中，我们展示了哪些节点将满足这些要求，假设我们要删除<code>dog</code>节点。</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095730453.png" alt="image-20240207095730453"></p><p>要找到这些节点，您可以选择左子树中的最右节点或右子树中的最左节点。</p><p>然后，我们用<code>cat</code>或<code>elf</code>替换<code>dog</code>节点，然后删除旧的<code>cat</code>或<code>elf</code>节点。</p><p>这称为<strong>Hibbard删除</strong>，在删除中保持了BST属性。</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095803817.png" alt="image-20240207095803817"></p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095812382.png" alt="image-20240207095812382"></p><blockquote><p>若将树重新拉直，k左右两边将会是g和m，我们只需要将其中一个替换掉k，那么就能实现删除的同时保持树的特性！</p></blockquote><h2 id="作为集合和映射的BST"><a href="#作为集合和映射的BST" class="headerlink" title="作为集合和映射的BST"></a>作为集合和映射的BST</h2><iframe width="770" height="458" src="https://www.youtube.com/embed/sL2p1slgUMg" title="[ADTs, Sets, Maps, BSTs, Video 7] - Sets vs Maps, Summary, Tips for Lab" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>我们可以使用BST来实现<code>Set</code> ADT！但是它更好，因为在<code>ArraySet</code>中，我们需要在最坏的情况下<code>O*(*n*)</code>时间来运行<code>contains</code>，因为我们需要搜索整个集合。但是，如果我们使用BST，我们可以将此运行时间减少到log(<em>n</em>)&#96;，因为BST属性使我们能够使用二分查找！</p><p>我们还可以通过使每个BST节点保存<code>(key,value)</code>对而不是单个值来将二叉树转换为映射。我们将比较每个元素的键以确定在树中的位置。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>抽象数据类型（ADTs）是根据操作而不是实现来定义的。</p><p>几种有用的ADT：</p><ul><li>不相交集、映射、集合、列表。</li><li>Java提供了映射、集合、列表接口，以及几种实现。</li></ul><p>我们已经看到了实现Set（或Map）的两种方法：</p><ul><li>ArraySet：在最坏的情况下，需要<code>Θ(*N*)</code>的操作。</li><li>BST：如果树是平衡的，则需要Θ(log<em>N</em>)&#96;的操作。</li></ul><p>BST实现：</p><ul><li>搜索和插入都很简单（但插入有点棘手）。</li><li>删除更具挑战性。典型的方法是“Hibbard删除”。</li></ul><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-13-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd10-ADP%E3%80%81%E6%A0%91/image-20240207095946155.png" alt="image-20240207095946155"></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(十二)-Rd8.9-不相交集</title>
      <link href="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/"/>
      <url>/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>slide:<a href="https://docs.google.com/presentation/d/1I9Jzt95GvxRqwGMzN7DSEIREKhMZ0qEUzPyWLl6CU5g/edit#slide=id.g5347e2c8f_210">cs61b 2020 lec14 ds1 disjoint sets - Google 幻灯片</a></p><p>Reading:<a href="https://joshhug.gitbooks.io/hug61b/content/chap9/chap91.html">9.1 Introduction · Hug61B (gitbooks.io)</a></p><p>code:<a href="https://algs4.cs.princeton.edu/15uf/">Case Study: Union-Find (princeton.edu)</a></p><h1 id="Disjoint-Sets简介"><a href="#Disjoint-Sets简介" class="headerlink" title="Disjoint Sets简介"></a>Disjoint Sets简介</h1><p>如果两个集合没有共同元素，则称它们为<em>不相交集合</em>。一个不相交集合（或者称为并查集）数据结构用于追踪固定数量的元素，这些元素被划分为多个<em>不相交集合</em>。该数据结构具有两个操作：</p><ol><li><code>connect(x, y)</code>: 连接 <code>x</code> 和 <code>y</code>。也称为 <code>union</code>。</li><li><code>isConnected(x, y)</code>: 如果 <code>x</code> 和 <code>y</code> 连接（即属于同一集合），则返回true。</li></ol><p>不相交集合数据结构有一定数量的元素，每个元素最初都位于自己的子集中。通过对某些元素 <code>x</code> 和 <code>y</code> 调用 <code>connect(x, y)</code>，我们可以将子集合并在一起。</p><p>例如，假设我们有四个元素，我们将它们称为 A、B、C、D。初始时，每个元素都在自己的集合中：</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/intro1_resized.png" alt="img"></p><p>调用 <code>connect(A, B)</code> 后：</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/intro2_resized.png" alt="img"></p><p>请注意，子集 A 和 B 被合并。让我们来检查一些 <code>isConnected</code> 调用的输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CodeisConnected(A, B) -&gt; <span class="literal">true</span></span><br><span class="line"><span class="title function_">isConnected</span><span class="params">(A, C)</span> -&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>调用 <code>connect(A, D)</code> 后：</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/intro3_resized.png" alt="img"></p><p>我们找到了 A 所属的集合，并将其与 D 所属的集合合并，形成了一个大的 A、B、D 集合。C 保持不变。 <code>isConnected(A, D) -&gt; true</code> <code>isConnected(A, C) -&gt; false</code></p><p>有了这个直观理解，让我们正式定义一下我们的不相交集合接口是什么样子的。作为提醒，一个 <strong>接口</strong> 确定了一个数据结构应该具有的行为（但不包括实现方法）。现在，我们只处理非负整数集合。这并不是一个限制，因为在实际应用中，我们可以为我们想要表示的任何内容分配整数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line">    <span class="comment">/** 连接两个项目 P 和 Q */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 检查两个项目是否连接 */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了学习如何实现一个迷人的数据结构之外，这一章还将是一个了解数据结构实现如何演变的机会。我们将讨论四个不相交集合设计的迭代过程：<em>Quick Find → Quick Union → Weighted Quick Union (WQU) → WQU with Path Compression</em>。<strong>我们将看到设计决策如何极大地影响渐近运行时间和代码复杂度。</strong></p><h1 id="快速查找Quick-Find"><a href="#快速查找Quick-Find" class="headerlink" title="快速查找Quick Find"></a>快速查找Quick Find</h1><iframe width="770" height="458" src="https://www.youtube.com/embed/W6Dckcv8PIo" title="[Disjoint Sets, Video 2] - Quick Find" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>现在我们来解决如何实现我们的 <code>DisjointSets</code> 接口所需的行为。我们的挑战是跟踪集合成员关系。</p><h2 id="集合列表"><a href="#集合列表" class="headerlink" title="集合列表"></a>集合列表</h2><p>直观地，我们可能首先考虑将不相交集合表示为一个集合列表，例如 <code>List&lt;Set&lt;Integer&gt;&gt;</code>。</p><p>例如，如果我们有 N&#x3D;6 个元素，并且还没有连接任何元素，我们的集合列表看起来像：<code>[&#123;0&#125;, &#123;1&#125;, &#123;2&#125;, &#123;3&#125;, &#123;4&#125;, &#123;5&#125;, &#123;6&#125;]</code>。看起来不错。然而，考虑如何完成像 <code>connect(5, 6)</code> 这样的操作。我们将不得不遍历多达 <code>N</code> 个集合来找到5，以及多达 <code>N</code> 个集合来找到6。我们的运行时间变为 <code>O(N)</code>。而且，如果你试图实现这个，代码会非常复杂。</p><blockquote><p>要记住的教训是 <strong>初始设计决策决定了我们的代码复杂度和运行时间。</strong></p></blockquote><h2 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a>快速查找</h2><p>让我们考虑另一种方法，使用一个 <em>整数数组</em>。</p><ul><li>数组的<strong>索引</strong>表示我们集合的元素。</li><li>索引处的<strong>值</strong>是它所属的集合编号。</li></ul><p>例如，我们将 <code>&#123;0, 1, 2, 4&#125;, &#123;3, 5&#125;, &#123;6&#125;</code> 表示为：</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/9.2.1-1707267489271-11.png" alt="img"></p><p>数组索引（0…6）是元素。<code>id[i]</code> 处的值是它所属的集合。<em>具体的集合编号并不重要，只要同一集合中的所有元素共享相同的id。</em></p><h3 id="connect-x-y"><a href="#connect-x-y" class="headerlink" title="connect(x, y)"></a><code>connect(x, y)</code></h3><p>让我们看看连接操作如何工作。当前，<code>id[2] = 4</code> 和 <code>id[3] = 5</code>。调用 <code>connect(2, 3)</code> 后，所有id为4和5的元素应该具有相同的id。现在暂时将它们全部赋值为5：</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/9.2.2-1707267498002-14.png" alt="img"></p><h3 id="isConnected-x-y"><a href="#isConnected-x-y" class="headerlink" title="isConnected(x, y)"></a><code>isConnected(x, y)</code></h3><p>要检查 <code>isConnected(x, y)</code>，我们只需检查 <code>id[x] == id[y]</code>。请注意，这是一个常数时间操作！</p><p>我们将此实现称为 “快速查找”，因为查找元素是否相连需要常数时间。</p><h3 id="总结和代码"><a href="#总结和代码" class="headerlink" title="总结和代码"></a>总结和代码</h3><table><thead><tr><th>实现方式</th><th>构造函数</th><th><code>connect</code></th><th><code>isConnected</code></th></tr></thead><tbody><tr><td>集合列表</td><td>Θ(N)</td><td>O(N)</td><td>O(N)</td></tr><tr><td>快速查找</td><td>Θ(N)</td><td>Θ(N)</td><td>Θ(1)</td></tr></tbody></table><p>N &#x3D; 不相交集合数据结构中的元素数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickFindDS</span> <span class="keyword">implements</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Θ(N) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuickFindDS</span><span class="params">(<span class="type">int</span> N)</span>&#123;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 需要遍历数组 =&gt; Θ(N) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> id[p];</span><br><span class="line">        <span class="type">int</span> <span class="variable">qid</span> <span class="operator">=</span> id[q];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; id.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (id[i] == pid)&#123;</span><br><span class="line">                id[i] = qid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Θ(1) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (id[p] == id[q]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速合并Quick-Union"><a href="#快速合并Quick-Union" class="headerlink" title="快速合并Quick Union"></a>快速合并Quick Union</h1><iframe width="770" height="458" src="https://www.youtube.com/embed/RY7UCusguGg" title="[Disjoint Sets, Video 3] - Quick Union" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>假设我们优先考虑使 <code>connect</code> 操作快速。我们仍然将使用数组来表示我们的集合。但是，与其使用一个id，我们将每个项目分配给其父项的索引。如果一个项目没有父项，那么它就是一个 ‘根’，我们为其分配一个负值。</p><p>这种方法使我们可以将我们的每个集合想象成一棵树。例如，我们将 <code>&#123;0, 1, 2, 4&#125;, &#123;3, 5&#125;, &#123;6&#125;</code> 表示为：</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/9.3.1-1707267897651-23.png" alt="img"></p><p>请注意，我们使用<strong>只有一个数组</strong>来表示集合。我们自己将其视为树。</p><p>对于快速合并，我们定义一个辅助函数 <code>find(int item)</code>，它返回项目所在树的根。例如，对于上面的集合，<code>find(4) == 0</code>，<code>find(1) == 0</code>，<code>find(5) == 3</code> 等。每个元素都有一个唯一的根。</p><h2 id="connect-x-y-1"><a href="#connect-x-y-1" class="headerlink" title="connect(x, y)"></a><code>connect(x, y)</code></h2><p>要连接两个项目，我们找到每个项目所属的集合（它们各自树的根），并将其中一个作为另一个的子项。例如：</p><p><code>connect(5, 2)</code>：</p><ol><li><code>find(5)</code> -&gt; 3</li><li><code>find(2)</code> -&gt; 0</li><li>设置 <code>find(5)</code> 的值为 <code>find(2)</code>，也就是 <code>parent[3] = 0</code></li></ol><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/9.3.2-1707267923567-26.png" alt="img"></p><p>请注意，元素3现在指向元素0，将两棵树&#x2F;集合合并为一棵树。</p><p>在最佳情况下，如果 <code>x</code> 和 <code>y</code> 都是它们树的根，那么 <code>connect(x, y)</code> 就会简单地使 <code>x</code> 指向 <code>y</code>，这是一个 Θ(1) 的操作！（因此称为快速合并）</p><h2 id="isConnected-x-y-1"><a href="#isConnected-x-y-1" class="headerlink" title="isConnected(x, y)"></a><code>isConnected(x, y)</code></h2><p>如果两个元素属于同一个集合，那么它们将在同一棵树中。因此，它们将具有相同的根。因此对于 <code>isConnected(x, y)</code>，我们只需检查 <code>find(x) == find(y)</code>。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>快速合并存在潜在的性能问题：树可能变得非常长。在这种情况下，找到一个项目的根 (<code>find(item)</code>) 就变得非常昂贵。考虑下面的树：</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/9.3.3.png" alt="9.3.3"></p><p>在最坏的情况下，我们必须遍历所有项目才能到达根，这是一个 Θ(N) 的运行时间。由于我们必须对 <code>connect</code> 和 <code>isConnected</code> 都调用 <code>find</code>，所以它们的运行时间都由 O(N) 上限约束。</p><h3 id="总结和代码-1"><a href="#总结和代码-1" class="headerlink" title="总结和代码"></a>总结和代码</h3><table><thead><tr><th>实现方式</th><th>构造函数</th><th><code>connect</code></th><th><code>isConnected</code></th></tr></thead><tbody><tr><td>集合列表</td><td>Θ(N)</td><td>O(N)</td><td>O(N)</td></tr><tr><td>快速合并</td><td>Θ(N)</td><td>O(N)</td><td>O(N)</td></tr><tr><td>快速查找</td><td>Θ(N)</td><td>Θ(N)</td><td>Θ(1)</td></tr></tbody></table><p>N &#x3D; 不相交集合数据结构中的元素数量</p><p>从运行时间表中，快速合并似乎比快速查找更差！但请注意，O(N) 是一个 <strong>上限</strong>。当我们的树是平衡的时候，<code>connect</code> 和 <code>isConnected</code> 都表现得相当好。在下一节中，我们将看到如何 <em>保证</em> 它们的性能良好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickUnionDS</span> <span class="keyword">implements</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuickUnionDS</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[p] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> j= find(q);</span><br><span class="line">        parent[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="加权快速联合Weighted-Quick-Uion-WQU"><a href="#加权快速联合Weighted-Quick-Uion-WQU" class="headerlink" title="加权快速联合Weighted Quick Uion(WQU)"></a>加权快速联合Weighted Quick Uion(WQU)</h1><p>Quick Union 的改进依赖于一个关键的见解：每当我们调用 <code>find</code> 时，我们都必须爬到树的根部。因此，树越短，速度就越快！</p><p><strong>新规则</strong>：每当我们调用 <code>connect</code> 时，我们总是将<strong>较小树的根</strong>链接到<strong>较大树</strong>。</p><p>遵循此规则将为您的树提供最大高度 <code>logN</code> ，其中 N 是不相交集中的元素数量。这如何影响 <code>connect</code> 和 <code>isConnected</code> 的运行时？</p><iframe frameborder="0" allowfullscreen src="https://www.youtube.com/embed/xc9s9wdaSdU" style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; font-size: inherit; border: none; top: 0px; left: 0px; width: 770px; height: 458.125px;"></iframe><p>让我们通过一个例子来说明这样做的好处。考虑连接下面两组 T1 和 T2：</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/9.4.1.png" alt="img"></p><p>我们有两种连接它们的选项：</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/9.4.2.png" alt="img"> 第一个选项我们将 T1 链接到 T2。在第二个中，我们将 T2 链接到 T1。</p><p><strong>第二个选项更可取</strong>，因为它的高度只有 2，而不是 3。根据我们的新规则，我们也会选择第二个选项，因为 T2 小于 T1（尺寸为 3 与 6）。</p><p>我们根据树中的项目数量来确定更小&#x2F;更大。因此，当连接两棵树时，我们需要知道它们的大小（或重量）。我们可以通过用 <code>-(size of tree)</code> 替换 <code>-1</code> 来将此信息存储在树的根中。您将在<a href="https://sp19.datastructur.es/materials/lab/lab6/lab6">Lab 6</a>中实现这一点。</p><h2 id="最大高度：Log-N"><a href="#最大高度：Log-N" class="headerlink" title="最大高度：Log N"></a>最大高度：Log N</h2><p>遵循上述规则可确保任何树的最大高度为 θ(log N)。 N 是不相交集中的元素数量。<strong>通过扩展， <code>connect</code> 和 <code>isConnected</code> 的运行时间以 O(log N) 为界。</strong></p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/image-20240207091146331.png" alt="image-20240207091146331"></p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/image-20240207091744666.png" alt="image-20240207091744666"></p><p>您可能想知道为什么我们不根据高度而是重量来链接树木。事实证明，这实现起来更复杂，并且给了我们相同的 θ(log N) 高度限制。</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/image-20240207091815565.png" alt="image-20240207091815565"></p><h2 id="总结和代码-2"><a href="#总结和代码-2" class="headerlink" title="总结和代码"></a>总结和代码</h2><table><thead><tr><th>Implementation</th><th>Constructor</th><th><code>connect</code></th><th><code>isConnected</code></th></tr></thead><tbody><tr><td>ListOfSets</td><td>Θ(N)</td><td>O(N)</td><td>O(N)</td></tr><tr><td>QuickFind</td><td>Θ(N)</td><td>Θ(N)</td><td>Θ(1)</td></tr><tr><td>QuickUnion</td><td>Θ(N)</td><td>O(N)</td><td>O(N)</td></tr><tr><td>Weighted Quick Union</td><td>Θ(N)</td><td>O(log N)</td><td>O(log N)</td></tr></tbody></table><p>N &#x3D; number of elements in our DisjointSets data structure</p><p>代码:<a href="https://sp19.datastructur.es/materials/lab/lab6/lab6">Lab 6</a>中实现 or <a href="https://algs4.cs.princeton.edu/15uf/WeightedQuickUnionUF.java.html">WeightedQuickUnionUF.java (princeton.edu)</a></p><h1 id="带路径压缩的加权快速联合WQU-with-Path-Compression"><a href="#带路径压缩的加权快速联合WQU-with-Path-Compression" class="headerlink" title="带路径压缩的加权快速联合WQU with Path Compression"></a>带路径压缩的加权快速联合WQU with Path Compression</h1><iframe width="770" height="458" src="https://www.youtube.com/embed/DZKzDebT4gU" title="[Disjoint Sets, Video 5] - Weighted Quick Union with Path Compression and Summary" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>每当我们调用 <code>find(x)</code> 时，我们都必须遍历从 <code>x</code> 到 root 的路径。因此，在此过程中，我们可以将我们访问的所有项目连接到它们的根，而无需额外的渐近成本。</p><p>将沿途的所有项目连接到根将有助于每次调用 <code>find</code> 时使我们的树更短。</p><p>回想一下， <code>connect(x, y)</code> 和 <code>isConnected(x, y)</code> 总是调用 <code>find(x)</code> 和 <code>find(y)</code> 。因此，在足够多地调用 <code>connect</code> 或 <code>isConnected</code> 之后，基本上所有元素都将直接指向它们的根。</p><p>通过扩展， <code>connect</code> 和 <code>isConnected</code> 的平均运行时间从长远来看几乎保持不变！这称为摊销运行时间（来自摊销分析，第 8.4 章）。</p><p>更具体地说，对于 N 个元素上的 M 次操作，具有路径压缩的 WQU 为 <code>O(N + M (lg* N))</code>。 <code>lg* </code>是迭代对数，对于任何现实世界的输入都小于 5。</p><blockquote><p><code>lg*</code>:</p><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/image-20240207091913787.png" alt="image-20240207091913787"></p></blockquote><h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p>N：不相交集中的元素数量</p><table><thead><tr><th>执行</th><th><code>isConnected</code></th><th><code>connect</code></th></tr></thead><tbody><tr><td>快速查找</td><td>Θ(N)</td><td>Θ(1)</td></tr><tr><td>快联</td><td>O(N)</td><td>O(N)</td></tr><tr><td>加权快速联合 (WQU)</td><td>O(log N)</td><td>O(log N)</td></tr><tr><td>带路径压缩的 WQU</td><td>O(α(N))*</td><td>O(α(N))*</td></tr></tbody></table><p>*长期表现稳定。</p><p>代码:<a href="https://algs4.cs.princeton.edu/15uf/WeightedQuickUnionPathCompressionUF.java.html">WeightedQuickUnionPathCompressionUF.java (princeton.edu)</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2024/02/07/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-9-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/image-20240207091954317.png" alt="image-20240207091954317"></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(十一)-Rd8.1-封装、API、ADT</title>
      <link href="/2024/02/02/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-11-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-1/"/>
      <url>/2024/02/02/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-11-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-1/</url>
      
        <content type="html"><![CDATA[<h1 id="高效编程"><a href="#高效编程" class="headerlink" title="高效编程"></a>高效编程</h1><p>效率有两种形式：</p><p>1.） 编程成本。</p><ul><li>开发您的程序需要多长时间？</li><li>读取、修改和维护代码的难易程度如何？</li></ul><p>2.） 执行成本（从下周开始）。</p><ul><li>您的程序需要多少时间才能执行？</li><li>您的程序需要多少内存？</li></ul><p>61B 中讨论了一些有用的 Java 特性：</p><ul><li>包（Packages）<ul><li>优点：组织，使事物成为包私有。</li><li>缺点：过于具体。</li></ul></li><li>静态类型检查（Static type checking）。<ul><li>优点：早期检查错误，更像是一篇故事。</li><li>缺点：不够灵活，（强制转换等）</li></ul></li><li>继承（Inheritance）<ul><li>优点：代码重用。</li><li>缺点： “Is a”，，调试路径变得烦人，不能实例化，要实现接口的每个方法。</li></ul></li></ul><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>首先，我们将定义一些术语：</p><ul><li><p><strong>模块</strong>：一组方法，作为整体一起执行某个任务或一组相关任务。 </p></li><li><p><strong>封装的</strong>：如果模块的实现完全隐藏，只能通过文档化的接口访问，则称其为封装的。</p></li></ul><h1 id="API（应用程序编程接口）"><a href="#API（应用程序编程接口）" class="headerlink" title="API（应用程序编程接口）"></a>API（应用程序编程接口）</h1><p>ADT（抽象数据结构）的API是构造函数和方法列表以及每个方法的简短描述。</p><p>API由语法和语义规范组成。</p><ul><li>编译器验证是否符合语法。 <ul><li>也就是说，API中指定的一切都存在。</li></ul></li><li>测试有助于验证语义是否正确。 <ul><li>也就是说，一切都按照应该的方式工作。 </li><li>语义规范通常用英语编写（可能包括使用示例）。数学上精确的形式规范在某种程度上可能存在，但并不普遍。</li></ul></li></ul><h1 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h1><p>ADT（抽象数据结构）是根据其行为而不是实现定义的高级类型。</p><p>即）Proj1中的Deque是一个具有特定行为（<code>addFirst</code>、<code>addLast</code>等）的ADT。但是，我们实际使用的数据结构是<code>ArrayDeque</code>和<code>LinkedListDeque</code>。</p><p>有些ADT实际上是其他ADT的特殊情况。例如，栈和队列只是具有更具体行为的列表。</p><p>练习 8.1.1 使用链表作为其底层数据结构编写一个栈类。您只需要实现一个函数：push(Item x)。确保该类是通用的，其中“Item”是泛型类型！</p><p>可能会以几种不同的方式编写它。让我们看看三种流行的解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtensionStack</span>&lt;Item&gt; <span class="keyword">extends</span> <span class="title class_">LinkedList</span>&lt;Item&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Item x)</span> &#123;</span><br><span class="line">        add(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个解决方案使用扩展(<em>extension</em>)。它简单地从<code>LinkedList&lt;Item&gt;</code>中借用方法并将其用作自己的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelegationStack</span>&lt;Item&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Item&gt; L = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Item&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Item x)</span> &#123;</span><br><span class="line">        L.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法使用委托(<em>Delegation</em>)。它创建一个LinkedList对象并调用其方法以实现目标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackAdapter</span>&lt;Item&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> List L;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StackAdapter</span><span class="params">(List&lt;Item&gt; worker)</span> &#123;</span><br><span class="line">        L = worker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Item x)</span> &#123;</span><br><span class="line">        L.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法类似于前一种方法，除了它可以使用实现List接口的任何类（如<code>LinkedList</code>、<code>ArrayList</code>等）。</p><p><strong>警告</strong>：注意“is-a”和“has-a”关系之间的区别。</p><ul><li><p>猫有一个爪子</p></li><li><p>猫是一种猫科动物</p></li></ul><p>在本节的前面，定义了委托是通过传入一个类来完成的，而扩展是通过继承（只是因为一开始可能不容易注意到）。</p><p><strong>委托vs扩展</strong>：现在看起来，委托和扩展似乎可以互换使用；然而，在使用它们时必须记住一些重要的区别。</p><p>扩展倾向于在知道父类中发生什么的情况下使用。换句话说，你知道方法是如何实现的。此外，通过扩展，基本上是在说你正在扩展的类的行为与执行扩展的类的行为相似。另一方面，委托是当你不想将当前类视为从中提取方法的类的版本时使用的。</p><p>视图：视图是现有对象的替代表示。视图本质上限制了用户对底层对象的访问。然而，通过视图进行的更改将影响实际对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 创建一个ArrayList。 */</span></span><br><span class="line">List&lt;String&gt; L = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/** 添加一些项目。 */</span></span><br><span class="line">L.add(<span class="string">&quot;at&quot;</span>); L.add(<span class="string">&quot;ax&quot;</span>); …</span><br></pre></td></tr></table></figure><p>假设你只想要一个索引为1到4的列表。然后，您可以使用<code>sublist</code>方法通过以下方式进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** subList me up fam. */</span></span><br><span class="line">List&lt;String&gt; SL = l.subList(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">/** Mutate that thing. */</span></span><br><span class="line">SL.set(<span class="number">0</span>, “jug”);</span><br></pre></td></tr></table></figure><p>现在，这有什么用呢？嗯，假设我们只想反转列表的一部分。例如，在下图中，我们希望反转上图中的<code>ax ban bat</code>。</p><p><img src="/2024/02/02/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-11-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-1/reverse_list1.png" alt="reverse"></p><p>最直观的方法是创建一个接受列表对象和应该被反转的索引的方法。但是，这可能有点繁琐，因为我们添加了一些多余的逻辑。</p><p>为了避免这样做，我们可以只创建一个通用的反转函数，该函数接受一个列表并反转该列表。由于视图改变了它表示的底层对象，我们可以像前面一样创建一个子列表，然后反转子列表。最终结果实际上会改变实际列表而不是副本。</p><p><img src="/2024/02/02/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-11-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd8-1/reverse_list2.png" alt="img"></p><p>这一切都很好。然而，它会导致一个问题。您声称您可以提供一个列表对象，当操作该列表对象时，可以影响原始列表对象-这有点奇怪。思考一下“如何返回一个实际的List但仍然对另一个List产生影响？”可能有点令人困惑。好吧，答案是访问方法。</p><p>首先要注意的是，<code>sublist</code>方法返回一个List类型。此外，有一个称为<code>Sublist</code>的定义类，它扩展了<code>AbstractList</code>。由于<code>Abstract List</code>实现了List接口，它和<code>Sublist</code>都是<code>List</code>类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Item&gt; <span class="title function_">sublist</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">    Return <span class="keyword">new</span> <span class="title class_">this</span>.Sublist(start,end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的首要之处是<code>subList</code>返回一个<code>List</code>类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Private <span class="keyword">class</span> <span class="title class_">Sublist</span> <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;Item&gt;&#123;</span><br><span class="line">    Private <span class="type">int</span> start end;</span><br><span class="line">    Sublist(inst start, <span class="type">int</span> end)&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，<code>sublist</code>函数返回一个<code>List</code>是因为<code>SubList</code>类扩展了<code>AbstractList</code>。由于<code>AbstractList</code>实现了<code>List</code>接口，它和<code>Sublist</code>都是List类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Item <span class="title function_">get</span><span class="params">(<span class="type">int</span> k)</span>&#123;<span class="keyword">return</span> AbstractList.<span class="built_in">this</span>.get(start+k);&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, Item x)</span>&#123;AbstractList.<span class="built_in">this</span>.add(start+k, x); end+=<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这两个方法是在 <code>Sublist</code> 类中定义的。</p><p>在给定的上下文中，<code>Sublist</code> 类被设计为一个视图，它提供了对原始列表的部分元素的访问和操作。<code>Sublist</code> 不是通过复制数据来创建一个独立的列表，而是通过引用原始列表的一部分来创建视图。这样的设计可以节省内存，并且在需要修改原始列表的情况下，视图的操作会直接影响原始列表。</p><p>具体来说，<code>get</code> 方法通过调用外部类 <code>AbstractList</code> 的 <code>get</code> 方法获取原始列表中的元素。这是因为 <code>Sublist</code> 类没有自己的数据存储，而是依赖于外部类提供的数据。类似地，<code>add</code> 方法也是通过调用外部类 <code>AbstractList</code> 的 <code>add</code> 方法，将元素添加到原始列表的指定位置，并且 <code>end</code> 计数也通过修改外部类的字段来更新。</p><p>这种依赖关系的设计有几个优点：</p><ol><li><strong>节省内存：</strong> 不需要为子列表复制一份原始列表的数据，而是直接引用原始列表的部分数据。</li><li><strong>动态更新：</strong> 由于视图是对原始数据的引用，对视图的修改会直接影响原始数据。这样的动态性使得修改子列表时可以实时反映在原始列表中，无需执行额外的同步操作。</li></ol><p>总体而言，这种依赖关系的设计使得 <code>Sublist</code> 能够提供高效的视图功能，同时节省内存并保持数据的一致性。</p></blockquote><p>应该注意的一点是，从我们的子列表中获取第k个项与从具有偏移量等于我们的起始索引的原始列表中获取第k个项是相同的。因为我们使用的是外部类（最父级的类）的get方法，我们改变了我们的原始列表。</p><p>类似地，向我们的子列表添加元素与在起始索引的子列表中添加元素相同。因为我们使用的是子列表的get方法，我们改变了我们的原始列表。</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ul><li>API很难设计；然而，拥有一种一致的设计理念可以使您的代码更清晰，更容易处理。 </li><li>继承经常被频繁使用，但它存在问题，应该谨慎使用，只有在对类的属性（既被扩展又进行扩展的类）有把握的情况下才使用。</li></ul><h2 id="三种实现方式："><a href="#三种实现方式：" class="headerlink" title="三种实现方式："></a><strong>三种实现方式：</strong></h2><ul><li><strong>使用扩展（Extension）：</strong> 通过继承现有类的方式实现，比如使用<code>extends</code>关键字。文章给出了一个使用扩展的例子，即创建一个扩展了<code>LinkedList</code>的<code>ExtensionStack</code>类，它简单地借用了<code>LinkedList</code>的方法并将其作为自己的方法使用。</li><li><strong>使用委托（Delegation）：</strong> 通过创建一个新的类，在其中包含一个实例化的现有类，并调用其方法来实现目标。文章给出了一个使用委托的例子，即创建一个<code>DelegationStack</code>类，它包含一个<code>LinkedList</code>对象，通过调用其方法来实现堆栈的目标。</li><li><strong>使用视图（Views）：</strong> 视图是对现有对象的替代表示，通过视图可以限制用户对底层对象的访问。视图的更改会影响实际对象。这一概念在后文有具体的例子。</li></ul><h2 id="关于视图的讨论："><a href="#关于视图的讨论：" class="headerlink" title="关于视图的讨论："></a><strong>关于视图的讨论：</strong></h2><ul><li><strong>视图的概念：</strong> 视图是现有对象的替代表示，通过它可以限制用户对底层对象的访问。尽管视图可以限制访问，但通过视图进行的更改会直接影响实际对象。</li><li><strong>使用sublist方法创建视图：</strong> 通过示例说明了使用<code>sublist</code>方法创建视图。例如，创建一个ArrayList <code>L</code>，然后使用<code>sublist</code>方法获取索引1到4的部分视图（<code>SL</code>）。这样，对<code>SL</code>的更改将直接影响原始列表 <code>L</code>。</li><li><strong>通过视图修改原始列表：</strong> 通过视图，可以在不创建额外逻辑的情况下修改原始列表的部分内容。文章以一个具体的例子说明了如何通过创建视图，并在视图上进行修改，来实现对原始列表的修改。</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li><strong>扩展（Extension）：</strong><ul><li><strong>使用场景：</strong> 当你想要在已有类的基础上构建一个新的类，并且新类是已有类的扩展，具有类似的行为，可以考虑使用扩展。</li><li><strong>优势：</strong> 可以继承现有类的方法，使代码重用更为简单。</li></ul></li><li><strong>委托（Delegation）：</strong><ul><li><strong>使用场景：</strong> 当你想要在新的类中使用现有类的功能，但不是扩展它，而是将这些功能委托给其他类实现，可以考虑使用委托。</li><li><strong>优势：</strong> 更灵活，允许更动态地改变委托对象，避免了继承链的一些问题。</li></ul></li><li><strong>视图（Views）：</strong><ul><li><strong>使用场景：</strong> 当你需要对现有对象的一部分进行操作，并且希望对这部分的修改能够直接影响到原始对象时，可以考虑使用视图。</li><li><strong>优势：</strong> 节省内存，避免了不必要的数据复制，同时提供对原始数据的动态操作。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(十)-Rd6-迭代器，equal方法，异常处理</title>
      <link href="/2024/02/02/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd6/"/>
      <url>/2024/02/02/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd6/</url>
      
        <content type="html"><![CDATA[<p><a href="https://joshhug.gitbooks.io/hug61b/content/chap6/chap61.html">6.1 Lists, Sets, and ArraySet · Hug61B (gitbooks.io)</a></p><p>在本节中，我们将学习如何使用 Java 的内置 <code>List</code> 和 <code>Set</code> 数据结构，以及构建我们自己的 <code>ArraySet</code> </p><h1 id="Java中的Lists"><a href="#Java中的Lists" class="headerlink" title="Java中的Lists"></a>Java中的Lists</h1><p>我们从头开始构建了一个列表，但 Java 提供了一个内置 <code>List</code> 接口和几个实现，例如 <code>ArrayList</code> .请记住，由于 <code>List</code> 是一个接口，我们无法对其进行设置！我们必须确定它的一个实现。</p><p>为了访问它，我们可以使用类、接口的全名（“规范名称”）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.List&lt;Integer&gt; L = <span class="keyword">new</span> <span class="title class_">java</span>.util.ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>但是，这有点冗长。以类似于我们导入的方式，我们可以导入 <code>JUnit</code> java 库：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; L = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        L.add(<span class="number">5</span>);</span><br><span class="line">        L.add(<span class="number">10</span>);</span><br><span class="line">        System.out.println(L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="集合-Sets"><a href="#集合-Sets" class="headerlink" title="集合(Sets)"></a>集合(Sets)</h1><p>集合是唯一元素的集合 - 每个元素只能有一个副本，也无序。</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>Java 具有 <code>Set</code> 接口和实现，例如 <code>HashSet</code> .如果您不想使用全名，请记住导入它们！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">s.add(<span class="string">&quot;Tokyo&quot;</span>);</span><br><span class="line">s.add(<span class="string">&quot;Lagos&quot;</span>);</span><br><span class="line">System.out.println(S.contains(<span class="string">&quot;Tokyo&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>在 python 中，我们只需调用 <code>set()</code> .为了检查， <code>contains</code> 我们不使用方法，而是使用关键字 <code>in</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>()</span><br><span class="line">s.add(<span class="string">&quot;Tokyo&quot;</span>)</span><br><span class="line">s.add(<span class="string">&quot;Lagos&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Tokyo&quot;</span> <span class="keyword">in</span> s) // <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="ArraySet"><a href="#ArraySet" class="headerlink" title="ArraySet"></a>ArraySet</h2><p>我们的目标是用以下方法制作我们自己的集合 <code>ArraySet</code> ：</p><ul><li><code>add(value)</code>: add the value to the set if not already present<br><code>add(value)</code> ：将值添加到集合中（如果尚不存在）</li><li><code>contains(value)</code>: check to see if ArraySet contains the key<br><code>contains(value)</code> ：检查 ArraySet 是否包含键</li><li><code>size()</code>: return number of values<br><code>size()</code> ：返回值的数量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraySet</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">// the next item to be added will be at position size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArraySet</span><span class="params">()</span> &#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns true if this map contains a mapping for the specified key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i += <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (items[i].equals(x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Associates the specified value with the specified key in this map. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (contains(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        items[size] = x;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns the number of key-value mappings in this map. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h1><p>我们在 <code>ArraySet</code> 上一节中的实现有一个小错误。当我们添加<code>null</code>到  ArraySet 时，我们得到一个 NullPointerException。</p><p>问题出在我们检查 <code>contains</code> <code>items[i].equals(x)</code> 的方法上。如果 <code>items[i]</code>值为 null，则我们调用 <code>null.equals(x)</code> -&gt; NullPointerException。</p><p>在 Java 中，异常是对象，我们使用以下格式抛出异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new ExceptionObject(parameter1, ...)</span><br></pre></td></tr></table></figure><p>当用户尝试将 null 添加到我们的 <code>ArraySet</code> .我们将抛出一个接受一个 <code>IllegalArgumentException</code> 参数（一条 <code>String</code> 消息）。</p><p>我们更新 <code>add</code> 的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">   Throws an IllegalArgumentException if the key is null. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;can&#x27;t add null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (contains(x)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    items[size] = x;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论哪种方式，我们都会得到一个异常 - 为什么这样更好？</p><ol><li>我们可以控制我们的代码：我们有意识地决定在什么时候停止我们的程序流</li><li>对于使用我们代码的用户来说，更有用的异常类型和有用的错误消息</li></ol><p>但是，如果程序根本不崩溃会更好。在这种情况下，我们可以做不同的事情。以下是一些：</p><p><strong>方法 1</strong>：如果数组被传递到数组中，则不要将其添加到 <code>null</code> 数组中 <code>add</code> </p><p><strong>方法 2</strong>：更改 <code>contains</code> 方法以考虑情况 if <code>items[i] == null</code> .</p><p>无论您做出什么决定，重要的是用户知道会发生什么。这就是为什么文档（例如关于您的方法的评论）非常重要的原因。</p><h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>我们可以在 Java 的 <code>HashSet</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">s.add(<span class="string">&quot;Tokyo&quot;</span>);</span><br><span class="line">s.add(<span class="string">&quot;Lagos&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String city : s) &#123;</span><br><span class="line">    System.out.println(city);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果我们尝试对我们的 <code>ArraySet</code> 做同样的事情，我们会得到一个错误。我们如何启用此功能？</p><h2 id="增强的-For-循环"><a href="#增强的-For-循环" class="headerlink" title="增强的 For 循环"></a>增强的 For 循环</h2><p>让我们首先了解当我们使用增强的 for 循环时会发生什么。我们可以将增强的 for 循环“翻译”成一种丑陋的手动方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (String city : s) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码翻译为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line">Iterator&lt;String&gt; seer = s.iterator();</span><br><span class="line"><span class="keyword">while</span> (seer.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> seer.next();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的关键是一个称为迭代器的对象。</p><p>在我们的示例中，在 List.java 中，我们可以定义一个 <code>iterator()</code> 返回迭代器对象的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>现在，我们可以使用该对象遍历列表中的所有条目：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; friends = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">...</span><br><span class="line">Iterator&lt;Integer&gt; seer = friends.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (seer.hasNext()) &#123;</span><br><span class="line">System.out.println(seer.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码的行为与上面的 foreach 循环版本相同。</p><p>我们的迭代器方法中有三种关键方法：</p><ul><li><p>首先，我们得到一个新的迭代器对象，其中包含 <code>Iterator&lt;Integer&gt; seer = friends.iterator();</code></p></li><li><p>接下来，我们使用 while 循环遍历列表。我们检查是否还有剩余的项目，如果还有看不见的项目，则返回 <code>seer.hasNext()</code> true，如果所有项目都已处理，则返回 false。</p></li><li><p>最后， <code>seer.next()</code> 一次做两件事。它返回列表的下一个元素，在这里我们将其打印出来。它还将迭代器<strong>前进一项</strong>。这样，迭代器将只检查每个项目一次。</p></li></ul><h2 id="实现迭代器"><a href="#实现迭代器" class="headerlink" title="实现迭代器"></a>实现迭代器</h2><p>让我们首先考虑编译器需要了解什么才能成功编译以下迭代器示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; friends = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">Iterator&lt;Integer&gt; seer = friends.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(seer.hasNext()) &#123;</span><br><span class="line">    System.out.println(seer.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以查看调用相关方法的每个对象的静态类型。 <code>friends</code> 是一个列表，在它 <code>iterator()</code> 上面被调用，所以我们必须问：</p><ul><li>Does the List interface have an iterator() method?<br>List 接口有 iterator（） 方法吗？</li></ul><p><code>seer</code> 是一个迭代器，在它 <code>hasNext()</code> 上面 <code>next()</code> 被调用，所以我们必须问：</p><ul><li>Does the Iterator interface have next&#x2F;hasNext() methods?<br>迭代器接口是否有 next&#x2F;hasNext（） 方法？</li></ul><p>那么我们如何实现这些要求呢？</p><p>List 接口扩展了 Iterable 接口，继承了抽象的 iterator（） 方法。（实际上，List 扩展了扩展 Iterable 的 Collection，但以这种方式开始代码思考更容易。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;T&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，编译器检查迭代器是否具有 <code>hasNext()</code> 和 <code>next()</code> 。Iterator 接口显式指定以下抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将向 ArrayMap 类添加迭代键。首先，我们编写一个名为 ArraySetIterator 的新类，它<strong>嵌套在</strong> ArraySet 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArraySetIterator</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ArraySetIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> wizPos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArraySetIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        wizPos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> wizPos &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">returnItem</span> <span class="operator">=</span> items[wizPos];</span><br><span class="line">        wizPos += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> returnItem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>若需要用增强For循环，就需要告诉编译器你有一个迭代器，那如何告诉编译器呢？答案是继承Iterable</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraySet</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; </span><br></pre></td></tr></table></figure><h1 id="Object方法"><a href="#Object方法" class="headerlink" title="Object方法"></a><code>Object</code>方法</h1><p>所有类都继承自总体 Object 类。继承的方法如下：</p><ul><li><code>String toString()</code></li><li><code>boolean equals(Object obj)</code></li><li><code>Class &lt;?&gt; getClass()</code></li><li><code>int hashCode()</code></li><li><code>protected Objectclone()</code></li><li><code>protected void finalize()</code></li><li><code>void notify()</code></li><li><code>void notifyAll()</code></li><li><code>void wait()</code></li><li><code>void wait(long timeout)</code></li><li><code>void wait(long timeout, int nanos)</code></li></ul><p>在本章中，我们将重点介绍前两个。我们将利用继承来覆盖类中的这两个方法，以按照我们希望它们的方式运行。</p><h2 id="toString（）"><a href="#toString（）" class="headerlink" title="toString（）"></a>toString（）</h2><p>该 <code>toString()</code> 方法提供对象的字符串表示形式。该 <code>System.out.println()</code> 函数在传递给它的任何对象上隐式调用此方法，并打印返回的字符串。当你运行 <code>System.out.println(dog)</code> 时，它实际上是这样做的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> dog.toString()</span><br><span class="line">System.out.println(s)</span><br></pre></td></tr></table></figure><p>默认 <code>Object</code> 类的<code>toString()</code> 方法打印对象在内存中的位置。这是一个十六进制字符串。像 Arraylist 和 java 数组这样的类有自己的方法重写版本 <code>toString()</code> 。这就是为什么当你使用 Arraylist 并为其编写测试时，错误总是会以这样的格式（1、2、3、4）返回列表，而不是返回内存位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">returnString</span> <span class="operator">=</span> <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i += <span class="number">1</span>) &#123;</span><br><span class="line">        returnString += keys[i];</span><br><span class="line">        returnString += <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    returnString += <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> returnString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个方法很不好，因为每次<code>+=</code>都是在创建一个新的String对象</p><p>为了解决这个问题，Java 有一个名为 <code>StringBuilder</code> .它会创建一个可变的字符串对象，因此您可以继续追加到同一个字符串对象，而不是每次都创建一个新对象。</p></blockquote><p>重写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">returnSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">            returnSB.append(items[i].toString());</span><br><span class="line">            returnSB.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        returnSB.append(items[size - <span class="number">1</span>]);</span><br><span class="line">        returnSB.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> returnSB.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><p><code>equals()</code> 并在 <code>==</code> Java 中具有不同的行为。 <code>==</code> 检查两个对象在内存中是否实际上是同一个对象。记住，按值传递！ <code>==</code> 检查两个盒子是否装有相同的东西。对于基元，这意味着检查值是否相等。对于对象，这意味着检查地址&#x2F;指针是否相等。</p><p>假设我们有这个 <code>Doge</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Doge</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Doge</span><span class="params">(<span class="type">int</span> age, String name)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">Doge</span> <span class="variable">fido</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Doge</span>(<span class="number">5</span>, <span class="string">&quot;Fido&quot;</span>);</span><br><span class="line">      <span class="type">Doge</span> <span class="variable">doggo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Doge</span>(<span class="number">6</span>, <span class="string">&quot;Doggo&quot;</span>);</span><br><span class="line">      <span class="type">Doge</span> <span class="variable">fidoTwin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Doge</span>(<span class="number">5</span>, <span class="string">&quot;Fido&quot;</span>);</span><br><span class="line">      <span class="type">Doge</span> <span class="variable">fidoRealTwin</span> <span class="operator">=</span> fido;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们将此代码插入 java 可视化工具，我们将在下面所示的指针图中看到该框。</p><p><img src="/2024/02/02/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10-CS61b%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd6/image-20240202181822175.png" alt="image-20240202181822175"></p><p>练习 6.4.2：如果我们运行以下命令，java 将返回什么？</p><ul><li><code>x == y</code></li><li><code>x == z</code></li><li><code>fido == doggo</code></li><li><code>fido == fidoTwin</code></li><li><code>fido = fidoRealTwin</code></li></ul><p><strong>答案</strong></p><ul><li><code>True</code></li><li><code>False</code></li><li><code>False</code></li><li><code>False</code></li><li><code>True</code></li></ul><p><code>fido</code> 并且 <code>fidoTwin</code> 不被考虑 <code>==</code> ，因为它们指向不同的对象。然而，这是非常愚蠢的，因为它们的所有属性都是相同的。您可以看到如何在 <code>==</code> Java 测试中导致一些问题。当我们为 ArrayList 编写测试并想要检查 expected 是否与函数返回的内容相同时，我们会将 expected 创建为新的 arraylist。如果我们 <code>==</code> 在测试中使用，它总是会返回 false。这就是 <code>equals(Object o)</code> 目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object other)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == other) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (other.getClass() != <span class="built_in">this</span>.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArraySet&lt;T&gt; o = (ArraySet&lt;T&gt;) other;</span><br><span class="line">        <span class="keyword">if</span> (o.size() != <span class="built_in">this</span>.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (T item : <span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!o.contains(item)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Java 中的等式规则：重写 <code>.equals()</code> 方法时，有时可能比看起来更棘手。实现方法 <code>.equals()</code> 时要遵守的几条规则如下：</p><p>1.） <code>equals</code> 必须是等价关系</p><ul><li><strong>反身</strong>： <code>x.equals(x)</code> 是真的</li><li><strong>对称</strong>： <code>x.equals(y)</code> 当且仅当 <code>y.equals(x)</code></li><li><code>x.equals(z)</code><br><strong>及物</strong>： <code>x.equals(y)</code> 和 <code>y.equals(z)</code> 暗示 <code>x.equals(z)</code></li></ul><p>2.） 它必须接受一个 Object 参数，以便覆盖原始 <code>.equals()</code> 方法</p><p>3.） 它必须一致 如果 <code>x.equals(y)</code> ，那么只要 <code>x</code> 和 <code>y</code> 保持不变： <code>x</code> 必须继续相等 <code>y</code></p><p>4.) It is never true for null <code>x.equals(null)</code> must be false<br>4.）  null永远不会为真， <code>x.equals(null)</code> 必须是假的</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(九)-Rd4.3-子类多态性与HoFs的关系</title>
      <link href="/2024/01/30/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-3/"/>
      <url>/2024/01/30/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-3/</url>
      
        <content type="html"><![CDATA[<p>幻灯片:<a href="https://docs.google.com/presentation/d/13SVUU8oeTch0ex42hBQLGTZ4XAaMKDJmuXMqegEoVqM/edit#slide=id.g4eef494c27_45_245">cs61b 2021 lec10 inheritance3 - Google 幻灯片</a></p><p>Reading:<a href="https://joshhug.gitbooks.io/hug61b/content/chap4/chap43.html">4.3 Subtype Polymorphism vs. HOFs · Hug61B (gitbooks.io)</a></p><h1 id="子类多态性"><a href="#子类多态性" class="headerlink" title="子类多态性"></a>子类多态性</h1><p>多态性的核心是“多种形式”。在 Java 中，多态性是指对象可以具有多种形式或类型。在面向对象编程中，多态性涉及如何将一个对象视为其自身类的实例、其超类的实例、其超类的超类的实例等。</p><p>考虑一个静态类型为<code>deque</code>的变量deque。调用<code>dequeue .addFirst()</code> 将在执行时确定，这取决于调用 <code>addFirst</code> 时<code>deque</code>的运行时类型或动态类型。正如我们在上一章中看到的，Java使用动态方法选择来选择调用哪个方法。</p><blockquote><ol><li><strong>运行时类型（Runtime Type）：</strong> 运行时类型指的是在程序执行过程中，某个变量或对象的实际类型。这是由程序在运行时动态决定的。在一些面向对象的语言中，对象可能被声明为某个类型，但在运行时可能会被赋予该类型的子类型。因此，运行时类型是程序实际处理的对象类型，而不仅仅是在代码中声明的类型。如基类。</li><li><strong>动态类型（Dynamic Type）：</strong> 动态类型是指变量或对象在运行时的类型。与静态类型相对应，动态类型意味着类型信息是在运行时确定的，而不是在编译时。在一些动态语言中，变量可以在运行时引用不同的类型，因此变量的动态类型是可以变化的。</li></ol></blockquote><p>假设我们想编写一个 python 程序，该程序打印两个对象中较大的一个的字符串表示形式。有两种方法可以做到这一点。</p><ol><li>显式 HoF 方法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_larger</span>(<span class="params">x, y, compare, stringify</span>):</span><br><span class="line">    <span class="keyword">if</span> compare(x, y):</span><br><span class="line">        <span class="keyword">return</span> stringify(x)</span><br><span class="line">    <span class="keyword">return</span> stringify(y)</span><br></pre></td></tr></table></figure><ol start="2"><li>子类多态性方法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_larger</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">if</span> x.largerThan(y):</span><br><span class="line">        <span class="keyword">return</span> x.<span class="built_in">str</span>()</span><br><span class="line">    <span class="keyword">return</span> y.<span class="built_in">str</span>()</span><br></pre></td></tr></table></figure><p>使用显式高阶函数方法，您有一种常用的方法来打印出两个对象中较大的一个。相反，在子类多态性方法中，对象本身做出选择。所调用 <code>largerFunction</code> 的取决于 x 和 y 的实际含义。</p><h2 id="Max-函数"><a href="#Max-函数" class="headerlink" title="Max 函数"></a>Max 函数</h2><p>假设我们想编写一个 <code>max</code> 函数，该函数接受任何数组（无论类型如何）并返回数组中的最大项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">max</span><span class="params">(Object[] items)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (items[i] &gt; items[maxDex]) &#123;</span><br><span class="line">            maxDex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> items[maxDex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Dog[] dogs = &#123;<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Elyse&quot;</span>, <span class="number">3</span>), <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Sture&quot;</span>, <span class="number">9</span>), <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Benjamin&quot;</span>, <span class="number">15</span>)&#125;;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">maxDog</span> <span class="operator">=</span> (Dog) max(dogs);</span><br><span class="line">    maxDog.bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一处很明显的错误:<code>items[i] &gt; items[maxDex]</code>，这会导致编译错误的原因是，此行假定 <code>&gt;</code> 运算符使用任意 Object 类型，而实际上并非如此。</p><p>相反，我们可以在 Dog 类中定义一个函数，并放弃编写一个 <code>maxDog</code> 可以接受任意类型的数组的“一个真正的最大函数”。我们可以这样定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Dog <span class="title function_">maxDog</span><span class="params">(Dog[] dogs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dogs == <span class="literal">null</span> || dogs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">maxDog</span> <span class="operator">=</span> dogs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (Dog d : dogs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d.size &gt; maxDog.size) &#123;</span><br><span class="line">            maxDog = d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这在目前是可行的，但如果我们放弃制作广义 <code>max</code> 函数的梦想，让 Dog 类定义自己的 <code>max</code> 函数，那么我们将不得不对稍后定义的任何类做同样的事情。我们需要编写一个函数、一个函数、一个 <code>maxCat</code> <code>maxPenguin</code> <code>maxWhale</code> 函数等，导致不必要的重复工作和大量冗余代码。</p><p>导致这种情况的根本问题是 <strong>Objects 不能与 <code>&gt;</code> 进行比较</strong>。这是有道理的，因为 Java 怎么知道它是否应该使用对象的 String 表示、大小或其他度量来进行比较？在 Python 或 C++ 中， <code>&gt;</code> 运算符的工作方式可以重新定义，以便在应用于不同类型时以不同的方式工作。不幸的是，Java 没有这个功能。相反，我们求助于<strong>接口继承</strong>来帮助我们。</p><p>我们可以创建一个接口来保证任何实现类（如 Dog）都包含一个比较方法，我们称之为 <code>compareTo</code> 。</p><p><img src="/2024/01/30/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-3/dog_comparable.png" alt="img"></p><p>让我们编写我们的接口。我们指定一种方法<code>compareTo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OurComparable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将这样定义它的行为：</p><ul><li>如果 <code>this</code> &lt; o，则返回负数。</li><li>如果 <code>this</code> 等于 o，则返回 0。</li><li>如果 <code>this</code> &gt; o，则返回正数。</li></ul><p>现在我们已经创建了 <code>OurComparable</code> 接口，我们可以要求 Dog 类实现该 <code>compareTo</code> 方法。首先，我们将 Dog 的类头更改为  <code>implements OurComparable</code> ，然后根据上面定义的行为编写 <code>compareTo</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">OurComparable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String n, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        size = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; says: bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">uddaDog</span> <span class="operator">=</span> (Dog) o;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size - uddaDog.size;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>请注意，由于 <code>compareTo</code> 接受任何任意对象 o，因此我们必须将输入转换为 Dog 才能使用 <code>size</code> 实例变量进行比较。</strong></p></blockquote><p>现在，我们可以将我们在练习 4.3.1 中定义的 <code>max</code> 函数推广为，而不是接受任何任意的对象数组，而是接受 <code>OurComparable</code> 对象 - 我们肯定知道所有对象都实现了该 <code>compareTo</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> OurComparable <span class="title function_">max</span><span class="params">(OurComparable[] items)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> items[i].compareTo(items[maxDex]);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            maxDex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> items[maxDex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们的函数可以接受任何 <code>OurComparable</code> 类型对象的数组， <code>max</code> 并返回数组中的最大对象。</p><p>使用继承，我们能够推广我们的最大化函数。这种方法有什么好处？</p><ul><li>不需要每个类中的求最大代码（即不需要 <code>Dog.maxDog(Dog[])</code> 函数</li><li>我们有代码可以优雅地对多种类型（大多数）进行操作</li></ul><h2 id="Comparables"><a href="#Comparables" class="headerlink" title="Comparables"></a>Comparables</h2><p>我们刚刚构建的 <code>OurComparable</code> 接口可以工作，但并不完美。以下是它的一些问题：</p><ul><li>对象间尴尬的类型转换</li><li>我们编写了它。<ul><li>没有现有类继承 OurComparable （例如 String 等）</li><li>没有现有类使用 OurComparable（例如，没有使用 OurCompare 的内置 max 函数）</li></ul></li></ul><p>解决方案是什么？我们将利用一个名为 <code>Comparable</code> . <code>Comparable</code> 已经由 Java 定义，并被无数库使用。</p><p><code>Comparable</code> 看起来与我们制作的 OurComparable 接口非常相似，但有一个主要区别。你能发现它吗？</p><p><img src="/2024/01/30/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-3/comparable_interface.png" alt="img"></p><p>请注意， <code>Comparable&lt;T&gt;</code> 这意味着它采用泛型类型。这将帮助我们避免将对象转换为特定类型！现在，我们将重写 Dog 类以实现 Comparable 接口，确保将泛型类型 <code>T</code> 更新为 Dog：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Dog&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Dog uddaDog)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size - uddaDog.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在剩下的就是将 Maximizer 类中的每个 OurComparable 实例更改为 Comparable。看着最大的狗说吠叫：</p><p>我们现在使用真正的内置接口，而不是使用我们个人创建的接口 <code>OurComparable</code> 。 <code>Comparable</code> 因此，我们可以利用所有已经存在的库并使用 <code>Comparable</code> .</p><p><img src="/2024/01/30/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-3/comparable.png" alt="img"></p><h2 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h2><p>我们刚刚了解了可比较的接口，它为每只狗嵌入了将自己与另一只狗进行比较的能力。现在，我们将介绍一个看起来非常相似的新接口，称为 <code>Comparator</code> .</p><p>让我们从定义一些术语开始。</p><ul><li>自然顺序 - 用于指特定类 <code>compareTo</code> 的方法中隐含的顺序。</li></ul><p>例如，如前所述，狗的自然排序是根据大小的值定义的。如果我们想以不同于狗的自然顺序的方式对狗进行排序，例如按它们名字的字母顺序排序，该怎么办？</p><p>Java 实现这一点的方式是使用 <code>Comparator</code>。由于 <code>Comparator</code> 是一个对象，我们将使用 <code>Comparator</code> 的方法是通过在 <code>Dog</code> 类内部编写一个实现 <code>Comparator</code> 接口的嵌套类。</p><p>但首先，这个接口里面有什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这表明 <code>Comparator</code> 接口要求任何实现类实现该 <code>compare</code> 方法。的规则 <code>compare</code> 就像： <code>compareTo</code></p><ul><li>如果 o1 &lt; o2，则返回负数。</li><li>如果 o1 等于 o2，则返回 0。</li><li>如果 o1 &gt; o2，则返回正数。</li></ul><p>让我们给 Dog 一个 NameComparator。为此，我们可以简单地遵循 <code>String</code> 已经定义 <code>compareTo</code> 的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Dog&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Dog uddaDog)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size - uddaDog.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NameComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Dog&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Dog a, Dog b)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.name.compareTo(b.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Dog&gt; <span class="title function_">getNameComparator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NameComparator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>请注意，我们已将 NameComparator 声明为静态类。这是一个细微的差异，但我们这样做是因为我们不需要实例化 Dog 来获取 NameComparator。让我们看看这个比较器是如何工作的。</p></blockquote><p>正如你所看到的，我们可以像这样检索我们的 NameComparator：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Dog&gt; nc = Dog.getNameComparator();</span><br></pre></td></tr></table></figure><p>总而言之，我们有一个 Dog 类，它有一个私有的 NameComparator 类和一个返回 NameComparator 的方法，我们可以用它来按名称的字母顺序比较狗。</p><p>让我们看看继承层次结构中的一切是如何工作的——我们有一个内置于 Java 的比较器接口，我们可以实现它来在 Dog 中定义我们自己的比较器（ <code>NameComparator</code> 、 <code>SizeComparator</code> 等）。</p><p><img src="/2024/01/30/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-3/comparator.png" alt="img"></p><p>总而言之，Java 中的接口为我们提供了进行回调的能力。有时，一个函数需要另一个可能尚未编写的函数的帮助（例如 <code>max</code> needs <code>compareTo</code> ）。回调函数是帮助函数（在方案中为 <code>compareTo</code> ）。在某些语言中，这是使用显式函数传递来实现的;在 Java 中，我们将所需的函数包装在一个接口中。</p><p>一个可比者说，“我想将自己与另一个对象进行比较”。它嵌入在对象本身中，它定义了类型的<strong>自然顺序</strong>。另一方面，比较器更像是将两个对象相互比较的第三方机器。由于只有一种方法 <code>compareTo</code> 的空间，如果我们想要多种方法进行比较，我们必须求助于比较器。</p><blockquote><p>即<code>a.max(b)</code>和max(a, b)的区别</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>接口为我们提供了进行回调的能力：</p><ul><li>有时候，一个函数需要另一个可能尚未编写的函数的帮助。 例如：<code>max</code> 需要 <code>compareTo</code>。 这种帮助函数有时被称为“回调”。 </li><li>一些编程语言使用显式的函数传递来处理这种情况。 </li><li>在Java中，我们通过将所需的函数包装在接口中来实现这一点（例如，<code>Arrays.sort</code> 需要在比较器接口中定义的 <code>compare</code>）。 </li><li><code>Arrays.sort</code> 在需要进行比较时会“回调”相应的函数。 类似于在需要信息时将你的号码提供给别人。</li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li><strong>Comparables（可比较的）：</strong><ul><li>可比较的对象通常实现<code>Comparable</code>接口，该接口定义了<code>compareTo</code>方法，规定了对象的自然顺序。</li><li>自然顺序是对象的默认排序方式。</li><li>在子类中实现<code>compareTo</code>方法，以便对象可以在不同场景中进行比较，例如在排序中使用。</li></ul></li><li><strong>Comparators（比较器）：</strong><ul><li>比较器是实现了<code>Comparator</code>接口的对象，该接口定义了<code>compare</code>方法，允许两个对象进行自定义的比较。</li><li>比较器允许在不修改对象类本身的情况下定义多种比较方式。</li><li>在需要多种比较方式时，可以创建不同的比较器类，例如<code>NameComparator</code>和<code>SizeComparator</code>。</li></ul></li><li><strong>子类多态性：</strong><ul><li>多态性涉及对象在程序执行过程中可以具有多种形式或类型的概念。</li><li>在Java中，多态性表现为对象可以被视为其自身类的实例、其超类的实例等。</li><li>子类多态性通过继承和接口实现，使得代码更加灵活，允许处理不同类型的对象。</li></ul></li><li><strong>接口和回调函数：</strong><ul><li>接口提供了进行回调的能力，允许一个函数在需要时调用另一个可能尚未编写的函数。</li><li>在Java中，回调函数通常通过将函数包装在接口中实现，例如<code>compareTo</code>方法在<code>OurComparable</code>接口中定义。</li><li>使用接口和比较器，可以实现多种比较方式，使得对象在排序等场景中更加灵活。</li></ul></li></ol><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><ol><li><strong>Comparables 和 Comparators：</strong><ul><li><code>Comparables</code> 和 <code>Comparators</code> 都是用于进行对象比较的机制，但它们的使用场景和实现方式略有不同。</li><li><code>Comparables</code> 用于定义对象的自然顺序，要求对象自身实现 <code>Comparable</code> 接口，并重写 <code>compareTo</code> 方法来规定比较规则。</li><li><code>Comparators</code> 用于实现自定义的比较逻辑，可以为同一类对象定义多个不同的比较方式，而无需修改对象类本身。比较器实现 <code>Comparator</code> 接口，并重写 <code>compare</code> 方法。</li></ul></li><li><strong>子类多态性和接口的关系：</strong><ul><li>子类多态性涉及对象在程序执行过程中可以具有多种形式或类型的概念。在文章中，子类多态性通过继承和接口实现，使得对象可以具有不同的形式。</li><li>接口在这里起到了关键作用。例如，<code>OurComparable</code> 接口定义了 <code>compareTo</code> 方法，通过让类实现这个接口，可以在不同类型的类之间实现相似的比较行为，实现多态性。</li></ul></li><li><strong>使用 Comparables 和 Comparators 实现灵活性：</strong><ul><li>通过使用 <code>Comparables</code> 接口，对象可以定义它们的自然顺序，使得它们可以参与排序等操作。</li><li>使用 <code>Comparators</code> 接口，可以实现多种比较方式，而不必修改对象的类。这提供了灵活性，允许在不同的上下文中使用不同的比较规则。</li></ul></li></ol><p>总体而言，Comparables 和 Comparators 提供了不同层次的比较机制，使得代码更加灵活，同时子类多态性通过接口的实现使得对象可以以多种形式存在。这些概念相互协作，为Java中的对象比较和多态性提供了强大的工具。</p><h2 id="对抽象的意义"><a href="#对抽象的意义" class="headerlink" title="对抽象的意义"></a>对抽象的意义</h2><ol><li><strong>抽象接口提高通用性：</strong><ul><li>接口（比如 <code>Comparable</code> 和 <code>Comparator</code>）提供了抽象的规范，定义了在不同类之间进行比较的通用方式。</li><li>这种抽象性使得可以编写通用的算法和方法，而无需关心具体类的实现细节，从而提高了代码的通用性。</li></ul></li><li><strong>多态性提高扩展性：</strong><ul><li>使用 <code>Comparables</code> 和 <code>Comparators</code> 的多态性，代码可以处理不同类型的对象，并根据实际情况选择适当的比较方式。</li><li>新的类可以轻松地实现相应的接口或比较器，而不需要修改现有的代码，从而提高了代码的扩展性。</li></ul></li><li><strong>减少耦合度：</strong><ul><li>通过接口和多态性，实现了对象之间的松散耦合。例如，一个算法可能仅关心对象是否可比较，而不关心对象的具体类型。</li><li>这种减少耦合度的设计使得代码更加灵活，减少了对具体实现的依赖，提高了系统的可维护性。</li></ul></li><li><strong>支持算法的通用性：</strong><ul><li>通过接口和抽象的比较机制，可以编写通用的排序、搜索等算法，这些算法可以在不同类型的对象上工作，只要它们实现了相应的接口或比较器。</li><li>这种通用性使得可以更容易地共享和重用算法，同时减少了代码冗余。</li></ul></li><li><strong>更好的代码组织和可读性：</strong><ul><li>使用抽象接口和多态性，可以更清晰地组织代码，将通用的比较逻辑与具体类的实现分离。</li><li>这提高了代码的可读性，使得代码更易于理解和维护。</li></ul></li></ol><p>总体而言，通过在面向对象的设计中引入抽象接口和多态性，可以使代码更加灵活、通用和可扩展。这种实现对于处理不同类型的对象、支持通用算法以及减少代码耦合度都具有重要的意义。</p><h2 id="思维流程"><a href="#思维流程" class="headerlink" title="思维流程"></a>思维流程</h2><ol><li><p>我们希望编写一个 <code>max</code> 函数，该函数接受任何数组（无论类型如何）并返回数组中的最大项。因为目前我们只有<code>Dog</code>类，所以我们在<code>Dog</code>类中编写了一个<code>MaxDog</code>的方法。</p></li><li><p>虽然这样子可以实现我们的目的，但是有个问题，当我们有其他类想要比较时，这个<code>Max</code>函数没有办法比较，导致这种情况的根本问题是 <strong>Objects 不能与 <code>&gt;</code> 进行比较</strong>。于是我们想创建一个接口来保证任何实现类（如 Dog）都包含一个比较方法，我们称之为 <code>compareTo</code> 。</p></li><li><p>于是我们创建了一个OurComparable接口，里面规定了compareTo方法。我们在Dog类中实现后，把max方法修改成了这样</p></li><li><p><img src="/2024/01/30/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-3/image-20240130034614544.png" alt="image-20240130034614544"></p></li><li><p>但是这样子又有些问题:没有现有类继承 OurComparable, 没有现有类使用 OurComparable。解决方案是什么？我们将利用一个名为 <code>Comparable</code> . <code>Comparable</code> 已经由 Java 定义，并被无数库使用。</p></li><li><p>如前所述，狗的自然排序是根据大小的值定义的。如果我们想以不同于狗的自然顺序的方式对狗进行排序，例如按它们名字的字母顺序排序，该怎么办？</p></li><li><p>Java 实现这一点的方式是使用 <code>Comparator</code>。由于 <code>Comparator</code> 是一个对象，我们将使用 <code>Comparator</code> 的方法是通过在 <code>Dog</code> 类内部编写一个实现 <code>Comparator</code> 接口的嵌套类。</p></li><li><pre><code class="java">import java.util.Comparator;public class Dog implements Comparable&lt;Dog&gt; &#123;    ...    public int compareTo(Dog uddaDog) &#123;        return this.size - uddaDog.size;    &#125;    private static class NameComparator implements Comparator&lt;Dog&gt; &#123;        public int compare(Dog a, Dog b) &#123;            return a.name.compareTo(b.name);        &#125;    &#125;    public static Comparator&lt;Dog&gt; getNameComparator() &#123;        return new NameComparator();    &#125;&#125;</code></pre></li><li><p>这样子就能实现自定义排序</p></li><li><p><img src="/2024/01/30/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-3/image-20240130032414722.png" alt="image-20240130032414722"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(八)-Rd4.2-Extends.Casting,HigherOrderFunction</title>
      <link href="/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-2/"/>
      <url>/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-2/</url>
      
        <content type="html"><![CDATA[<p>幻灯片:<a href="https://docs.google.com/presentation/d/1zsr4-MHM5STYr_b0l-lZ8ABqAPzyIU3P31qWKP2M3m4/edit#slide=id.g109ce79706_0_385">cs61b 2021 lec9 inheritance2 - Google 幻灯片</a></p><p>Reading:<a href="https://joshhug.gitbooks.io/hug61b/content/chap4/chap42.html">4.2 Extends, Casting, Higher Order Functions · Hug61B (gitbooks.io)</a></p><h1 id="Extends关键字"><a href="#Extends关键字" class="headerlink" title="Extends关键字"></a>Extends关键字</h1><p>现在，您已经了解了如何使用 <code>implements</code> 关键字来定义与接口的层次结构关系。如果我们想定义类之间的层次结构关系怎么办？</p><ul><li><code>implements</code> 关键字：定义类与接口的层次结构关系</li><li><code>extends</code>关键字：定义类之间的层次结构关系</li></ul><p>通过使用 <code>extends</code> 关键字，子类继承父类的所有成员。 “成员”包括：</p><ul><li>所有实例变量和静态变量</li><li>所有方法</li><li>所有嵌套类</li></ul><p>请注意，构造函数不是继承的，子类不能直接访问私有成员。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 请注意，当有人调用 removeLast SLList 时，它会丢弃该值 - 再也看不到了。但是，如果那些被移除的价值观离开并开始对我们进行大规模的反抗呢？在这种情况下，我们需要记住那些被删除的（或者更确切地说是有缺陷的&gt;:(）值是什么，以便我们可以追踪它们并在以后终止它们。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">我们创建了一个新类 VengefulSLList，它记住了所有被 removeLast 放逐的元素。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VengefulSLList</span>&lt;Item&gt; <span class="keyword">extends</span> <span class="title class_">SLList</span>&lt;Item&gt; &#123;</span><br><span class="line">    SLList&lt;Item&gt; deletedItems;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VengefulSLList</span><span class="params">()</span> &#123;</span><br><span class="line">        deletedItems = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Item&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Item</span> <span class="variable">x</span> <span class="operator">=</span> <span class="built_in">super</span>.removeLast();</span><br><span class="line">        deletedItems.addLast(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Prints deleted items. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLostItems</span><span class="params">()</span> &#123;</span><br><span class="line">        deletedItems.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="surper"><a href="#surper" class="headerlink" title="surper()"></a>surper()</h2><p>我们继承过来的不包含构造函数，虽然构造函数不是继承的，但 Java 要求所有构造函数都必须<strong>从调用其超类的构造函数之一开始</strong>。当我们调用子类的构造函数的时候，会隐形地调用基类的构造函数，也可以在构造函数中加入<code>surper()</code>语句来显性调用基类的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">VengefulSLList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();<span class="comment">//或者删掉</span></span><br><span class="line">    deletedItems = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Item&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样子看起来surper()好像没有存在的必要</p></blockquote><p>但是如果我们需要调用带参数的构造函数，如果纯隐形调用基类的构造函数的话，我们的传入的参数并没有什么用，于是我们需要将参数传入<code>surper()</code>中，即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">VengefulSLList</span><span class="params">(Item x)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(x);</span><br><span class="line">    deletedItems = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Item&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象类-The-Object-Class"><a href="#对象类-The-Object-Class" class="headerlink" title="对象类(The Object Class)"></a>对象类(The Object Class)</h2><p>Java 中的每个类都是 Object 类或 <code>extends</code> Object 类的后代。即使类中没有显式类，它们仍然隐式 <code>extends</code> 扩展 Object 类。</p><p><img src="/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-2/image-20240130003225738.png" alt="image-20240130003225738"></p><blockquote><p>虚线表示隐式继承</p></blockquote><p>Documentation for Object class: <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html">Object (Java SE 9 &amp; JDK 9 ) (oracle.com)</a></p><h1 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装(Encapsulation)"></a>封装(Encapsulation)</h1><p>封装是面向对象编程的基本原则之一，也是我们作为程序员用来抵抗我们最大的敌人：复杂性的方法之一。管理复杂性是我们在编写大型程序时必须面对的主要挑战之一。</p><p>我们可以用来对抗复杂性的一些工具包括分层抽象（抽象障碍！）和称为“为变革而设计”的概念。这围绕着这样一种想法，即程序应该被构建成模块化的、可互换的部分，这些部分可以在不破坏系统的情况下进行交换。此外，在管理大型系统时，隐藏其他人不需要的信息是另一种基本方法。</p><p>封装的根源在于这种向外部隐藏信息的概念。观察它的一种方法是了解封装如何类似于人类细胞。细胞的内部可能非常复杂，由染色体、线粒体、核糖体等组成，但它被完全封装在一个模块中——抽象出内部的复杂性。</p><p><img src="/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-2/cell_encapsulated.png" alt="img"></p><p>在计算机科学术语中，模块可以定义为一组方法，这些方法作为一个整体协同工作以执行一项任务或一组相关任务。这可能类似于表示列表的类。现在，如果一个模块的实现细节在内部被隐藏，并且与它交互的唯一方法是通过一个记录的接口，那么该模块就被称为封装。</p><p>以 <code>ArrayDeque</code> 类为例。外部世界能够 <code>ArrayDeque</code> 通过其定义的方法（如 <code>addLast</code> 和 ）利用和 <code>removeLast</code> 与之交互。但是，他们不需要了解数据结构如何实现的复杂细节，以便能够有效地使用它。</p><h2 id="抽象障碍-Abstraction-Barriers"><a href="#抽象障碍-Abstraction-Barriers" class="headerlink" title="抽象障碍(Abstraction Barriers)"></a>抽象障碍(Abstraction Barriers)</h2><p>理想情况下，用户应该无法观察他们正在使用的数据结构的内部工作原理。幸运的是，Java 使实施抽象壁垒变得容易。在 Java 中使用关键字 <code>private</code> ，几乎不可能查看对象内部 - 确保底层复杂性不会暴露给外界。</p><h2 id="继承如何破坏封装"><a href="#继承如何破坏封装" class="headerlink" title="继承如何破坏封装"></a>继承如何破坏封装</h2><p>假设我们在 Dog 类中有以下两种方法。我们本可以实现 <code>bark</code> 并 <code>barkMany</code> 像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;bark&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">barkMany</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">        bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，我们可以这样实现它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">    barkMany(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">barkMany</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从用户的角度来看，这些实现中的任何一个的功能都是完全相同的。但是，如果我们要定义一个 <code>Dog</code> called <code>VerboseDog</code> 的子类，并按如下方式覆盖其方法，则观察其 <code>barkMany</code> 效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">barkMany</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;As a dog, I say: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">        bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所看到的，使用第一个实现，输出是 <code>As a dog, I say: bark bark bark</code>，而使用第二个实现，程序陷入无限循环。对 <code>bark()</code> 的调用将调用 ，它调用 <code>barkMany(1)</code> <code>bark()</code> ，无限多次重复该过程。</p><h1 id="类型检查和铸造"><a href="#类型检查和铸造" class="headerlink" title="类型检查和铸造"></a>类型检查和铸造</h1><p>在讨论类型和转换之前，让我们回顾一下动态方法选择。回想一下，动态方法查找是根据对象的动态类型确定在运行时执行的方法的过程。具体来说，如果 SLList 中的方法被 VengefulSLList 类重写，则在运行时调用的方法由该变量的运行时类型或动态类型确定。</p><p><img src="/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-2/dynamic_selection.png" alt="img"></p><p>对于这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sl.printLostItems();</span><br></pre></td></tr></table></figure><p>上面的这一行会导致编译时错误。请记住，编译器根据对象的静态类型来确定某些内容是否有效。由于 <code>sl</code> 是静态类型 SLList，并且 <code>printLostItems</code> 未在 SLList 类中定义，因此即使 <code>sl</code> 的运行时类型是 VengefulSLList，也不允许运行代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VengefulSLList&lt;Integer&gt; vsl2 = sl;</span><br></pre></td></tr></table></figure><p>出于类似的原因，上面的这一行也会导致编译时错误。通常，编译器只允许基于编译时类型的方法调用和赋值。由于编译器只看到 的静态类型 <code>sl</code> 是 SLList，因此它不允许 VengefulSLList“容器”保存它。</p><p>总结:</p><ul><li>基类无法调用子类的方法</li><li>子类指针无法存储基类地址</li></ul><h2 id="表达-式"><a href="#表达-式" class="headerlink" title="表达 式"></a>表达 式</h2><p>与上面的变量一样，使用关键字的 <code>new</code> 表达式也具有编译时类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLList&lt;Integer&gt; sl = <span class="keyword">new</span> <span class="title class_">VengefulSLList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><p>上面，表达式右侧的编译时类型是 <code>VengefulSLList</code>。编译器检查以确保 <code>VengefulSLList</code> “is-a”<code> SLList</code>，并允许此赋值，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VengefulSLList&lt;Integer&gt; vsl = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><p>上面，表达式右侧的编译时类型是<code> SLList</code>。编译器检查 <code>SLList</code> “is a”<code>VengefulSLList</code>，并非在所有情况下都是如此，因此会导致编译错误。</p><p>此外，方法调用具有与其声明类型相等的编译时类型。假设我们有这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Dog <span class="title function_">maxDog</span><span class="params">(Dog d1, Dog d2)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>由于返回类型 <code>maxDog</code> 为 Dog，因此任何调用 <code>maxDog</code> 都将具有编译时类型 Dog。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Poodle</span> <span class="variable">frank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Poodle</span>(<span class="string">&quot;Frank&quot;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">Poodle</span> <span class="variable">frankJr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Poodle</span>(<span class="string">&quot;Frank Jr.&quot;</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Dog</span> <span class="variable">largerDog</span> <span class="operator">=</span> maxDog(frank, frankJr);</span><br><span class="line"><span class="type">Poodle</span> <span class="variable">largerPoodle</span> <span class="operator">=</span> maxDog(frank, frankJr); <span class="comment">//does not compile! RHS has compile-time type Dog</span></span><br></pre></td></tr></table></figure><p>将 Dog 对象分配给 Poodle 变量（如在 SLList 案例中）会导致编译错误。贵宾犬“是”一只狗，但更一般的狗对象可能并不总是贵宾犬，即使它显然是你和我（我们知道这一点 <code>frank</code> ，并且 <code>frankJr</code> 都是贵宾犬！当我们确定分配会起作用时，有什么办法可以解决这个问题吗？</p><h2 id="转换-Casting"><a href="#转换-Casting" class="headerlink" title="转换(Casting)"></a>转换(Casting)</h2><p>Java 有一种特殊的语法，您可以在其中告诉编译器特定表达式具有特定的编译时类型。这称为<strong>“转换”</strong>。通过强制转换，我们可以告诉编译器将表达式视为不同的编译时类型。</p><p>回顾上面失败的代码，既然我们知道并且 <code>frank</code> <code>frankJr</code> 都是贵宾犬，我们可以强制执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Poodle</span> <span class="variable">largerPoodle</span> <span class="operator">=</span> (Poodle) maxDog(frank, frankJr); <span class="comment">// compiles! Right hand side has compile-time type Poodle after casting</span></span><br></pre></td></tr></table></figure><p><em>注意</em>：转换是一种强大但危险的工具。从本质上讲，强制转换是告诉编译器不要执行其类型检查职责 - 告诉它信任你并按照你希望的方式行事。以下是可能出现的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Poodle</span> <span class="variable">frank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Poodle</span>(<span class="string">&quot;Frank&quot;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">Malamute</span> <span class="variable">frankSr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Malamute</span>(<span class="string">&quot;Frank Sr.&quot;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Poodle</span> <span class="variable">largerPoodle</span> <span class="operator">=</span> (Poodle) maxDog(frank, frankSr); <span class="comment">// runtime exception!</span></span><br></pre></td></tr></table></figure><p>在这种情况下，我们比较贵宾犬和雪橇犬。如果没有强制转换，编译器通常不允许调用编译 <code>maxDog</code> ，因为右侧的编译时类型是 Dog，而不是 Poodle。但是，强制转换允许此代码通过，并且当在运行时返回雪橇犬时，我们尝试将雪橇犬强制转换为贵宾犬时，我们遇到了运行时 <code>maxDog</code> 异常 - a <code>ClassCastException</code> .</p><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>高阶函数是将其他函数视为数据的函数。例如，以这个 Python 程序 <code>do_twice</code> 为例，它接受另一个函数作为输入，并将其应用于输入 <code>x</code> 两次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tenX</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>*x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_twice</span>(<span class="params">f, x</span>):</span><br><span class="line">    <span class="keyword">return</span> f(f(x))</span><br></pre></td></tr></table></figure><p>调用 <code>print(do_twice(tenX, 2))</code> 会将 tenX 应用于 2，然后再次将 tenX 应用于其结果 20，从而得到 200。我们如何在 Java 中做这样的事情？</p><p>在老式的 Java（Java 7 及更早版本）中，内存框（变量）不能包含指向函数的指针。这意味着我们无法编写具有“Function”类型的函数，因为根本没有函数类型。</p><p>为了解决这个问题，我们可以利用接口继承。让我们编写一个接口来定义任何接受整数并返回整数的函数 - 一个 <code>IntUnaryFunction</code> .</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IntUnaryFunction</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以编写一个类来 <code>implements IntUnaryFunction</code> 表示一个具体的函数。让我们创建一个函数，它接受一个整数并返回该整数的 10 倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TenX</span> <span class="keyword">implements</span> <span class="title class_">IntUnaryFunction</span> &#123;</span><br><span class="line">    <span class="comment">/* Returns ten times the argument. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span> * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这一点上，我们已经用 Java 编写了 <code>tenX</code> 该函数的 Python 等价物。让我们现在写 <code>do_twice</code> 吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">do_twice</span><span class="params">(IntUnaryFunction f, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f.apply(f.apply(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 中调用 <code>print(do_twice(tenX, 2))</code> 如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(do_twice(<span class="keyword">new</span> <span class="title class_">TenX</span>(), <span class="number">2</span>));</span><br></pre></td></tr></table></figure><h1 id="继承备忘单"><a href="#继承备忘单" class="headerlink" title="继承备忘单"></a>继承备忘单</h1><p><code>VengefulSLList extends SLList</code> 表示 VengefulSLList “is-an” SLList，并继承 SLList 的所有成员：</p><ul><li>变量、方法、嵌套类</li><li>不是构造函数 子类构造函数必须首先调用超类构造函数。该 <code>super</code> 关键字可用于调用重写的超类方法和构造函数。</li></ul><p>重写方法的调用遵循两个简单的规则：</p><ul><li>编译器是安全的，只允许我们根据静态类型做事。</li><li>对于重写的方法（非重载方法），调用的实际方法基于调用表达式的动态类型</li><li>可以使用强制转换来否决编译器类型检查。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(七)-Rd4.1-导言和接口</title>
      <link href="/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-1/"/>
      <url>/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://joshhug.gitbooks.io/hug61b/content/chap4/chap41.html">4.1 Intro and interfaces · Hug61B (gitbooks.io)</a></p><h1 id="方法重载-method-overloading"><a href="#方法重载-method-overloading" class="headerlink" title="方法重载(method overloading)"></a>方法重载(<em>method overloading</em>)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longest</span><span class="params">(SLList&lt;String&gt; list)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longest</span><span class="params">(AList&lt;String&gt; list)</span></span><br></pre></td></tr></table></figure><p>这就是所谓的方法重载。当您调用 <code>WordUtils.longest</code> 时，Java 会根据您提供的参数类型知道要运行哪一个。如果为其提供 <code>AList</code>，它将调用 <code>AList </code>方法。与 <code>SLList</code> 相同。</p><p>Java 足够聪明，知道如何为不同类型的两种相同的方法处理，这很好，但重载有几个缺点：</p><ul><li>这是超级重复和丑陋的，因为你现在有两个几乎相同的代码块。</li><li>它需要更多的代码来维护，这意味着如果你想对方法进行一些小的更改，例如更正一个错误，你需要在 <code>longest</code> 方法中为每种类型的列表进行更改。</li><li>如果我们想创建更多的列表类型，我们必须为每个新的列表类复制该方法。</li></ul><h1 id="上位词、下位词和接口继承"><a href="#上位词、下位词和接口继承" class="headerlink" title="上位词、下位词和接口继承"></a>上位词、下位词和接口继承</h1><p><strong>Hypernyms, Hyponyms, and Interface Inheritance</strong></p><p>狗是贵宾犬、雪橇犬、哈士奇等的上位词。相反，贵宾犬、雪橇犬和哈士奇是狗的下位词。</p><p>这些词构成了“is-a”关系的层次结构：</p><ul><li>a poodle “is-a” dog<br>贵宾犬“is-a”狗</li><li>a dog “is-a” canine<br>一只狗“是”犬</li><li>a canine “is-a” carnivore<br>犬科动物“IS-A”食肉动物</li><li>a carnivore “is-an” animal<br>食肉动物“is-an”动物</li></ul><p><img src="/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-1/hierarchy.png" alt="hierarchy"></p><p>同样的层次结构也适用于 SLLists 和 ALists！SLList 和 AList 都是更一般的列表的下位词。</p><p>我们将在 Java 中形式化这种关系：如果 SLList 是 List61B 的下位词，那么 SLList 类是 List61B 类的子类，而 List61B 类是 SLList 类的超类。</p><p><strong>图 4.1.1 :</strong></p><p><img src="/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-1/subclass.png" alt="subclass"></p><p>在 Java 中，为了表达这个层次结构，我们需要做<strong>两件事</strong>：</p><ul><li>第 1 步：为常规列表超义词定义一个类型——我们将选择名称 List61B。</li><li>第 2 步：指定 SLList 和 AList 是该类型的下位词。</li></ul><p>新的 List61B 是 Java 所说的**接口(interface)**。它本质上是一个指定列表必须能够执行的操作的协定，但它不为这些行为提供任何实现。</p><p>这是我们的 List61B 接口。至此，我们已经完成了建立关系层次结构的第一步：创建超义词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List61B</span>&lt;Item&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(Item x)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> add <span class="title function_">Last</span><span class="params">(Item y)</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">getFirst</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">getLast</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">removeLast</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Item x, <span class="type">int</span> position)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，要完成步骤 2，我们需要指定 AList 和 SLList 是 List61B 类的下位词。在 Java 中，我们在类定义中定义了这种关系。</p><p>我们将添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class AList&lt;Item&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure><p>定义关系的词：implements。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class AList&lt;Item&gt; implements List61B&lt;Item&gt;&#123;...&#125;</span><br></pre></td></tr></table></figure><p><code>implements List61B&lt;Item&gt;</code> 本质上是一个承诺。AList 说“我保证我将拥有并定义 List61B 接口中指定的所有属性和行为”</p><p>现在我们可以编辑我们 <code>longest</code> 的方法 <code>WordUtils</code> 以接收 List61B。因为 AList 和 SLList 共享“is-a”关系。</p><h1 id="方法覆盖-Override"><a href="#方法覆盖-Override" class="headerlink" title="方法覆盖(@Override)"></a>方法覆盖(@Override)</h1><p>在子类中实现所需的函数时，在方法签名的顶部包含 <code>@Override</code> 标记很有用（实际上在 61B 中也是必需的）。在这里，我们只用一种方法做到了这一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(Item x)</span> &#123;</span><br><span class="line">    insert(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，即使您不包含此标记，您<strong>仍然会</strong>覆盖该方法。所以从技术上讲，你不必包括它。但是，包含标记可以作为程序员的一种保护措施，提醒编译器您打算重写此方法。你问为什么这会有帮助？嗯，这有点像有一个校对员！编译器会告诉您过程中是否出现问题。</p><p>为什么我们要用Override呢？:</p><ul><li>主要原因:防止打字错误。<ul><li>如果你说@Override，但如果这个方法没有覆盖任何东西，你会得到一个编译错误。</li><li>例如public void addLats(项目x)</li></ul></li><li>提醒程序员，方法定义来自继承层次结构中更高的位置。</li></ul><h2 id="接口继承-Interface-Inheritance"><a href="#接口继承-Interface-Inheritance" class="headerlink" title="接口继承(Interface Inheritance)"></a>接口继承(Interface Inheritance)</h2><p>接口继承是指子类继承超类的所有方法&#x2F;行为的关系。正如我们在 Hyponyms 和 Hypernyms 部分中定义的 List61B 类一样，该接口包括所有方法签名，但不包括实现。由子类实际提供这些实现。</p><p>这种继承也是多代的。这意味着，如果我们有一长串的超类&#x2F;子类关系，如图 4.1.1 所示，AList 不仅继承了 List61B 的方法，而且还继承了它上面的所有其他类，一直到最高超类 AKA AList 继承自 Collection。</p><h1 id="GRoE"><a href="#GRoE" class="headerlink" title="GRoE"></a>GRoE</h1><p>回想一下我们在第一章中介绍的平等黄金法则。这意味着每当我们进行赋值时 <code>a = b</code> ，我们都会将 b 中的位复制到 a 中，并要求 b 与 a 的类型相同。你不能分配 <code>Dog b = 1</code> OR <code>Dog b = new Cat()</code> ，因为 1 不是狗，猫也不是。</p><p>让我们尝试将此规则应用于我们之前在本章中编写 <code>longest</code> 的方法。</p><p><code>public static String longest(List61B&lt;String&gt; list)</code> 接受 List61B。我们说过这也可以接受 AList 和 SLList，但由于 AList 和 List61B 是不同的类，这怎么可能呢？好吧，回想一下，AList 与 List61B 共享“is-a”关系，这意味着 AList 应该能够放入 List61B 框中！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List61B&lt;String&gt; someList = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;String&gt;();</span><br><span class="line">    someList.addFirst(<span class="string">&quot;elk&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当它运行时，将创建 SLList，并且其地址存储在 someList 变量中。然后将字符串“elk”插入到 addFirst 引用的 SLList 中。</p></blockquote><h2 id="实现继承"><a href="#实现继承" class="headerlink" title="实现继承"></a>实现继承</h2><p>以前，我们有一个接口 List61B，它只有标识 List61B 应该做什么的方法标头。但是，现在我们将看到我们可以在 List61B 中编写已经填写了实现的方法。这些方法确定 List61B 的上位词应如何表现。</p><p>为此，必须在方法签名中包含 <strong><code>default</code> 关键字</strong>。</p><p>如果我们在 List61B 中定义此方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size(); i += <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print(get(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么所有实现 List61B 类的东西都可以使用该方法！</p><p>然而，这种方法对于SLList来说过于慢，因为他是基于链表实现的列表，这样子相当于运用了两次for循环</p><p>我们希望 SLList 的打印方式与其接口中指定的方式不同。为此，我们需要覆盖它。在 SLList 中，我们实现了这种方法;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> sentinel.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">        System.out.print(p.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，每当我们在 SLList 上调用 print（） 时，它都会调用此方法而不是 List61B 中的方法。</p><h3 id="动态类型以及动态方法选择"><a href="#动态类型以及动态方法选择" class="headerlink" title="动态类型以及动态方法选择"></a>动态类型以及动态方法选择</h3><p>您可能想知道，Java 如何知道要调用哪个 print（）？问得好。Java 之所以能够做到这一点，是因为有一种叫做动态方法选择的东西。</p><p>我们知道 java 中的变量有一个类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List61B&lt;String&gt; lst = new SLList&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>In the above declaration and instantiation, lst is of type “List61B”. This is called the “static type”<br>在上面的声明和实例化中，lst 的类型为“List61B”。这称为“静态类型”</p><p>但是，对象本身也具有类型。LST 指向的对象类型为 SLList。尽管这个对象本质上是一个 SLList（因为它被声明为 SLList），但它也是一个 List61B，因为我们之前探讨过的“is-a”关系。但是，由于对象本身是使用 SLList 构造函数实例化的，因此我们将其称为“动态类型”。</p><h4 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型:"></a>动态类型:</h4><ul><li>这是在实例化时指定的类型(例如在使用new时)。</li><li>等于所指向的对象的类型。</li></ul><p><img src="/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-1/image-20240129204744765.png" alt="image-20240129204744765"></p><p><img src="/2024/01/29/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Rd4-1/image-20240129204833057.png" alt="image-20240129204833057"></p><p>当 Java 运行被重写的方法时，它会在其动态类型中搜索适当的方法签名并运行它。</p><p><strong>重要提示：这不适用于重载方法！</strong></p><p>假设同一类中有两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">peek</span><span class="params">(List61B&lt;String&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(list.getLast());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">peek</span><span class="params">(SLList&lt;String&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(list.getFirst());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后运行此代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SLList&lt;String&gt; SP = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;String&gt;();</span><br><span class="line">List61B&lt;String&gt; LP = SP;</span><br><span class="line">SP.addLast(<span class="string">&quot;elk&quot;</span>);</span><br><span class="line">SP.addLast(<span class="string">&quot;are&quot;</span>);</span><br><span class="line">SP.addLast(<span class="string">&quot;cool&quot;</span>);</span><br><span class="line">peek(SP);</span><br><span class="line">peek(LP);</span><br></pre></td></tr></table></figure><p>对 peek（） 的第一次调用将使用第二个 peek 方法，该方法接受 SLList。对 peek（） 的第二次调用将使用第一个 peek 方法，该方法接受 List61B。这是因为两个重载方法之间的唯一区别是<strong>参数的类型</strong>。当 Java 检查要调用的方法时，它会检查静态类型并使用相同类型的参数调用该方法。</p><blockquote><p>动态方法不适用于方法重载，方法重载只考虑签名，不考虑指向</p><p>这里的SP和LP的动态类型都是SLList(因为都指向SLList)</p></blockquote><h2 id="接口继承-vs-实现继承"><a href="#接口继承-vs-实现继承" class="headerlink" title="接口继承 vs 实现继承"></a>接口继承 vs 实现继承</h2><ol><li><strong>接口继承（Interface Inheritance）：</strong><ul><li>接口继承是指一个类使用另一个类的接口（方法签名）而不继承其实现。</li><li>在接口继承中，子类仅继承父类的方法签名，但并不继承实际的实现代码。</li><li>接口继承的主要目的是为了定义一组共享的方法规范，以确保实现这些接口的类都有相似的行为。</li><li>多个类可以实现同一个接口，从而达到代码的可复用性和灵活性。</li></ul></li><li><strong>实现继承（Implementation Inheritance）：</strong><ul><li>实现继承是指一个类从另一个类直接继承实现代码，包括属性和方法。</li><li>在实现继承中，子类不仅继承了父类的方法签名，还继承了具体的方法实现。</li><li>实现继承用于在子类中重用和扩展父类的功能，但可能导致较强的耦合性和继承链的脆弱性。</li></ul></li></ol><p>总的来说，区分接口继承和实现继承的关键在于是否继承了具体的实现代码。接口继承注重于定义规范，而实现继承注重于代码的重用和共享。在面向对象设计中，通常倡导使用接口继承来实现松耦合的设计，避免过度依赖具体的实现。</p><p>创建这些层次结构时，请记住，子类和超类之间的关系应为<strong>“is-a”</strong>关系。AKA Cat 应该只实现 Animal Cat is an Animal。您不应该使用“has-a”关系来定义它们。Cat 有爪子，但 Cat 绝对不应该实现 Claw。</p><p>最后，实现继承听起来不错，但也有一些缺点：</p><ul><li>我们是容易犯错的人，我们无法跟踪所有事情，所以你有可能推翻了一种方法，但忘记了你做了。</li><li>I如果两个接口提供冲突的默认方法，则可能很难解决冲突。</li><li>它鼓励过于复杂的代码</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B项目练习笔记(三)-Proj1</title>
      <link href="/2024/01/29/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj1/"/>
      <url>/2024/01/29/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj1/</url>
      
        <content type="html"><![CDATA[<h1 id="The-Deque-API"><a href="#The-Deque-API" class="headerlink" title="The Deque API"></a>The Deque API</h1><p>Deque（通常发音为“deck”）是双端队列的不规则首字母缩写。双端队列是具有动态大小的序列容器，可以在两端（其前端或后端）扩展或收缩。</p><p>具体而言，任何 deque 实现都必须具有以下操作：</p><ul><li><code>public void addFirst(T item)</code> ：将某个类型的 <code>T</code> 项目添加到 deque 的前面。你可以假设这 <code>item</code> 从来都不是 <code>null</code> .</li><li><code>public void addLast(T item)</code> ：将类型的 <code>T</code> 项目添加到 deque 的背面。你可以假设这 <code>item</code> 从来都不是 <code>null</code> .</li><li><code>public boolean isEmpty()</code> ：如果 deque 为空，则返回， <code>false</code> 否则返回 <code>true</code> 。</li><li><code>public int size()</code> ：返回 deque 中的项数。</li><li><code>public void printDeque()</code> ：从头到尾打印 deque 中的项目，用空格分隔。打印完所有项目后，打印出新行。</li><li><code>public T removeFirst()</code> ：删除并返回 deque 前面的项目。如果不存在此类项，则返回 <code>null</code> 。</li><li><code>public T removeLast()</code> ：删除并返回 deque 背面的项目。如果不存在此类项，则返回 <code>null</code> 。</li><li><code>public T get(int index)</code> ：获取给定索引处的项，其中 0 是前面，1 是下一个项，依此类推。如果不存在此类项，则返回 <code>null</code> 。不得改动deque！</li></ul><p>此外，我们还希望我们的两个 Deque 实现这两个特殊方法：</p><ul><li><code>public Iterator&lt;T&gt; iterator()</code> ：我们将要创建的 Deque 对象是可迭代的（即 <code>Iterable&lt;T&gt;</code> ），因此我们必须提供此方法来返回迭代器。</li><li><code>public boolean equals(Object o)</code> ：返回参数 <code>o</code> 是否等于 Deque。 <code>o</code> 如果它是 Deque，并且如果它以相同的顺序包含相同的内容（由泛型 <code>T</code> <code>equals</code> 方法支配）则被认为是相等的。（添加 2&#x2F;12：您需要为此使用 <code>instance of</code> 关键字。阅读<a href="https://www.javatpoint.com/downcasting-with-instanceof-operator">here</a>了解更多信息）</li></ul><blockquote><p>添加 2&#x2F;12：您不应该实现接口 <code>Deque</code> ，而应该只实现 <code>Iterable</code> 两个实现 <code>LinkedListDeque</code> 和 <code>ArrayDeque</code> .如果您执行前者，我们的自动评分器将为您提供 API 错误。</p><p>您将在第 11 讲 （2&#x2F;12） 中了解 an <code>Iterator</code> 是什么，所以现在不要担心。这个项目旨在随着您从讲座和讨论中学到更多东西而一点一点地完成，这是练习您在本课程中学到的所有东西的绝佳机会。</p><p>您的类应该接受任何泛型类型（而不仅仅是整数）。有关创建和使用泛型数据结构的信息，请参阅 <a href="https://docs.google.com/presentation/d/19TTe3JgFscc4RLwokvQ_gOM72DSrfs9Y6ZST_fv3aQ4">lecture 5</a>。请务必密切注意最后一张幻灯片中关于泛型的经验法则。</p><p>在此项目中，您将为 Deque 接口提供两种实现：一种由链表提供支持，另一种由调整大小数组提供支持</p></blockquote><h1 id="项目任务"><a href="#项目任务" class="headerlink" title="项目任务"></a>项目任务</h1><h2 id="Linked-List-Deque"><a href="#Linked-List-Deque" class="headerlink" title="Linked List Deque"></a>Linked List Deque</h2><p>作为第一个 deque 实现，您将构建基于 <code>LinkedListDeque</code> 链表的类。</p><p>您的操作受以下规则的约束：</p><ul><li><code>add</code> 并且 <code>remove</code> 操作不得涉及任何循环或递归。单个此类操作必须花费“恒定时间”，即执行时间不应取决于 deque 的大小。这意味着您不能使用遍历 deque 的所有&#x2F;大多数元素的循环。</li><li><code>get</code> 必须使用迭代，而不是递归。</li><li><code>size</code> 必须花费恒定的时间。</li><li><code>LinkedListDeque</code> 循环使用 for-each 循环所需的时间应与项目数成正比。</li><li>不要保留对不再在 deque 中的项目的引用。程序在任何给定时间使用的内存量必须与项数成正比。例如，如果将 10,000 个项目添加到 deque，然后删除 9,999 个项目，则生成的内存使用量应等于 1 个项目的 deque，而不是 10,000。请记住，Java 垃圾收集器将在且仅当没有指向该对象的指针时为我们“删除”内容。</li></ul><p>实现上面“Deque API”部分中列出的所有方法。</p><p>此外，您还需要实现：</p><ul><li><code>public LinkedListDeque()</code> ：创建一个空的链表取消。</li><li><code>public T getRecursive(int index)</code> ：与 get 相同，但使用递归。</li></ul><p>虽然这听起来很简单，但有许多设计问题需要考虑，您可能会发现实现比您预期的更具挑战性。请务必查阅有关双向链表的讲座，特别是关于哨兵节点的幻灯片：两个哨兵拓 <a href="https://docs.google.com/presentation/d/1suIeJ1SIGxoNDT8enLwsSrMxcw4JTvJBsMcdARpqQCk/pub?start=false&loop=false&delayms=3000&slide=id.g829fe3f43_0_291">two sentinel topology</a>扑和圆形哨兵拓扑<a href="https://docs.google.com/presentation/d/1suIeJ1SIGxoNDT8enLwsSrMxcw4JTvJBsMcdARpqQCk/pub?start=false&loop=false&delayms=3000&slide=id.g829fe3f43_0_376">circular sentinel topology</a>。我更喜欢循环方法。</p><p><img src="/2024/01/29/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj1/5f80de28514b0bc51dc944e1a7129ac.png" alt="5f80de28514b0bc51dc944e1a7129ac"></p><p><img src="/2024/01/29/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj1/e38a8427e6351cf3a2733e4708df329.png" alt="e38a8427e6351cf3a2733e4708df329"></p><h3 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> deque;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListDeque</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> T item;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        <span class="keyword">public</span> Node prev;</span><br><span class="line">        Node(T i, Node p, Node n) &#123;</span><br><span class="line">            item = i;</span><br><span class="line">            prev = p;</span><br><span class="line">            next = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node sentinel;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListDeque</span><span class="params">()</span> &#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span> ,<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        sentinel.prev = sentinel;</span><br><span class="line">        sentinel.next = sentinel;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListDeque</span><span class="params">(T i)</span> &#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> <span class="title class_">Node</span>(i, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        sentinel.next = <span class="keyword">new</span> <span class="title class_">Node</span>(i, sentinel, sentinel);</span><br><span class="line">        sentinel.prev = sentinel.next;</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item of type T to the front of the deque.</span></span><br><span class="line"><span class="comment">     * You can assume that item is never null. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        sentinel.next = <span class="keyword">new</span> <span class="title class_">Node</span>(item, sentinel, sentinel.next);</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item of type T to the back of the deque.</span></span><br><span class="line"><span class="comment">     * You can assume that item is never null. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        sentinel.prev = <span class="keyword">new</span> <span class="title class_">Node</span>(item, sentinel.prev, sentinel);</span><br><span class="line">        sentinel.prev.prev.next = sentinel.prev;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns true if deque is empty, false otherwise. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns the number of items in the deque. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Prints the items in the deque from first to last, separated by a space.</span></span><br><span class="line"><span class="comment">     * Once all the items have been printed, print out a new line. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printDeque</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print(p.next.item);</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            p = p.next;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes and returns the item at the front of the deque.</span></span><br><span class="line"><span class="comment">     * If no such item exists, returns null. */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="type">T</span> <span class="variable">item</span> <span class="operator">=</span> sentinel.next.item;</span><br><span class="line">        sentinel.next.next.prev = sentinel.next.prev;</span><br><span class="line">        sentinel.next = sentinel.next.next;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes and returns the item at the back of the deque.</span></span><br><span class="line"><span class="comment">     * If no such item exists, returns null. */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="type">T</span> <span class="variable">item</span> <span class="operator">=</span> sentinel.prev.item;</span><br><span class="line">        sentinel.prev.prev.next = sentinel;</span><br><span class="line">        sentinel.prev = sentinel.prev.prev;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Gets the item at the given index, where 0 is the front, 1 is the next item, and so forth.</span></span><br><span class="line"><span class="comment">     * If no such item exists, returns null. Must not alter the deque! */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T <span class="title function_">getRecursivehelper</span><span class="params">(<span class="type">int</span> index, Node s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s.item;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getRecursivehelper(index - <span class="number">1</span>, s.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Same as get, but uses recursion. */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getRecursive</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getRecursivehelper(index, sentinel.next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Array-Deque"><a href="#Array-Deque" class="headerlink" title="Array Deque"></a>Array Deque</h2><p>对于此实现，您的操作受以下规则的约束：</p><ul><li><code>add</code> 并且 <code>remove</code> 必须花费恒定的时间，除非在调整大小操作期间。</li><li><code>get</code> 并且 <code>size</code> 必须花费恒定的时间。</li><li>数组的起始大小应为 8。</li><li>程序在任何给定时间使用的内存量必须与项数成正比。例如，如果将 10,000 个项目添加到 deque，然后删除 9,999 个项目，则不应仍使用长度为 10,000ish 的数组。对于长度为 16 或更大的数组，使用系数应始终至少为 25%。这意味着，在执行将数组中的元素数控制在数组长度的 25% 以下的删除操作之前，应减小数组的大小。对于较小的阵列，使用系数可以任意降低。</li></ul><p>实现上面“Deque API”部分中列出的所有方法。</p><p>此外，您还需要实现：</p><ul><li><code>public ArrayDeque()</code> ：创建一个空数组 deque。</li></ul><p>您将需要以某种方式跟踪哪些数组索引包含 Deque 的正面和背面元素。我们强烈建议您在本练习中将数组视为循环数组。换言之，如果你的前面项位于零位置，而 u <code>addFirst</code> ，则新的前面应该循环回数组的末尾（因此 deque 中的新前面项将是基础数组中的最后一个项）。与非循环方法相比，这将导致更少的头痛。有关更多详细信息，请参阅项目 1 <a href="https://docs.google.com/presentation/d/1XBJOht0xWz1tEvLuvOL4lOIaY0NSfArXAvqgkrx0zpc/edit#slide=id.g1094ff4355_0_450">project 1 demo slides</a> 演示幻灯片。</p><h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> deque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDeque</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] item;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nextFirst;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nextLast;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">()</span> &#123;</span><br><span class="line">        item = (T []) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">8</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        nextFirst = <span class="number">1</span>;</span><br><span class="line">        nextLast = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(ArrayDeque other)</span> &#123;</span><br><span class="line">        item = (T []) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">8</span>];</span><br><span class="line">        System.arraycopy(other.item, <span class="number">0</span>, item, <span class="number">0</span>, size);</span><br><span class="line">        size = other.size;</span><br><span class="line">        nextFirst = other.nextFirst;</span><br><span class="line">        nextLast = other.nextLast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">ForwardValue</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        n--;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            n = item.length - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">BackValue</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= item.length) &#123;</span><br><span class="line">            n = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** before performing a remove operation that will bring the number of elements in the array under 25% the length of the array, </span></span><br><span class="line"><span class="comment">     * resize the size of the array down. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        T[] a = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[x];</span><br><span class="line">        <span class="keyword">if</span> ((size &lt; item.length / <span class="number">4</span>) &amp;&amp; (size &gt; <span class="number">16</span>)) &#123;</span><br><span class="line">            System.arraycopy(item, nextFirst+<span class="number">1</span>, a, <span class="number">0</span>, size);</span><br><span class="line">            nextFirst = -<span class="number">1</span>;</span><br><span class="line">            nextLast = size;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.arraycopy(item, <span class="number">0</span>, a, <span class="number">0</span>, nextFirst+<span class="number">1</span>);</span><br><span class="line">            System.arraycopy(item, nextLast, a, a.length - item.length + nextFirst + <span class="number">1</span>, item.length - nextFirst -<span class="number">1</span>);</span><br><span class="line">            nextFirst = a.length - item.length + nextFirst;</span><br><span class="line">        &#125;</span><br><span class="line">        item = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item of type T to the front of the deque.</span></span><br><span class="line"><span class="comment">     * You can assume that item is never null. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(T i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == item.length) &#123;</span><br><span class="line">            resize(size * <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">while</span> (item[nextFirst] != <span class="literal">null</span>) &#123;</span><br><span class="line">                nextFirst = ForwardValue(nextFirst);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        item[nextFirst] = i;</span><br><span class="line">        size++;</span><br><span class="line">        nextFirst = ForwardValue(nextFirst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item of type T to the back of the deque.</span></span><br><span class="line"><span class="comment">     * You can assume that item is never null. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(T i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == item.length) &#123;</span><br><span class="line">            resize(size * <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">while</span> (item[nextLast] != <span class="literal">null</span>) &#123;</span><br><span class="line">                nextLast = BackValue(nextLast);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        item[nextLast] = i;</span><br><span class="line">        size++;</span><br><span class="line">        nextLast = BackValue(nextLast);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns true if deque is empty, false otherwise. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size &lt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns the number of items in the deque. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Prints the items in the deque from first to last, separated by a space.</span></span><br><span class="line"><span class="comment">     * Once all the items have been printed, print out a new line. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printDeque</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            System.out.println(item[(nextFirst + i + <span class="number">1</span>) % item.length]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes and returns the item at the front of the deque.</span></span><br><span class="line"><span class="comment">     * If no such item exists, returns null. */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((size &lt; item.length / <span class="number">4</span>) &amp;&amp; (size &gt; <span class="number">16</span>)) &#123;</span><br><span class="line">            resize(item.length / <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">curValue</span> <span class="operator">=</span> item[BackValue(nextFirst)];</span><br><span class="line">        item[BackValue(nextFirst)] = <span class="literal">null</span>;</span><br><span class="line">        nextFirst = BackValue(nextFirst);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> curValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes and returns the item at the back of the deque.</span></span><br><span class="line"><span class="comment">     * If no such item exists, returns null. */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((size &lt; item.length / <span class="number">4</span>) &amp;&amp; (size &gt; <span class="number">16</span>)) &#123;</span><br><span class="line">            resize(item.length / <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">T</span> <span class="variable">curValue</span> <span class="operator">=</span> item[ForwardValue(nextLast)];</span><br><span class="line">        item[ForwardValue(nextLast)] = <span class="literal">null</span>;</span><br><span class="line">        nextLast = ForwardValue(nextLast);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> curValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Gets the ith item in the list (0 is the front). */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item[(nextFirst + i + <span class="number">1</span>) % item.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Deque-Interface-接口"><a href="#Deque-Interface-接口" class="headerlink" title="Deque Interface(接口)"></a>Deque Interface(接口)</h1><p>回想一下，我们通过以下方法定义了 <code>Deque</code> API 或行为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void addFirst(T item)</span><br><span class="line">public void addLast(T item)</span><br><span class="line">public boolean isEmpty()</span><br><span class="line">public int size()</span><br><span class="line">public void printDeque()</span><br><span class="line">public T removeFirst()</span><br><span class="line">public T removeLast()</span><br><span class="line">public T get(int index) </span><br></pre></td></tr></table></figure><p>由于程序将依赖于此行为，因此提供什么 <code>Deque</code> 实现对它来说并不重要，或者 <code>LinkedListDeque</code> ， <code>ArrayDeque</code> 并且应该同时适用于两者。为了实现这一点，我们将使用接口的强大功能。</p><p>在包含上述所有方法的新 <code>Deque.java</code> 文件中创建一个接口。在 IntelliJ 中，使用“New → Java Class”。IntelliJ 会假设你想要一个类，所以一定要把 <code>class</code> 关键词换成 <code>interface</code> 。不要忘记声明 <code>Deque</code> 接口是包的一部分 <code>deque</code> ！</p><p>修改你的 <code>LinkedListDeque</code> 或 <code>ArrayDeque</code> ，以便它们通过添加到 <code>implements Deque&lt;T&gt;</code> 声明类存在的行来实现 <code>Deque</code> 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDeque</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Deque</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListDeque</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Deque</span>&lt;T&gt;</span><br></pre></td></tr></table></figure><p>向覆盖方法的每个 <code>Deque</code> 方法添加 <code>@Override</code> 标记。</p><p>现在，在接口中 <code>Deque</code> ，给出 <code>isEmpty()</code> 一个 <code>default</code> 实现，如果 <code>size()</code> 是 <code>0</code> ，则返回 <code>true</code> .由于 your <code>LinkedListDeque</code> 和 实现接口 <code>Deque</code> ，给定默认 <code>isEmpty()</code> 实现，您可以从之前实现的 <code>LinkedListDeque</code> 和 <code>ArrayDeque</code> <code>ArrayDeque</code> 中删除该方法。</p><p>现在，在实现 <code>Deque</code> 接口并从 <code>LinkedListDeque</code> 和 <code>ArrayDeque</code> 实现中删除 <code>isEmpty()</code> 方法后，代码将在完整的自动分级器上编译。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> deque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Deque</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(T i)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(T i)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size() &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printDeque</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">removeFirst</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">removeLast</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Guitar-Hero"><a href="#Guitar-Hero" class="headerlink" title="Guitar Hero"></a>Guitar Hero</h1><p>在项目的这一部分中，我们将创建另一个包，用于使用我们刚刚制作的 <code>deque</code> 包生成合成乐器。我们将有机会使用我们的数据结构来实现一种算法，该算法允许我们模拟吉他弦的弹拨。</p><h2 id="The-GH2-Package"><a href="#The-GH2-Package" class="headerlink" title="The GH2 Package"></a>The GH2 Package</h2><p>该 <code>gh2</code> 包只有一个主要组件，您将对其进行编辑：</p><ul><li><code>GuitarString</code> ，该类使用 <code>Deque&lt;Double&gt;</code> 来实现 <a href="http://en.wikipedia.org/wiki/Karplus%E2%80%93Strong_string_synthesis">Karplus-Strong 算法</a> 来合成吉他弦声音。</li></ul><p>我们为您提供了框架代码 <code>GuitarString</code> ，您将在其中使用在本项目第一部分中创建的 <code>deque</code> 包。</p><h2 id="GuitarString"><a href="#GuitarString" class="headerlink" title="GuitarString"></a>GuitarString</h2><p>我们想要完成 <code>GuitarString</code> 文件，它应该使用包 <code>deque</code> 来复制拨弦的声音。我们将使用 Karplus-Strong 算法，该算法很容易通过 <code>Deque</code> .</p><p>The Karplus-Algorithm is simply the following three steps:<br>Karplus算法只是以下三个步骤：</p><ol><li>用随机噪声（ <code>double</code> 值介于 -0.5 和 0.5 之间）替换 a <code>Deque</code> 中的每个项目。</li><li>去掉<code>Deque</code> 最前面的double值，并和<code>Deque</code> 下一个double （提示：使用 <code>removeFirst()</code> 和 <code>get()</code> )取平均值 然后 乘以能量衰减因子 0.996（我们称之为整个量 <code>newDouble</code> ）。然后，添加到 <code>newDouble</code> 到<code>Deque</code>的最后 .</li><li>播放您在步骤2中退出队列的double (newDouble)。回到步骤2(并不断重复)。</li></ol><p>或者从视觉上看，如果如 <code>Deque</code> 顶部所示，我们将删除 0.2，将其与 0.4 合并形成 0.2988，添加 0.2988，然后播放 0.2。</p><p><img src="/2024/01/29/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj1/karplus-strong.png" alt="karplus-strong"></p><p>您可以使用该 <code>StdAudio.play</code> 方法播放值 <code>double</code> 。例如 <code>StdAudio.play(0.333)</code> ，会告诉扬声器的振膜将自己伸展到其总范围的 1&#x2F;3， <code>StdAudio.play(-0.9)</code> 会告诉它几乎向后伸展它的小心脏，几乎尽可能远。扬声器振膜的运动会取代空气，如果你以很好的模式取代空气，这些干扰将被你的意识解释为令人愉悦，这要归功于数十亿年的进化。有关详细信息，请参阅此页面。如果你只是这样做 <code>StdAudio.play(0.9)</code> ，再也不玩任何东西，那么图像中显示的隔膜将只是静止不动地前进的 9&#x2F;10。</p><p>完成 <code>GuitarString.java</code> ，以便实现 Karplus-Strong 算法的第 1 步和第 2 步。请注意，您必须在 <code>GuitarString</code> 构造函数中用零填充缓冲区 <code>Deque</code> 。第 3 步将由 <code>GuitarString</code> 类的客户端完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gh2;</span><br><span class="line"><span class="keyword">import</span> deque.*;</span><br><span class="line"><span class="comment">// import deque.Deque;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Note: This file will not compile until you complete the Deque implementations</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuitarString</span> &#123;</span><br><span class="line">    <span class="comment">/** Constants. Do not change. In case you&#x27;re curious, the keyword final</span></span><br><span class="line"><span class="comment">     * means the values cannot be changed at runtime. We&#x27;ll discuss this and</span></span><br><span class="line"><span class="comment">     * other topics in lecture on Friday. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SR</span> <span class="operator">=</span> <span class="number">44100</span>;      <span class="comment">// Sampling Rate</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">DECAY</span> <span class="operator">=</span> <span class="number">.996</span>; <span class="comment">// energy decay factor</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Buffer for storing sound data. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Double&gt; buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a guitar string of the given frequency.  */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GuitarString</span><span class="params">(<span class="type">double</span> frequency)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> (<span class="type">int</span>) Math.round(SR / frequency);</span><br><span class="line">        buffer = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Double&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            buffer.addFirst(<span class="number">0.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pluck the guitar string by replacing the buffer with white noise. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pluck</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//       Make sure that your random numbers are different from each</span></span><br><span class="line">        <span class="comment">//       other. This does not mean that you need to check that the numbers</span></span><br><span class="line">        <span class="comment">//       are different from each other. It means you should repeatedly call</span></span><br><span class="line">        <span class="comment">//       Math.random() - 0.5 to generate new random numbers for each array index.</span></span><br><span class="line">        <span class="type">double</span> temp;</span><br><span class="line">        Deque&lt;Double&gt; NewBuffer = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Double&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buffer.size(); i++) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> Math.random() - <span class="number">0.5</span>;</span><br><span class="line">            temp = buffer.get(i);</span><br><span class="line">            NewBuffer.addLast(temp - r);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer = NewBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advance the simulation one time step by performing one iteration of</span></span><br><span class="line"><span class="comment">     * the Karplus-Strong algorithm.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">double</span> NewDouble;</span><br><span class="line">        <span class="type">double</span> <span class="variable">temp</span> <span class="operator">=</span> buffer.get(<span class="number">0</span>);</span><br><span class="line">        buffer.removeFirst();</span><br><span class="line">        NewDouble = DECAY * <span class="number">0.5</span> * (temp + buffer.get(<span class="number">0</span>));</span><br><span class="line">        buffer.addLast(NewDouble);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return the double at the front of the buffer. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sample</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buffer.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GuitarHero"><a href="#GuitarHero" class="headerlink" title="GuitarHero"></a>GuitarHero</h2><p>非作业，单纯好玩</p><p>考虑创建一个类似于 <code>GuitarHeroLite</code> 的程序 <code>GuitarHero</code> ，但支持 37Hz 到 110Hz 的半音阶上总共 880 个音符。使用以下 37 个键来表示键盘，从最低音符到最高音符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String keyboard = &quot;q2we4r5ty7u8i9op-[=zxdcfvgbnjmk,.;/&#x27; &quot;;</span><br></pre></td></tr></table></figure><p>这种键盘排列模仿钢琴键盘：“白键”位于键盘的 qwerty 和 zxcv 行上，“黑键”位于键盘的 12345 和 asdf 行上。</p><p>字符串键盘的第 i 个字符对应于 <img src="/2024/01/29/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj1/image-20240129042827790.png" alt="image-20240129042827790"> 的频率，因此字符“q”为 110Hz，“i”为 220Hz，“v”为 440Hz，“”为 880Hz。甚至不要考虑包含 37 个单独的 GuitarString 变量或 37 路 if 语句！相反，创建一个包含 37 <code>GuitarString</code> 个对象的数组，并用于 <code>keyboard.indexOf(key)</code> 确定键入了哪个键。确保如果按下的键与您的 37 个音符之一不对应，您的程序不会崩溃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gh2;</span><br><span class="line"><span class="keyword">import</span> deque.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdDraw;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.introcs.StdAudio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuitarHero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">keyboard</span> <span class="operator">=</span> <span class="string">&quot;q2we4r5ty7u8i9op-[=zxdcfvgbnjmk,.;/&#x27; &quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FREQ</span> <span class="operator">=</span> <span class="number">440</span>;</span><br><span class="line">        ArrayDeque&lt;GuitarString&gt; guitar = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">/* check if the user has typed a key; if so, process it */</span></span><br><span class="line">            <span class="keyword">if</span> (StdDraw.hasNextKeyTyped()) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> StdDraw.nextKeyTyped();</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> keyboard.indexOf(key);</span><br><span class="line">                <span class="type">double</span> <span class="variable">freq</span> <span class="operator">=</span> FREQ * Math.pow(<span class="number">2</span>, (<span class="type">double</span>) (i - <span class="number">24</span>) /<span class="number">12</span>);</span><br><span class="line">                guitar.addLast(<span class="keyword">new</span> <span class="title class_">GuitarString</span>(freq));</span><br><span class="line">                <span class="keyword">if</span> (guitar.size() &gt; index) &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                guitar.get(index).pluck();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="type">double</span> <span class="variable">sample</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; guitar.size(); j++) &#123;</span><br><span class="line">                sample += guitar.get(j).sample();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* play the sample on standard audio */</span></span><br><span class="line">            StdAudio.play(sample);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* advance the simulation of each guitar string by one step */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; guitar.size(); j++) &#123;</span><br><span class="line">                guitar.get(j).tic();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Even-More-Fun-更有趣"><a href="#Even-More-Fun-更有趣" class="headerlink" title="Even More Fun 更有趣"></a>Even More Fun 更有趣</h2><p>这部分作业没有评分，只是为了好玩。</p><ul><li>Harp 字符串：在包中 <code>gh2</code> 创建一个 Harp 类。在将新值排入队列之前翻转新值的符号 <code>tic()</code> 会将声音从吉他式变为竖琴式。您可能希望使用衰减因子来提高真实感，并将缓冲区大小调整两倍，因为 <code>tic()</code> 自然共振频率会因变化而减半。</li><li>Drums：在包中 <code>gh2</code> 创建一个 Drum 类。在将新值排入队列之前，以 0.5 的概率翻转新值的符号 <code>tic()</code> 将产生鼓声。衰减系数为 1.0（无衰减）将产生更好的声音，您需要调整使用的频率集。</li><li>吉他在 6 根物理弦之一上弹奏每个音符。为了模拟这种情况，您可以将 <code>GuitarString</code> 实例分成 6 组，当一个字符串被摘取时，将该组中的所有其他字符串清零。</li><li>钢琴带有一个阻尼踏板，可用于使琴弦静止。您可以通过在按住某个键（例如 Shift）的迭代中更改衰减因子来实现此目的。</li><li>虽然我们使用了平等的气质，但当音乐音程跟随正音调系统中的小部分时，耳朵会发现它更令人愉悦。例如，当音乐家使用铜管乐器演奏完美的五度和声时，频率之比为 3&#x2F;2 &#x3D; 1.5，而不是 27&#x2F;12 ∼ 1.498。编写一个程序，其中每对连续的音符都只有语调。</li></ul><h2 id="Why-It-Works-为什么有效"><a href="#Why-It-Works-为什么有效" class="headerlink" title="Why It Works 为什么有效"></a>Why It Works 为什么有效</h2><p>使Karplus-Strong算法起作用的两个主要组件是环形缓冲区反馈机制和平均操作。</p><ul><li><strong>The ring buffer feedback mechanism</strong>. The ring buffer models the medium (a string tied down at both ends) in which the energy travels back and forth. The length of the ring buffer determines the fundamental frequency of the resulting sound. Sonically, the feedback mechanism reinforces only the fundamental frequency and its harmonics (frequencies at integer multiples of the fundamental). The energy decay factor (.996 in this case) models the slight dissipation in energy as the wave makes a round trip through the string.<br><strong>环形缓冲区反馈机制。</strong>环形缓冲器模拟能量来回传播的介质（两端系在一起的绳子）。环形缓冲器的长度决定了所产生声音的基频。在声音上，反馈机制仅增强基频及其谐波（基频整数倍的频率）。能量衰减因子（在本例中为 .996）模拟了波在弦上往返时能量的轻微耗散。</li><li><strong>The averaging operation</strong>. The averaging operation serves as a gentle low-pass filter (which removes higher frequencies while allowing lower frequencies to pass, hence the name). Because it is in the path of the feedback, this has the effect of gradually attenuating the higher harmonics while keeping the lower ones, which corresponds closely with how a plucked guitar string sounds.<br>平均操作。平均操作用作温和的低通滤波器（它去除较高频率，同时允许较低频率通过，因此得名）。因为它在反馈的路径中，所以具有逐渐衰减高次谐波同时保持低次谐波的效果，这与弹拨吉他弦的声音非常吻合。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h1><p>通过项目一，我学到了以下东西:</p><ul><li>如何构造出一个Deque API</li><li>package的用法</li><li>接口的创立</li><li>数列的一个使用实例</li><li>更高效的调试方法</li></ul><h2 id="困难复盘点"><a href="#困难复盘点" class="headerlink" title="困难复盘点:"></a>困难复盘点:</h2><h3 id="Linked-List-Deque-1"><a href="#Linked-List-Deque-1" class="headerlink" title="Linked List Deque"></a>Linked List Deque</h3><p>这个部分比较困难的是<code>add</code>和<code>remove</code>方法，刚开始会错意了，以为环状列表中，最后一个不指向哨兵节点导致一开始尝试错误。</p><p>后面比较麻烦的是<code>prev</code>和<code>next</code>的指向问题，我借助了可视化+调试慢慢得完善好。</p><h3 id="Array-Deque-1"><a href="#Array-Deque-1" class="headerlink" title="Array Deque"></a>Array Deque</h3><p>经常遇到<code>NullPointerException</code>或者<code>OutIndex</code>这些问题，于是使用了<strong>异常断点</strong><code>this instanceof NullPointerException</code>+可视化工具来和<strong>条件断点</strong>和<strong>恢复按钮</strong>判断出出错点</p><p>最困难的地方莫过于<code>resize方法</code>分<strong>扩大列表</strong>和缩小列表这两种情况来讨论。我的解决方法是先建立一个新的列表然后借助<code>System.arraycopy(src, srcPos, dest, destPos, length)</code>来快速得复制，其中复制的参数我根据可视化的列表图像和<code>nextFirst</code>和<code>item.length</code>慢慢得摸索，最终完成。</p><p>其中扩大列表应该分有多种扩增方法，我最开始是直接在后面扩增开了，导致<code>remove</code>方法无法找到解决方法，最后选择在<code>nextFirst</code>和<code>nextLast</code>中间扩增开，这样子remove的时候，<code>nextFirst</code>的值会慢慢的增加，然后成功删除掉首尾的值。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国矿业大学寒招介绍</title>
      <link href="/2024/01/26/%E7%9F%BF%E5%A4%A7%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/01/26/%E7%9F%BF%E5%A4%A7%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="学校基本介绍"><a href="#学校基本介绍" class="headerlink" title="学校基本介绍"></a>学校基本介绍</h1><div class="row">    <embed src="攻城狮入学秘籍.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="美照"><a href="#美照" class="headerlink" title="美照"></a>美照</h2><p><img src="/2024/01/26/%E7%9F%BF%E5%A4%A7%E4%BB%8B%E7%BB%8D/image-20240126201435433.png" alt="image-20240126201435433"><br><img src="/2024/01/26/%E7%9F%BF%E5%A4%A7%E4%BB%8B%E7%BB%8D/image-20240126201515111.png" alt="image-20240126201515111"></p><p><img src="/2024/01/26/%E7%9F%BF%E5%A4%A7%E4%BB%8B%E7%BB%8D/image-20240126201524308.png" alt="image-20240126201524308"><br><img src="/2024/01/26/%E7%9F%BF%E5%A4%A7%E4%BB%8B%E7%BB%8D/image-20240126201528737.png" alt="image-20240126201528737"><br><img src="/2024/01/26/%E7%9F%BF%E5%A4%A7%E4%BB%8B%E7%BB%8D/image-20240126201531917.png" alt="image-20240126201531917"></p><h1 id="广东省分数线介绍"><a href="#广东省分数线介绍" class="headerlink" title="广东省分数线介绍"></a>广东省分数线介绍</h1><p><img src="/2024/01/26/%E7%9F%BF%E5%A4%A7%E4%BB%8B%E7%BB%8D/963e7976544c87211d085232790d877.jpg" alt="963e7976544c87211d085232790d877"></p><h2 id="粗略版"><a href="#粗略版" class="headerlink" title="粗略版"></a>粗略版</h2><table><thead><tr><th>招生专业类</th><th>23-计划数</th><th>23-平均分</th><th>23-平均位次</th><th>22-计划数</th><th>22-平均分</th><th>22-平均位次</th><th>21-计划数</th><th>21-平均分</th><th>21-平均位次</th></tr></thead><tbody><tr><td>人工智能</td><td>6</td><td>608</td><td>21079</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>大数据管理与应用</td><td>2</td><td>607</td><td>21726</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>机器人工程</td><td>3</td><td>607</td><td>21726</td><td>2</td><td>599</td><td>22073</td><td></td><td></td><td></td></tr><tr><td>遥感科学与技术</td><td>4</td><td>606</td><td>22388</td><td>4</td><td>595</td><td>26470</td><td></td><td></td><td></td></tr><tr><td>计算机类</td><td>15</td><td>613</td><td>18163</td><td>15</td><td>604</td><td>18725</td><td>15</td><td>605</td><td>19989</td></tr><tr><td>电子信息类</td><td>12</td><td>609</td><td>20482</td><td>12</td><td>600</td><td>21339</td><td>12</td><td>598</td><td>24417</td></tr><tr><td>机械类</td><td>12</td><td>605</td><td>23074</td><td>10</td><td>598</td><td>22774</td><td>12</td><td>595</td><td>26470</td></tr><tr><td>安全科学与工程类</td><td>4</td><td>605</td><td>23074</td><td>5</td><td>596</td><td>25799</td><td></td><td></td><td></td></tr><tr><td>土木类</td><td>7</td><td>596</td><td>25799</td><td>4</td><td>596</td><td>25799</td><td>7</td><td>596</td><td>25799</td></tr><tr><td>建筑类</td><td>3</td><td>603</td><td>24424</td><td>2</td><td>599</td><td>23750</td><td>2</td><td>599</td><td>23750</td></tr><tr><td>数学类</td><td>4</td><td>599</td><td>23750</td><td>6</td><td>600</td><td>21339</td><td>4</td><td>599</td><td>23750</td></tr><tr><td>电气类</td><td>8</td><td>614</td><td>17633</td><td>8</td><td>601</td><td>22482</td><td>8</td><td>601</td><td>22482</td></tr><tr><td>物理学类</td><td>4</td><td>606</td><td>22388</td><td>2</td><td>601</td><td>22482</td><td></td><td></td><td></td></tr><tr><td>能源动力类</td><td>6</td><td>605</td><td>23074</td><td>6</td><td>597</td><td>23542</td><td>6</td><td>594</td><td>27190</td></tr><tr><td>应急管理</td><td>2</td><td>602</td><td>25108</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>金融学</td><td>3</td><td>604</td><td>23748</td><td>2</td><td>606</td><td>22073</td><td>5</td><td>593</td><td>27190</td></tr><tr><td>新能源材料与器件</td><td>2</td><td>609</td><td>20482</td><td>4</td><td>593</td><td>26493</td><td>5</td><td>594</td><td>27190</td></tr><tr><td>会计学</td><td>10</td><td>601</td><td>25783</td><td>16</td><td>594</td><td>27190</td><td>12</td><td>594</td><td>27190</td></tr><tr><td>化工与制药类</td><td>2</td><td>600</td><td>26467</td><td>4</td><td>591</td><td>28044</td><td>6</td><td>595</td><td>26470</td></tr><tr><td>人力资源管理</td><td>10</td><td>580</td><td>6643</td><td>16</td><td>594</td><td>27190</td><td>12</td><td>594</td><td>27190</td></tr><tr><td>行政管理</td><td>6</td><td>577</td><td>7285</td><td>4</td><td>580</td><td>7150</td><td></td><td></td><td></td></tr><tr><td>网络与新媒体</td><td>2</td><td>579</td><td>6826</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>汉语言文学</td><td>4</td><td>585</td><td>5663</td><td>4</td><td>581</td><td>6892</td><td>6</td><td>581</td><td>37607</td></tr><tr><td>英语</td><td>6</td><td>579</td><td>6826</td><td>6</td><td>581</td><td>37607</td><td>6</td><td>581</td><td>37607</td></tr><tr><td>土木工程（中外合作）</td><td>3</td><td>584</td><td>39149</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>建筑环境与能源应用工程(中外合作)</td><td>3</td><td>584</td><td>39149</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>工程力学</td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>环境设计</td><td>5</td><td>541</td><td>-</td><td>5</td><td>538</td><td>-</td><td>5</td><td>540</td><td>-</td></tr><tr><td>运动训练</td><td>2</td><td>78</td><td>-</td><td>2</td><td>78</td><td>-</td><td>2</td><td>78</td><td>-</td></tr></tbody></table><h1 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="Q-矿大保研率怎么样"><a href="#Q-矿大保研率怎么样" class="headerlink" title="Q:矿大保研率怎么样"></a>Q:矿大保研率怎么样</h2><p>A:矿大保研率基本上有15%那个样子</p><h2 id="Q-学校自不自由"><a href="#Q-学校自不自由" class="headerlink" title="Q:学校自不自由"></a>Q:学校自不自由</h2><p>A:上床下桌，不限功率不断电，无门禁，24小时可出入学校宿舍。</p><h2 id="Q-矿大饮食怎么样"><a href="#Q-矿大饮食怎么样" class="headerlink" title="Q:矿大饮食怎么样"></a>Q:矿大饮食怎么样</h2><p>A:矿大饮食基本上挺实惠的，我曾经0.01吃过一顿饭，而且学校里KFC，麦当劳，瑞幸，库迪，霸王茶姬等都有。</p><h2 id="Q-住宿条件怎么样"><a href="#Q-住宿条件怎么样" class="headerlink" title="Q:住宿条件怎么样"></a>Q:住宿条件怎么样</h2><p>A:<img src="/2024/01/26/%E7%9F%BF%E5%A4%A7%E4%BB%8B%E7%BB%8D/image-20240126201549159.png" alt="image-20240126201549159"></p><p>上床下桌，不限功率，不停电，独立浴室。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CS61B项目练习笔记(二)--Lab3</title>
      <link href="/2024/01/25/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-2-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab3/"/>
      <url>/2024/01/25/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-2-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab3/</url>
      
        <content type="html"><![CDATA[<p>经验点:</p><ul><li><code>Stopwatch</code>的使用</li><li>在类的两个实现之间执行比较测试。</li><li>随机调用类内部的方法。</li><li>在类的两个实现之间执行随机比较测试。</li><li>使用 IntelliJ 中的<strong>恢复按钮</strong>。</li><li>向断点添加条件。</li><li>创建<strong>异常断点</strong>。</li></ul><h1 id="Stopwatch库的使用"><a href="#Stopwatch库的使用" class="headerlink" title="Stopwatch库的使用"></a><code>Stopwatch</code>库的使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> timingtest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.Stopwatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hug.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopwatchDemo</span> &#123;</span><br><span class="line">    <span class="comment">/** Computes the nth Fibonacci number using a slow naive recursive strategy.*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stopwatch</span> <span class="variable">sw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stopwatch</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">fib41</span> <span class="operator">=</span> fib(<span class="number">41</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">timeInSeconds</span> <span class="operator">=</span> sw.elapsedTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;The 50th fibonacci number is &quot;</span> + fib41);</span><br><span class="line">        System.out.println(<span class="string">&quot;Time taken to compute 41st fibonacci number: &quot;</span> + timeInSeconds + <span class="string">&quot; seconds.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>import edu.princeton.cs.algs4.Stopwatch;</code>导入库</li><li><code> Stopwatch sw = new Stopwatch();</code>开始计时</li><li><code>double timeInSeconds = sw.elapsedTime();</code>结束计时，返回时间</li></ul><h1 id="在类的两个实现之间执行比较测试。"><a href="#在类的两个实现之间执行比较测试。" class="headerlink" title="在类的两个实现之间执行比较测试。"></a>在类的两个实现之间执行比较测试。</h1><p>测试代码的一种技术是进行“比较测试”。在这样的测试中，我们有两个相同类的实现。一个实现是已知的（或坚信的）是正确的，另一个正在开发中，尚未验证。</p><p>例如，我们提供了类 <code>AListNoResizing</code> 。此类不支持任何调整大小操作，只是具有 1000 的硬编码数组大小。这意味着它实际上没有用，因为它永远不能容纳超过 1000 个项目。但是，由于它非常简单，我们对它的工作充满信心。</p><p>相比之下，我们也提供了课程 <code>BuggyAList</code> 。此类具有一个基础数组，该数组会根据存储的数据量向上和向下调整大小。由于调整大小有点棘手，因此我们更加怀疑此类的正确性。顾名思义，它确实在某处有一个错误。本实验的其余部分的目标是找到此 bug。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> randomizedtest;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testThreeAddThreeRemove</span> &#123;</span><br><span class="line">    AListNoResizing&lt;Integer&gt; list_1 = <span class="keyword">new</span> <span class="title class_">AListNoResizing</span>&lt;&gt;();</span><br><span class="line">    BuggyAList&lt;Integer&gt; list_2 = <span class="keyword">new</span> <span class="title class_">BuggyAList</span>&lt;&gt;();</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_1</span><span class="params">()</span> &#123;</span><br><span class="line">        list_1.addLast(<span class="number">4</span>);</span><br><span class="line">        list_1.addLast(<span class="number">5</span>);</span><br><span class="line">        list_1.addLast(<span class="number">6</span>);</span><br><span class="line">        list_2.addLast(<span class="number">4</span>);</span><br><span class="line">        list_2.addLast(<span class="number">5</span>);</span><br><span class="line">        list_2.addLast(<span class="number">6</span>);</span><br><span class="line">        assertEquals(list_1.removeLast(), list_2.removeLast());</span><br><span class="line">        assertEquals(list_1.removeLast(), list_2.removeLast());</span><br><span class="line">        assertEquals(list_1.removeLast(), list_2.removeLast());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="随机函数调用"><a href="#随机函数调用" class="headerlink" title="随机函数调用"></a>随机函数调用</h1><p>原则上，可以仔细制作一组比较测试，最终找到错误。但是，另一种补充策略是使用随机方法，在该方法中，我们对两个实现进行随机调用，并使用 JUnit 方法来验证它们是否始终返回相同的值。</p><p>作为随机调用方法的函数示例，下面的代码随机调用 <code>AList</code> <code>addLast</code> 对象 <code>AListNoResizing</code> ， <code>size</code> 总共调用其中一个函数的 N 次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> randomizedtest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hug.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBuggyAList</span> &#123;</span><br><span class="line">  <span class="comment">// YOUR TESTS HERE</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">randomizedTest</span><span class="params">()</span> &#123;</span><br><span class="line">      AListNoResizing&lt;Integer&gt; correct = <span class="keyword">new</span> <span class="title class_">AListNoResizing</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">operationNumber</span> <span class="operator">=</span> StdRandom.uniform(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">          <span class="keyword">if</span> (operationNumber == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// addLast</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">randVal</span> <span class="operator">=</span> StdRandom.uniform(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">              correct.addLast(randVal);</span><br><span class="line">              System.out.println(<span class="string">&quot;addLast(&quot;</span> + randVal + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operationNumber == <span class="number">1</span>) &#123;</span><br><span class="line">              <span class="comment">// size</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> correct.size();</span><br><span class="line">              System.out.println(<span class="string">&quot;size: &quot;</span> + size);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="调试器功能-条件断点和恢复"><a href="#调试器功能-条件断点和恢复" class="headerlink" title="调试器功能-条件断点和恢复"></a>调试器功能-条件断点和恢复</h1><ol><li>在显示 的 <code>int operationNumber = StdRandom.uniform(0, 2);</code> 行上设置断点。</li><li>然后，使用 debug 选项在 IntelliJ 中的这一行停止。</li><li>单击可视化工具，您将看到一个包含大量空值的数组，这些空值最终将存储要添加到列表中的数据。</li><li>单击“单步执行”，您将看到 operationNumber 设置为 0 或 1。这是因为该 <code>StdRandom.uniform(0, 2)</code> 函数返回 [0， 2] 范围内的随机整数，即排除正确的参数。如果选择的数字为 0，则将在列表末尾添加一个随机数。如果选择的数字是 1，则将打印尺寸。</li><li>单击调试器上的 <code>resume</code> 按钮（下面以黄色突出显示），我们的代码将再次遇到它，命中断点。<img src="https://sp21.datastructur.es/materials/lab/lab3/img/resume_button.png" alt="folder structure"></li><li>尝试单击“恢复”几次，您将看到值开始填充数组。请注意，每次单击“恢复”时，代码都会运行（就像您多次按下单步执行一样），直到它再次返回到断点。</li><li>我们还可以从可视化工具切换回能够查看打印语句的输出。为此， <code>Debugger</code> 请再次单击（旁边 <code>Java Visualizer</code> ）并继续单击恢复。在某些计算机上，您可能需要单击 <code>Debugger</code> 而不是 <code>Console</code> 。单击“恢复”的每个类型，都会看到另一个 print 语句，对应于对 addLast 或 size 的调用。</li><li>现在让我们尝试一个条件断点。右键单击断点，您会看到一个弹出框，上面写着“条件：”。在框中，键入 <code>L.size() == 12</code> 。<img src="https://sp21.datastructur.es/materials/lab/lab3/img/conditional_breakpoint.png" alt="folder structure"></li><li>单击“恢复”，代码将一直运行，直到满足断点的条件，即大小为 12。尝试一下，然后单击可视化工具，您应该会看到大小现在为 12，数组中有 12 个项目。如果您不小心点击得太远，很遗憾，您必须重新启动测试。</li></ol><p>这两个新功能（恢复和条件断点）对实验 3 的其余部分没有用。但是，它们可能会在将来的项目中派上用场，您需要在实验 4 中使用它们。此时应删除条件断点，以便它不会影响实验室的其余部分。</p><h1 id="执行随机比较"><a href="#执行随机比较" class="headerlink" title="执行随机比较"></a>执行随机比较</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBuggyAList</span> &#123;</span><br><span class="line">  <span class="comment">// YOUR TESTS HERE</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">randomizedTest</span><span class="params">()</span> &#123;</span><br><span class="line">      AListNoResizing&lt;Integer&gt; correct = <span class="keyword">new</span> <span class="title class_">AListNoResizing</span>&lt;&gt;();</span><br><span class="line">      BuggyAList&lt;Integer&gt; broken = <span class="keyword">new</span> <span class="title class_">BuggyAList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">operationNumber</span> <span class="operator">=</span> StdRandom.uniform(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">          <span class="keyword">if</span> (operationNumber == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// addLast</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">randVal</span> <span class="operator">=</span> StdRandom.uniform(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">              correct.addLast(randVal);</span><br><span class="line">              broken.addLast(randVal);</span><br><span class="line">              System.out.println(<span class="string">&quot;addLast(&quot;</span> + randVal + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operationNumber == <span class="number">1</span>) &#123;</span><br><span class="line">              <span class="comment">// size</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> correct.size();</span><br><span class="line">              System.out.println(<span class="string">&quot;size: &quot;</span> + size);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operationNumber == <span class="number">2</span> &amp;&amp; correct.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="type">int</span> <span class="variable">last_num</span> <span class="operator">=</span> correct.getLast();</span><br><span class="line">              assertEquals(correct.removeLast(), broken.removeLast());</span><br><span class="line">              System.out.println(<span class="string">&quot;removeLast(&quot;</span> + last_num + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这就提出了一个关于随机测试的重要观点：如果你应用随机操作，并且这个错误相当模糊，你的随机操作序列可能无法检测到这个错误！有一些方法可以改进随机测试来避免这个问题，但这超出了我们课程的范围。</p><p>另一个注意事项：随机测试不应替代精心设计的单元测试！我个人通常倾向于在可能的情况下进行非随机测试，并将随机测试视为一种补充测试方法。有关此问题的辩论，请参阅此<a href="https://news.ycombinator.com/item?id=24349522">链接</a>。</p><h1 id="异常断点的使用"><a href="#异常断点的使用" class="headerlink" title="异常断点的使用"></a>异常断点的使用</h1><p>请单击“运行 -&gt; 查看断点”。您应该会看到一个类似这样的窗口弹出窗口：</p><p><img src="/2024/01/25/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-2-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab3/breakpoints.png" alt="folder structure"></p><p>单击左侧显示“任何例外”的复选框，然后单击显示“条件：”的复选框，然后在窗口中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this instanceof java.lang.ArrayIndexOutOfBoundsException</span><br></pre></td></tr></table></figure><p>完成此操作后，断点窗口应如下所示：</p><p><img src="/2024/01/25/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-2-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab3/breakpoints_filled_in.png" alt="folder structure"></p><p>单击“调试”按钮，代码应在异常即将发生时停止。单击可视化工具，并尝试找出代码崩溃的原因。现在可以开始真正的问题解决了！</p><p>注意：如果在未指定条件的情况下使用调试功能，则代码将停止在一些不同的神秘位置。确保在未指定条件的情况下，绝不会选中“任何异常”。这是因为启动 JUnit 测试的过程会生成一堆最终被忽略的异常。这远远超出了我们课程的范围。如果使用完执行断点，则应取消选中左上角的“Java Exceptions Breakpoints”框。</p><blockquote><p>答案:</p><p><img src="/2024/01/25/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-2-CS61B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-Lab3/image-20240125222121979.png" alt="image-20240125222121979"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    Item[] a = (Item[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i += <span class="number">1</span>) &#123;</span><br><span class="line">        a[i] = items[i];</span><br><span class="line">    &#125;</span><br><span class="line">    items = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Item <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((size &lt; items.length / <span class="number">4</span>) &amp;&amp; (size &gt; <span class="number">4</span>)) &#123;</span><br><span class="line">            resize(size / <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Item</span> <span class="variable">x</span> <span class="operator">=</span> getLast();</span><br><span class="line">        items[size - <span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line">        size = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>观察可知，是<code>removeLast()</code>方法在传入<code>resize</code>方法值的时候过小，导致新收缩的数组太小，没办法存储所有原数组的值，答案为<code>resize(size / 4)</code>改为<code>resize(items.length / 4)</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(六)-数组基础的列表(2.4,2.5)</title>
      <link href="/2024/01/24/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-4-2-5/"/>
      <url>/2024/01/24/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-4-2-5/</url>
      
        <content type="html"><![CDATA[<p><a href="https://joshhug.gitbooks.io/hug61b/content/chap2/chap24.html">2.4 Arrays · Hug61B (gitbooks.io)</a></p><p><a href="https://joshhug.gitbooks.io/hug61b/content/chap2/chap25.html">2.5 The AList · Hug61B (gitbooks.io)</a></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组基础"><a href="#数组基础" class="headerlink" title="数组基础"></a>数组基础</h2><p>数组是一种特殊类型的对象，它由一系列编号的内存盒组成。这与类实例不同，类实例具有命名的内存盒。为了得到数组的第i个元素，我们使用了在HW 0和Project 0中看到的括号表示法，例如 <code>A[i]</code> 得到A的第 <code>i</code> 个元素。</p><p>数组包括：</p><ul><li>一个固定的整数长度N</li><li>一个由N个存储器盒组成的序列（N &#x3D;长度），其中所有盒都是相同类型的，编号为0到N - 1。</li></ul><blockquote><p>和类不同，数组没有方法</p></blockquote><h3 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h3><ul><li><code>x = new int[3];</code></li><li><code>y = new int[]&#123;1, 2, 3, 4, 5&#125;;</code></li><li><code>int[] z = &#123;9, 10, 11, 12, 13&#125;;</code></li></ul><p>所有这三种表达法都创建了一个数组。</p><p>第一种表示法，用于创建 <code>x</code> ，将创建一个指定长度的数组，并使用默认值填充每个内存框。在本例中，它将创建一个长度为3的数组，并使用默认值 <code>int</code> <code>0</code> 填充3个框中的每一个。</p><p>第二种表示法，用于创建 <code>y</code> ，创建一个数组，其大小正好可以容纳指定的起始值。在本例中，它创建了一个长度为5的数组，其中包含这五个特定的元素。</p><p>第三种表示法用于声明和创建 <code>z</code> ，其行为与第二种表示法相同。唯一的区别是它省略了 <code>new</code> 的用法，并且只能在与变量声明组合时使用。</p><blockquote><p>这些符号没有一个比其他符号更好。</p></blockquote><h3 id="数组的访问和修改"><a href="#数组的访问和修改" class="headerlink" title="数组的访问和修改"></a>数组的访问和修改</h3><p>下面的代码展示了我们将用于处理数组的所有关键语法。试着单步执行下面的代码，并确保您理解每行执行时会发生什么。为此，请<a href="https://cscircles.cemc.uwaterloo.ca/java_visualize/#">单击此处</a>查看交互式可视化。除了最后一行代码之外，我们以前见过所有这些语法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] z = <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span>[] x, y;</span><br><span class="line"></span><br><span class="line">x = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">y = x;</span><br><span class="line">x = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">99</span>&#125;;</span><br><span class="line">y = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">z = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">xL</span> <span class="operator">=</span> x.length;</span><br><span class="line"></span><br><span class="line">String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">6</span>];</span><br><span class="line">s[<span class="number">4</span>] = <span class="string">&quot;ketchup&quot;</span>;</span><br><span class="line">s[x[<span class="number">3</span>] - x[<span class="number">1</span>]] = <span class="string">&quot;muffins&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] b = &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line">System.arraycopy(b, <span class="number">0</span>, x, <span class="number">3</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>最后一行演示了一种将信息从一个数组复制到另一个数组的方法。 <code>System.arraycopy</code> 有五个参数：</p><ul><li>用作源的数组</li><li>在源数组中从何处开始</li><li>用作目标的阵列</li><li>在目标阵列中从何处开始</li><li>要复制多少项</li></ul><p>对于Python老手来说， <code>System.arraycopy(b, 0,x, 3, 2)</code> 相当于Python中的 <code>x[3:5] = b[0:2]</code> 。</p><p>复制数组的另一种方法是使用循环。 <code>arraycopy</code> 通常比循环更快，并导致更紧凑的代码。唯一的缺点是 <code>arraycopy</code> （可以说）更难阅读。请注意，Java数组只在运行时执行边界检查。也就是说，下面的代码可以很好地编译，但是会在运行时崩溃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] x = &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] y = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; x.length) &#123;</span><br><span class="line">    y[i] = x[i];</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>容易数组越界</p></blockquote><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>Java中所谓的2D数组实际上只是一个数组的数组。它们遵循我们已经学习过的对象的相同规则，但是让我们回顾一下它们，以确保我们理解它们是如何工作的。</p><p>数组的数组的数组可能有点混乱。代码 <code>int[][] bamboozle = new int[4][]</code> 这将创建一个名为 <code>bamboozle</code> 的整数数组数组。具体来说，这正好创建了四个内存盒，每个内存盒都可以指向一个整数数组（长度未指定）。</p><p>尝试逐行运行下面的代码，看看结果是否符合你的直觉。如需交互式可视化，请<a href="https://cscircles.cemc.uwaterloo.ca/java_visualize/#">单击此处</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] pascalsTriangle;</span><br><span class="line">pascalsTriangle = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][];</span><br><span class="line"><span class="type">int</span>[] rowZero = pascalsTriangle[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">pascalsTriangle[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>&#125;;</span><br><span class="line">pascalsTriangle[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">pascalsTriangle[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">pascalsTriangle[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] rowTwo = pascalsTriangle[<span class="number">2</span>];</span><br><span class="line">rowTwo[<span class="number">1</span>] = -<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] matrix;</span><br><span class="line">matrix = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][];</span><br><span class="line">matrix = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] pascalAgain = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                                 &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>答案:<code>x[0][0]: -1, w[0][0]: 1</code></p></blockquote><h2 id="数组-vs-类"><a href="#数组-vs-类" class="headerlink" title="数组 vs 类"></a>数组 vs 类</h2><p>数组和类都可以用来组织一堆内存盒。在这两种情况下，内存盒的数量是固定的，即数组的长度不能改变，就像类字段不能添加或删除一样。</p><p>数组和类中内存盒的主要区别：</p><ul><li>数组框使用 <code>[]</code> 表示法编号和访问，类框使用点表示法命名和访问。</li><li>数组框必须全部为同一类型。类框可以是不同的类型。</li></ul><p>这些差异的一个特别显著的影响是， <code>[]</code> 表示法允许我们指定我们在运行时想要的索引。例如，考虑下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">indexOfInterest</span> <span class="operator">=</span> askUserForInteger();</span><br><span class="line"><span class="type">int</span>[] x = &#123;<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> x[indexOfInterest];</span><br><span class="line">System.out.println(k);</span><br></pre></td></tr></table></figure><p>如果我们运行这段代码，我们可能会得到这样的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ javac arrayDemo</span><br><span class="line">$ java arrayDemo</span><br><span class="line">What index do you want? 2</span><br><span class="line">102</span><br></pre></td></tr></table></figure><p>相比之下，在类中指定字段不是我们在运行时做的事情。例如，考虑下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">fieldOfInterest</span> <span class="operator">=</span> <span class="string">&quot;mass&quot;</span>;</span><br><span class="line"><span class="type">Planet</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Planet</span>(<span class="number">6e24</span>, <span class="string">&quot;earth&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">mass</span> <span class="operator">=</span> p[fieldOfInterest];</span><br></pre></td></tr></table></figure><p>如果我们试着编译它，我们会得到一个语法错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ javac classDemo</span><br><span class="line">FieldDemo.java:5: error: array required, but Planet found</span><br><span class="line">        double mass = earth[fieldOfInterest];        </span><br><span class="line">                               ^</span><br></pre></td></tr></table></figure><p>如果我们尝试使用点表示法，也会出现同样的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">fieldOfInterest</span> <span class="operator">=</span> <span class="string">&quot;mass&quot;</span>;</span><br><span class="line"><span class="type">Planet</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Planet</span>(<span class="number">6e24</span>, <span class="string">&quot;earth&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">mass</span> <span class="operator">=</span> p.fieldOfInterest;</span><br></pre></td></tr></table></figure><p>编译，我们会得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ javac classDemo</span><br><span class="line">FieldDemo.java:5: error: cannot find symbol</span><br><span class="line">        double mass = earth.fieldOfInterest;        </span><br><span class="line">                           ^</span><br><span class="line">  symbol:   variable fieldOfInterest</span><br><span class="line">  location: variable earth of type Planet</span><br></pre></td></tr></table></figure><p>这并不是你经常会遇到的限制，但值得指出，只是为了获得好的奖学金。值得一提的是，有一种方法可以在运行时指定所需的字段，称为反射，但它被认为是典型程序的非常糟糕的编码风格。你可以在<a href="https://docs.oracle.com/javase/tutorial/reflect/member/fieldValues.html">here</a>阅读更多关于反射的内容。<strong>你永远不应该在任何61B程序中使用反射，我们不会在我们的课程中讨论它。</strong></p><p>一般来说，编程语言的部分设计是为了限制程序员的选择，使代码更容易推理。通过将这些特性限制在特殊的Reflections API中，我们使典型的Java程序更易于阅读和解释。</p><h2 id="附录：Java数组与其他语言"><a href="#附录：Java数组与其他语言" class="headerlink" title="附录：Java数组与其他语言"></a>附录：Java数组与其他语言</h2><p>与其他语言中的数组相比，Java数组：</p><ul><li>没有特殊的“切片”语法（比如Python）。</li><li>不能收缩或展开（例如在Ruby中）。</li><li>不要有成员方法（例如在JavaScript中）。</li><li>必须只包含相同类型的值（与Python不同）。</li></ul><h1 id="AList"><a href="#AList" class="headerlink" title="AList"></a>AList</h1><p>在我们之前实现的<code>DLList</code>中，如果我们使用<code>get()</code>方法，与数组为基础的列表相比，它会非常的慢。这是因为，由于我们只有对列表的第一项和最后一项的引用，因此我们始终需要从前面或后面遍历列表才能找到我们尝试检索的项目。例如，如果我们想在长度为 10,000 的列表中获取项目 #417，我们必须遍历 417 个转发链接才能找到我们想要的项目。</p><p>在最坏的情况下，该项目位于最中间，我们需要浏览与列表长度成比例的多个项目（具体来说，项目数除以 2）。换言之，最坏情况下的 <code>get</code> 执行时间与整个列表的大小呈线性关系。这与 的 <code>getBack</code> 运行时形成鲜明对比，无论列表的大小如何，它都是恒定的。在本课程的后面，我们将根据大 O 和大 Theta 表示法正式定义运行时。现在，我们将坚持非正式的理解。</p><h2 id="AList的实现-初版"><a href="#AList的实现-初版" class="headerlink" title="AList的实现(初版)"></a>AList的实现(初版)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Array based list.</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span> Josh Hug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AList</span> &#123;</span><br><span class="line">    <span class="comment">/** Creates an empty list. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] item;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AList</span><span class="params">()</span> &#123;</span><br><span class="line">        item = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts X into the back of the list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        item[size] = x;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns the item from the back of the list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Gets the ith item in the list (0 is the front). */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns the number of items in the list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Deletes item from back of the list and</span></span><br><span class="line"><span class="comment">     * returns deleted item. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        cur_item = getLast();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> cur_item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这段代码存在一个问题，如果我们创建的列表实际大小比100大，会导致越界，若我们增加一开始的<code>item</code>数组的大小，又会造成空间内存的浪费。</p><h2 id="调节数组大小"><a href="#调节数组大小" class="headerlink" title="调节数组大小"></a>调节数组大小</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">    System.arraycopy(items, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    item = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == item.length) &#123;</span><br><span class="line">        resize(size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    items[size] = x;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 从一个大小为 100 的数组开始，如果我们调用 <code>addLast</code> 1,000 次，大约会创建和填充500,000个内存盒</p><p>创建所有这些存储盒并重新复制其内容需要时间。在下图中，我们在顶部绘制了 SLList 的总时间与操作次数的关系，在底部绘制了基于朴素数组的列表的总时间与操作次数的关系。SLList 显示一条直线，这意味着对于每个 <code>add</code> 操作，列表需要相同的额外时间。这意味着每个操作都需要恒定的时间！你也可以这样想：图形是线性的，表明每个操作都需要恒定的时间，因为常数的积分是一条线。</p><p>相比之下，朴素数组列表显示抛物线，表明每个操作都需要线性时间，因为直线的积分是抛物线。这对现实世界具有重大影响。对于插入 100,000 个项目，我们可以通过计算 N^2&#x2F;N 的比率来粗略计算多长时间。 将 100,000 个项目插入到我们基于数组的列表中需要 （100,000^2）&#x2F;100,000 或 100,000 倍的时间。这显然是不能接受的。</p><p><img src="/2024/01/24/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-4-2-5/insert_experiment.png" alt="fig25/insert_experiment.png"></p><p>这就非常的慢了</p><h3 id="方法二——几何大小调整"><a href="#方法二——几何大小调整" class="headerlink" title="方法二——几何大小调整"></a>方法二——几何大小调整</h3><p>我们可以通过增加数组的大小来增加我们的性能问题，而不是增加一个加法量。也就是说，与其添加等于某个调整大小因子 <code>RFACTOR</code> 的内存盒数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertBack</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == item.length) &#123;</span><br><span class="line">           resize(size + RFACTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    items[size] = x;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相反，我们通过将框数乘以 <code>RFACTOR</code> 来调整大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertBack</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == item.length) &#123;</span><br><span class="line">           resize(size * RFACTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    items[size] = x;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重复我们之前的计算实验，我们看到我们的新 <code>AList</code> 插件在很短的时间内完成了 100,000 个插入，以至于我们甚至没有注意到。我们将推迟到本书的最后一章对为什么会发生这种情况进行全面分析。</p><h2 id="内存性能"><a href="#内存性能" class="headerlink" title="内存性能"></a>内存性能</h2><p>我们 <code>AList</code> 几乎完成了，但我们有一个主要问题。假设我们插入 1,000,000,000 个项目，然后删除 990,000,000 个项目。在这种情况下，我们将只使用 10,000,000 个内存盒，剩下 99% 完全未使用。</p><p>为了解决这个问题，我们还可以在数组开始看起来为空时缩小数组的大小。具体来说，我们定义了一个“使用比率”R，它等于列表的大小除以 <code>items</code> 数组的长度。例如，在下图中，使用率为0.04。</p><p>在典型的实现中，当 R 降至小于 0.25 时，我们将数组的大小减半。</p><h2 id="泛型AList"><a href="#泛型AList" class="headerlink" title="泛型AList"></a>泛型AList</h2><p>就像我们之前所做的那样，我们可以修改我们的 <code>AList</code> ，以便它可以保存任何数据类型，而不仅仅是整数。为此，我们再次在类中使用特殊的角括号表示法，并在适当的情况下将任意类型参数替换为整数。例如，在下面，我们用作 <code>Glorp</code> 类型参数。</p><p>有一个显著的语法差异：Java 不允许我们创建泛型对象数组，因为泛型的实现方式存在一个模糊的问题。也就是说，我们不能做这样的事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glorp[] items = <span class="keyword">new</span> <span class="title class_">Glorp</span>[<span class="number">8</span>];</span><br></pre></td></tr></table></figure><p>相反，我们必须使用如下所示的笨拙语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glorp[] items = (Glorp []) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">8</span>];</span><br></pre></td></tr></table></figure><p>这将产生一个编译警告，但这只是我们必须忍受的事情。我们将在后面的章节中更详细地讨论这一点。</p><p>我们所做的另一个更改是，<strong>我们将“删除”的任何项目都清空。</strong>以前，我们没有理由将已删除的元素清零，而使用泛型对象，我们确实希望清空对所存储对象的引用。这是为了避免“游荡”。回想一下，Java 仅在最后一个引用丢失时销毁对象。如果我们未能清空引用，那么 Java 将不会对已添加到列表中的对象进行垃圾回收。</p><blockquote><p>因为我们使用泛型对象时，相比之前的int对象，我们的列表的内存盒是指向某个对象的引用，若我们没有清空的话，该对象的内存还是会堆叠在内存中，不会被Java垃圾回收。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(五)--链表基础的列表(2.2,2.3)</title>
      <link href="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/"/>
      <url>/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://joshhug.gitbooks.io/hug61b/content/chap2/chap22.html">2.2 SLList ·拥抱61B — 2.2 The SLList · Hug61B (gitbooks.io)</a></p><p><a href="https://joshhug.gitbooks.io/hug61b/content/chap2/chap23.html">2.3 DLList ·拥抱61B — 2.3 The DLList · Hug61B (gitbooks.io)</a></p><h1 id="SLLists"><a href="#SLLists" class="headerlink" title="SLLists"></a>SLLists</h1><p>在第 2.1 章中，我们构建了类 <code>IntList</code> ，这是一个列表数据结构，从技术上讲，它可以完成列表可以执行的所有操作。然而，在实践中，它 <code>IntList</code> 使用起来相当笨拙，导致代码难以阅读和维护。</p><p>从根本上说，问题在于 <code>IntList</code> 这就是我所说的裸递归数据结构。为了正确使用递归，程序员必须理解和利用递归，即使是简单的列表相关任务。这限制了它对新手程序员的有用性，并可能引入一类全新的棘手错误，程序员可能会遇到这些错误，具体取决于该 <code>IntList</code> 类提供的帮助程序方法类型。</p><h2 id="初级版本"><a href="#初级版本" class="headerlink" title="初级版本:"></a>初级版本:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">        <span class="keyword">public</span> IntNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span> &#123;</span><br><span class="line">            item = i;</span><br><span class="line">            next = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IntNode first; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item to the front of the list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, first);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Retrieves the front item from the list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item to the end of the list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">/* Your Code Here! */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns the number of items in the list using recursion. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/* Your Code Here! */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IntList和SLList的比较"><a href="#IntList和SLList的比较" class="headerlink" title="IntList和SLList的比较"></a>IntList和SLList的比较</h1><h2 id="创建："><a href="#创建：" class="headerlink" title="创建："></a>创建：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntList</span> <span class="variable">L1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">5</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="type">SLList</span> <span class="variable">L2</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><blockquote><p>隐藏 <code>SLList</code> 用户存在空链接的详细信息。</p></blockquote><h2 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h2><h3 id="SLList"><a href="#SLList" class="headerlink" title="SLList:"></a>SLList:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SLList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>(<span class="number">15</span>);</span><br><span class="line">L.addFirst(<span class="number">10</span>);</span><br><span class="line">L.addFirst(<span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> L.getFirst();</span><br></pre></td></tr></table></figure><h3 id="IntList"><a href="#IntList" class="headerlink" title="IntList:"></a>IntList:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">15</span>, <span class="literal">null</span>);</span><br><span class="line">L = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">10</span>, L);</span><br><span class="line">L = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">5</span>, L);</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> L.first;</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>直观地比较这两种数据结构，我们有：（ <code>IntList</code> 版本在顶部， <code>SLList</code> 版本在下方）</p><p><img src="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/IntList_vs_SLList.png" alt="IntList_vs_SLList.png"></p><p>从本质上讲，该 <code>SLList</code> 类充当列表用户和裸递归数据结构之间的中间人。如上 <code>IntList</code> 所述， <code>IntList</code> 用户具有指向 <code>IntList</code> .正如奥维德所说：凡人不能在不死的情况下注视神，所以也许最好在那里 <code>SLList</code> 充当我们的中间人。</p><blockquote><p>SLList提高了代码的抽象性，只提供接口出来，而不是提供具有风险的裸数据<code>first</code>来获取。</p></blockquote><h3 id="公有与私有"><a href="#公有与私有" class="headerlink" title="公有与私有"></a>公有与私有</h3><p>IntList的数据皆为public，没有预留接口来调用。</p><p>如果SLList数据也皆为public，那么可以绕过接口直接获取，具有一定风险。</p><p>私有变量和方法只能通过同一 <code>.java</code> 文件中的代码访问，例如在本例 <code>SLList.java</code> 中。这意味着像 <code>SLLTroubleMaker</code> 下面的类将无法编译，从而产生 <code>first has private access in SLList</code> 错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLLTroubleMaker</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SLList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>(<span class="number">15</span>);</span><br><span class="line">        L.addFirst(<span class="number">10</span>);</span><br><span class="line">        L.first.next.next = L.first.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比之下， <code>SLList.java</code> 文件内的任何代码都能够访问该 <code>first</code> 变量。</p><p>限制访问似乎有点愚蠢。毕竟， <code>private</code> 关键字唯一要做的就是破坏原本编译的程序。然而，在大型软件工程项目中， <code>private</code> 关键字是一个非常宝贵的信号，表明最终用户应该忽略某些代码片段（因此不需要理解）。同样，关键字 <code>public</code> 应该被看作是一种方法可用的声明，并且将永远像现在一样工作。</p><p>打个比方，汽车具有某些 <code>public</code> 功能，例如油门和制动踏板。在引擎盖下，有 <code>private</code> 关于它们如何运作的详细信息。在汽油动力汽车中，油门踏板可以控制某种燃油喷射系统，而在电池供电的汽车中，它可以调整输送到电机的电池电量。虽然私人细节可能因汽车而异，但我们预计所有油门踏板都有相同的行为。更改这些会引起用户的极大恐慌，并且很可能会发生可怕的事故。</p><h1 id="SList的改进"><a href="#SList的改进" class="headerlink" title="SList的改进"></a>SList的改进</h1><h2 id="嵌套IntNode类"><a href="#嵌套IntNode类" class="headerlink" title="嵌套IntNode类"></a>嵌套IntNode类</h2><blockquote><p>由IntList改名而来</p></blockquote><p>目前，我们有两个 <code>.java</code> 文件： <code>IntNode</code> 和 <code>SLList</code> .然而，这真的 <code>IntNode</code> 只是故事中的一个配角 <code>SLList</code> 。</p><p>在这种情况下，Java 为我们提供了将一个类声明嵌入到另一个类声明中的能力。语法简单直观：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">            <span class="keyword">public</span> IntNode next;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span> &#123;</span><br><span class="line">                item = i;</span><br><span class="line">                next = n;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> IntNode first; </span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">           first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">       &#125; </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>嵌套类对代码性能没有有意义的影响，只是保持代码井井有条的工具。有关嵌套类的更多信息，请参阅 Oracle 的官方文档。</p><p>如果嵌套类不需要使用 <code>SLList</code> 的任何实例方法或变量，则可以声明嵌套类 <code>static</code> ，如下所示。将嵌套类声明为 意味着 <code>static</code> 静态类中的方法不能访问封闭类的任何成员。在这种情况下，这意味着 中 <code>IntNode</code> 的任何方法都无法访问 <code>first</code> 、 <code>addFirst</code> 或 <code>getFirst</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">            <span class="keyword">public</span> IntNode next;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span> &#123;</span><br><span class="line">                item = i;</span><br><span class="line">                next = n;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> IntNode first;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样可以节省一些内存，因为每个 <code>IntNode</code> 都不再需要跟踪如何访问其封闭 <code>SLList</code> 式 .</p><p>换句话说，如果你检查上面的代码，你会发现该 <code>IntNode</code> 类从不使用 <code>SLList</code> 的 <code>first</code> 变量 ，也不使用 <code>SLList</code> 的任何方法。因此，我们可以使用 static 关键字，这意味着该 <code>IntNode</code> 类不会引用其 boss，从而节省了少量内存。</p><h3 id="一个简单的经验法则是，如果不使用外部类的任何实例成员，请使嵌套类成为静态类。"><a href="#一个简单的经验法则是，如果不使用外部类的任何实例成员，请使嵌套类成为静态类。" class="headerlink" title="一个简单的经验法则是，如果不使用外部类的任何实例成员，请使嵌套类成为静态类。"></a><strong>一个简单的经验法则是，如果不使用外部类的任何实例成员，请使嵌套类成为静态类。</strong></h3><h2 id="addLast-and-size"><a href="#addLast-and-size" class="headerlink" title="addLast() and size()"></a>addLast() and size()</h2><h3 id="addLast"><a href="#addLast" class="headerlink" title="addLast()"></a>addLast()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Adds an item to the end of the list. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advance p to the end of the list. */</span></span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 于 <code>IntList</code> 的 <code>size</code> 递归调用很简单： <code>return 1 + this.rest.size()</code> .对于一个 <code>SLList</code> ，这种方法是没有意义的。 <code>SLList</code> 没有 <code>rest</code> 变量。取而代之的是，我们将使用一种与中间人类一起使用的通用模式，例如 <code>SLList</code> – 我们将创建一个私有帮助程序方法，该方法与底层的裸递归数据结构进行交互。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Returns the size of the list starting at IntNode p. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">(IntNode p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + size(p.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们有两个方法，都命名为 <code>size</code> .这在 Java 中是允许的，因为它们具有不同的参数。我们说两个名称相同但签名不同的方法被重载。有关重载方法的更多信息，请参阅 Java 的官方文档。</p><p>另一种方法是在 <code>IntNode</code> 类本身中创建非静态帮助程序方法。这两种方法都很好，尽管我个人更喜欢 <code>IntNode</code> 在类中没有任何方法。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>我们可以发现，当我们需要得到size的值的时候都会重新调用一遍<code>size()</code>函数，这对性能有一定的影响，</p><p>假设在大小为 1,000 的列表 <code>size</code> 上需要 2 秒。我们预计，在大小为 1,000,000 的列表中，该 <code>size</code> 方法将需要 2,000 秒，因为计算机必须单步执行列表中 1,000 倍的项目才能到达末尾。对于大型列表来说，使用非常 <code>size</code> 慢的方法是不可接受的，因为我们可以做得更好。</p><p>为此，我们可以简单地将一个 <code>size</code> 变量添加到跟踪当前大小的 <code>SLList</code> 类中，从而生成下面的代码。这种保存重要数据以加快检索速度的做法有时称为**缓存(caching)**。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">    ... <span class="comment">/* IntNode declaration omitted. */</span></span><br><span class="line">    <span class="keyword">private</span> IntNode first;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, first);</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种修改使我们 <code>size</code> 的方法非常快，无论列表有多大。当然，它也会减慢我们的 <code>addFirst</code> 和 <code>addLast</code> 方法的速度，也会增加我们类的使用记忆，但只是微不足道的量。在这种情况下，权衡显然有利于创建大小缓存。</p><h2 id="空列表构造引发的空指针异常"><a href="#空列表构造引发的空指针异常" class="headerlink" title="空列表构造引发的空指针异常"></a>空列表构造引发的空指针异常</h2><p>我们能够轻松实现一个创建空列表的构造函数。最自然的方法是设置为 <code>first</code> <code>null</code> 如果列表为空。这将产生以下构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">()</span> &#123;</span><br><span class="line">    first = <span class="literal">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不幸的是，如果我们插入到一个空列表中，这会导致我们 <code>addLast</code> 的方法崩溃。由于 <code>first</code> 是 <code>null</code> ，尝试访问 <code>p.next</code> <code>while (p.next != null)</code> 下面会导致空指针异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">    <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> first;</span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空列表解决方法—哨兵节点"><a href="#空列表解决方法—哨兵节点" class="headerlink" title="空列表解决方法—哨兵节点"></a>空列表解决方法—哨兵节点</h2><p>有两种解决方案</p><h3 id="一-为addLast-添加一种特殊情况处理"><a href="#一-为addLast-添加一种特殊情况处理" class="headerlink" title="(一)为addLast()添加一种特殊情况处理"></a>(一)为<code>addLast()</code>添加一种特殊情况处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> first;</span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此解决方案有效，但在必要时应避免使用上面所示的特殊情况代码。人类只有这么多的工作记忆，因此我们希望尽可能地控制复杂性。对于像 这样的简单数据结构 <code>SLList</code> ，特殊情况的数量很少。更复杂的数据结构（如树）可能会变得更加丑陋。</p><h3 id="二-哨兵节点"><a href="#二-哨兵节点" class="headerlink" title="(二)哨兵节点"></a>(二)哨兵节点</h3><p>一个更干净的，虽然不那么明显的解决方案是让它变得 <code>SLLists</code> “相同”，即使它们是空的。我们可以通过创建一个始终存在的特殊节点来做到这一点，我们称之为哨兵节点。哨兵节点将持有一个值，我们不会关心它。</p><p>例如，创建的 <code>SLList L = new SLList()</code> 空列表如下所示：</p><p><img src="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/empty_sentinelized_SLList.png" alt="empty_sentinelized_SLList.png"></p><p>具有项目 5、10 和 15 的 a <code>SLList</code> 如下所示：</p><p><img src="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/three_item_sentenlized_SLList.png" alt="three_item_sentenlized_SLList.png"></p><p>由于 <code>SLList</code> 没有哨兵没有特殊情况，我们可以简单地从我们 <code>addLast</code> 的方法中删除特殊情况，从而得到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">    <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> sentinel;</span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不变量"><a href="#不变量" class="headerlink" title="不变量"></a>不变量</h2><p>不变性是<strong>关于数据结构的事实</strong>，它保证为真（假设代码中没有错误）。</p><p>具有哨兵节点的 A <code>SLList</code> 至少具有以下不变量：</p><ul><li>引用 <code>sentinel</code> 始终指向哨兵节点。</li><li>前面的项（如果存在）始终位于 <code>sentinel.next.item</code> 。</li><li>该 <code>size</code> 变量始终是已添加的项的总数。</li></ul><p>不变量使推理代码变得更加容易，并且还为您提供了在确保代码正常工作方面要努力实现的具体目标。</p><h1 id="SList最终版本"><a href="#SList最终版本" class="headerlink" title="SList最终版本"></a>SList最终版本</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">        <span class="keyword">public</span> IntNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span> &#123;</span><br><span class="line">            item = i;</span><br><span class="line">            next = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IntNode sentinel;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">()</span> &#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> <span class="title class_">IntNode</span>(<span class="number">99</span>, <span class="literal">null</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> <span class="title class_">IntNode</span>(<span class="number">99</span>, <span class="literal">null</span>);</span><br><span class="line">        sentinel.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, sentinel.next);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item to the front of the list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        sentinel.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, sentinel.next);</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Retrieves the front item from the list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sentinel.next.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns the number of items in the list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item to the end of the list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        <span class="comment">/* Advance p to the end of the list. */</span></span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Crashes when you call addLast on an empty SLList. Fix it. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SLList</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>();</span><br><span class="line">        x.addLast(<span class="number">5</span>);</span><br><span class="line">        x.addLast(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DLLists"><a href="#DLLists" class="headerlink" title="DLLists"></a>DLLists</h1><h2 id="addLast-1"><a href="#addLast-1" class="headerlink" title="addLast"></a>addLast</h2><p>考虑上面 <code>addLast(int x)</code> 中的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">    <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> sentinel;</span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法的问题在于它很慢。对于一个很长的列表，该 <code>addLast</code> 方法必须遍历整个列表，就像我们在第 2.2 章中看到的方法 <code>size</code> 一样。同样，我们可以尝试通过添加变量 <code>last</code> 来加快代码速度，如下所示</p><p>考虑表示上述实现的 <code>SLList</code> 框和指针图，其中包括最后一个指针。假设我们想要支持 <code>addLast</code> 、 <code>getLast</code> 和 <code>removeLast</code> 操作。所示结构是否支持快速 <code>addLast</code> 、 <code>getLast</code> 和 <code>removeLast</code> 操作？如果不是，哪些操作很慢？</p><blockquote><p><code>addLast</code> 会很快，但 <code>getLast</code> <code>removeLast</code> 会很慢。这是因为在删除最后一个节点后，我们没有简单的方法来获取倒数第二个节点来更新 <code>last</code> 指针。</p></blockquote><h2 id="SecondToLast"><a href="#SecondToLast" class="headerlink" title="SecondToLast"></a>SecondToLast</h2><p>结构的问题在于，删除列表中最后一项的方法本身会很慢。这是因为我们需要首先找到倒数第二项，然后将其下一个指针设置为 null。添加 <code>secondToLast</code> 指针也无济于事，因为这样我们就需要找到列表中倒数第三项，以确保 <code>secondToLast</code> 在删除最后一项后 <code>last</code> 遵守适当的不变量</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><h3 id="添加prev指针"><a href="#添加prev指针" class="headerlink" title="添加prev指针"></a>添加prev指针</h3><p>解决此问题的最自然方法是为每个 添加一个前一个指针 <code>IntNode</code> ，即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> IntNode prev;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">public</span> IntNode next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换句话说，我们的列表现在每个节点都有两个链接。此类列表的一个常见术语是“双向链表”，我们简称为 a <code>DLList</code> 。这与第 2.2 章中的单个链表形成鲜明对比，又名 <code>SLList</code> .</p><p>添加这些额外的指针将导致额外的代码复杂性。您将在项目 1 中自行构建一个双向链表，而不是引导您完成它。下面的框图和指针图分别更精确地显示了大小为 0 和大小为 2 的列表的双向链表的外观。</p><p><img src="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/dllist_basic_size_0.png" alt="dllist_basic_size_0.png"></p><p><img src="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/dllist_basic_size_2.png" alt="dllist_basic_size_2.png"></p><h3 id="哨兵-Sentinel-改进"><a href="#哨兵-Sentinel-改进" class="headerlink" title="哨兵(Sentinel )改进"></a>哨兵(Sentinel )改进</h3><p>后退指针允许列表支持在恒定时间内添加、获取和删除列表的正面和背面。这种设计存在一个微妙的问题， <code>last</code> 指针有时指向哨兵节点，有时指向真实节点。就像 的非哨兵版本一样 <code>SLList</code> ，这会导致具有特殊情况的代码比我们在第 8 次也是最后一次改进后得到的代码要丑陋得多。（你能想到什么 <code>DLList</code> 方法会有这些特殊情况吗？</p><p><img src="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/image-20240122183046374.png" alt="image-20240122183046374"></p><blockquote><p>对于每个方法我们都要用if语句检查一下last指向的是不是哨兵节点，这就很麻烦。</p></blockquote><p>一种解决方法是将第二个哨兵节点添加到列表的后面。这导致拓扑如下所示，显示为框和指针图。</p><p><img src="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/dllist_double_sentinel_size_0.png" alt="dllist_double_sentinel_size_0.png"></p><p><img src="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/dllist_double_sentinel_size_2.png" alt="dllist_double_sentinel_size_2.png"></p><p>另一种方法是实现列表，使其呈圆形，前指针和后指针共享同一哨兵节点。</p><p><img src="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/dllist_circular_sentinel_size_0.png" alt="dllist_circular_sentinel_size_0.png"></p><p><img src="/2024/01/22/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%97%E8%A1%A8-2-2-2-3/dllist_circular_sentinel_size_2.png" alt="dllist_circular_sentinel_size_2.png"></p><p>双哨兵和圆形哨兵方法都有效，并产生没有丑陋特殊情况的代码，尽管我个人认为圆形哨兵方法更干净，更美观。我们不会讨论这些实泛型 DLList现的细节，因为你将有机会在项目 1 中探索一个或两个。</p><h2 id="泛型-DLList"><a href="#泛型-DLList" class="headerlink" title="泛型 DLList"></a>泛型 DLList</h2><p>语法一开始有点奇怪。基本思想是，在类声明中的类名称之后，在尖括号内使用任意占位符： <code>&lt;&gt;</code> .然后，在要使用任意类型的任何位置，都可以改用该占位符。</p><p>例如，我们 <code>DLList</code> 之前的声明是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DLList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> IntNode sentinel;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> IntNode prev;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">        <span class="keyword">public</span> IntNode next;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以容纳任何类型的泛型 <code>DLList</code> 如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DLList</span>&lt;BleepBlorp&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> IntNode sentinel;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> IntNode prev;</span><br><span class="line">        <span class="keyword">public</span> BleepBlorp item;</span><br><span class="line">        <span class="keyword">public</span> IntNode next;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>BleepBlorp</code>只是我编造的一个名字，你可以用大多数你可能想用的任何其他名字来代替， <code>BleepBlorp</code> 比如 <code>GloopGlop</code> 、、 <code>Horse</code> <code>TelbudorphMulticulus</code> 或其他什么。</p><p>现在我们已经定义了该类的泛型版本，我们还必须使用特殊语法来实例化该 <code>DLList</code> 类。为此，我们在声明期间将所需的类型放在尖括号内，并在实例化期间使用空尖括号。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DLList&lt;String&gt; d2 = <span class="keyword">new</span> <span class="title class_">DLList</span>&lt;&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">d2.addLast(<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure><p>由于泛型仅适用于引用类型，因此我们不能将原语放在 <code>int</code> 尖括号内或 <code>double</code> 尖括号内，例如 <code>&lt;int&gt;</code> .取而代之的是，我们使用原始类型的参考版本，在 case 的情况下 <code>int</code> 是 <code>Integer</code> ，例如</p><p>关于使用泛型类型还有其他细微差别，但我们会将它们推迟到本书的后面一章，届时您有更多机会自己尝试它们。现在，请使用以下经验法则：</p><ul><li>在<strong>实现</strong>数据结构的 .java 文件中，仅在文件最顶部的类名之后指定一次泛型类型名。</li><li>在其他使用数据结构的 .java 文件中，在声明期间指定所需的特定类型，并在实例化期间使用空菱形运算符。</li><li>如果需要在基元类型上实例化泛型，请使用 <code>Integer</code>  、 <code>Character</code> 、<code>Long</code> 、 <code>Short</code> 、<code>Byte</code>、 <code>Double</code> 、<code>Boolean</code> 或 <code>Float</code> 代替其基元等效项。</li></ul><p>次要细节：您也可以在实例化时在尖括号内声明类型，尽管这不是必需的，只要您还在同一行上声明一个变量即可。换句话说，下面的代码行是完全有效的，即使右侧的 <code>Integer</code> 代码是多余的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DLList&lt;Integer&gt; d1 = <span class="keyword">new</span> <span class="title class_">DLList</span>&lt;Integer&gt;(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(四)--Reading2.1-列表-海象之谜</title>
      <link href="/2024/01/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reading2-1-%E6%95%B0%E7%BB%84/"/>
      <url>/2024/01/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reading2-1-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是海象之谜"><a href="#什么是海象之谜" class="headerlink" title="什么是海象之谜?"></a>什么是海象之谜?</h1><p>尝试预测当我们运行下面的代码时会发生什么。更改为 b 会影响 a 吗，更改为 x 会影响 y 吗？提示：如果你来自 Python，Java 也有相同的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PollQuestions</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Walrus</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Walrus</span>(<span class="number">1000</span>, <span class="number">8.3</span>);</span><br><span class="line">        Walrus b;</span><br><span class="line">        b = a;</span><br><span class="line">        b.weight = <span class="number">5</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        y = x;</span><br><span class="line">        x = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;x is: &quot;</span> + x);</span><br><span class="line">        System.out.println(<span class="string">&quot;y is: &quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Walrus</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> weight;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> tuskSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Walrus</span><span class="params">(<span class="type">int</span> w, <span class="type">double</span> ts)</span> &#123;</span><br><span class="line">            weight = w;</span><br><span class="line">            tuskSize = ts;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">&quot;weight: %d, tusk size: %.2f&quot;</span>, weight, tuskSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a><strong>答案:</strong></h2><p><img src="/2024/01/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reading2-1-%E6%95%B0%E7%BB%84/image-20240120023307369.png" alt="image-20240120023307369"></p><p><img src="/2024/01/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reading2-1-%E6%95%B0%E7%BB%84/image-20240120024122499.png" alt="image-20240120024122499"></p><h1 id="位"><a href="#位" class="headerlink" title="位"></a>位</h1><p>计算机中的所有信息都以 1 和 0 的序列形式存储在内存中。一些例子：</p><ul><li>72 通常存储为 01001000</li><li>205.75 通常存储为 01000011 01001101 11000000 00000000</li><li>字母 H 通常存储为 01001000（与 72 相同）</li><li>真实值通常存储为00000001</li></ul><p>一个有趣的观察结果是，72 和 H 都存储为 01001000。这就提出了一个问题：一段 Java 代码如何知道如何解释 01001000？</p><p>答案是<strong>通过类型</strong></p><h1 id="声明变量（简体）"><a href="#声明变量（简体）" class="headerlink" title="声明变量（简体）"></a>声明变量（简体）</h1><p>您可以将计算机视为包含大量用于存储信息的内存位，每个内存位都有一个唯一的地址。现代计算机可以使用数十亿个这样的比特。</p><p>当你声明某种类型的变量时，Java 会找到一个连续的块，该块的位恰好足够容纳该类型的事物。例如，如果声明一个 int，则会得到一个 32 位的块。如果声明一个字节，则会得到一个 8 位的块。Java 中的每种数据类型都包含不同数量的位。在这个类中，确切的数字对我们来说并不是很重要。</p><p>为了方便的比喻，我们将其中一个块称为比特的“盒子”。</p><p>除了留出内存之外，Java 解释器还在内部表中创建一个条目，该条目将每个变量名称映射到框中第一个位的位置。</p><p>例如，如果声明 <code>int x</code> 了 和 <code>double y</code> ，则 Java 可能会决定使用计算机内存的 352 到 384 位来存储 x，并使用 20800 到 20864 位来存储 y。然后，解释器将记录 int x 从位 352 开始，y 从位 20800 开始。例如，在执行代码后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">double</span> y;</span><br></pre></td></tr></table></figure><p>我们最终会得到尺寸为 32 和 64 的盒子，如下图所示：</p><p><img src="/2024/01/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reading2-1-%E6%95%B0%E7%BB%84/x_and_y_empty_bitwise.png" alt="x_and_y_empty_bitwise"></p><p>声明变量时，Java 不会将任何内容写入保留框中。换句话说，没有默认值。因此，Java 编译器会阻止您使用变量，直到使用 <code>=</code> 运算符将位填充到框中。出于这个原因，我避免在上图的框中显示任何位。</p><p>当您为内存盒赋值时，它将填充您指定的位。例如，如果我们执行以下行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = -<span class="number">1431195969</span>;</span><br><span class="line">y = <span class="number">567213.112</span>;</span><br></pre></td></tr></table></figure><p><img src="/2024/01/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reading2-1-%E6%95%B0%E7%BB%84/x_and_y_empty_filled.png" alt="x_and_y_empty_filled.png"></p><h2 id="简化的框表示法"><a href="#简化的框表示法" class="headerlink" title="简化的框表示法"></a>简化的框表示法</h2><p>虽然我们在上一节中使用的框表示法对于理解引擎盖下发生的事情非常有用，但它对实际目的没有用，因为我们不知道如何解释二进制位。</p><p>因此，我们将用人类可读的符号来编写它们，而不是用二进制文件编写内存盒内容。我们将在课程的其余部分这样做。例如，在执行以下操作后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">double</span> y;</span><br><span class="line">x = -<span class="number">1431195969</span>;</span><br><span class="line">y = <span class="number">567213.112</span>;</span><br></pre></td></tr></table></figure><p>我们可以使用我称之为简化框表示法来表示程序环境，如下所示：</p><p><img src="/2024/01/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reading2-1-%E6%95%B0%E7%BB%84/x_and_y_simplified_box_notation.png" alt="x_and_y_simplified_box_notation.png"></p><h1 id="黄金平等法则-（GRoE）"><a href="#黄金平等法则-（GRoE）" class="headerlink" title="黄金平等法则 （GRoE）"></a>黄金平等法则 （GRoE）</h1><p>现在有了简化的盒子符号，我们终于可以开始解开海象之谜了。</p><p>事实证明，我们的 Mystery 有一个简单的解决方案：当你编写 <code>y = x</code> 时，你告诉 Java 解释器将 x 中的<strong>位</strong>复制到 y 中。在理解我们的海象之谜时，这条平等的黄金法则 （GRoE） 是所有真理的根源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">y = x;</span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;x is: &quot;</span> + x);</span><br><span class="line">System.out.println(<span class="string">&quot;y is: &quot;</span> + y);</span><br></pre></td></tr></table></figure><p>因此，Java的复制操作是复制<strong>位</strong></p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>上面，我们说了 8 种原始类型：byte、short、int、long、float、double、boolean、char。其他所有内容，包括数组，都不是原始类型，而是 <code>reference type</code> .</p><p>当我们使用 <code>new</code> （例如 Dog、Walrus、Planet）实例化一个 Object 时，Java 首先为类的每个实例变量分配一个框，并用默认值填充它们。然后，构造函数通常（但并非总是）用其他值填充每个框。</p><blockquote><p>引用类型可能都需要new，这可能意味着引用变量声明的其实是类似于cpp中的指针?</p></blockquote><h3 id="引用变量声明"><a href="#引用变量声明" class="headerlink" title="引用变量声明"></a>引用变量声明</h3><p>当我们声明任何引用类型（Walrus、Dog、Planet、数组等）的变量时，无论什么类型的对象，Java 都会分配一个 64 位的盒子。</p><p>乍一看，这似乎导致了海象悖论。上一节中的 Walrus 需要超过 64 位来存储。此外，无论对象的类型如何，我们只能获得 64 位来存储它，这似乎很奇怪。</p><p>但是，通过以下信息可以轻松解决此问题：64 位框不包含有关海象的数据，而是内存中海象的地址。</p><blockquote><p>类似cpp中的指针，指针变量存储的是指针指向的地址，通常只有4个字节；而指针所指向的那个地址不一定存储了4个字节。</p></blockquote><h3 id="框和指针表示法"><a href="#框和指针表示法" class="headerlink" title="框和指针表示法"></a>框和指针表示法</h3><p>和以前一样，很难解释引用变量中的一堆位，因此我们将为引用变量创建一个简化的框表示法，如下所示：</p><ul><li>如果一个地址全为零，我们将用 null 表示它。</li><li>非零地址将由指向对象实例化的箭头表示。</li></ul><p>这有时也称为“框和指针”表示法。</p><p>对于上一节中的示例，我们将有：</p><p><img src="/2024/01/20/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reading2-1-%E6%95%B0%E7%BB%84/someWalrus_simplified_bit_notation.png" alt="someWalrus_simplified_bit_notation.png"></p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>当您将参数传递给函数时，您也只是在复制位。换言之，GRoE 也适用于参数传递。复制位通常称为“按值传递”。在 Java 中，我们总是按值传递。</p><p>例如，请考虑以下函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">average</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们调用这个函数，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5.5</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">10.5</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">avg</span> <span class="operator">=</span> average(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上我们是将x，y的值拷贝给了a, b。</p><h1 id="列表的实例化"><a href="#列表的实例化" class="headerlink" title="列表的实例化"></a>列表的实例化</h1><p>如上所述，存储数组的变量是引用变量，就像任何其他变量一样。例如，请考虑以下声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] x;</span><br><span class="line">Planet[] planets;</span><br></pre></td></tr></table></figure><p>这两个声明都创建了 64 位的内存盒。 <code>x</code> 只能保存数组的地址，并且 <code>planets</code> 只能保存 <code>Planet</code> <code>int</code> 数组的地址。</p><p>实例化数组与实例化对象非常相似。例如，如果我们创建一个大小为 5 的整数数组，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = new int[]&#123;0, 1, 2, 95, 4&#125;;</span><br></pre></td></tr></table></figure><p>然后，关键字 <code>new</code> 创建 5 个框，每个框 32 位，并返回整个对象的地址以分配给 x。</p><h1 id="破碎的被褥法则"><a href="#破碎的被褥法则" class="headerlink" title="破碎的被褥法则"></a>破碎的被褥法则</h1><p><a href="https://readit.site/a/9amjk">https://readit.site/a/9amjk</a></p><p><a href="https://mathwithbaddrawings.com/2015/04/08/the-math-ceiling-wheres-your-cognitive-breaking-point/">数学天花板：你的认知突破点在哪里？– 糟糕的图纸数学 — The Math Ceiling: Where’s your cognitive breaking point? – Math with Bad Drawings</a></p><p>我感觉这个很有意思:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在大学里，我和我的室友从一些朋友那里买了一个二手被褥。他们住在一楼;我们住在四楼。他们很好心，他们帮我们抬上楼梯。</span><br><span class="line">当他们登上三楼的平台时，他们听到了一声裂缝。一根小小的金属棒从被褥上折断了。我们都检查了一下，但甚至不知道这件作品是从哪里来的。由于被褥看起来很好，我们只是耸了耸肩。</span><br><span class="line">在我们的房间里呆了一个星期后，被褥开始下垂。“它总是这样吗？”我们互相问。</span><br><span class="line">一个月后，它尴尬地下垂了。坐在最后，沙发的曲率会把你（和其他人）扔进一个中央的猪堆里。</span><br><span class="line">到学期结束时，它已经倒在尘土飞扬的宿舍地板上，这是曾经繁荣的被褥的破碎骨架。</span><br><span class="line">现在，宜家家具是客厅的果蝇：出了名的短命。毫无疑问，我们的被褥寿命是有上限的，也许是三四年。但这一个只活了八个月。</span><br><span class="line">事后看来，很明显，破碎的碎片绝对至关重要。没有它被褥似乎很好。但日复一日，随着每一个新的屁股，重量都压在结构的某些部分上，从来都不意味着独自承受负载。框架变得扭曲。压力不可持续地增加。被褥的内部时钟默默地滴答作响，直到缺乏支持被证明是压倒性的，整个事情都崩溃了。</span><br><span class="line">而且，可悲的是，数学课也是如此。</span><br><span class="line">假设你正在读八年级。您可以以完美的流动性和精度绘制线性方程。您可以计算它们的斜率、识别点并生成平行线和垂直线。</span><br><span class="line">但是，如果你缺少一个简单的理解——这些图只是满足方程的 x-y 对——那么你就是一个破碎的被褥。你错过了未来学习至关重要的一块。二次函数会困扰你;正弦曲线永远不会有意义;你可能会在微积分之后保释，安慰自己，“好吧，至少我的上限比一些人高。</span><br><span class="line">你可能会问，“既然我现在很好，难道我不能在以后真正需要的时候添加缺失的部分吗？有时，是的。但这要困难得多。你现在已经花了好几年时间没有这个关键的部分。你已经开发了捷径和零敲碎打的方法来度过难关。这些工作了一段时间，但它们扭曲了框架，现在你来了。为了继续前进，你必须忘记你的变通方法--有效地将被褥弯曲回原来的形状--然后才能继续。但是，放弃让你走到这一步的策略几乎是不可能的。</span><br><span class="line">稍后添加缺失的部分意味着要等到损坏已经开始，并且很难挽回。</span><br><span class="line">我相信，这是许多学生所经历的天花板。这不是他们神经病学的固有局限性。这是我们创造的东西。我们通过言语或行动说：“你不明白也没关系。只需按照以下步骤操作，并在后面检查您的答案。我们通过说“只有聪明的人才能得到它;至于其余的，我只想确保他们能做到。我们通过说，“好吧，他们现在不明白，但他们最终会自己弄清楚。</span><br><span class="line">这样一来，我们就可以成功地把被褥弄上楼梯。但在这个过程中会丢失一些东西。在没有关键理解的情况下将我们的学生送上前方，就像在没有替换弹药的情况下将他们送上战场一样。当然，他们会发射几发子弹，但当他们意识到缺少一些东西时，恢复为时已晚。</span><br></pre></td></tr></table></figure><p>一时半解虽然这在短期内可能很好，但从长远来看，在没有完全理解的情况下做问题可能会注定你以后会失败。有一篇关于这个所谓的破碎被褥法则的博客文章，你可能会觉得很有趣。</p><h1 id="IntLists"><a href="#IntLists" class="headerlink" title="IntLists"></a>IntLists</h1><p>事实证明，一个非常基本的列表实现起来是微不足道的，如下所示：</p><p>实现起来其实类似于”链表”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> first;</span><br><span class="line">    <span class="keyword">public</span> IntList rest;        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IntList</span><span class="params">(<span class="type">int</span> f, IntList r)</span> &#123;</span><br><span class="line">        first = f;</span><br><span class="line">        rest = r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Return the size of the list using... recursion! */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">this</span>.rest.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Return the size of the list using no recursion! */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">iterativeSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">IntList</span> <span class="variable">p</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            totalSize += <span class="number">1</span>;</span><br><span class="line">            p = p.rest;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSize;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns the ith item of this IntList*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rest.get(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(三)--Junit测试</title>
      <link href="/2024/01/19/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Junit%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/01/19/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Junit%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="测试理念"><a href="#测试理念" class="headerlink" title="测试理念"></a>测试理念</h1><h2 id="正确性工具-1：自动分级器"><a href="#正确性工具-1：自动分级器" class="headerlink" title="正确性工具#1：自动分级器"></a>正确性工具#1：自动分级器</h2><p>自动评分器可能是您接触到的第一个正确性工具。事实上，CS61B的自动分级器是基于 JUnit 加上一些额外的自定义库。</p><p>对自动分级者有一些很大的好处。也许最重要的是，它可以为您验证正确性，使您免于编写所有测试的繁琐且无指导性的任务。它还通过提供多汁的分数作为实现正确性的激励，使评估过程游戏化。如果学生花费过多的时间追逐实际上不会影响他们的成绩或学习的最终分数，这也可能适得其反。</p><p>然而，自动分级器在现实世界中并不存在，依赖自动分级器会养成坏习惯。偶尔上传代码并等待自动评分器运行会阻碍一个人的工作流程。Autograder Driven Development 是一个极端版本，学生编写所有代码，修复编译器错误，然后提交给自动评分器。在得到错误后，学生可以尝试进行一些更改，在打印语句中撒上一些，然后再次提交。并重复。最终，如果您依赖自动评分器，则无法控制工作流或代码。</p><h2 id="正确性工具-2：JUnit-测试"><a href="#正确性工具-2：JUnit-测试" class="headerlink" title="正确性工具 #2：JUnit 测试"></a>正确性工具 #2：JUnit 测试</h2><p>正如我们所看到的，JUnit 测试为您打开了一个新世界。您无需依赖其他人编写的自动评分器，而是为程序的每个部分编写测试。我们将这些部分中的每一个都称为一个单元。这使您可以对代码的每个单元充满信心 - 您可以依赖它们。这也有助于减少调试时间，因为您可以一次将注意力隔离到一个代码单元（通常是单个方法）。单元测试还迫使您明确每个代码单元应该完成什么。</p><p>但是，单元测试也有一些缺点。首先，编写全面的测试需要时间。编写不完整的单元测试很容易，这会给代码带来错误的信心。为依赖于其他单元的单元编写测试也很困难（考虑 your <code>LinkedListDeque</code> 中 <code>addFirst</code> 的方法）。</p><h3 id="测试驱动开发-（TDD）"><a href="#测试驱动开发-（TDD）" class="headerlink" title="*测试驱动开发 （TDD）*"></a>*<strong>测试驱动开发 （TDD）*</strong></h3><p>TDD 是一个开发过程，在这个过程中，我们在编写代码本身之前为代码编写测试。步骤如下：</p><ol><li>确定新功能。</li><li>为该功能编写单元测试。</li><li>运行测试。它应该失败。</li><li>编写通过测试的代码。</li><li>可选：重构代码以使其更快、更简洁等。除了现在我们有一个应该通过的测试的参考。</li></ol><p><img src="/2024/01/19/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Junit%E6%B5%8B%E8%AF%95/image-20240119190920106.png" alt="image-20240119190920106"></p><h2 id="正确性工具-3：集成测试"><a href="#正确性工具-3：集成测试" class="headerlink" title="正确性工具#3：集成测试"></a>正确性工具#3：集成测试</h2><p>单元测试很棒，但我们也应该确保这些单元能够正常工作（与这个模因不同）。集成测试验证组件是否正确地交互在一起。JUnit 实际上可以用于此目的。你可以把单元测试想象成最细微的，而集成测试的抽象级别高于此。</p><p>集成测试的挑战在于，手动操作很繁琐，但自动化却具有挑战性。在高度抽象的层次上，很容易错过细微或罕见的错误。</p><h1 id="JUnit-测试"><a href="#JUnit-测试" class="headerlink" title="JUnit 测试"></a>JUnit 测试</h1><p><a href="https://junit.org/junit4/javadoc/4.12/org/junit/Assert.html">Assert (JUnit API)</a></p><p>虽然 JUnit 确实改进了一些东西，但我们之前的测试代码在几个方面有点笨拙。在本节的其余部分，我们将讨论您可以进行的两个主要增强功能，以便您的代码更简洁、更易于使用。从语法的角度来看，这些增强功能看起来非常神秘，所以只需复制我们现在正在做的事情，我们将在后面的章节中解释其中的一些（但不是全部）。</p><p>第一个增强功能是使用所谓的<strong>“测试注释”</strong>。为此，我们：</p><ul><li>在每个方法前面加上 <code>@org.junit.Test</code> （不带分号）。</li><li>将每种测试方法更改为非静态。</li><li>从类中删除 <code>TestSort</code> 我们 <code>main</code> 的方法。</li></ul><p>第二个增强功能将允许我们为一些非常长的方法名称以及注释名称使用较短的名称。具体来说，我们将使用所谓的<strong>“import 语句”</strong>。</p><blockquote><p>不同与Python, import语句后要加分号</p></blockquote><p>我们首先将 import 语句 <code>import org.junit.Test;</code> 添加到文件的顶部。完成此操作后，我们可以简单地将 的所有 <code>@org.junit.Test</code> 实例替换为 <code>@Test</code> .</p><p>然后，我们添加第二个 import 语句 <code>import static org.junit.Assert.*</code> 。这样做之后，我们可以省略任何我们拥有的 <code>org.junit.Assert.</code> .例如，我们可以简单地替换为 <code>org.junit.Assert.assertEquals(expected2, actual2);</code> <code>assertEquals(expected2, actual2);</code></p><p>例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSort</span> &#123;</span><br><span class="line">    <span class="comment">//导入包前为@org.junit.Test</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindSmallest</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] input = &#123;<span class="string">&quot;i&quot;</span>, <span class="string">&quot;have&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;egg&quot;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">expected</span> <span class="operator">=</span> <span class="string">&quot;an&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">actual</span> <span class="operator">=</span> Sort.findSmallest(input);</span><br><span class="line">        assertArrayEquals(expected, actual);</span><br><span class="line">        <span class="comment">//导入前为org.junit.Assert.assertArrayEquals(expected, actual);       </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B项目练习笔记(一)--Proj0</title>
      <link href="/2024/01/18/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-1-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj0/"/>
      <url>/2024/01/18/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-1-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj0/</url>
      
        <content type="html"><![CDATA[<p>本人项目链接<a href="https://github.com/xxbaizero0/CS61B-Tutorial/tree/main/proj0/game2048">CS61B-Tutorial&#x2F;proj0&#x2F;game2048 at main · xxbaizero0&#x2F;CS61B-Tutorial (github.com)</a></p><p>我的任务仅驻留在 <code>Model.java</code> 并且仅限于四个方法:</p><ul><li><p><code>public static boolean emptySpaceExists（Board b）</code></p></li><li><p><code>public static boolean maxTileExists（Board b）</code></p></li><li><p><code>public static boolean atLeastOneMoveExists(Board b)</code></p></li><li><p><code>public boolean tilt(Side side)</code></p></li></ul><h1 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h1><h1 id="配置项目cdk，导入库"><a href="#配置项目cdk，导入库" class="headerlink" title="配置项目cdk，导入库"></a>配置项目cdk，导入库</h1><p>我们想要使用 <code>javalib</code> 文件夹中的这些 <code>.jar</code> 文件。仍然在“项目结构”中，单击左侧名为“库”的项目设置部分。如果您看到已添加， <code>javalib</code> 则无事可做。否则，我们将单击“+”按钮，然后单击“Java”，这将启动我们操作系统的文件浏览器，然后单击该 <code>javalib</code> 文件夹。然后，在屏幕的右下角，点击“应用”，然后点击蓝色的“确定”按钮。</p><p><img src="/2024/01/18/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-1-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj0/intellij-setup.gif" alt="IntelliJ Setup"></p><h2 id="修改项目文件"><a href="#修改项目文件" class="headerlink" title="修改项目文件"></a>修改项目文件</h2><p>游戏运行的<strong>上下左右移动键</strong>为<strong>英语语言下的按键</strong>，我们需要修改<code>GUISource.java</code></p><p><img src="/2024/01/18/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-1-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj0/bottom.png" alt="img"></p><h1 id="代码答案"><a href="#代码答案" class="headerlink" title="代码答案"></a>代码答案</h1><h2 id="public-static-boolean-emptySpaceExists（Board-b）"><a href="#public-static-boolean-emptySpaceExists（Board-b）" class="headerlink" title="public static boolean emptySpaceExists（Board b）"></a><code>public static boolean emptySpaceExists（Board b）</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Returns true if at least one space on the Board is empty.</span></span><br><span class="line"><span class="comment"> *  Empty spaces are stored as null.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">emptySpaceExists</span><span class="params">(Board b)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Fill in this function.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> b.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b.tile(i, j) == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="public-static-boolean-maxTileExists（Board-b）"><a href="#public-static-boolean-maxTileExists（Board-b）" class="headerlink" title="public static boolean maxTileExists（Board b）"></a><code>public static boolean maxTileExists（Board b）</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns true if any tile is equal to the maximum valid value.</span></span><br><span class="line"><span class="comment"> * Maximum valid value is given by MAX_PIECE. Note that</span></span><br><span class="line"><span class="comment"> * given a Tile object t, we get its value with t.value().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">maxTileExists</span><span class="params">(Board b)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Fill in this function.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> b.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b.tile(i, j) != <span class="literal">null</span>&amp;&amp;b.tile(i, j).value() == MAX_PIECE)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="public-static-boolean-atLeastOneMoveExists-Board-b"><a href="#public-static-boolean-atLeastOneMoveExists-Board-b" class="headerlink" title="public static boolean atLeastOneMoveExists(Board b)"></a><code>public static boolean atLeastOneMoveExists(Board b)</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">atLeastOneMoveExists</span><span class="params">(Board b)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Fill in this function.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> b.size();</span><br><span class="line">    <span class="keyword">if</span>(emptySpaceExists(b)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i + <span class="number">1</span> &lt; length)</span><br><span class="line">                <span class="keyword">if</span>(</span><br><span class="line">                    (b.tile(i-<span class="number">1</span>, j).value() == b.tile(i, j).value())</span><br><span class="line">                    ||(b.tile(i+<span class="number">1</span>, j).value() == b.tile(i, j).value())) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j - <span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; j+<span class="number">1</span> &lt; length)</span><br><span class="line">                <span class="keyword">if</span>((b.tile(i,j-<span class="number">1</span>).value() == b.tile(i, j).value())</span><br><span class="line">                   ||(b.tile(i, j +<span class="number">1</span>).value() == b.tile(i, j).value())) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了<code>emptySpaceExists()</code>函数，实际上增加了无所谓的时间，但是如果要完善的话if条件句还需要加长，可读性不高，因此没有修改。</p><p>如果有任何有效的移动，则应返回 true。所谓“有效移动”，是指如果用户在玩 2048 时可以按下一个按钮（UP、DOWN、LEFT 或 RIGHT），导致至少一个图块移动，那么这样的按键被视为有效移动。</p><p>有两种方法可以进行有效移动：</p><ul><li>棋盘上至少有一个空白区域。</li><li>有两个相邻的图块具有相同的值。</li></ul><p>例如，对于下面的板，我们应该返回 true，因为至少有一个空白区域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|   2|    |   2|    |</span><br><span class="line">|   4|   4|   2|   2|</span><br><span class="line">|    |   4|    |    |</span><br><span class="line">|   2|   4|   4|   8|</span><br></pre></td></tr></table></figure><p>对于下面的板子，我们应该返回 false。无论你在 2048 年按下什么按钮，都不会发生任何事情，即没有两个相邻的瓷砖具有相等的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|   2|   4|   2|   4|</span><br><span class="line">|  16|   2|   4|   2|</span><br><span class="line">|   2|   4|   2|   4|</span><br><span class="line">|   4|   2|   4|   2|</span><br></pre></td></tr></table></figure><p>对于下面的棋盘，我们将返回 true，因为向右或向左移动将合并两个 64 个图块，并且向上或向下移动将合并 32 个图块。或者换句话说，至少存在两个值相等的相邻图块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|   2|   4|  64|  64|</span><br><span class="line">|  16|   2|   4|   8|</span><br><span class="line">|   2|   4|   2|  32|</span><br><span class="line">|   4|   2|   4|  32|</span><br></pre></td></tr></table></figure><h2 id="public-boolean-tilt-Side-side"><a href="#public-boolean-tilt-Side-side" class="headerlink" title="public boolean tilt(Side side)"></a><code>public boolean tilt(Side side)</code></h2><p>倾斜方法的工作是实际移动所有瓷砖。如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|   2|    |   2|    |</span><br><span class="line">|   4|   4|   2|   2|</span><br><span class="line">|    |   4|    |    |</span><br><span class="line">|   2|   4|   4|   8|</span><br></pre></td></tr></table></figure><p>然后按 up，将修改 <code>board</code> 实例变量， <code>tilt</code> 使游戏的状态现在为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|   2|   8|   4|   2|</span><br><span class="line">|   4|   4|   4|   8|</span><br><span class="line">|   2|    |    |    |</span><br><span class="line">|    |    |    |    |</span><br></pre></td></tr></table></figure><p>除了修改板之外，还必须发生另外两件事：</p><ol><li>必须更新评分实例变量，以反映所有图块合并的总值（如果有）。在上面的例子中，我们将两个 4 合并成一个 8，将两个 2 合并成一个 4，因此分数应该增加 8 + 4 &#x3D; 12。</li><li>如果板发生任何变化，我们必须将 <code>changed</code> 局部变量设置为 <code>true</code> 。这是因为在 的 <code>tilt</code> 框架代码的末尾，您可以看到我们调用了一个 <code>setChanged()</code> 方法：这通知 GUI 有一些东西要绘制。您不会对自己 <code>setChanged</code> 进行任何调用：只需修改 <code>changed</code> 局部变量。</li></ol><p>示例：</p><p><img src="/2024/01/18/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-1-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj0/image-20240118213830819.png" alt="image-20240118213830819"></p><p><img src="/2024/01/18/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-1-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj0/image-20240118213851546.png" alt="image-20240118213851546"></p><p><img src="/2024/01/18/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-1-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj0/image-20240118214110920.png" alt="image-20240118214110920"></p><p><img src="/2024/01/18/JAVA-CS61B-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-1-CS61B%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Proj0/image-20240118214147334.png" alt="image-20240118214147334"></p><h2 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h2><ul><li>我们可以只专注于一个方向的实现，然后通过数组的旋转来实现多方向的实现。</li><li>由上图可知，我们最好从每列顶部开始遍历，这样才能符合游戏逻辑</li></ul><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tilt</span><span class="params">(Side side)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> changed;</span><br><span class="line">        changed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Modify this.board (and perhaps this.score) to account</span></span><br><span class="line">        <span class="comment">// for the tilt to the Side SIDE. If the board changed, set the</span></span><br><span class="line">        <span class="comment">// changed local variable to true.</span></span><br><span class="line">        board.setViewingPerspective(side);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; board.size(); c++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> board.size()-<span class="number">1</span>; r &gt;= <span class="number">0</span>; r--)&#123;</span><br><span class="line">                <span class="type">Tile</span> <span class="variable">t</span> <span class="operator">=</span> board.tile(c, r);</span><br><span class="line">                <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> r;</span><br><span class="line">                <span class="keyword">if</span>(board.tile(c, r) != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> board.size()-<span class="number">1</span>; i &gt; r; i--)&#123;</span><br><span class="line">                        <span class="keyword">if</span> (board.tile(c, i) == <span class="literal">null</span>) &#123;</span><br><span class="line">                            board.move(c, i, t);</span><br><span class="line">                            row = i;</span><br><span class="line">                            changed = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row -<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(board.tile(c, i)!=<span class="literal">null</span> &amp;&amp; t.value() != board.tile(c, i).value()) <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(board.tile(c, i)!=<span class="literal">null</span> &amp;&amp; t.value() == board.tile(c, i).value())&#123;</span><br><span class="line">                            board.move(c, row, board.tile(c, i));</span><br><span class="line">                            changed = <span class="literal">true</span>;</span><br><span class="line">                            score += board.tile(c, row).value();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        board.setViewingPerspective(Side.NORTH);</span><br><span class="line">        checkGameOver();</span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">            setChanged();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(二)--Reading.1.Introducing</title>
      <link href="/2024/01/18/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reading-1-Introducion-to-Java/"/>
      <url>/2024/01/18/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reading-1-Introducion-to-Java/</url>
      
        <content type="html"><![CDATA[<p><a href="https://joshhug.gitbooks.io/hug61b/content/chap1/chap11.html">1.1 要点 ·拥抱61B — 1.1 Essentials · Hug61B (gitbooks.io)</a></p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>System.out.println(&quot;Hello world!&quot;);</code>相当于与c++中的<code>cout&lt;&lt;&quot;Hello world!&quot;&lt;&lt;endl;</code></p><p><code>System.out.print(&quot;Hello world!&quot;);</code>相当于与c++中的<code>cout&lt;&lt;&quot;Hello world!&quot;;</code></p></blockquote><p>对于那些来自像 Python 这样的语言的人来说，这似乎毫无必要地冗长。然而，这一切都是有充分理由的，我们将在接下来的几周内理解这一点。需要注意的一些关键语法特征：</p><ul><li>该程序由一个类声明组成，该声明使用关键字 <code>public class</code> 声明。在 Java 中，所有代码都位于类中。</li><li>运行的代码位于名为 <code>main</code> 的方法中，该方法声明为 <code>public static void main(String[] args)</code> 。</li><li>我们使用大括号 <code>&#123;</code> 和来表示一段代码的开头和 <code>&#125;</code> 结尾。</li><li>语句必须以分号结尾。</li></ul><h2 id="运行-Java-程序"><a href="#运行-Java-程序" class="headerlink" title="运行 Java 程序"></a>运行 Java 程序</h2><p>执行 Java 程序的最常见方法是通过两个程序的序列运行它。第一种是 Java 编译器，或 <code>javac</code> .第二个是 Java 解释器，或 <code>java</code> .</p><p>![image-20240118035144027](2-CS61B学习笔记-Reading.1.Introducion to Java&#x2F;image-20240118035144027.png)</p><p>例如，要运行 <code>HelloWorld.java</code> ，我们会在终端中键入命令，然后键入命令 <code>javac HelloWorld.java</code> <code>java HelloWorld</code> 。结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ javac HelloWorld.java</span><br><span class="line">$ java HelloWorld</span><br><span class="line">Hello World! </span><br></pre></td></tr></table></figure><blockquote><p>在上图中，$ 表示我们终端的命令提示符。</p></blockquote><p>您可能会注意到，我们在编译时包含“.java”，但在解释时不包括“.class”。这就是它的方式（TIJTWII）。</p><h2 id="代码样式、注释、Javadoc"><a href="#代码样式、注释、Javadoc" class="headerlink" title="代码样式、注释、Javadoc"></a>代码样式、注释、Javadoc</h2><p>代码在很多方面都很漂亮。它可以很简洁。它可以很聪明。它可以是有效的。新手最不被重视的代码方面之一是代码风格。当你作为一个新手编程时，你往往一心一意地让它工作，而不考虑再看一遍或不得不长时间维护它。</p><p>在本课程中，我们将努力保持代码的可读性。良好的编码风格的一些最重要的特征是：</p><ul><li>一致的样式（间距、变量命名、大括号样式等）</li><li>大小（行不要太宽，源文件不要太长）</li><li>描述性命名（变量、函数、类），例如名称为 <code>year</code> or 而不是 <code>x</code> or <code>f</code> <code>getUserName</code> 的变量或函数。</li><li>避免重复代码：除了一些更改外，几乎不应该有两个几乎相同的重要代码块。</li><li>酌情注释。Java 中的行注释使用 <code>//</code> 分隔符。阻止（又名多行注释）注释 use <code>/*</code> 和 <code>*/</code> .</li></ul><p>黄金法则是：编写代码，以便陌生人易于理解。</p><p><a href="https://sp19.datastructur.es/materials/guides/style-guide.html">Style Guide | CS 61B Spring 2019 (datastructur.es)</a>这是该课程的官方风格指南。值得一看！</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>所有方法和几乎所有类都应该使用所谓的 Javadoc 格式在注释中进行描述。在 Javadoc 注释中<a href="https://en.wikipedia.org/wiki/Javadoc">Javadoc - 维基百科，自由的百科全书 — Javadoc - Wikipedia</a>，块注释以额外的星号开头，例如 <code>/**</code> ，并且注释通常（但并非总是）包含描述性标记。我们不会在本教科书中讨论这些标签，但请参阅上面的链接以了解它们的工作原理。</p><p>需要特别注意的是，所有方法和几乎所有类都应该使用所谓的 Javadoc 格式在注释中进行描述。在 Javadoc 注释中，块注释以额外的星号开头，例如 <code>/**</code> ，并且注释通常（但并非总是）包含描述性标记。我们不会在本教科书中讨论这些标签，但请参阅上面的链接以了解它们的工作原理。</p><p>举个没有标签的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LargerDemo</span> &#123;</span><br><span class="line">    <span class="comment">/** Returns the larger of x and y. */</span>           </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">larger</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(larger(<span class="number">8</span>, <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>广泛使用的 javadoc 工具<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javadoc.html">javadoc (oracle.com)</a>可用于生成代码的 HTML 描述。</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="定义和使用类"><a href="#定义和使用类" class="headerlink" title="定义和使用类"></a>定义和使用类</h2><p>Java 中的所有代码都必须是类的一部分（或类似于类的东西，我们将在后面学习）。大多数代码都是在方法内部编写的。让我们考虑一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">makeNoise</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bark!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们尝试运行该 <code>Dog</code> 类，我们只会收到一条错误消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ java Dog</span><br><span class="line">Error: Main method not found in <span class="keyword">class</span> <span class="title class_">Dog</span>, please define the main method as:</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br></pre></td></tr></table></figure><p>我们定义的 <code>Dog</code> 类不执行任何操作。我们只是定义了一些 <code>Dog</code> 可以做的事情，即制造噪音。要实际运行该类，我们需要向 <code>Dog</code> 该类添加一个 main 方法，正如我们在第 1.1 章中看到的那样。或者我们可以创建一个单独的 <code>DogLauncher</code> 类来运行该 <code>Dog</code> 类的方法。例如，考虑以下程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogLauncher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Dog.makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java DogLauncher</span><br><span class="line">Bark!</span><br></pre></td></tr></table></figure><p>使用另一个类的类有时称为该类的“客户端”，即 <code>DogLauncher</code> 是 <code>Dog</code> 的客户端。这两种技术都不是更好的：在某些情况下，添加 main 方法可能更好，而在其他情况下创建类似 client 类 <code>Dog</code> <code>DogLauncher</code> 可能更好。随着我们在整个课程中获得额外的练习，每种方法的相对优势将变得清晰。</p><p>因此总结下:</p><ul><li>类的使用有两种方法:<ul><li>一种是带有main方法的类</li><li>一种是只有方法，由另一个类来调用。</li></ul></li></ul><h2 id="静态方法-vs-非静态方法"><a href="#静态方法-vs-非静态方法" class="headerlink" title="静态方法 vs 非静态方法"></a>静态方法 vs 非静态方法</h2><p>同<code>cpp</code>的知识点，静态方法属于类，非静态方法属于对象(实例)。调用静态方法时，通常用<code>类名.方法</code>,调用非静态方法时通常用<code>对象名.方法</code>。</p><p>对比上下两个<code>Dog</code>类的<code>makeNoise</code>方法可以发现，在加上条件判断语句前为静态方法，加上后变为非静态方法，说明是不同体重对象的方法。</p><p>详细下面有说</p><h2 id="实例变量和对象实例化"><a href="#实例变量和对象实例化" class="headerlink" title="实例变量和对象实例化"></a>实例变量和对象实例化</h2><p>并非所有的狗都是一样的。有些狗喜欢不停地吠叫，而另一些狗则发出铿锵有力的咆哮，给所有听到它们光荣呼唤的人带来欢乐。通常，我们编写程序来模仿我们居住的宇宙的特征，而 Java 的语法很容易允许这种模仿。</p><p>允许我们表示 Dogdom 光谱的一种方法是为每种类型的 Dog 创建单独的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TinyDog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">makeNoise</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yip yip yip yip&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MalamuteDog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">makeNoise</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;arooooooooooooooo!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如您过去应该看到的，类可以实例化，实例可以保存数据。这导致了一种更自然的方法，我们创建 <code>Dog</code> 类的实例，并使 <code>Dog</code> 方法的行为取决于特定 <code>Dog</code> .为了更具体地说明这一点，请考虑以下类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weightInPounds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeNoise</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (weightInPounds &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yipyipyip!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (weightInPounds &lt; <span class="number">30</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;bark. bark.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;woof!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为使用这种狗的例子，请考虑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogLauncher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Dog d;</span><br><span class="line">        d = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        d.weightInPounds = <span class="number">20</span>;</span><br><span class="line">        d.makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些关键观察结果和术语：</p><ul><li>Java 中的 <code>Object</code> 是任何类的实例。</li><li>该 <code>Dog</code> 类有自己的变量，也称为实例变量或非静态变量。这些必须在类中声明，这与 Python 或 Matlab 等语言不同，后者可以在运行时添加新变量。</li><li>我们在 <code>Dog</code> 类中创建的方法没有关键字 <code>static</code> 。我们将此类方法称为实例方法或非静态方法。</li><li>要调用该 <code>makeNoise</code> 方法，我们必须首先使用 <code>new</code> 关键字实例化 a <code>Dog</code> ，然后制作特定的 <code>Dog</code> bark。换句话说，我们调用 <code>d.makeNoise()</code> 了 <code>Dog.makeNoise()</code> .</li><li>一旦一个对象被实例化，就可以将其分配给适当类型的声明变量，例如 <code>d = new Dog();</code></li><li>类的变量和方法也称为类的成员。</li><li>使用点表示法访问类的成员。</li></ul><h2 id="类方法与实例方法"><a href="#类方法与实例方法" class="headerlink" title="类方法与实例方法"></a>类方法与实例方法</h2><p>Java 允许我们定义两种类型的方法：</p><ul><li>类方法，又名静态方法。</li><li>实例方法，又名非静态方法。</li></ul><p>实例方法是只能由类的特定实例执行的操作。静态方法是由类本身执行的操作。两者在不同情况下都很有用。作为静态方法的示例，该 <code>Math</code> 类提供了一个 <code>sqrt</code> 方法。因为它是静态的，我们可以这样称呼它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = Math.sqrt(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>如果 <code>sqrt</code> 是一个实例方法，我们将得到下面笨拙的语法。幸运的是，它是一种 <code>sqrt</code> 静态方法，因此我们不必在实际程序中执行此操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Math</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Math</span>();</span><br><span class="line">x = m.sqrt(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>有时，拥有一个同时具有实例和静态方法的类是有意义的。例如，假设想要比较两只狗的能力。一种方法是添加一个用于比较 Dogs 的静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">15</span>);</span><br><span class="line"><span class="type">Dog</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">100</span>);</span><br><span class="line">Dog.maxDog(d, d2);</span><br></pre></td></tr></table></figure><p>请注意，我们已使用类名调用，因为此方法是静态方法。</p><p>我们也可以 <code>maxDog</code> 实现为非静态方法，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Dog <span class="title function_">maxDog</span><span class="params">(Dog d2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.weightInPounds &gt; d2.weightInPounds) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面，我们使用关键字 <code>this</code> 来指代当前对象。例如，可以使用以下方法调用此方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">15</span>);</span><br><span class="line"><span class="type">Dog</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">100</span>);</span><br><span class="line">d.maxDog(d2);</span><br></pre></td></tr></table></figure><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p>类具有静态变量有时很有用。这些是类本身固有的属性，而不是实例的属性。例如，我们可以记录狗的学名（或双子）是<code>Canis familiaris</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weightInPounds;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">binomen</span> <span class="operator">=</span> <span class="string">&quot;Canis familiaris&quot;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态变量应该使用类的名称而不是特定的实例来访问，例如，您应该使用 <code>Dog.binomen</code> ，而不是 <code>d.binomen</code> .</p><p>虽然 Java 在技术上允许你使用实例名称访问静态变量，但它的风格很糟糕，令人困惑，而且在我看来是 Java 设计者的错误。(不是我的评价)</p><h2 id="Java的构造函数"><a href="#Java的构造函数" class="headerlink" title="Java的构造函数"></a>Java的构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weightInPounds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> w)</span> &#123;</span><br><span class="line">        weightInPounds = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeNoise</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (weightInPounds &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yipyipyip!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (weightInPounds &lt; <span class="number">30</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;bark. bark.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;woof!&quot;</span>);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当我们尝试 <code>Dog</code> 创建 using <code>new</code> 关键字和单个整数参数时，都会调用带有签名 <code>public Dog(int w)</code> 的构造函数。对于那些来自 Python 的人来说，构造函数与 <code>__init__</code> 方法非常相似。</p><h2 id="数组实例化，对象数组"><a href="#数组实例化，对象数组" class="headerlink" title="数组实例化，对象数组"></a>数组实例化，对象数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/* Create an array of two dogs. */</span></span><br><span class="line">        Dog[] dogs = <span class="keyword">new</span> <span class="title class_">Dog</span>[<span class="number">2</span>];</span><br><span class="line">        dogs[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">8</span>);</span><br><span class="line">        dogs[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Yipping will result, since dogs[0] has weight 8. */</span></span><br><span class="line">        dogs[<span class="number">0</span>].makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，new 以两种不同的方式使用：一次用于创建一个可以容纳两个 <code>Dog</code> 对象的数组，两次用于创建每个实际 <code>Dog</code> 的 .</p><h3 id="public-static-void-main-String-args-的说明"><a href="#public-static-void-main-String-args-的说明" class="headerlink" title="public static void main(String[] args)的说明"></a>public static void main(String[] args)的说明</h3><p>根据我们目前所学到的知识，是时候揭开我们一直用于 main 方法的声明的神秘面纱了。把它分成几块，我们有：</p><ul><li><code>public</code> ：到目前为止，我们所有的方法都以这个关键字开头。</li><li>static&#96; ：它是一个静态方法，不与任何特定实例关联。</li><li><code>void</code> ：它没有返回类型。</li><li><code>main</code> ：这是方法的名称。</li><li><code>String[] args</code> ：这是传递给 main 方法的参数。</li></ul><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>由于 main 是由 Java 解释器本身调用的，而不是由另一个 Java 类调用的，因此解释器的工作是提供这些参数。它们通常引用命令行参数。例如，考虑以下程序 <code>ArgsDemo</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序打印出第 0 个命令行参数，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java ArgsDemo these are command line arguments</span><br><span class="line">these</span><br></pre></td></tr></table></figure><p>在上面的示例中，将是一个字符串数组， <code>args</code> 其中条目为 {“these”， “are”， “command”， “line”， “arguments”}。</p><blockquote><p>这样子可以识别命名 -m -v 等</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习笔记(一)--JAVA快速入门</title>
      <link href="/2024/01/16/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JAVA%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2024/01/16/JAVA-CS61B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JAVA%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cscircles.cemc.uwaterloo.ca/java_visualize/#">Java Visualizer (uwaterloo.ca)</a>类python tutor，可视化代码网站。</p><h1 id="基本程序"><a href="#基本程序" class="headerlink" title="基本程序"></a>基本程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassNameHere</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      x = x + <span class="number">1</span>;</span><br><span class="line">      System.out.println(x);</span><br><span class="line">      <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;</span><br><span class="line">      x = x + <span class="number">1</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;x is: &quot;</span> + x);</span><br><span class="line">      System.out.println(<span class="string">&quot;y is: &quot;</span> + y);      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JAVA是以类为单位的静态语言，不可或缺<strong>文件名命名的类</strong>以及<strong>main函数</strong>,语法类似cpp,结尾需要分号<code>;</code>。</p><blockquote><p>在Java中，如果一个类是public并且包含了main方法，则文件名必须与public类的名称相匹配。这是因为Java要求public类的名称与包含它的文件的名称相同。如果一个Java文件包含多个类，只能有一个类是public，并且文件名必须与public类的名称相匹配。</p></blockquote><h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassNameHere</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">10</span>)</span><br><span class="line">            x = x + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">10</span>)</span><br><span class="line">            x = x + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">dogSize</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (dogSize &gt;= <span class="number">50</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;woof!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dogSize &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;bark!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;yip!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同cpp</p><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">bottles</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line"><span class="keyword">while</span> (bottles &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(bottles + <span class="string">&quot; bottles of beer on the wall.&quot;</span>);</span><br><span class="line">    bottles = bottles - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同cpp</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassNameHere</span> &#123;</span><br><span class="line">    <span class="comment">/** Uses a basic for loop to sum a. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i = i + <span class="number">1</span>) &#123;</span><br><span class="line">        sum = sum + a[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同cpp</p><h2 id="增强的For循环"><a href="#增强的For循环" class="headerlink" title="增强的For循环"></a>增强的For循环</h2><p>Java 还支持使用“增强的 for 循环”通过数组进行迭代。基本思想是，在许多情况下，我们实际上根本不关心指数。在这种情况下，我们避免使用涉及冒号的特殊语法创建索引变量。</p><p>例如，在下面的代码中，我们执行与 <code>BreakDemo</code> 上述完全相同的操作。但是，在这种情况下，我们不会 创建索引 <code>i</code> .取而代之的是，从 <code>a[0]</code> ， <code>String</code> <code>s</code> 一直 <code>String</code> <code>a</code> 到 <code>a[a.length - 1]</code> 。您可以在此链接中试用此代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnhancedForBreakDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] a = &#123;<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;laser horse&quot;</span>, <span class="string">&quot;ketchup&quot;</span>, <span class="string">&quot;horse&quot;</span>, <span class="string">&quot;horbse&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : a) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j += <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                <span class="keyword">if</span> (s.contains(<span class="string">&quot;horse&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(max(<span class="number">10</span>, <span class="number">15</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 中的函数与变量一样，具有特定的返回类型。该 <code>max</code> 函数的返回类型 <code>int</code> 为 （由函数名称前的单词“int”表示）。Java 中的函数也被称为方法，所以我将从这一刻开始永远这样称呼它们。</p><p>我们将整个字符串 <code>public static int max(int x, int y)</code> 称为方法的签名，因为它列出了参数、返回类型、名称和任何修饰符。在这里，我们的修饰符是 <code>public</code> 和 <code>static</code> ，尽管我们几天内不会了解这些修饰符的含义。</p><p>CPP</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> iostream</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> x, iny)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;(<span class="built_in">max</span>(<span class="number">10</span>, <span class="number">15</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y):</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(<span class="number">5</span>, <span class="number">15</span>))</span><br></pre></td></tr></table></figure><p>MATLAB</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m</span> = <span class="title">max</span><span class="params">(x, y)</span></span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">        m = x</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        m = y</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">max</span>(<span class="number">5</span>, <span class="number">15</span>))</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">numbers[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">numbers[<span class="number">1</span>] = <span class="number">7</span>;</span><br><span class="line">numbers[<span class="number">2</span>] = <span class="number">10</span>;</span><br><span class="line">System.out.println(numbers[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>Or</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>&#125;;</span><br><span class="line">System.out.println(numbers[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><blockquote><p>您可以使用 <code>.length</code> 以下代码获取数组的长度 <code>3</code> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61B </category>
          
          <category> CS61B </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP—面对对象</title>
      <link href="/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP—基础语法</title>
      <link href="/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数组之前的知识是基础中的基础就不再整理了,只挑几个稍微要看一下的。</p><h1 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h1><p>基本语法例子示范</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> day = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Monday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Tuesday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Wednesday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thursday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Friday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Weekend&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果为 Wednesday；</p></blockquote><p>如果case语句中没有break;那么将执行该case下的所有语句:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> day = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Monday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 没有break，继续执行下一个case</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Tuesday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 没有break，继续执行下一个case</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Wednesday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 没有break，继续执行下一个case</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thursday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 没有break，继续执行下一个case</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Friday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 没有break，继续执行下一个case</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Weekend&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Wednesday</span><br><span class="line">Thursday</span><br><span class="line">Friday</span><br><span class="line">Weekend</span><br></pre></td></tr></table></figure></blockquote><p>其他需要注意的点:</p><ul><li><p>switch后圆括号中的表达式的类型只能是整型或能够隐式转换为整型的类型(如字符型,或枚举型)</p></li><li><p>每个case语句后必须是与表达式类型兼容的一个常量(但不能是<strong>字符串常量</strong>)</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> grade = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:  <span class="comment">// 字符常量，与表达式类型兼容</span></span><br><span class="line">            <span class="comment">// 代码块</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:    <span class="comment">// 整数常量，与表达式类型兼容</span></span><br><span class="line">            <span class="comment">// 代码块</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2.5</span>:  <span class="comment">// 错误，浮点数常量与字符类型不兼容</span></span><br><span class="line">            <span class="comment">// 代码块</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:  <span class="comment">// 错误，字符串常量不兼容</span></span><br><span class="line">            <span class="comment">// 代码块</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h1><p>基本语法例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (count &lt; <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意while后面有<strong>分号;</strong></li></ul><h1 id="字符串数组常用函数"><a href="#字符串数组常用函数" class="headerlink" title="字符串数组常用函数"></a>字符串数组常用函数</h1><h2 id="strcat-字符串连接函数"><a href="#strcat-字符串连接函数" class="headerlink" title="strcat-字符串连接函数"></a>strcat-字符串连接函数</h2><h3 id="函数原形"><a href="#函数原形" class="headerlink" title="函数原形:"></a>函数原形:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcat</span><span class="params">(<span class="type">char</span> str1[],<span class="type">const</span> <span class="type">char</span> str2[])</span></span>;</span><br></pre></td></tr></table></figure><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>把str2中的字符串连接到str1字符的后面, str1中字符的结束标志<code>\0</code>被st2里的字符串及其结束标志所覆盖。本函数返回值是str1的首地址。</p><p><img src="/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-20231220200644095.png" alt="image-20231220200644095"></p><h2 id="strcpy-字符串复制函数"><a href="#strcpy-字符串复制函数" class="headerlink" title="strcpy-字符串复制函数"></a>strcpy-字符串复制函数</h2><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcat</span><span class="params">(<span class="type">char</span> str1[],<span class="type">const</span> <span class="type">char</span> str2[])</span></span>;</span><br></pre></td></tr></table></figure><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>把str2中的字符串复制到str1中，str2中的串结束标志”\0”也一同复制。参数str2还可以是一个字符串常量，这时相当于把一个字符串赋予一个字符数组。</p><p><img src="/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-20231220200904869.png" alt="image-20231220200904869"></p><h2 id="strcmp-字符串比较函数"><a href="#strcmp-字符串比较函数" class="headerlink" title="strcmp-字符串比较函数"></a>strcmp-字符串比较函数</h2><h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> str1[],<span class="type">const</span> <span class="type">char</span> str2[])</span></span>;</span><br></pre></td></tr></table></figure><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>依照ASCII码表中的值的大小，依次比较两个字符串中对应位置上的字符，并由函数返回值返回比较结果。</p><p><img src="/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-20231220201312707.png" alt="image-20231220201312707"></p><h2 id="strlen-计算字符串长度函数"><a href="#strlen-计算字符串长度函数" class="headerlink" title="strlen-计算字符串长度函数"></a>strlen-计算字符串长度函数</h2><h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> str[])</span></span>;</span><br></pre></td></tr></table></figure><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><p>计算字符串中的长度,返回首次出现的结束标志<code>\0</code>之前的字符数,并作为返回值。</p><blockquote><p>计算时不包括\0</p></blockquote><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="指针的定义与声明"><a href="#指针的定义与声明" class="headerlink" title="指针的定义与声明"></a>指针的定义与声明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr;  <span class="comment">// 定义一个指向整数的指针</span></span><br><span class="line"><span class="type">double</span> *dblPtr;  <span class="comment">// 定义一个指向双精度浮点数的指针</span></span><br><span class="line"><span class="type">char</span> *charPtr;  <span class="comment">// 定义一个指向字符的指针</span></span><br></pre></td></tr></table></figure><h2 id="取地址操作符"><a href="#取地址操作符" class="headerlink" title="取地址操作符&amp;"></a>取地址操作符<code>&amp;</code></h2><p>取地址操作符 <code>&amp;</code> 用于获取变量的内存地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;number;  <span class="comment">// 将变量number的地址赋给指针ptr</span></span><br></pre></td></tr></table></figure><h2 id="指针和函数"><a href="#指针和函数" class="headerlink" title="指针和函数:"></a>指针和函数:</h2><p>指针可以用于传递地址，从而在函数中修改实际参数的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyValue</span><span class="params">(<span class="type">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">    *ptr = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span> *ptr = &amp;number;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">modifyValue</span>(ptr);  <span class="comment">// 传递指向number的指针给函数</span></span><br><span class="line">    <span class="comment">// 现在，number的值被修改为100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针解引用操作符"><a href="#指针解引用操作符" class="headerlink" title="指针解引用操作符 *"></a>指针解引用操作符 <code>*</code></h2><p>指针解引用操作符 <code>*</code> 用于访问指针所指向地址的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = *ptr;  <span class="comment">// 获取ptr指针所指向地址的值，将其赋给变量value</span></span><br></pre></td></tr></table></figure><h2 id="动态内存分配与释放"><a href="#动态内存分配与释放" class="headerlink" title="动态内存分配与释放:"></a>动态内存分配与释放:</h2><p>使用 <code>new</code> 操作符可以在运行时动态分配内存，而 <code>delete</code> 操作符用于释放动态分配的内存：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *dynamicPtr = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">// 动态分配一个整数大小的内存空间</span></span><br><span class="line"><span class="comment">// 使用 dynamicPtr 操作内存</span></span><br><span class="line"><span class="keyword">delete</span> dynamicPtr;  <span class="comment">// 释放动态分配的内存</span></span><br></pre></td></tr></table></figure><h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><p>指针和数组之间有着密切的关系，指针可以用于访问数组元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *arrPtr = numbers;  <span class="comment">// 将数组名赋给指针，指向数组的第一个元素</span></span><br></pre></td></tr></table></figure><h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p>空指针表示不指向任何有效的内存地址。在C++中，可以使用 <code>nullptr</code> 来表示空指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *nullPtr = <span class="literal">nullptr</span>;  <span class="comment">// 定义一个空指针</span></span><br></pre></td></tr></table></figure><h2 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h2><ul><li><p>常量指针：指针本身不可变，但指向的值可变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr = &amp;value;  <span class="comment">// 指向常量的指针</span></span><br></pre></td></tr></table></figure></li><li><p>指针常量：指向的值不可变，但指针本身可变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> ptr = &amp;value;  <span class="comment">// 常量指针</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表的创建"><a href="#链表的创建" class="headerlink" title="链表的创建"></a>链表的创建</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Set a, b;</span><br><span class="line"><span class="built_in">init</span>(&amp;a);</span><br><span class="line"><span class="built_in">init</span>(&amp;b);</span><br><span class="line"><span class="built_in">createSet</span>(&amp;a);</span><br><span class="line"><span class="built_in">createSet</span>(&amp;b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n, k, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k &gt;&gt; m;</span><br><span class="line">List lst;</span><br><span class="line"><span class="built_in">createList</span>(lst, n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向前插入生成"><a href="#向前插入生成" class="headerlink" title="向前插入生成"></a>向前插入生成</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Set</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">Node* head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(Set* x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">x-&gt;num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createSet</span><span class="params">(Set* x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//生成链表时一定采用往前插入的方法，即每个新产生的结点插入到链表的第一个结点的前面。</span></span><br><span class="line"><span class="type">int</span> n, i;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">Node* node = <span class="keyword">new</span> Node;</span><br><span class="line">cin &gt;&gt; node-&gt;data;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">x-&gt;head = node;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">Node* node = <span class="keyword">new</span> Node;</span><br><span class="line">cin &gt;&gt; node -&gt; data;</span><br><span class="line">node -&gt; next = x-&gt;head;</span><br><span class="line">x-&gt;head = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="向后插入"><a href="#向后插入" class="headerlink" title="向后插入"></a>向后插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span> &#123;</span><br><span class="line"></span><br><span class="line">Node* head;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createList</span><span class="params">(List&amp; lst, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">//生成链表时采用往后插入的方法，即每个新结点插入到链表尾部。</span></span><br><span class="line">lst.length = n;</span><br><span class="line">Node* _head = <span class="keyword">new</span> Node;</span><br><span class="line">_head-&gt;data = <span class="number">1</span>;</span><br><span class="line">lst.head = _head;</span><br><span class="line">Node* tail = _head;</span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (i; i &lt;= n; i++) &#123;</span><br><span class="line">Node* node = <span class="keyword">new</span> Node;</span><br><span class="line">node-&gt;data = i;</span><br><span class="line">tail-&gt;next = node;</span><br><span class="line">tail = tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h1><h2 id="漂亮的递归"><a href="#漂亮的递归" class="headerlink" title="漂亮的递归"></a>漂亮的递归</h2><p>【问题描述】键盘输入正整数 n，求出n与其反序数x之和并输出。例如，输入2038，n+x &#x3D; 2038 +8302 &#x3D;10340，输出应为10340。要求：编写函数实现数据转换成反序数值。【输入形式】输入一个整数； 【输出形式】输出一个整数； 【样例输入】2038 【样例输出】10340 【样例说明】不要任何输入输出的文字提示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> store = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">10</span>) <span class="keyword">return</span> store + n;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">store += n % <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reverse</span>(n / <span class="number">10</span>, store * <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n, reverse_num;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line">reverse_num = <span class="built_in">reverse</span>(n);</span><br><span class="line">std::cout &lt;&lt; n + reverse_num;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>写递归最关键的地方在于<strong>基本条件</strong>，基本条件出来了，递归的转折点也就出来了。</p></blockquote><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的旋转"><a href="#数组的旋转" class="headerlink" title="数组的旋转"></a>数组的旋转</h3><p><strong>【问题描述】</strong> 旋转是图像处理的基本操作，在这个问题中，你需要将一个图像逆时针旋转90度。 计算机中的图像表示可以用一个矩阵来表示，为了旋转一个图像，只需要将对应的矩阵旋转即可。 <strong>【输入格式】</strong> 输入的第一行包含两个整数n, m（1≤n, m≤10），分别表示图像矩阵的行数和列数。 接下来n行每行包含m个整数，表示输入的图像。 </p><p><strong>【输出格式】</strong> 输出m行，每行包含n个整数，表示原始矩阵逆时针旋转90度后的矩阵。每行后空格结束。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【样例输入】</span><br><span class="line">        2 3</span><br><span class="line">        1 5 3</span><br><span class="line">        3 2 4</span><br><span class="line">【样例输出】</span><br><span class="line">        3 4 </span><br><span class="line">        5 2 </span><br><span class="line">        1 3 </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> ls[<span class="number">10</span>][<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> ls2[<span class="number">10</span>][<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//初始化ls数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; ls[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数组旋转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            ls2[i][j] = ls[j][m - i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出旋转后的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cout &lt;&lt; ls2[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>也可以动态开辟:</p><p>&#x2F;&#x2F; 使用new运算符分配内存<br>int** ls &#x3D; new int* [n];<br>for (int i &#x3D; 0; i &lt; n; ++i) {<br>    ls[i] &#x3D; new int[m];<br>}<br>for (int i &#x3D; 0; i &lt; n; i++) {<br>    for (int j &#x3D; 0; j &lt; m; j++) {<br>        cin &gt;&gt; ls[i][j];<br>    }<br>}</p></blockquote><h3 id="求二维数组的鞍点"><a href="#求二维数组的鞍点" class="headerlink" title="求二维数组的鞍点"></a>求二维数组的鞍点</h3><p>【问题描述】找出一个二维数组（以三行四列的数组为例）中的鞍点，即该位置上的元素在该行上值最大，在该列上值最小（也可能没有鞍点）。</p><p>【输入形式】二维数组（以三行四列的数组为例）</p><p>【输出形式】如果有鞍点，输出鞍点的值及所在行列（例如[1][2]&#x3D;96 is Saddle Point），如果没有，输出没有鞍点（例如 No Saddle Point）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【样例输入】 </span><br><span class="line">  9 80 205 40</span><br><span class="line">  90 60 96 1</span><br><span class="line">  210 3 101 89</span><br><span class="line">【样例输出】</span><br><span class="line">  [1][2]=96 is Saddle Point</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ls[<span class="number">3</span>][<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> min = <span class="number">999</span>, max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">cin &gt;&gt; ls[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (ls[i][j] &gt; max) &#123;</span><br><span class="line">max = ls[i][j];</span><br><span class="line">col = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (ls[j][col] &lt; min) &#123;</span><br><span class="line">min = ls[j][col];</span><br><span class="line">row = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ls[row][col] == max) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">max = <span class="number">0</span>;</span><br><span class="line">min = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (min == max) cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; row &lt;&lt; <span class="string">&#x27;]&#x27;</span> &lt;&lt; <span class="string">&#x27;[&#x27;</span> &lt;&lt; col &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; min &lt;&lt; <span class="string">&quot; is Saddle Point&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;NO&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h3><p>【题目描述】<br>输入一个字符串（长度不超过255），请找出字符串中的所有的正整数（如-12，当作12），然后输出其中的素数。如果出现12.5，则看作12和5两个整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【样例输入】</span><br><span class="line"> How3.5many12prime-17number79inthestring.</span><br><span class="line">【样例输出】</span><br><span class="line"> 3 5 17 79</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; str.<span class="built_in">length</span>()) &#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (str[i] &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">num = num * <span class="number">10</span> + str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">is_prime</span>(num) &amp;&amp; num &gt; <span class="number">1</span>) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解计算机原理--第一章</title>
      <link href="/2023/12/14/%E8%AF%BB%E4%B8%80%E6%9C%AC%E5%A5%BD%E4%B9%A6-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-index/"/>
      <url>/2023/12/14/%E8%AF%BB%E4%B8%80%E6%9C%AC%E5%A5%BD%E4%B9%A6-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-index/</url>
      
        <content type="html"><![CDATA[<h1 id="二、信息的表示和表达"><a href="#二、信息的表示和表达" class="headerlink" title="二、信息的表示和表达"></a>二、信息的表示和表达</h1><h2 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h2><h3 id="2-1-1-十六进制表示法"><a href="#2-1-1-十六进制表示法" class="headerlink" title="2.1.1 十六进制表示法"></a>2.1.1 十六进制表示法</h3><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998390485614.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998390485614.png?x-oss-process=style/stylename</a>)</p><blockquote><p>转化为二进制需要从右到左每4分为一组转换(不足补0)</p></blockquote><h4 id="十进制和十六进制互选转换"><a href="#十进制和十六进制互选转换" class="headerlink" title="十进制和十六进制互选转换"></a>十进制和十六进制互选转换</h4><p>十进制除16倒取余<br>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998394198795.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998394198795.png?x-oss-process=style/stylename</a>)</p><h3 id="2-1-2-字数据大小"><a href="#2-1-2-字数据大小" class="headerlink" title="2.1.2 字数据大小"></a>2.1.2 字数据大小</h3><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998395609489.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998395609489.png?x-oss-process=style/stylename</a>)</p><blockquote><p>unsigned long、unsigned long int<br>都是同个意思</p></blockquote><h3 id="2-1-3-寻址和字节顺序"><a href="#2-1-3-寻址和字节顺序" class="headerlink" title="2.1.3 寻址和字节顺序"></a>2.1.3 寻址和字节顺序</h3><p>对于跨越多字节的程序对象，两个规则</p><ul><li>这个对象的地址是什么</li><li>字内存中如何排序这些字节</li></ul><h4 id="地址为所使用字节最小的地址"><a href="#地址为所使用字节最小的地址" class="headerlink" title="地址为所使用字节最小的地址"></a>地址为所使用字节最小的地址</h4><h4 id="排序方法有两个通用规则"><a href="#排序方法有两个通用规则" class="headerlink" title="排序方法有两个通用规则"></a>排序方法有两个通用规则</h4><ul><li>大端法:最高有效字节中最前面的方法</li><li>小端法:最低有效字节中最前面的方法<blockquote></blockquote>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998409476624.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998409476624.png?x-oss-process=style/stylename</a>)</li></ul><h3 id="2-1-4-表示字符串"><a href="#2-1-4-表示字符串" class="headerlink" title="2.1.4 表示字符串"></a>2.1.4 表示字符串</h3><p>字符串被编码为一个以null（值为0）字符结尾的字符数组，每个字符都由某个标准编码来表达，因此，文本数据比二进制数据具有更强的平台独立性</p><h3 id="2-1-5-表达代码"><a href="#2-1-5-表达代码" class="headerlink" title="2.1.5 表达代码"></a>2.1.5 表达代码</h3><p>不同机器类型使用不同的且不兼容的指令和编码方式，即使是完全一样的进程，运行中不同操作系统上也有不同的编码规则，因此二进制代码是不兼容的。</p><h3 id="2-1-6-布尔代数"><a href="#2-1-6-布尔代数" class="headerlink" title="2.1.6 布尔代数"></a>2.1.6 布尔代数</h3><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998567614189.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998567614189.png?x-oss-process=style/stylename</a>)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998568366125.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998568366125.png?x-oss-process=style/stylename</a>)</p><blockquote><p>布尔代数符合分配率<br>a&amp;(b|c) &#x3D; (a&amp;b)|(a&amp;c)<br>a|(b&amp;c) &#x3D; (a|b)&amp;(a|c)</p></blockquote><blockquote><p>布尔环<br>加分逆元(x+(-x) &#x3D; 0)<br>a^a &#x3D; 0<br>(a^b)^a &#x3D; b</p></blockquote><h3 id="2-1-7-位级运算"><a href="#2-1-7-位级运算" class="headerlink" title="2.1.7 位级运算"></a>2.1.7 位级运算</h3><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998569179935.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998569179935.png?x-oss-process=style/stylename</a>)</p><h4 id="掩码运算"><a href="#掩码运算" class="headerlink" title="掩码运算"></a>掩码运算</h4><p>掩码是一个位模式，表示一个字中选出的位的集合</p><blockquote><p>例子</p></blockquote><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998575552748.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998575552748.png?x-oss-process=style/stylename</a>)</p><h3 id="2-1-8-逻辑运算"><a href="#2-1-8-逻辑运算" class="headerlink" title="2.1.8 逻辑运算"></a>2.1.8 逻辑运算</h3><p>||、&amp;&amp;和！分别代表媒体逻辑中的OR、AND和NOT运算</p><h3 id="2-1-9移位运算"><a href="#2-1-9移位运算" class="headerlink" title="2.1.9移位运算"></a>2.1.9移位运算</h3><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998578307265.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998578307265.png?x-oss-process=style/stylename</a>)</p><ul><li>唯一例外是算术右移[10010101]的情况。<strong>因为操作数的最高位数1，填充的值就是1.</strong><blockquote><p>一般为算术右移<br>对于无符号数，右移必须是逻辑的<br>x&gt;&gt;j&gt;&gt;k等价于(x&lt;&lt;j)&lt;&lt;k<br>操作符的优先级中，加号的优先级比操作符的高</p></blockquote></li></ul><h2 id="2-2-整数表示"><a href="#2-2-整数表示" class="headerlink" title="2.2 整数表示"></a>2.2 整数表示</h2><p>编码整数的两种不同的方法：</p><ul><li>只能表示非负数</li><li>能够表示负数，0，正数</li></ul><blockquote><p>下文用到的数学术语</p></blockquote><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998582975352.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998582975352.png?x-oss-process=style/stylename</a>)</p><h3 id="2-2-1-整型数据类型"><a href="#2-2-1-整型数据类型" class="headerlink" title="2.2.1 整型数据类型"></a>2.2.1 整型数据类型</h3><h4 id="数据类型的典型取值范围"><a href="#数据类型的典型取值范围" class="headerlink" title="数据类型的典型取值范围"></a>数据类型的典型取值范围</h4><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998586485045.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998586485045.png?x-oss-process=style/stylename</a>)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998586665394.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998586665394.png?x-oss-process=style/stylename</a>)</p><blockquote><p>取值范围是不对称的——负数的范围比整数的范围大1</p></blockquote><blockquote><p>下表是C语言标准定义的每种数据类型必须能够表示的最小的取值范围。</p></blockquote><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998588029453.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998588029453.png?x-oss-process=style/stylename</a>)</p><h3 id="无符号的编码"><a href="#无符号的编码" class="headerlink" title="无符号的编码"></a>无符号的编码</h3><p>将位向量看作二进制表示的数，将获得了位向量的无符号表达</p><h4 id="无符号数编码的定义"><a href="#无符号数编码的定义" class="headerlink" title="无符号数编码的定义"></a>无符号数编码的定义</h4><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998590944911.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998590944911.png?x-oss-process=style/stylename</a>)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998591542514.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998591542514.png?x-oss-process=style/stylename</a>)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998592255921.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998592255921.png?x-oss-process=style/stylename</a>)</p><blockquote><p>B2Uw是一个双射，函数Ｂ2Uw将每个长度为w的位向量都映射位0～2^w - 1之间的一个唯一值；反过来,U2Bw在0～2^w - 1之间的每一个整数都可以映射为一个唯一的长度为w的位模式。</p></blockquote><h3 id="2-2-3-补码编码"><a href="#2-2-3-补码编码" class="headerlink" title="2.2.3 补码编码"></a>2.2.3 补码编码</h3><h4 id="补码编码的定义"><a href="#补码编码的定义" class="headerlink" title="补码编码的定义"></a>补码编码的定义</h4><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998595311062.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998595311062.png?x-oss-process=style/stylename</a>)<br>字的最高有效位解释为负权，也叫做符号位。</p><blockquote><p>符号位为1时值为负<br>符号位为0时值为非负</p></blockquote><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998597654820.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998597654820.png?x-oss-process=style/stylename</a>)</p><blockquote><p>B2Tw也是双射</p></blockquote><h4 id="可表示的整数的范围"><a href="#可表示的整数的范围" class="headerlink" title="可表示的整数的范围"></a>可表示的整数的范围</h4><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998599315139.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998599315139.png?x-oss-process=style/stylename</a>)</p><ul><li>补码范围不对称：｜TMin｜ &#x3D; |TMax| + 1<br>之所以不对称是因为一半的位模式表示负数，而另一半表示为非负数，因为0是非负数所以比负数多1</li><li>最大的无符号值刚好比补码的最大值的两倍大一点：UMaxw &#x3D; 2Tmxw + 1.<blockquote><p>c语言标准并没有要求用补码形式来表示用符号整数，但是几乎所有的机器都是这么做的。</p></blockquote></li></ul><blockquote><p>为来使代码具有最大可移植性，能够做所有可能的机器上运行，我们不应该假设任何可表示的数值类型，也不应该假设也符号数会使用何种特殊的表达方式。<br>许多程序的书写都是用补码来表示用符号数，并且具有图2-9和图2-10所示的典型的取值范围，这些程序能够值大量机器上移植</p></blockquote><p>staint.h中定义了一组数据类型：intN_t和uintN_t（对不同N值指定N位用符号和无符号整数）</p><blockquote><p>N：8、16、32和64</p></blockquote><p>这些数据类型对应着一组宏，定义了每个N对值对应对最小和最大值：INTN_MIN、INTN_MAX和UINTN_MAX</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998607174352.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998607174352.png?x-oss-process=style/stylename</a>)</p><h4 id="有符号的其他表示方法-反码和原码"><a href="#有符号的其他表示方法-反码和原码" class="headerlink" title="有符号的其他表示方法(反码和原码)"></a>有符号的其他表示方法(反码和原码)</h4><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998607836002.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998607836002.png?x-oss-process=style/stylename</a>)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998608162844.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998608162844.png?x-oss-process=style/stylename</a>)</p><p>![图2-15](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998608493945.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998608493945.png?x-oss-process=style/stylename</a>)</p><h3 id="2-2-4-有符号数和无符号数之间的转换"><a href="#2-2-4-有符号数和无符号数之间的转换" class="headerlink" title="2.2.4 有符号数和无符号数之间的转换"></a>2.2.4 有符号数和无符号数之间的转换</h3><p>从位级角度思考<br>转换<strong>数值变但是位模式不变</strong></p><h4 id="补码转换为无符号数"><a href="#补码转换为无符号数" class="headerlink" title="补码转换为无符号数"></a>补码转换为无符号数</h4><ul><li>原理<br>![公式2.5](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998611816561.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998611816561.png?x-oss-process=style/stylename</a>)</li><li>推导<br>![公式2.6](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998612864476.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998612864476.png?x-oss-process=style/stylename</a>)</li></ul><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998613857100.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998613857100.png?x-oss-process=style/stylename</a>)</p><h4 id="无符号数转换为补码"><a href="#无符号数转换为补码" class="headerlink" title="无符号数转换为补码"></a>无符号数转换为补码</h4><ul><li>原理</li></ul><p>![公式2.7](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998613713711.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998613713711.png?x-oss-process=style/stylename</a>)</p><ul><li>推导</li></ul><p>![公式2.8](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999191653704.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999191653704.png?x-oss-process=style/stylename</a>)</p><p>![图2-17](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999191775362.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999191775362.png?x-oss-process=style/stylename</a>)</p><h3 id="2-2-5-C语言中有符号数与无符号数"><a href="#2-2-5-C语言中有符号数与无符号数" class="headerlink" title="2.2.5 Ｃ语言中有符号数与无符号数"></a>2.2.5 Ｃ语言中有符号数与无符号数</h3><p><strong>默认补码，要创建无符号常数，后缀加u&#x2F;U</strong><br>Ｃ语言运算中，如果一个运算数是有符号而另一个是无符号，Ｃ语言就会隐式将<strong>有符号</strong>强制转换为<strong>无符号数</strong>，并假设两个数都是非负的</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/">http://mwebpng.oss-cn-beijing.aliyuncs.com</a><u></u>&#x2F;2023&#x2F;12&#x2F;15&#x2F;16999196070225.png?x-oss-process&#x3D;style&#x2F;stylename)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999196160028.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999196160028.png?x-oss-process=style/stylename</a>)</p><h3 id="2-2-6-扩展一个数的位表示"><a href="#2-2-6-扩展一个数的位表示" class="headerlink" title="2.2.6 扩展一个数的位表示"></a>2.2.6 扩展一个数的位表示</h3><h4 id="从较小类型转换到一个较大的类型-零扩展"><a href="#从较小类型转换到一个较大的类型-零扩展" class="headerlink" title="从较小类型转换到一个较大的类型(零扩展)"></a>从较小类型转换到一个较大的类型(零扩展)</h4><p>将无符号转换为另一个更大的数据类型</p><ul><li>零扩展：在表示的开头添加0</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读一本好书 </category>
          
          <category> 深入了解计算机原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读一本好书 </tag>
            
            <tag> 深入了解计算机原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tree递归</title>
      <link href="/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/"/>
      <url>/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>@<a href="%E9%97%AE%E9%A2%98">TOC</a><br>#Tree ADT<br><img src="/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/tree.jpg" alt="tree" title="tree"></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree</span>(<span class="params">label, branches=[]</span>):</span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches:</span><br><span class="line">        <span class="keyword">assert</span> is_tree(branch),<span class="string">&#x27;branches must be a tree&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> [label] + <span class="built_in">list</span>(branches)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">label</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">branches</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_tree</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(tree) != <span class="built_in">list</span> <span class="keyword">or</span> <span class="built_in">len</span>(tree) &lt;<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(tree):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_tree(branch):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_leaf</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> branches(tree)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>tree函数用于构造，label函数和branches函数用于选择，is_leaf和is_tree函数用于辅助</p></blockquote><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="fib-tree"><a href="#fib-tree" class="headerlink" title="fib_tree"></a>fib_tree</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib_tree</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left, right = fbi_tree(n-<span class="number">1</span>), fbi_tree(n-<span class="number">2</span>)</span><br><span class="line">        fib_n = label(left)+label(right)</span><br><span class="line">        <span class="keyword">return</span> tree(fib_n,left+right)</span><br></pre></td></tr></table></figure><blockquote><p>可见，基本情况是n &#x3D;&#x3D; 0 or n &#x3D;&#x3D;1<br>树递归的思想是从上到下，一旦到达基本情况变返回递归结果<br>这段函数从树顶端递归到0 or 1的情况，然后根据0和1的结果，逐层向上计算树节点的值</p></blockquote><h2 id="count-leaf"><a href="#count-leaf" class="headerlink" title="count_leaf"></a>count_leaf</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_leaves</span>(<span class="params">tree</span>):</span><br><span class="line">      <span class="keyword">if</span> is_leaf(tree):</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          branch_counts = [count_leaves(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(tree)]</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">sum</span>(branch_counts)</span><br></pre></td></tr></table></figure><blockquote><p>不断递归检查树枝是否为叶子，一旦是，便返回1并存储在数列中。最后用sum求树叶数</p></blockquote><h2 id="leaves"><a href="#leaves" class="headerlink" title="leaves"></a>leaves</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leaves</span>(<span class="params">tree</span>):</span><br><span class="line"><span class="keyword">if</span> is_leaf(tree):</span><br><span class="line"><span class="keyword">return</span> [label(tree)]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sum</span>([leaves(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(tree)],[])</span><br></pre></td></tr></table></figure><blockquote><p>分离树叶，不断递归检查树枝是否为树叶，若是，以数列形式存储在[ ]中，最后用sum消去一层[ ]<br>#为什么要用sum(<list>, [])？<br>因为当该分支只存在树叶时，leavers(b) for b in branches(tree)是以数列形式出现的，而若该分支同时存在树叶和树枝时，则返回单单数字(int).</list></p></blockquote><h2 id="increment-leaf"><a href="#increment-leaf" class="headerlink" title="increment_leaf:"></a>increment_leaf:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">increment_leaf</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> tree(label(t)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[increment_leaves(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br><span class="line"><span class="comment">#OR</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">increment</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">return</span> tree(label(t)+<span class="number">1</span>,[increment(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上面的increment只增加leaf<br>下面的increment增加所有节点</p></blockquote><h2 id="print-tree"><a href="#print-tree" class="headerlink" title="print_tree"></a>print_tree</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_tree</span>(<span class="params">t,indent = <span class="number">0</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>*indent + <span class="built_in">str</span>(label(t)))</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> branches(t):</span><br><span class="line">        print_tree(b, indent+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="print-path"><a href="#print-path" class="headerlink" title="print_path"></a>print_path</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_sums</span>(<span class="params">t, so_far</span>):</span><br><span class="line">    so_far = so_far + label(t)</span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="built_in">print</span>(so_far)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> branches(t):</span><br><span class="line">            print_sums(b, so_far)</span><br></pre></td></tr></table></figure><h2 id="count-paths"><a href="#count-paths" class="headerlink" title="count_paths"></a>count_paths</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_paths</span>(<span class="params">t, total</span>):</span><br><span class="line">    <span class="keyword">if</span> label(t) == total:</span><br><span class="line">        found = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        found = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> found + <span class="built_in">sum</span>([count_paths(b,total-label(t)) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br></pre></td></tr></table></figure><blockquote><p>重点在于返回的count_paths(b,total-label(t)中的<code>total-label(t)</code><br>在递归过程中，total-label(t)不断更新到达下一分支时，满足条件的值。</p></blockquote><p><img src="/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/cp.png" alt="输出结果"></p><p><img src="/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/count_paths.png" alt="图示"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="berry-finder"><a href="#berry-finder" class="headerlink" title="berry_finder"></a>berry_finder</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">berry_finder</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns True if t contains a node with the value &#x27;berry&#x27; and </span></span><br><span class="line"><span class="string">    False otherwise.</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = tree(1, [tree(&#x27;berry&#x27;,[tree(&#x27;not berry&#x27;)])])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; berry_finder(t)</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;*** YOUR CODE HERE ***&quot;</span></span><br><span class="line">    <span class="keyword">if</span> label(t) == <span class="string">&#x27;berry&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t):</span><br><span class="line">        <span class="keyword">if</span> berry_finder(branch):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="replace-loki-at-leaf"><a href="#replace-loki-at-leaf" class="headerlink" title="replace_loki_at_leaf"></a>replace_loki_at_leaf</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">replace_loki_at_leaf</span>(<span class="params">t, lokis_replacement</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns a new tree where every leaf value equal to &quot;loki&quot; has</span></span><br><span class="line"><span class="string">    been replaced with lokis_replacement.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> label(t) == <span class="string">&#x27;loki&#x27;</span><span class="keyword">and</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> tree(lokis_replacement, [replace_loki_at_leaf(branch,lokis_replacement) <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t)])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[replace_loki_at_leaf(branch,lokis_replacement) <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Height"><a href="#Height" class="headerlink" title="Height"></a>Height</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Q5: Height</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the height of a tree.</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = tree(3, [tree(5, [tree(1)]), tree(2)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; height(t)</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;*** YOUR CODE HERE ***&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>([height(branch) <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t)])</span><br></pre></td></tr></table></figure><h2 id="find-path"><a href="#find-path" class="headerlink" title="find_path"></a>find_path</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_path</span>(<span class="params">t, x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = tree(2, [tree(7, [tree(3), tree(6, [tree(5), tree(11)])] ), tree(15)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; find_path(t, 5)</span></span><br><span class="line"><span class="string">    [2, 7, 6, 5]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; find_path(t, 10)  # returns None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> label(t) == x:</span><br><span class="line">        <span class="keyword">return</span> [label(t)]</span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t):</span><br><span class="line">        path = find_path(branch, x)</span><br><span class="line">        <span class="keyword">if</span> path:</span><br><span class="line">            <span class="keyword">return</span> [label(t)] + path</span><br></pre></td></tr></table></figure><h2 id="sprout-leaves"><a href="#sprout-leaves" class="headerlink" title="sprout_leaves"></a>sprout_leaves</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sprout_leaves</span>(<span class="params">t, leaves</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Sprout new leaves containing the data in leaves at each leaf in</span></span><br><span class="line"><span class="string">    the original tree t and return the resulting tree.</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t1 = tree(1, [tree(2), tree(3)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(t1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">      3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; new1 = sprout_leaves(t1, [4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(new1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">      3</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[tree(leaf) <span class="keyword">for</span> leaf <span class="keyword">in</span> leaves])</span><br><span class="line">    <span class="keyword">return</span> tree(label(t),[sprout_leaves(branch,leaves) <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们可以发现，完成这些例子和练习的核心思想有：</p><ol><li>重构tree，且将branches部分用递归方法不断更新为我们需要的树枝。</li><li>利用 for语句和branches选择函数对函数进行递归。</li><li>而递归的关键就在于我们对基本情况的定义和对tree ADT的理解应用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CS61A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/"/>
      <url>/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>笔记来源网课教程：<a href="https://www.bilibili.com/video/BV1oD4y1h7S3">C++教程</a><br>10月·8号发布</p><h1 id="C-是怎么工作的"><a href="#C-是怎么工作的" class="headerlink" title="C++是怎么工作的"></a>C++是怎么工作的</h1><p>项目中的源文件传输给编译器，编译器将其转化成二进制的东西，可能转化成某种库，也可能是可执行的程序<br>opp编译成obj文件，然后通过linker将obj整合起来</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>编译前处理include后面的文件，该文件通常叫做“头文件”，我们之所以要包括iostream这个头文件，是因为我们需要一个被调用的函数的声明，例如<code>std::cout</code></p><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>程序的入口，它不一定需要返回值，默认返回0</p><h2 id><a href="#" class="headerlink" title="&lt;&lt;重载语句"></a>&lt;&lt;重载语句</h2><p>相当于一个函数而已，相当于print()<br><code>std::cout &lt;&lt; &quot;Hello World&quot;&lt;&lt; std::endl;</code><br>相当于<br><code>std::cout .print( &quot;Hello World&quot;).pint(std::endl); </code></p><h2 id="链接项目中的函数代码"><a href="#链接项目中的函数代码" class="headerlink" title="链接项目中的函数代码"></a>链接项目中的函数代码</h2><p><strong>Log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; </span><br><span class="line"><span class="comment">// 声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过linker将main.cpp中声明并使用的函数链接到某个项目文件中唯一的log函数中</p></blockquote><blockquote><p>声明只包含了函数，定义包含了函数和函数体</p></blockquote><h1 id="C-编译器的工作"><a href="#C-编译器的工作" class="headerlink" title="C++编译器的工作"></a>C++编译器的工作</h1><p>首先预处理,将所有代码转化成常量数据或指令。<br>将我们项目所有的cpp生成opj文件<br>cpp叫做<strong>翻译单元</strong></p><h2 id="include工作原理"><a href="#include工作原理" class="headerlink" title="#include工作原理"></a>#include工作原理</h2><p>在编译前将指定的文件粘贴并复制到当前cpp当中</p><p><strong>EndBrace.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; </span><br><span class="line"><span class="comment">// 声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&#x27;EndBrace.h&#x27;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>编译器的工作就是，将EndBrace中的所有代码copy进去当前cpp</p></blockquote><h2 id="查看预处理器实际上生成的文件"><a href="#查看预处理器实际上生成的文件" class="headerlink" title="查看预处理器实际上生成的文件"></a>查看预处理器实际上生成的文件</h2><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E9%A2%84%E5%A4%84%E7%90%86.png" alt="预处理器文件"><br>编译后会生成一个.i文件<br>里面含有预处理后的结果</p><h2 id="查看obj文件"><a href="#查看obj文件" class="headerlink" title="查看obj文件"></a>查看obj文件</h2><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E7%A8%8B%E5%BA%8F%E9%9B%86.png" alt="程序集"></p><p>将obj中的二进制文件转化为汇编代码(ASM文件) </p><blockquote><p>若在优化将速度调最大会忽略掉一些无用的操作</p></blockquote><h1 id="C-链接"><a href="#C-链接" class="headerlink" title="C++链接"></a>C++链接</h1><p>编译后的操作，链接的焦点是找到每个符号和函数在哪里然后连接在一起。<br><strong>编译可能不需要main函数，但是链接过程一定需要main函数</strong></p><blockquote><p>编译错误 错误类型是C开头，链接错误是LIN开头</p></blockquote><blockquote><p>不能存在两个相同的函数带着相同的参数，这样链接器不知道链接哪一个，从而产生错误。</p></blockquote><h2 id="易错处"><a href="#易错处" class="headerlink" title="易错处"></a>易错处</h2><p><strong>Log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 注意log函数名字已经被修改了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; </span><br><span class="line"><span class="comment">//声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//log(&quot;multiply&quot;);</span></span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">Multiply</span>(<span class="number">5</span>, <span class="number">8</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链接没有错误</p></blockquote><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; </span><br><span class="line"><span class="comment">//声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;multiply&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; Multiply(5, 8) &lt;&lt; std::endl;</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链接错误</p></blockquote><p><strong>为什么？</strong><br>虽然在这个文件中可能用不上Multiply函数，但在其他文件可能用得上，所以链接器确实需要链接它</p><h3 id="限制链接，函数只在当前翻译单元使用的方法"><a href="#限制链接，函数只在当前翻译单元使用的方法" class="headerlink" title="限制链接，函数只在当前翻译单元使用的方法"></a>限制链接，函数只在当前翻译单元使用的方法</h3><p>用<code>static</code>加在函数前</p><h2 id="产生链接错误的例子及修正"><a href="#产生链接错误的例子及修正" class="headerlink" title="产生链接错误的例子及修正"></a>产生链接错误的例子及修正</h2><h3 id="错误例子"><a href="#错误例子" class="headerlink" title="错误例子"></a>错误例子</h3><p><strong>log.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initlog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;Initialized log&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;multiply&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; Multiply(5, 8) &lt;&lt; std::endl;</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链接失败，log重复了</p></blockquote><p><strong>原因分析：</strong><br>两个头文件同时引入了两个log函数所以产生错误.</p><h3 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h3><ol><li><strong>log.h</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将log函数修改为静态函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>log.h</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>inlind的作用是获得我们实际的函数体并将函数调用替换为函数体。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>(<span class="string">&quot;Initialized log&quot;</span>);</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Initialized log&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><ol start="3"><li>将定义移到一个翻译单元</li></ol><p><strong>log.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initlog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;Initialized log&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-变量"><a href="#C-变量" class="headerlink" title="C++变量"></a>C++变量</h1><p>变量允许我们命名存储在内存中的数据并继续使用<br>当我们创造变量时，他被存储在内存中。</p><h2 id="不同变量类型的区别是内存大小"><a href="#不同变量类型的区别是内存大小" class="headerlink" title="不同变量类型的区别是内存大小"></a>不同变量类型的区别是内存大小</h2><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul><li>char : 1 byte (经常存储字符)</li><li>short : 2 byte</li><li>int : 4 byte</li><li>long : 4 byte</li><li>long long : 8 byte</li><li>float : 4 byte</li><li>double : 8 byte</li><li>bool : 1 byte<blockquote><p>float和double的区别可以是在数字后面加f(float)<br>1 是 Ture,0 是 False.</p></blockquote></li></ul><h3 id="查看数字大小"><a href="#查看数字大小" class="headerlink" title="查看数字大小"></a>查看数字大小</h3><p>sizeof(bool)</p><h1 id="C-函数"><a href="#C-函数" class="headerlink" title="C++函数"></a>C++函数</h1><p>最主要的是提高维护效率<br>避免复制重复<br>我们通常在头文件中写声明，在翻译单元或cpp文件中编写定义，原因就是<strong>链接错误中的修改方法3</strong></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io_mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">multiply</span>(a, b);</span><br><span class="line">std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">io_mul</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">io_mul</span>(<span class="number">3</span>,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">io_mul</span>(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>io_mul的作用就是避免重复</p></blockquote><h1 id="C-头文件"><a href="#C-头文件" class="headerlink" title="C++头文件"></a>C++头文件</h1><p> 当我们跨文件调用函数的时候免不了声明，如果某个函数很常用那就要一直复制粘贴，很繁琐。<br> 而头文件就是塞入一堆声明，然后在其他cpp中include后，让预处理器帮忙复制粘贴。</p><h2 id="pragma-once"><a href="#pragma-once" class="headerlink" title="pragma once"></a>pragma once</h2><p>当我们创建了一个头文件，vs会自动帮我们填写<code>#pragma once</code><br>这个的作用是防止include多个头文件时，里面有重复的声明，导致编译失败。他只会复制一次声明</p><h2 id="ifndef"><a href="#ifndef" class="headerlink" title="ifndef"></a>ifndef</h2><p><strong>log.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nitLog</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>检查是否有个_LOG_H被定义了，如果没有就编译中包括以下代码,如果被定义了，那么这些都不会被包括进来 </p></blockquote><blockquote><p>如果通过了这初次检查，我们定义_LOG_H,如果下次用到的时候，就不会重复声明了</p></blockquote><h2 id="include两个不同形式"><a href="#include两个不同形式" class="headerlink" title="include两个不同形式"></a>include两个不同形式</h2><h3 id="形式"><a href="#形式" class="headerlink" title="&lt; &gt;形式"></a>&lt; &gt;形式</h3><p>告诉编译器去搜索包含路径的文件夹 </p><h3 id="“-“形式"><a href="#“-“形式" class="headerlink" title="“ “形式"></a>“ “形式</h3><p>告诉编译器就在当前文件夹，我们也可以用”..&#x2F;log.h”去返回到当前文件的上级目录</p><h2 id="区别c-标准库和c标准库"><a href="#区别c-标准库和c标准库" class="headerlink" title="区别c++标准库和c标准库"></a>区别c++标准库和c标准库</h2><p>关键在于有无.h扩展，c++文件通常没有。</p><h1 id="如何在vs中调试代码"><a href="#如何在vs中调试代码" class="headerlink" title="如何在vs中调试代码"></a>如何在vs中调试代码</h1><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>在断点处暂停程序</p><h3 id="读取内存"><a href="#读取内存" class="headerlink" title="读取内存"></a>读取内存</h3><p>程序中断后,内存数据实际上还在,查看内存对诊断问题.</p><h2 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h2><ol start="0"><li>确保模式是<strong>debug模式</strong></li><li><strong>设置断点</strong></li><li><strong>读内存</strong></li></ol><h3 id="按键介绍"><a href="#按键介绍" class="headerlink" title="按键介绍"></a>按键介绍</h3><ul><li>逐语句(F11)(step into):进入到当前这行代码上的函数里面</li><li>逐过程(F10)(step over):从当前函数跳到下一行代码</li><li>跳出(shift+F11)(step out):跳出当前函数，回到调用这个函数的位置</li></ul><h3 id="窗口介绍"><a href="#窗口介绍" class="headerlink" title="窗口介绍"></a>窗口介绍</h3><ul><li>自动、局部窗口 : 向你展示可能重要的全局或局部</li><li>监视1：观察变量(输入要观察的变量然后回车)</li></ul><blockquote><p>右键可以修改成查看16进制</p></blockquote><h3 id="内存视图"><a href="#内存视图" class="headerlink" title="内存视图"></a>内存视图</h3><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE.png" alt="内存视图"><br><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE_1.png" alt="内存视图浏览"></p><ul><li>最左侧为内存地址</li><li>中间是以16进制存储的实际值</li><li>最右边是以ACCII对值的解释</li></ul><h4 id="内存视图的使用"><a href="#内存视图的使用" class="headerlink" title="内存视图的使用"></a>内存视图的使用</h4><p>在地址一栏输入&amp;＋变量名即可</p><h1 id="VS的最佳设置"><a href="#VS的最佳设置" class="headerlink" title="VS的最佳设置"></a>VS的最佳设置</h1><h2 id="项目的设置"><a href="#项目的设置" class="headerlink" title="项目的设置"></a>项目的设置</h2><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E8%99%9A%E6%8B%9F%E7%BB%84%E7%BB%87.ong" alt="虚拟组织"></p><blockquote><p>这只是虚拟组织的文件夹，在文件资源管理器中并不存在。</p></blockquote><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E6%98%BE%E7%A4%BA%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt="显示所有文件"><br>我们可以点击<strong>显示所有文件</strong>这个按钮，这样子新添加文件夹的时候就实际的添加了文件夹，而非虚拟文件夹。</p><h2 id="文件夹的设置"><a href="#文件夹的设置" class="headerlink" title="文件夹的设置"></a>文件夹的设置</h2><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E8%AE%BE%E7%BD%AE.png" alt="设置"><br><code>$(SolutionDir)bin\$(Platform)\$(Configuration)\</code></p><h1 id="C-条件与分值-if语句"><a href="#C-条件与分值-if语句" class="headerlink" title="C++条件与分值(if语句)"></a>C++条件与分值(if语句)</h1><p> 检查条件，然后跳转到内存的不同的地方,并从这里开始执行指令。</p><h2 id="内在指令"><a href="#内在指令" class="headerlink" title="内在指令"></a>内在指令</h2><p> <img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E5%8F%8D%E6%B1%87%E7%BC%96.png" alt="反汇编"></p><blockquote><p>设置断点调试时，右键进入反汇编模式</p></blockquote><ul><li>mov : move</li><li>jne ：jump not equal</li><li>je ：jump equel</li></ul><blockquote><ol><li><p><code>mov dword ptr [a], 5</code>：这条指令将立即数5移动到名为<code>a</code>的整数变量。它将5存储到<code>a</code>的内存位置。</p></li><li><p><code>cmp dword ptr [a], 5</code>：这是一个比较指令，用于比较<code>a</code>的值与5的值。它将<code>a</code>的值与5进行比较，但不会更改任何寄存器的值。</p></li><li><p><code>jne main+34h (07FF6F0B823B4h)</code>：这是一个条件跳转指令。它检查前面的比较结果是否不等于（jne表示”jump if not<br>equal”）零，如果不等于零，则跳转到指定的地址，这里是<code>main+34h</code>。</p></li><li><p><code>mov dword ptr [rbp+0F4h], 1</code>：如果比较结果是相等的（即<code>a</code>等于5），则将立即数1移动到内存中的某个位置，该位置可能是一个标志变量，用于表示条件满足。</p></li><li><p><code>jmp main+3Eh (07FF6F0B823BEh)</code>：这是一个无条件跳转指令，它将程序跳转到指定的地址，这里是<code>main+3Eh</code>。</p></li><li><p><code>mov dword ptr [rbp+0F4h], 0</code>：这个指令是前面条件跳转的目标（如果比较结果不等于零），它将立即数0移动到内存中的某个位置，表示条件不满足。</p></li><li><p><code>movzx eax, byte ptr [rbp+0F4h]</code>：这条指令将内存中的一个字节（8位）加载到32位寄存器<code>eax</code>中，并将其零扩展（即高位填充0）。这可能是为了将条件满足与否的标志位加载到寄存器中。</p></li><li><p><code>mov byte ptr [comparisonResult], al</code>：这个指令将寄存器<code>al</code>中的字节值写入名为<code>comparisonResult</code>的布尔变量。这是将条件判断的结果保存到布尔变量中的操作。</p></li><li><p><code>movzx eax, byte ptr [comparisonResult]</code>：这是将布尔变量<code>comparisonResult</code>的值加载到寄存器<code>eax</code>中，以便进行进一步的条件判断。</p></li><li><p><code>test eax, eax</code>：这个指令将寄存器<code>eax</code>与自身进行按位与操作。它的目的是检查<code>eax</code>中的值是否为零。</p></li><li><p><code>je main+5Ch (07FF6F0B823DCh)</code>：这是一个条件跳转指令，如果前面的按位与操作结果等于零（即<code>eax</code>中的值为零），则跳转到指定的地址，这里是<code>main+5Ch</code>。</p></li><li><p><code>lea rcx, [string &quot;hello&quot; (07FF6F0B8BCA4h)]</code>：这个指令将字符串”hello”的地址加载到寄存器<code>rcx</code>中，准备调用一个名为<code>Log</code>的函数。</p></li><li><p><code>call Log (07FF6F0B8135Ch)</code>：这是一个函数调用指令，它调用名为<code>Log</code>的函数，并将<code>rcx</code>中的地址作为参数传递给该函数，用于记录”hello”。</p></li></ol></blockquote><h1 id="C-循环"><a href="#C-循环" class="headerlink" title="C++循环"></a>C++循环</h1><p>for and while 循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; a &lt; <span class="number">5</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line">pass</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>变量的声明,循环的条件(评估后的bool值),一次循环后的操作</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">.....</span><br><span class="line">i ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h1 id="C-控制流语句"><a href="#C-控制流语句" class="headerlink" title="C++控制流语句"></a>C++控制流语句</h1><p>控制流一般和循环一起使用</p><ul><li>continue :只能在循环使用</li><li>break : 能在循环和switch语句使用</li><li>return</li></ul><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>跳到循环的下一个迭代</p><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>跳出循环</p><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>返回值，终止语句</p><h1 id="C-指针"><a href="#C-指针" class="headerlink" title="C++指针"></a>C++指针</h1><p>指针是整数，一种存储内存地址的数字。对管理和操纵内存有很大用处.</p><h2 id="指针的引用和逆引用"><a href="#指针的引用和逆引用" class="headerlink" title="指针的引用和逆引用"></a>指针的引用和逆引用</h2><p>类型的意义在于逆引用指针时可以访问和修改变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;var;</span><br><span class="line">*ptr = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="申请内存和二次指针"><a href="#申请内存和二次指针" class="headerlink" title="申请内存和二次指针"></a>申请内存和二次指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>** ptr = &amp;buffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>pte地址的内存实际上是buffer的内存地址，只不过反了过来<br>比如如果pte的内存是b8 f1 02 00<br>那么buffer的内存地址就是00 02 f1 b8</p></blockquote><h1 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h1><p>(指针的扩展)<br>引用不用占用内存，但是指针是变量，会占用内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;</span><br><span class="line"><span class="comment">//ref 实际上不存在，编译后只会有变量a</span></span><br><span class="line"><span class="comment">//相当于a的别名</span></span><br><span class="line"> </span><br><span class="line"> std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用的作用"><a href="#引用的作用" class="headerlink" title="引用的作用"></a>引用的作用</h2><blockquote><p>运用指针的例子</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increment</span><span class="params">(<span class="type">int</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">(*value)++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">Increment</span>(&amp;a)；</span><br><span class="line"><span class="built_in">Log</span>(a);</span><br><span class="line"><span class="comment">//结果为 : 6</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运用引用的例子</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increment</span><span class="params">(<span class="type">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">Increment</span>(a);</span><br><span class="line"><span class="built_in">Log</span>(a);</span><br><span class="line"><span class="comment">//结果为 : 6</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在C++中，函数参数的默认传递方式是按值传递(pass by value)。这意味着当你调用一个函数时，传递给函数的是原始数据的副本，而不是原始数据本身。这是因为按值传递会创建原始数据的副本，以便函数可以在副本上执行操作，而不会影响原始数据。<br> 当你调用Increment(a)时，a的值被复制到Increment函数的局部变量value中，然后在函数内部对value进行递增操作。这个递增操作只会影响value的副本，而不会影响a的原始值。这就是为什么在main函数中a 的值仍然是5。</p></blockquote><p>那如果我用return a呢？</p><blockquote><p>如果你在 Increment 函数中返回 value，那么你需要在 main 函数中捕获这个返回值并将其分配给 a，才能使 a 的值增加。这是因为在 C++ 中，函数的返回值不会自动修改传递给它的参数。<br>a &#x3D; increment(a)</p></blockquote><p>简而言之，引用可以节约内存开销,避免重复复制。</p><h2 id="引用的注意"><a href="#引用的注意" class="headerlink" title="引用的注意"></a>引用的注意</h2><p>你不能改变它引用的东西<br>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;</span><br><span class="line">ref = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>* ref = &amp;a;</span><br><span class="line">*ref = <span class="number">2</span>;</span><br><span class="line">ref = &amp;b;</span><br><span class="line">*ref = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Log</span>(a);</span><br><span class="line"><span class="built_in">Log</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，错误例子中会运行成功，但是他并不是更改引用,ref这个引用还是引用的a</p></blockquote><h1 id="C-类"><a href="#C-类" class="headerlink" title="C++类"></a>C++类</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> xa, <span class="type">int</span> ya)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x += xa * speed;</span><br><span class="line">y += ya * speed;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void Move(Player&amp; player, int xa, int ya)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//player.x += xa * player.speed;</span></span><br><span class="line"><span class="comment">//player.y += xa * player.speed;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Player player;</span><br><span class="line">player.x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>花括号后面需要有分号<br>由类类型构成的变量称为<strong>对象</strong><br>新的对象变量称为<strong>实例</strong><br>类中的函数称为<strong>方法</strong></p></blockquote><blockquote><p>类中的属性是私有的，如果需要访问修改需要public类中的属性。</p></blockquote><h1 id="C-类与结构体对比"><a href="#C-类与结构体对比" class="headerlink" title="C++类与结构体对比"></a>C++类与结构体对比</h1><p>类默认是私有的，类外部调用时无法调用。<br>技术上说，没什么区别，但是使用情境不同。<br>struct and class</p><blockquote><p>弹幕：用结构体当数据容器，用类来写具备逻辑的功能对象.</p></blockquote><h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2><ol><li>默认的继承访问权 : class默认的是private,strcut默认的是public。</li><li>默认访问权限 : struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。</li><li>“class”这个关键字还用于定义模板参数，就像“typename”。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python—字符串,多态函数（接口），特殊方法名称[61A Fall 2023 Lecture 20——Inheritance]</title>
      <link href="/2023/12/14/Python-Python%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0-61A-Fall-2023-Lecture-20%E2%80%94%E2%80%94Inheritance-Python%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0-61A-Fall-2023-Lecture-20%E2%80%94%E2%80%94Inheritance/"/>
      <url>/2023/12/14/Python-Python%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0-61A-Fall-2023-Lecture-20%E2%80%94%E2%80%94Inheritance-Python%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0-61A-Fall-2023-Lecture-20%E2%80%94%E2%80%94Inheritance/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h1 id="字符串表示形式"><a href="#字符串表示形式" class="headerlink" title="字符串表示形式"></a>字符串表示形式</h1><h2 id="str"><a href="#str" class="headerlink" title="str()"></a>str()</h2><p>方便阅读</p><h2 id="repr"><a href="#repr" class="headerlink" title="repr()"></a>repr()</h2><p>方便调试</p><ul><li>repr 返回对象的官方表示形式</li><li>print 用于打印可读性好的字符串</li><li>str 返回对象的非正式表示</li><li>eval 用于执行字符串表示的代码。</li><li>在字符串示例中，由于字符串中包含引号和全角逗号，因此在 repr 和 str 的输出中会反映这些差异，但 eval 用于执行这些字符串时，它们被正确处理。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half= Fraction(<span class="number">1</span>，<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>halfFraction(<span class="number">1</span>，<span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt;&gt; <span class="built_in">repr</span>(half)</span><br><span class="line"><span class="string">&#x27;Fraction(1，2)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(half)</span><br><span class="line"><span class="number">1</span>/<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(half)</span><br><span class="line"><span class="string">&#x27;1/2&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">repr</span>(half))</span><br><span class="line">Fraction(<span class="number">1</span>，<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">str</span>(half))</span><br><span class="line">05</span><br></pre></td></tr></table></figure><blockquote><p>repr(half) 返回对象的”official”字符串表示形式，它是 Fraction(1，2)，它是有效的Python表达式，可以用于重建相同的对象。<br>print(half) 打印对象时，print 使用对象的 str 方法，所以它输出 ‘1&#x2F;2’，这是用户友好的字符串表示。<br>str(half) 返回对象的”informal”字符串表示形式，这里返回 ‘1&#x2F;2’。<br>eval(repr(half)) 使用 eval 函数来执行 repr(half) 返回的字符串，这将返回一个新的 Fraction 对象，即 Fraction(1，2)。<br>eval(str(half)) 使用 eval 函数来执行 str(half) 返回的字符串，这将返回浮点数 0.5，因为 eval 解释它为数学表达式。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&quot;Hello, World&quot;</span></span><br><span class="line">&gt;&gt;&gt;s</span><br><span class="line"><span class="string">&#x27;Hello，World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">repr</span>(s))</span><br><span class="line"><span class="string">&#x27;Hello，World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s)</span><br><span class="line">Hello，World</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">str</span>(s))</span><br><span class="line">Hello，World</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(s)</span><br><span class="line"><span class="string">&#x27;Hello，World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(s)</span><br><span class="line"><span class="string">&quot;&#x27;Hello,World&#x27;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">repr</span>(s))</span><br><span class="line"><span class="string">&#x27;Hello，World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(<span class="built_in">repr</span>(<span class="built_in">repr</span>(s)))</span><br><span class="line"><span class="string">&#x27;\&#x27;&quot;\\\&#x27;Hello,world\\\&#x27;&quot;\&#x27;&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">eval</span>(<span class="built_in">eval</span>(<span class="built_in">repr</span>(<span class="built_in">repr</span>(<span class="built_in">repr</span>(s)))))))</span><br><span class="line"><span class="string">&#x27;Hello, World&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h1><h2 id="f’-’"><a href="#f’-’" class="headerlink" title="f’{}’"></a>f’{}’</h2><p>花括号里的为Python表达式 会自动计算<br>你也可以用str()或repr()</p><h1 id="多态函数"><a href="#多态函数" class="headerlink" title="多态函数"></a>多态函数</h1><p>使用于许多不同类型数据的函数<br>str和repr函数就是例子</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="repr-1"><a href="#repr-1" class="headerlink" title="repr"></a>repr</h3><p>调用一个零参数方法，相应地称为__repr__</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>half.__repr__()</span><br><span class="line"><span class="string">&#x27;Fraction(1, 2)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="str-1"><a href="#str-1" class="headerlink" title="str"></a>str</h3><p>调用一个零参数方法，相应地称为_str_</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half.__str__()</span><br><span class="line"><span class="string">&#x27;1/2&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用print()时实际上就是调用了__str__()</p></blockquote><h2 id="repr和str的实现"><a href="#repr和str的实现" class="headerlink" title="repr和str的实现"></a>repr和str的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repr</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">type</span>(x).__repr__(x)</span><br></pre></td></tr></table></figure><p>通过查找为你提供的参数类型来设法跳过实例属性或忽略他们</p><blockquote><p>是一个类属性，也是一个函数，但是这个函数不是绑定方法，因为它是在type类中查找的</p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>对象属性是消息传递的一种形式，它允许不同的数据类型以不同的方式响应同一消息。</li></ul><blockquote><p>对象通过发送消息(通常是方法调用)来与其他对象进行交互。对象的属性可以是对象的状态或数据。</p></blockquote><ul><li>从不同类引出类似行为的一组共享消息是一种强大的抽象方法。</li></ul><blockquote><p>不同的类可以实现相同的接口或共享相同的消息。</p></blockquote><ul><li>接口是一组共享属性名称，以及它们的行为规范。在复数的情况下，实现算术所需的接口由四个属性组成： real 、 imag 、 magnitude 和 angle 。<blockquote><p>这是一个具体的示例，说明了接口的用途。如果多个类需要实现某种算术操作（例如复数的加法或乘法），可以定义一个接口，其中包含所需的属性名称和方法，以确保这些类都具有相同的接口，从而可以执行相似的操作。</p></blockquote></li></ul><p>消息传递：对象通过查找彼此的属性（传递消息）进行交互<br>属性查找规则允许不同的数据类型响应相同的消息<br>从不同对象类中引出类似行为的共享消息（属性名）是一种强大的<strong>抽象方法</strong></p><p><strong>实现返回python可解释和人类可读字符串的方法</strong>的<strong>类</strong>实现了用于<strong>生成字符串表示的接口</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ratio</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n , d</span>):</span><br><span class="line">        self.numer = n</span><br><span class="line">        self.denom = d</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Ratio(&#123;0&#125;, &#123;1&#125;)&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;0&#125;/&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half = Ratio(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(half)</span><br><span class="line"><span class="number">1</span>/<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half</span><br><span class="line">Ratio(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p>个人对接口的理解：有一些具有相同行为的类，我们定义了一个接口，使得我们不需要知道传入这些类中的数据类型便知道这些类都有一种可以计算某个结果的方法。这样子不管什么数据类型都可以计算出我们需要的预期结果。[这是抽象接口]</p></blockquote><blockquote><p>Python存在两种接口 一个是面对对象用于继承的抽象接口，一个是用于封装类显露出来的动态接口[下面Ratio类的add方法是一种接口，是动态接口]</p></blockquote><h1 id="特殊方法名称"><a href="#特殊方法名称" class="headerlink" title="特殊方法名称"></a>特殊方法名称</h1><p>总是有__在前面和后面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;zero, one, two = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one + two</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(zero), <span class="built_in">bool</span>(one)</span><br><span class="line">(<span class="literal">False</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt;zero, one, two = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one.__add__(two)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zero.__bool__(), one.__bool__()</span><br><span class="line">(<span class="literal">False</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><blockquote><p>内置语法和内置函数 与 实际执行工作的特殊方法名称中间存在对应关系</p></blockquote><p>这是使用接口来允许用户定义的对象与Python中内置系统进行交互的另一个示例。<br>我们举例类的时候可以覆盖特殊方法来建立我们想要的互动结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ratio</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n , d</span>):</span><br><span class="line">        self.numer = n</span><br><span class="line">        self.denom = d</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Ratio(&#123;0&#125;, &#123;1&#125;)&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;0&#125;/&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, <span class="built_in">int</span>):</span><br><span class="line">            n = self.numer + self.denom * other</span><br><span class="line">            d = self.denom</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(other, Ratio):</span><br><span class="line">            n = self.numer * other.denom + self.denom * other.numer</span><br><span class="line">            d = self.denom * other.denom</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(other, <span class="built_in">float</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">float</span>(self) + other</span><br><span class="line">        g = gcd(n, d)</span><br><span class="line">        <span class="keyword">return</span> Ratio(n//g, d//g)</span><br><span class="line">    __radd__ = __add__</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__float__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.numer/self.denom</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">n, d</span>):</span><br><span class="line">    <span class="keyword">while</span> n != d:</span><br><span class="line">        n, d = <span class="built_in">min</span>(n, d), <span class="built_in">abs</span>(n - d)</span><br><span class="line">    <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure><ul><li>类型分类：用了条件语句对传入的other数据类型进行判断从而提供不同的执行方法</li><li>类型强制：将一种类型的对象转换为另一种类型，以便能够将其与其他值组合。</li></ul><blockquote><p>这是让两个类进行交互时而使用的两种策略</p></blockquote><blockquote><p>__add__函数相当于是一个隐形接口，我们不需要知道传入的数据是不是浮点数、整数还是什么，都可以将他们加起来 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CS61A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是我的第一篇文章</title>
      <link href="/2023/12/14/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F/"/>
      <url>/2023/12/14/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2><p><a href="https://www.bilibili.com/video/BV1G84y1B7NH/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&vd_source=700c4afe7cf00e2775dbed3e27760082">(博客教程视频)</a></p><p><a href="https://www.fomal.cc/posts/e593433d.html">(博客教程网站)</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1G84y1B7NH/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&vd_source=700c4afe7cf00e2775dbed3e27760082">(博客教程视频)</a></p><p><a href="https://www.fomal.cc/posts/e593433d.html">(博客教程网站)</a></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>game</title>
      <link href="/game/index.html"/>
      <url>/game/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }  /* 小冰分类分类磁铁黑夜模式适配 *//* 一般状态 */[data-theme="dark"] .magnet_link_context {  background: #1e1e1e;  color: antiquewhite;}/* 鼠标悬浮状态 */[data-theme="dark"] .magnet_link_context:hover {  background: #3ecdf1;  color: #f2f2f2;}/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>个人小日记</title>
      <link href="/diary/index.html"/>
      <url>/diary/index.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="4d1857f52c5969e98a96a8921330e0c4117efb53962c8316a4e3b98f722b2612">7a04f49168c16fa5e6499f3676d544844c6ee71d97efcd86407c182421f8c9748441467c5356d4070dfc0ec89c73cad95fbdbaa1469f3bb0c020d40d393c058e20b17f4293d3831de9ff74ea82c612d5e35d6103e70a5831c9b317c6e3a55a309ab3bc19e68dd232cf553b57a7260b23a88d53d82b1ed65716f80b6d1b6a255ad9531d838eae3db02a68e499acaeaaeec58d4adee4cb4e4a445d95a9337d75a06d8a414424e18732794b3ba843b29fdc9322bd2fe9259ce157adb88932a1ac6e7e4da9c91153a7b24822e4335479e9eda389e904766c8d746e5699d662482a465241272d23afe4785e3ccbfdffb70de24459545fef6bc9b1b2d3ffc1c69ca2f16b97e1695881fba5a3049e2dc9bc9612966cf35c7898b36311d0d7b0b3a8bdf792ba3293c5538de2fdf7c2a78cb0d24b2000a70a862a2b726d49676dee3cde9c6f53b3786172c6117a15d32690b5fad5a06bcb5f5a274f4b219d206122c42364877c4e18a93c20ca747132fbdc89fc14e0164d279f30e7d6c945e0bf40a2806923fbf700c5f07935936af5347cfed170494e9745eef4fa3687c6454adf5b873489aa8fa0a7865f40ce15b75dbaf9938d42fb591f649aa6caf10d31e5d93adc59477e05a58972e0e7dbd1d3e2571c760931c30ef691d608840c315ebc06339c56f10796c905c64e40c449d9a7ff420f7c6542193201ec66c57c07efd823f94a19ad45400ffdb1108ed09861943096078e733b1bbe858cd0f62f76c0a0043fd9ae0425c1d1e368d778b0bb96616da862282e4309cc5a5f5da962ff4a31d174e67670ec8f89d4773660f8697b4f22f7ecc5330174a907813de6a2bc0ee31421a3a3b67a97c6d88507efe9c35baec3fec73dc9abf9bc514580b69ddd7d2cb5aabd9b2f25454a59b9296a4baafd71998cacc6b9e9a96f1a332ee5e888a7101496b373f64f032fe62950a0f36e7400de3da57fb9c929ee0fdc24263a379d27a8ba67811adc97d0a507987d940847fe71f3a810f915dc67b5442fc96f6070fdfb99a47faa9702b549cb10d2ca349139197b20dd7116ed97541ddaf7a40af6e0a6e0bff78136ae24683a01cffbaf0668bcce69a225d08e8128d8043fdc1efb38953bacc858c1a40eb572556c3eed4f0c703cdd991b83b2224f3251d109feed4ad50462ea60d36dcec3ebfc05d91f2b7d1e30c0677fdac3b8d5dfc7a555b283bad498a24a53e6678b9dd79658960f2d98aec4a174ab71db5862aa1f9d64a52d293e8a91ed27b952b7538385e1e3f97f81adcd804cd4504f6e262673d13e0f965026bb32081a27aa044f83427b685b8b3484dfe4a6156b75c501bc9fbd7755259c5dd233e8b0355aaab062efa3691482798679514061e191e07d05935ce45b888c38b868d9912f21a6a4e96fb7d47a2dcd0fbf7c81a15caebc61132f0e122333edca6a7fcc7fc785420e4ffb3c4ec22f6364509cb36c58e7cc032b075c9b61360b5bddef8597449c6b412bff09adf12ed2010052cfad2674d163401b43587e525725f324c5e8a0879289bc6e8e275fadf055a8d42b46710066c641743e482164426863e105a28de30eafd03bd669860230ea3a5d95767951dc1b637726291a215aec43ec84da91a2d692e5c546809024be1ee5c4b44eb06069ab390f6276c08d43265544a394b429d30d2e719babf12cd6f1dc05069b98ddf76b30bd83b391ba98e21222c47dbcd6b221aaf7435aebd86182ec1fb48d403c0cfc620d91a945e5f768cf91a63c914326da19af8d5ffeb60d80609e53fdac73d6e99a1f9fc001c6e416efd39ee1cd570be8397dc5b4c2e199fab2c7c69e07ba3255c9063875a184c3964c46ccc9987337bc534bd80bd0c806cd9d2a010f2e1e91a5f00af5b9f1238a8673fdbadeb852dfd89b27fc60c4e6aec44f543ec006f772c80bd3881dbc8d31ea1ae52b0b2828278aac79d189bd3d506149f0c7b03da250211b9af8ecfbbd632706ff43c1055f8a4941627d3c1cb9a20c120e1f1ff9beb7f8350e0df3a5bc488a5dbeb3d003bcd65c97ad264a9e64f4f994231de8a0327cc7bf89052f0107a52d477595a0710b9bcd3c153d4717a9ca0d4ad99230bef277bdf1cda56ec90785927a11817ea6fe793b3a96ab08dead5c9a8288ad76df3c4793a82e6320c5b16b0ae5f2581927328e3e04eb4f60a6303665f58e513dc6a284cd17da735d91d397f091b4f0d25be0fd4649bdc13efa07be6bc788c7de945912e9d31d6ea20df78148ea48ecfb19295089bd0f89db43ad4479b4fab656129f43353898ca634d051155b462484b50f5df94779c26edd98df23fe2bac293022ee3c7de77264fd261b6c20bd7852e94251f70f3e9557cb4d56155c4181d97ade73b426bd715a52eb3978666dcc4f8a026f0fde26203175478f5e511a2fe363418ac8a047ed9217dc7f5636ef17a8771d074a44830f46dc9433219d9bcd0ed2ee550e03aacb1c1237f0e83ffa2de31f6ac29a5e0ee3732e486a567088d96e5e23a763dc9e12e52de84e2414aaedb388c72ca19cdcafaeb0aebd36309d8bf11b2167d00af2201b66cd3ada93ef33ba7ef6db64a1d28b96fcad0b2ceee215640c097538510afe68a0f7856c3b0bff545561c6c86fe2ecc5cfd59bc9ac6173e9010742b0ebfa61e2424f008e2fa93bc0304d1de72dfc4f384ff9ac72e4559914c9029ceaccfa9f49e4533069c529aadd927558066cd035aa395584cca219f5cdcd402ec2f80998bcc21239706306e174481df56d161e73059728a534445749dd1f25f79239299d54a61ad4e60019f0adaec99f67c3656a76e03801edf4f8f3b1cecea72bf230f334a6faa3d651f344317b489a0913415606b46df71c53646909b18fa94282fbfa31d7d650830a358e88665b3d9c4b405c1edaaa0878c5ac7585273ea22718404b2111377808a3ca12f02d9806782c058d712efecd01966829915fe2724f61459342ea1b91b7f724fa850066d6221c7e2cdeac056439c30d31df2224bb7039daaeb608d04e5b1a58fc9e45043f1378599e3fd07549aa97046b740293df142283f9d0154592666973c332b80cbf5f39aea37a32915288851b4ace1db17d947b6081da22c41d8cc91a09575400ef8f8fa25e7097c4fe90a60c9adef1195581e0477a81b322debc5e443cb09c778780a4a3cfaf03b04e019debd36e2e9377801787908c45bbd9bf7ee4d41f3114c4617d1504087901c271bc695ceb8d4d27520f65bdea93f6ad2dcd2484737467d1bd9506b51f426425b16dbad64a6098789d7eb26fa670dad41f80b0018357f633bada49a71707d4d7ea09ee3d12f6c5c792e1f745767c569051b082820381da084d41fe862ce87cc700131df68dbe74829ca652875f44cdb6af2c89c340e74cc2cd329fb3d963ab520daf1864945905e4411f58b447f692d0a3af272c16ac2aa7757e25967c6c9cb49ad98f0264fffff6d7e7ba5d0a32f38a69d5cd53d5e6d1aaa7caf4969d7e641774f9dea4a5ea25f5ecfd92127bd4685179d92588606a2f5510f7d047e61af3697f5dba58feaa6d41a737453df0043dd794a22e01f418a7c9b087895603e20bd6e7101705777d50ddf54bda6397357fd53a4e433b8cb57c9ec5a52887f41c769bc83d7c9f9b055fb4c2f2bf33fc6dd4f0351b4254288ea40c3ca0838bcd16b3f72088bbe64de517a917c16b1c45ad26478491d4621d924ed597bf47cc752f916a2bfde968d7f79feb0a7dd2346bd36c2d1d481393bf03285350d81eeb37e2da088f376745435ae07bd4297cd304f03487d655c8a432a945f18362c781900df8447514aa8183d781719c59da8be9bcac3a583cbf07198e6578f7bd855c8b824cab41a5995c90479367c4da689e53cebc4eae87cd8e5b1acc8fa918b5ace82441d00a1e7b32cd450fe5013f4c54b2662f88628ed2e0363d961ad7f6e4a32e55705e3c9e88a0ecfbc549a09eb6f7e9865d9339e0842c81af223826e92937c1317aa1d79c3f00d73447a3fd2fe0b3eee490146048ba099d4a4d0978b5c762aece1e99f45d8d64066c94161dacef104bcf72cfeba721c1c3045ec80b18c03040291a72729d12091626ada78179d4519bffdb6204fe0d8329454496093cad3a97cf55adc47d17074981e74acbc629edfe141cdc3186b744ec1ad07f5ea2cd68bc0752fe0cadf3aa181c1a91cbd04569e2866497bd53f7a57dfc8c6651a8d72a2324acd3058ffcac894bc8d8258614ba7b79f7cf0816cb5c5d1d593f2f994978c318804a255afad7f8943c3c079f9b656dacd06b96b0f0334f7d9ee69c43d1a54c673e633d6095b25d7fd9f951ab624585e63aad18e5f0aebf038e8fafc183c95f6db34aa3a769d9317211a0e86d307e872e44a3726be9b21b26940c180aae1e4438b1a41dec6058e02562860b9f842c74dcecf0c27b051f407d3045d47e39d0410abe4d9b050a1adcba3f9ae7aba6b9034240b6a33e1dfd1bcf8c10cdebe3fb3f057b4463e70e6e3429c1edbf34e7946a756c1f4896b8349f60e5cef04cbd1c6c3034485737663cbd9f1bc43f4bec39f9d4f485e35c44cec296f49d65b660c6ec96ee8f109a643f86fcd8523937a327c17d7e57c0b13f3a5cfd5ed76bfb3d477df2ef7e181b599a68bbdee8b506034f4eb5aa1cee6f165a2fafba0dc2a81c8b0bd80007266331378731f32eac65d9672ef94e19ec7b6065aad6c9067db97334e65e5a50caadff996f613abac05b8215d3c006b955ff3e2e4d334daff859f2aa36cbc48df59e59739dab6f0345daaca4bd44144fcfbebeab6f392650386731ab096bc85f289e6196915b47cc112645241e5fd806b180652462a90ef440f0d60ac9a48d7c3cc7b296ea236c5aeee502b42ca133898dea291dc7c2d7484f6a232e89da5a674b15460494ded39843c081e8051d0de5a35ac6c25ba1f0eeba158f239ffbc38c33654bbd65edbd44fa0f12386d4e9bee024cad92c5c6e465d1e0a273f7adbc7e942d9b50f8ec59990b8cec550885c50901439adb31960f384b6725391ee6daa95cda81fb05a783917ba6cce46dea3a687d949fed518f78b785ad37619330c6a6ecdebc3e798894ce7539bb6feb4029ff623cbd203c6130770bbdc78d082d3cf863ad7d5420b917c6724f414121aadda29bebd132232e07a5a5d866afcf7e2d15a27d049f1116260a0bb8f1c932307b70378d713e4934eaab25d40b50abcae9b30dbaad65f202447c6f3db6632540831af2a53411610255d92e4f3bfd3bbf7b3f41ba901c1dd6e7340da24cf2be34322b39540390077ee12f1c12accff90b666ad32c8fa6e1e9be88c5e3997b430909c22f8e1f7034c1cb4ccc184c14e8a947373762128140d1cc49c0a6c916dc93abbc3b6feb820f57fdeb774be2f26c7efe1f4b86ceb08e4141612ef535aa8301a21ca4bb0e4772fb26e0b21ccf7f72eb7918bc247d689107d67e45e4d1cff6b2ef08874323badf1ef2d1add956a387bd5ac406712869cc066b9ba785fe2510e43cc0efade960a23ea251deb7b655fc2886ae5213868c6f601a79317d0c4076cc857821aa9dcf7017a805f636541fd2a9e61b9a5945a779bec41ebf6ec038eb3c9d9785d33496331245fb9354e3c2ec6d97aa49efccee10458be6f9c7b5a9d51af0c22438c32bdc190f6f4a6c1e8463db05d5f7be649685d501c6c7a5573e9914e2eeb076317610662aa91dffa64df7fc8cf6d186e8c6e89097859bce1655658ba62bea8bdc23fc03d353fbc9c82282dce7a4f4fc73f1bcfb4afcb1d7a2a861524b7bd232fa3b178cd9dd48dd20426497c447143c8f6881b1f2010c0ee2e26700ffb45f2c71b11d12dc9fe39807a313c44d0a3c921794fd18f570e1083ba95f7cb481e795d4965c17fd54b3c1f4b8486f0c63ab1d44027ade663bd4ef66df5ef6556235f48d2d1c2783829061132f37e420dea2b1cf69fd61410f3283b7eda20797cb11d9e95d67a75598f7028f7838e41a1ed419d8171</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">别猜了别猜了</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>有趣の文章</title>
      <link href="/%E6%9C%89%E8%B6%A3%E3%81%AE%E6%96%87%E7%AB%A0/index.html"/>
      <url>/%E6%9C%89%E8%B6%A3%E3%81%AE%E6%96%87%E7%AB%A0/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>23·12·23</title>
      <link href="/diary/23%C2%B712%C2%B723/index.html"/>
      <url>/diary/23%C2%B712%C2%B723/index.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="fac6055b69e98f52462d9cdbb2fdd1ff07debe2c5f3f2f531b8cb4f1d2ae9b13">7a04f49168c16fa5e6499f3676d544847369460cb37b8a9320df2540de47878192e3229550a92ebeb8cdebaea7cb2f0f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">别猜了别猜了</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
    </entry>
    
    
  
</search>
