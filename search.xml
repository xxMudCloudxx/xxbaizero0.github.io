<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python笔记(五)-浏览器自动化</title>
      <link href="/2023/12/23/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-5-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
      <url>/2023/12/23/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-5-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-selenium"><a href="#什么是-selenium" class="headerlink" title="什么是 selenium"></a>什么是 selenium</h1><p><strong>selenium</strong> 是浏览器自动化测试框架，原本被用于网页测试。但到了爬虫领域，它又成为了爬虫的好帮手。<strong>selenium</strong> 可以控制你的浏览器，模仿人浏览网页，从而获取数据，自动操作等。</p><p>因为要打开浏览器并控制它，所以和我们以前学的爬虫相比，它占用的资源会更多，爬取数据的效率也会有所降低，不过至少比我们手动操作还是快很多的。</p><h1 id="安装selenium"><a href="#安装selenium" class="headerlink" title="安装selenium"></a>安装selenium</h1><p>和其他 Python 第三方库的安装一样，我们要在命令行中使用 pip 命令安装 selenium：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium -i https://pypi.doubanio.com/simple</span><br></pre></td></tr></table></figure><p><strong>selenium</strong> 还需要安装相应的<strong>浏览器驱动</strong>才能控制浏览器。</p><p>下面我们以 <strong>Chrome 浏览器</strong> 为例，示范一下如何安装对应的浏览器驱动。</p><p>首先打开 <strong>Chrome 浏览器</strong>，依次点击浏览器右上角的 <strong>三个点</strong> - <strong>帮助</strong> - <strong>关于 Google Chrome</strong>来查看版本号，根据版本号去官网<a href="https://registry.npmmirror.com/binary.html?path=chromedriver/">CNPM Binaries Mirror (npmmirror.com)</a>。</p><p>我们选择最接近的版本即可，点击版本号后会进入文件选择页面。如果你是 Windows 系统，就下载里面的 <strong>chromedriver_win32.zip</strong> 文件；如果是 MacOS，要根据 CPU 决定，Intel 芯片下载 <strong>chromedriver_mac64.zip</strong>，M 系列芯片下载 <strong>chromedriver_mac_arm64.zip</strong>。</p><p>将下载好的 <strong>chromedriver</strong> 解压缩，Windows 系统得到 <strong>chromedriver.exe</strong>，MacOS 得到 <strong>chromedriver</strong>，这个就是我们需要的浏览器驱动。我们要将它放到 Python 所在安装目录里。 如果你忘了 Python 的安装目录，可以根据下面的操作来找到。</p><p>在代码编辑器中运行以下代码，让 Python 自己打印出所在的位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.executable)</span><br></pre></td></tr></table></figure><p>会打印出类似下面的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Windows 系统：</span><br><span class="line">C:\xxx\xxx\python.exe</span><br><span class="line">MacOS：</span><br><span class="line">/Users/xxx/xxx/xxx/python</span><br></pre></td></tr></table></figure><p>我们将末尾的 <strong>\python.exe</strong> 或者 <strong>&#x2F;python</strong> 去掉，就是 Python 所在的目录。我们可以在文件管理器中逐层点进目录，也可以将目录复制下来，在文件管理器的地址栏中粘贴，直接前往该目录。</p><p>打开目录后，我们将下载好的驱动放到目录中。这样，我们的前期准备工作就完成了。</p><p>为了验证驱动是否安装成功，Windows 系统在的 <strong>命令行</strong> 或者 <strong>Anaconda Prompt</strong> 中输入 <strong>chromedriver</strong> 命令，MacOS 系统在 <strong>终端</strong> 中输入 <strong>chromedriver</strong> 命令。如果出现类似下图所示的内容，就证明驱动已经安装成功了。</p><p><img src="/2023/12/23/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-5-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%8C%96/image-20231223224310908.png" alt="image-20231223224310908"></p><p>好了，一切准备就绪。</p><h1 id="打开浏览器"><a href="#打开浏览器" class="headerlink" title="打开浏览器"></a>打开浏览器</h1><p>我们先来看看如何用 <strong>selenium</strong> 打开 <strong>Chrome 浏览器</strong>，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 selenium 中导入 webdriver（驱动）</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择 Chrome 浏览器并打开</span></span><br><span class="line">browser = webdriver.Chrome()</span><br></pre></td></tr></table></figure><p>运行上面的代码，我们就有了一个<strong>打开的浏览器</strong>。我们将实例化后的浏览器对象赋值给 <code>browser</code> 变量，之后我们将操作该对象来控制浏览器。</p><h1 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h1><p>我们看一下如何获取数据。首先是控制浏览器打开网页，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 selenium 中导入 webdriver（驱动）</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择 Chrome 浏览器打开</span></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 打开网页</span></span><br><span class="line">browser.get(<span class="string">&#x27;https://www.bailog.top&#x27;</span>)</span><br><span class="line"><span class="comment"># 关闭浏览器</span></span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure><p>前面说过，<strong>browser</strong> 是我们实例化的浏览器。我们将网址传给 <strong>browser</strong> 对象的 <code>get()</code> 方法，即可打开对应的网页。最后调用 <code>quit()</code> 方法将浏览器关闭。</p><p>我们的目的是获取数据，接下来让我们用 <strong>browser</strong> 对象的 <strong>page_source</strong> 属性来获取网页的源代码。值得注意的是，用 <strong>selenium</strong> 获取的网页源代码是数据加载完毕后最终的源代码，也就是网页加载后通过 API 获取的数据也在这个源代码中。</p><p>因此，我们就不用再区分要爬取的网页是静态网页还是动态网页了，在 <strong>selenium</strong> 眼里统统都一样。我们来试着用 <strong>selenium</strong> 打印出博客的网页源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment"># 引入 time 模块</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.bailog.top/&#x27;</span>)</span><br><span class="line"><span class="comment"># 等待 2 秒</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 打印出网页源代码</span></span><br><span class="line"><span class="built_in">print</span>(browser.page_source)</span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure><blockquote><p>有些网站内容比较多，加载需要一些时间，我们可以在打开网页后等待几秒，这样可以确保我们获取的网页源代码是完整的。我们可以通过 <code>time.sleep()</code> 实现等待几秒：</p></blockquote><h1 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h1><p>我们之前掌握了用 <strong>BeautifulSoup</strong> 对获取的网页源代码进行处理，提取出我们需要的内容。<strong>selenium</strong> 也同样可以进行数据的处理，它俩原理类似，只是语法上有所不同。</p><p>接下来，我们来看看如何用 <strong>selenium</strong> 处理数据。我们以获取博客的 <strong>h1</strong> 元素为例，代码可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.bailog.top/&#x27;</span>)</span><br><span class="line">h1 = browser.find_element(by=<span class="string">&#x27;tag name&#x27;</span>, value=<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.text)</span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure><p>除此之外，<code>find_element()</code> 方法中的 <code>by</code> 参数还可以传入其它值来选择元素，一看就知道是干嘛的：</p><p><img src="/2023/12/23/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-5-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%8C%96/image-20231223231351215.png" alt="image-20231223231351215"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># &lt;p&gt;带你打开编程世界的大门&lt;/p&gt;</span></span><br><span class="line">browser.find_element(<span class="string">&#x27;tag name&#x27;</span>, <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;p class=&quot;slogan&quot;&gt;带你打开编程世界的大门&lt;/p&gt;</span></span><br><span class="line">browser.find_element(<span class="string">&#x27;class name&#x27;</span>, <span class="string">&#x27;slogan&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;p id=&quot;slogan&quot;&gt;带你打开编程世界的大门&lt;/p&gt;</span></span><br><span class="line">browser.find_element(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;slogan&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;p name=&quot;slogan&quot;&gt;带你打开编程世界的大门&lt;/p&gt;</span></span><br><span class="line">browser.find_element(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;slogan&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;a href=&quot;http://code.shanbay.com&quot;&gt;编程&lt;/a&gt;</span></span><br><span class="line">browser.find_element(<span class="string">&#x27;link text&#x27;</span>, <span class="string">&#x27;编程&#x27;</span>)</span><br><span class="line">browser.find_element(<span class="string">&#x27;partial link text&#x27;</span>, <span class="string">&#x27;编程&#x27;</span>)</span><br></pre></td></tr></table></figure><p>除此之外还有标志的定位器:</p><p><img src="/2023/12/23/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-5-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%8C%96/image-20231223231316986.png" alt="image-20231223231316986"></p><blockquote><p>需要先导入库from selenium.webdriver.common.by import By</p></blockquote><p>或者<strong>直接方法查找</strong>:</p><p><img src="/2023/12/23/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-5-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%8C%96/image-20231223231600074.png" alt="image-20231223231600074"></p><p>这些方法找到的元素（返回值）都是 <strong>WebElement</strong> 对象，它和 <strong>BeautifulSoup</strong> 里的 <strong>Tag</strong> 对象一样，也有一个 <code>text</code> 属性，一样也是获取元素里的文本内容。</p><p>不同的是，<strong>Tag</strong> 对象通过字典取值的方式获取元素的属性值，而 <strong>WebElement</strong> 对象则使用 <code>get_attribute()</code> 方法来获取。</p><p><img src="/2023/12/23/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-5-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%8C%96/image-20231223225815803.png" alt="image-20231223225815803"></p><p>我们来看个代码实例加深一下印象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &lt;a href=&quot;https://www.bailog.top/&quot;&gt;bai的小窝&lt;/a&gt;</span></span><br><span class="line">link = browser.find_element(<span class="string">&#x27;link text&#x27;</span>, <span class="string">&#x27;bai的小窝&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(link.get_attribute(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line"><span class="comment"># 输出：https://www.bailog.top</span></span><br><span class="line"><span class="built_in">print</span>(link.text)</span><br><span class="line"><span class="comment"># 输出：bai的小窝</span></span><br></pre></td></tr></table></figure><p><strong>BeautifulSoup</strong> 中通过 <code>select()</code> 方法查找所有被所传入的 CSS 选择器选中的元素。刚才介绍的那些方法都是查找第一个符合条件的元素，接下来我们来看看 <strong>selenium</strong> 中查找所有符合条件的元素的方法。</p><p>这些方法非常简单，直接把 <code>find_element()</code> 方法改成 <code>find_elements()</code> 方法即可：</p><p><img src="/2023/12/23/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-5-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%8C%96/image-20231223231508164.png" alt="image-20231223231508164"></p><p>比如获取网页源代码中所有的 <strong>a 元素</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.bailog.top/&#x27;</span>)</span><br><span class="line"><span class="comment"># 注意下面是 elements</span></span><br><span class="line">a_tags = browser.find_elements(<span class="string">&#x27;tag name&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> a_tags:</span><br><span class="line">  <span class="built_in">print</span>(tag.text)</span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure><p>值得一提的是，<strong>WebElement</strong> 对象也可以调用 <strong>selenium</strong> 查找元素的方法。这样就和 <strong>BeautifulSoup</strong> 中的 <strong>Tag</strong> 对象一样，可以一层一层的查找元素，直到找到为止。</p><p>如果你觉得 <strong>selenium</strong> 的方法名又长又难记，觉得还是 <strong>BeautifulSoup</strong> 的方法名简单好记。那么，接下来的内容你肯定喜欢。</p><p><strong>BeautifulSoup</strong> 的原理是将网页源代码的字符串形式解析成 <strong>BeautifulSoup 对象</strong>，然后通过 <strong>BeautifulSoup 对象</strong> 的属性和方法提取出我们需要的数据。发现没有？<strong>BeautifulSoup</strong> 只需要一个网页源代码的字符串形式即可。</p><p>之前我们都是使用 <strong>requests</strong> 库获取网页源代码，并通过 <code>text</code> 属性取得其字符串形式。而 <strong>selenium</strong> 获取网页后的 <code>page_source</code> 属性值正是字符串格式的！</p><p>接下来我要做什么，我想你应该也猜到了。对，就是将 <strong>selenium</strong> 和 <strong>BeautifulSoup</strong> 结合起来，共同完成爬虫的获取数据和处理数据。</p><p>以上面获取博客网页源代码中所有的 <strong>a 元素</strong> 为例，加上 <strong>BeautifulSoup</strong> 可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.bailog.top/&#x27;</span>)</span><br><span class="line"><span class="comment"># 用 BeautifulSoup 解析网页源代码</span></span><br><span class="line">soup = BeautifulSoup(browser.page_source, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">a_tags = soup.select(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> a_tags:</span><br><span class="line">  <span class="built_in">print</span>(tag.text)</span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure><p>这样一来，即使对 <strong>selenium</strong> 处理数据的方法不熟悉，我们也能成功提取到我们想要的数据，只需将 <strong>selenium</strong> 和我们熟悉的 <strong>BeautifulSoup</strong> 结合起来便可。</p><h1 id="控制浏览器"><a href="#控制浏览器" class="headerlink" title="控制浏览器"></a>控制浏览器</h1><p>上篇文章我们介绍了登录博客并批量获取博客中的文章内容, 我们可以使用 <code>selenium</code> 进行同样的操作，代码的可读性更强，我们写起来也更轻松。</p><p>要想做到这些，除了刚才学的那些查找元素的方法外，只要再学两个方法即可。这两个方法分别是 <code>click()</code> 和 <code>send_keys()</code>，我们来看看它俩的作用：</p><p><img src="/2023/12/23/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-5-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%8C%96/image-20231223230033954.png" alt="image-20231223230033954"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 打开博客</span></span><br><span class="line">browser.get(<span class="string">&#x27;https://wpblog.x0y1.com&#x27;</span>)</span><br><span class="line"><span class="comment"># 找到登录按钮</span></span><br><span class="line">login_btn = browser.find_element(<span class="string">&#x27;link text&#x27;</span>, <span class="string">&#x27;登录&#x27;</span>)</span><br><span class="line"><span class="comment"># 点击登录按钮</span></span><br><span class="line">login_btn.click()</span><br><span class="line"><span class="comment"># 等待 2 秒钟，等页面加载完毕</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 找到用户名输入框</span></span><br><span class="line">user_login = browser.find_element(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;user_login&#x27;</span>)</span><br><span class="line"><span class="comment"># 输入用户名</span></span><br><span class="line">user_login.send_keys(<span class="string">&#x27;codetime&#x27;</span>)</span><br><span class="line"><span class="comment"># 找到密码输入框</span></span><br><span class="line">user_pass = browser.find_element(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;user_pass&#x27;</span>)</span><br><span class="line"><span class="comment"># 输入密码</span></span><br><span class="line">user_pass.send_keys(<span class="string">&#x27;shanbay520&#x27;</span>)</span><br><span class="line"><span class="comment"># 找到登录按钮</span></span><br><span class="line">wp_submit = browser.find_element(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;wp-submit&#x27;</span>)</span><br><span class="line"><span class="comment"># 点击登录按钮</span></span><br><span class="line">wp_submit.click()</span><br><span class="line"><span class="comment"># 找到 Python 分类文章链接</span></span><br><span class="line">python_cat = browser.find_element(<span class="string">&#x27;css selector&#x27;</span>, <span class="string">&#x27;section#categories-2 ul li a&#x27;</span>)</span><br><span class="line"><span class="comment"># 点击该分类</span></span><br><span class="line">python_cat.click()</span><br><span class="line"><span class="comment"># 找到跳转的页面中的所有文章标题元素</span></span><br><span class="line">titles = browser.find_elements(<span class="string">&#x27;css selector&#x27;</span>, <span class="string">&#x27;h2.entry-title a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到标题元素中内含的链接</span></span><br><span class="line">links = [i.get_attribute(<span class="string">&#x27;href&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> titles]</span><br><span class="line"><span class="comment"># 依次打开 links 中的文章链接</span></span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> links:</span><br><span class="line">  browser.get(link)</span><br><span class="line">  <span class="comment"># 获取文章正文内容</span></span><br><span class="line">  content = browser.find_element(<span class="string">&#x27;class name&#x27;</span>, <span class="string">&#x27;entry-content&#x27;</span>)</span><br><span class="line">  <span class="built_in">print</span>(content.text)</span><br><span class="line">  </span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure><blockquote><p>提示：我们还用了一对新的查找元素的方式：<code>find_element(&#39;css selector&#39;, ...)</code> 和 <code>find_elements(&#39;css selector&#39;, ...)</code> ，这就运用了 css 选择器的知识，将 css 选择器以字符串的形式填入括号中，能帮我们更精准地查找元素。</p></blockquote><p>每一步的作用注释里都说了，我们主要关注 <code>click()</code> 和 <code>send_keys()</code> 这两个方法。通过 <strong>selenium</strong> 查找元素的方法找到对应的元素后，调用其 <code>click()</code> 方法就可以模拟点击该元素，一般用于点击链接或按钮；调用其 <code>send_keys()</code> 方法用于模拟按键输入，传入要输入的内容即可，常用于账号密码等输入框的表单填写。</p><p><strong>selenium</strong> 的基础知识就学到这里了，如果想要继续深入学习，可以参考这个中文文档：<a href="https://selenium-python-zh.readthedocs.io/en/latest/%E3%80%82">https://selenium-python-zh.readthedocs.io/en/latest/。</a></p><p>为了提升爬取效率，我们可以将浏览器设置为静默模式，让浏览器不必真的打开，而是在后台默默地获取数据、操作页面。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化配置</span></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line"><span class="comment"># headless 为静默模式</span></span><br><span class="line">options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line"><span class="comment"># 将配置传入浏览器</span></span><br><span class="line">browser = webdriver.Chrome(options=options)</span><br><span class="line"><span class="comment"># 打开网页</span></span><br><span class="line">browser.get(<span class="string">&#x27;https://www.bailog.top/&#x27;</span>)</span><br><span class="line"><span class="comment"># 关闭浏览器</span></span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python笔记(四)—模拟登录(cookie)</title>
      <link href="/2023/12/23/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-4-%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/"/>
      <url>/2023/12/23/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-4-%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="POST请求登录"><a href="#POST请求登录" class="headerlink" title="POST请求登录"></a>POST请求登录</h1><p>打开登录页后打开浏览器的开发者工具</p><p><img src="/2023/12/23/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-4-%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/image-20231223175343250.png" alt="image-20231223175343250"></p><ul><li>选择<strong>网络(Network)</strong></li><li>清空</li><li>勾选<strong>保留日志(Preserve log)</strong></li></ul><p>随后进行登录</p><p><img src="/2023/12/23/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-4-%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/image-20231223175745726.png" alt="image-20231223175745726"></p><p>我们可以发现请求列表中关于登录请求的标头(Headers)中，我们可以看到请求地址（Request URL），请求方式（Request Method）是 <strong>POST</strong>，状态码为 <strong>302</strong>。</p><blockquote><p>Tips：<strong>302</strong> 表示临时页面跳转，所以登录后会跳转到首页。</p></blockquote><p>和 <strong>GET</strong> 一样，<strong>POST</strong> 也是请求方式的一种。除此之外还有 <strong>PUT</strong>、<strong>DELETE</strong> 等方式，但最常用的还是 <strong>GET</strong> 和 <strong>POST</strong>。</p><p>它俩的区别是:</p><ul><li><p>本质上的区别:</p><ul><li><p><strong>GET</strong> 用于获取数据，比如刷微博；</p></li><li><p><strong>POST</strong> 用于提交数据，比如登录微博。</p></li></ul></li><li><p>形式上的区别:</p><ul><li><p><strong>GET</strong> 的参数显示在请求地址里；</p></li><li><p><strong>POST</strong> 的参数隐藏在 <strong>Form Data</strong> 里。</p></li></ul></li></ul><p><img src="/2023/12/23/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-4-%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/image-20231223191510621.png" alt="image-20231223191510621"></p><p><strong>log</strong> 是用户名，<strong>pwd</strong> 是密码，<strong>wp-submit</strong> 是提交类型，<strong>redirect_to</strong> 是登录后的跳转地址，<strong>test_cookie</strong> 不知道，可以先不管。</p><p>和发送 <strong>GET</strong> 请求一样，<strong>requests</strong> 库发送 <strong>POST</strong> 请求也很简单。我们看看官方文档中的介绍：</p><p><img src="/2023/12/23/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-4-%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/image-20231223191721715.png" alt="image-20231223191721715"></p><p>可以看到，我们通过 <strong>requests.post()</strong> 发送 <strong>POST</strong> 请求，而 <strong>POST</strong> 请求的参数通过字典的形式传递给 <strong>data</strong> 参数。因此，博客的登录操作可以用代码这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&#x27;log&#x27;</span>: <span class="string">&#x27;xx用户名xx&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pwd&#x27;</span>: <span class="string">&#x27;xx密码xx&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;wp-submit&#x27;</span>: <span class="string">&#x27;登录&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;redirect_to&#x27;</span>: <span class="string">&#x27;xx登录网站xx&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;testcookie&#x27;</span>: <span class="string">&#x27;1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">requests.post(<span class="string">&#x27;xx请求网站xx&#x27;</span>, data=data, headers=headers)</span><br></pre></td></tr></table></figure><blockquote><p>请求网站在标头中可以找到</p></blockquote><p>在发出 <strong>POST</strong> 请求之后，服务器会在 <strong>Response Headers</strong>（响应头）里返回一些关于该请求的信息。有内容的格式、内容大小、过期时间等信息，我们重点关注的是有关登录的信息——<strong>set-cookie</strong>。</p><p><img src="/2023/12/23/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-4-%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/image-20231223191949432.png" alt="image-20231223191949432"></p><p><strong>set-cookie</strong> 的作用是在浏览器中写入 <strong>cookie</strong>，之后的请求中会带上 <strong>cookie</strong> 信息。而我们的登录信息就藏在其中，所以在登录后，服务器能判断出我们是否已经登录。</p><h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p>简单地说，<strong>cookie</strong> 是浏览器储存在用户电脑上的一小段文本文件。该文件里存了加密后的用户信息，过期时间等，且每次请求都会带上 <strong>cookie</strong>。所以，你登录过某网站后，下次再次打开该网站便不再需要登录。</p><p>因为 <strong>cookie</strong> 有过期时间，因此一段时间之后，<strong>cookie</strong> 便会失效，需要你再次重新登录，生成新的 <strong>cookie</strong>。<strong>cookie</strong> 就像一张通行证，当没有或通行证过期了，就无法通过，需要重新办理通行证才行。</p><p><img src="/2023/12/23/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-4-%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/image-20231223192027251.png" alt="image-20231223192027251"></p><p>我们也可以用<code>r.cookies</code>将cookies打印出来</p><h1 id="使用cookies模拟登录"><a href="#使用cookies模拟登录" class="headerlink" title="使用cookies模拟登录"></a>使用cookies模拟登录</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 登录参数</span></span><br><span class="line">login_data = &#123;</span><br><span class="line">  <span class="string">&#x27;log&#x27;</span>: <span class="string">&#x27;xx用户名xx&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pwd&#x27;</span>: <span class="string">&#x27;xx密码xx&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;wp-submit&#x27;</span>: <span class="string">&#x27;登录&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;redirect_to&#x27;</span>: <span class="string">&#x27;xx登录网站xx&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;testcookie&#x27;</span>: <span class="string">&#x27;1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发请求登录</span></span><br><span class="line">login_req = requests.post(<span class="string">&#x27;xx请求网站xx&#x27;</span>, data=login_data, headers=headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取登录后的 cookies</span></span><br><span class="line">shared_cookies = login_req.cookies</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将登录后的 cookies 传递给 cookies 参数用于获取文章页面内容</span></span><br><span class="line">res = requests.get(<span class="string">&#x27;xx文章网站xx&#x27;</span>, cookies=shared_cookies, headers=headers)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>requests</strong> 请求之间的 <strong>cookie</strong> 不共享。因此，我们需要手动将登录过后的 <strong>cookie</strong> 传给爬取文章的请求。</p><p>登录成功后，我们通过 <code>login_req.cookies</code> 拿到登录后的 <code>cookie</code>，赋值给变量 <code>shared_cookies</code>，然后将其传递给查看文章请求的 <code>cookies</code> 参数，这样查看文章也有了登录状态，让我们顺利解析页面。</p><h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p>因为 <strong>HTTP</strong> 是无状态的，在一次请求、响应结束过后，连接就断开了。再次发起请求时，之前的状态全都丢失了，服务器也不再“认识你”。</p><p>有了 <strong>cookie</strong> 之后，我们可以将一些信息存到其中，比如用户身份信息等。但因为 <strong>cookie</strong> 容量有限，只有 <strong>4KB</strong>。因此，不可能将所有的用户信息都存到里面。这时候，<strong>session</strong> 就出现了。</p><p><strong>session</strong> 相当于在服务器上建立的一份用户档案，<strong>cookie</strong> 中只要存储用户的身份信息，服务器通过身份信息在 <strong>session</strong> 中查询用户的其他信息。这样一来，我们的所有操作都会被保留。比如我们添加到购物车的商品，重新打开页面后仍会被保留。</p><p>这么好用的东西，<strong>requests</strong> 库当然也支持。我们来看看官方文档中的关于 <strong>session</strong> 介绍：</p><p><img src="/2023/12/23/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-4-%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/image-20231223193127920.png" alt="image-20231223193127920"></p><p>文档说，我们可以通过 <strong>requests.Session()</strong> 创建一个 <strong>session</strong>，注意 <strong>S</strong> 要大写。然后我们就可以像使用 <strong>requests</strong> 一样使用 <strong>session</strong> 对象了，<strong>get()<strong>、</strong>post()</strong> 等方法统统都有，只需将原先的 <strong>requests</strong> 替换成我们创建的 <strong>session</strong> 即可。</p><p>有了 <strong>session</strong>，多个请求之间就可以共享 <strong>cookie</strong> 了，后续请求便不再需要传 <strong>cookies</strong> 参数。</p><p>除了 <strong>cookies</strong> 参数每次都要传很麻烦，<strong>headers</strong> 参数每次都要传也很麻烦。如果想要共享 <strong>headers</strong> 的话，可以像下面这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">session = requests.Session()</span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 设置 session 的全局 headers</span></span><br><span class="line">session.headers.update(headers)</span><br><span class="line"><span class="comment"># 默认使用全局的 headers</span></span><br><span class="line">session.get(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment"># 自定义 headers</span></span><br><span class="line">custom_headers = &#123; <span class="string">&#x27;referer&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line">session.get(<span class="string">&#x27;&#x27;</span>, headers=custom_headers)</span><br><span class="line"><span class="comment"># 既有全局的 user-agent 也有自定义的 referer</span></span><br></pre></td></tr></table></figure><p>我们可以通过 <strong>session.headers.update()</strong> 方法来更新全局的 <strong>headers</strong>，通过该 <strong>session</strong> 发送的请求都会使用我们设置的全局 <strong>headers</strong>。</p><p>当全局 <strong>headers</strong> 不满足我们的需求时，也可以给某个请求单独设置 <strong>headers</strong>。这时，该请求将同时拥有全局和单独设置的 <strong>headers</strong>。如果两个 <strong>headers</strong> 里的字段重复，会优先使用单独设置的 <strong>headers</strong> 字段的值。</p><p>因此，之前发的代码可以改写成下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 登录参数</span></span><br><span class="line">login_data = &#123;</span><br><span class="line">  <span class="string">&#x27;log&#x27;</span>: <span class="string">&#x27;xx用户名xx&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pwd&#x27;</span>: <span class="string">&#x27;xx密码xx&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;wp-submit&#x27;</span>: <span class="string">&#x27;登录&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;redirect_to&#x27;</span>: <span class="string">&#x27;xx登录网站xx&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;testcookie&#x27;</span>: <span class="string">&#x27;1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">session = requests.Session()</span><br><span class="line">session.headers.update(headers)</span><br><span class="line"><span class="comment"># 使用 session 登录</span></span><br><span class="line">login_req = session.post(<span class="string">&#x27;xx请求网站xx&#x27;</span>, data=login_data)</span><br><span class="line"><span class="comment"># 使用 session 获得 Python 分类文章</span></span><br><span class="line">comment_req = session.get(<span class="string">&#x27;xx文章网站xx&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相比之前，我们的代码又简洁了很多, 并且在向同一个网站发送多个请求时，使用 <strong>session</strong> 可以复用 TCP 连接，从而带来显著的性能提升.</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP—面对对象</title>
      <link href="/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP—基础语法</title>
      <link href="/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数组之前的知识是基础中的基础就不再整理了,只挑几个稍微要看一下的。</p><h1 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h1><p>基本语法例子示范</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> day = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Monday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Tuesday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Wednesday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thursday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Friday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Weekend&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果为 Wednesday；</p></blockquote><p>如果case语句中没有break;那么将执行该case下的所有语句:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> day = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Monday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 没有break，继续执行下一个case</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Tuesday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 没有break，继续执行下一个case</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Wednesday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 没有break，继续执行下一个case</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thursday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 没有break，继续执行下一个case</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Friday&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 没有break，继续执行下一个case</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Weekend&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Wednesday</span><br><span class="line">Thursday</span><br><span class="line">Friday</span><br><span class="line">Weekend</span><br></pre></td></tr></table></figure></blockquote><p>其他需要注意的点:</p><ul><li><p>switch后圆括号中的表达式的类型只能是整型或能够隐式转换为整型的类型(如字符型,或枚举型)</p></li><li><p>每个case语句后必须是与表达式类型兼容的一个常量(但不能是<strong>字符串常量</strong>)</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> grade = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:  <span class="comment">// 字符常量，与表达式类型兼容</span></span><br><span class="line">            <span class="comment">// 代码块</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:    <span class="comment">// 整数常量，与表达式类型兼容</span></span><br><span class="line">            <span class="comment">// 代码块</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2.5</span>:  <span class="comment">// 错误，浮点数常量与字符类型不兼容</span></span><br><span class="line">            <span class="comment">// 代码块</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:  <span class="comment">// 错误，字符串常量不兼容</span></span><br><span class="line">            <span class="comment">// 代码块</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h1><p>基本语法例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (count &lt; <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意while后面有<strong>分号;</strong></li></ul><h1 id="字符串数组常用函数"><a href="#字符串数组常用函数" class="headerlink" title="字符串数组常用函数"></a>字符串数组常用函数</h1><h2 id="strcat-字符串连接函数"><a href="#strcat-字符串连接函数" class="headerlink" title="strcat-字符串连接函数"></a>strcat-字符串连接函数</h2><h3 id="函数原形"><a href="#函数原形" class="headerlink" title="函数原形:"></a>函数原形:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcat</span><span class="params">(<span class="type">char</span> str1[],<span class="type">const</span> <span class="type">char</span> str2[])</span></span>;</span><br></pre></td></tr></table></figure><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>把str2中的字符串连接到str1字符的后面, str1中字符的结束标志<code>\0</code>被st2里的字符串及其结束标志所覆盖。本函数返回值是str1的首地址。</p><p><img src="/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-20231220200644095.png" alt="image-20231220200644095"></p><h2 id="strcpy-字符串复制函数"><a href="#strcpy-字符串复制函数" class="headerlink" title="strcpy-字符串复制函数"></a>strcpy-字符串复制函数</h2><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcat</span><span class="params">(<span class="type">char</span> str1[],<span class="type">const</span> <span class="type">char</span> str2[])</span></span>;</span><br></pre></td></tr></table></figure><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>把str2中的字符串复制到str1中，str2中的串结束标志”\0”也一同复制。参数str2还可以是一个字符串常量，这时相当于把一个字符串赋予一个字符数组。</p><p><img src="/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-20231220200904869.png" alt="image-20231220200904869"></p><h2 id="strcmp-字符串比较函数"><a href="#strcmp-字符串比较函数" class="headerlink" title="strcmp-字符串比较函数"></a>strcmp-字符串比较函数</h2><h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> str1[],<span class="type">const</span> <span class="type">char</span> str2[])</span></span>;</span><br></pre></td></tr></table></figure><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>依照ASCII码表中的值的大小，依次比较两个字符串中对应位置上的字符，并由函数返回值返回比较结果。</p><p><img src="/2023/12/20/CPP-CPP%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-CPP%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-20231220201312707.png" alt="image-20231220201312707"></p><h2 id="strlen-计算字符串长度函数"><a href="#strlen-计算字符串长度函数" class="headerlink" title="strlen-计算字符串长度函数"></a>strlen-计算字符串长度函数</h2><h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> str[])</span></span>;</span><br></pre></td></tr></table></figure><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><p>计算字符串中的长度,返回首次出现的结束标志<code>\0</code>之前的字符数,并作为返回值。</p><blockquote><p>计算时不包括\0</p></blockquote><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="指针的定义与声明"><a href="#指针的定义与声明" class="headerlink" title="指针的定义与声明"></a>指针的定义与声明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr;  <span class="comment">// 定义一个指向整数的指针</span></span><br><span class="line"><span class="type">double</span> *dblPtr;  <span class="comment">// 定义一个指向双精度浮点数的指针</span></span><br><span class="line"><span class="type">char</span> *charPtr;  <span class="comment">// 定义一个指向字符的指针</span></span><br></pre></td></tr></table></figure><h2 id="取地址操作符"><a href="#取地址操作符" class="headerlink" title="取地址操作符&amp;"></a>取地址操作符<code>&amp;</code></h2><p>取地址操作符 <code>&amp;</code> 用于获取变量的内存地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;number;  <span class="comment">// 将变量number的地址赋给指针ptr</span></span><br></pre></td></tr></table></figure><h2 id="指针和函数"><a href="#指针和函数" class="headerlink" title="指针和函数:"></a>指针和函数:</h2><p>指针可以用于传递地址，从而在函数中修改实际参数的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyValue</span><span class="params">(<span class="type">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">    *ptr = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span> *ptr = &amp;number;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">modifyValue</span>(ptr);  <span class="comment">// 传递指向number的指针给函数</span></span><br><span class="line">    <span class="comment">// 现在，number的值被修改为100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针解引用操作符"><a href="#指针解引用操作符" class="headerlink" title="指针解引用操作符 *"></a>指针解引用操作符 <code>*</code></h2><p>指针解引用操作符 <code>*</code> 用于访问指针所指向地址的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = *ptr;  <span class="comment">// 获取ptr指针所指向地址的值，将其赋给变量value</span></span><br></pre></td></tr></table></figure><h2 id="动态内存分配与释放"><a href="#动态内存分配与释放" class="headerlink" title="动态内存分配与释放:"></a>动态内存分配与释放:</h2><p>使用 <code>new</code> 操作符可以在运行时动态分配内存，而 <code>delete</code> 操作符用于释放动态分配的内存：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *dynamicPtr = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">// 动态分配一个整数大小的内存空间</span></span><br><span class="line"><span class="comment">// 使用 dynamicPtr 操作内存</span></span><br><span class="line"><span class="keyword">delete</span> dynamicPtr;  <span class="comment">// 释放动态分配的内存</span></span><br></pre></td></tr></table></figure><h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><p>指针和数组之间有着密切的关系，指针可以用于访问数组元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *arrPtr = numbers;  <span class="comment">// 将数组名赋给指针，指向数组的第一个元素</span></span><br></pre></td></tr></table></figure><h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p>空指针表示不指向任何有效的内存地址。在C++中，可以使用 <code>nullptr</code> 来表示空指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *nullPtr = <span class="literal">nullptr</span>;  <span class="comment">// 定义一个空指针</span></span><br></pre></td></tr></table></figure><h2 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h2><ul><li><p>常量指针：指针本身不可变，但指向的值可变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr = &amp;value;  <span class="comment">// 指向常量的指针</span></span><br></pre></td></tr></table></figure></li><li><p>指针常量：指向的值不可变，但指针本身可变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> ptr = &amp;value;  <span class="comment">// 常量指针</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表的创建"><a href="#链表的创建" class="headerlink" title="链表的创建"></a>链表的创建</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Set a, b;</span><br><span class="line"><span class="built_in">init</span>(&amp;a);</span><br><span class="line"><span class="built_in">init</span>(&amp;b);</span><br><span class="line"><span class="built_in">createSet</span>(&amp;a);</span><br><span class="line"><span class="built_in">createSet</span>(&amp;b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n, k, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k &gt;&gt; m;</span><br><span class="line">List lst;</span><br><span class="line"><span class="built_in">createList</span>(lst, n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向前插入生成"><a href="#向前插入生成" class="headerlink" title="向前插入生成"></a>向前插入生成</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Set</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">Node* head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(Set* x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">x-&gt;num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createSet</span><span class="params">(Set* x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//生成链表时一定采用往前插入的方法，即每个新产生的结点插入到链表的第一个结点的前面。</span></span><br><span class="line"><span class="type">int</span> n, i;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">Node* node = <span class="keyword">new</span> Node;</span><br><span class="line">cin &gt;&gt; node-&gt;data;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">x-&gt;head = node;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">Node* node = <span class="keyword">new</span> Node;</span><br><span class="line">cin &gt;&gt; node -&gt; data;</span><br><span class="line">node -&gt; next = x-&gt;head;</span><br><span class="line">x-&gt;head = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="向后插入"><a href="#向后插入" class="headerlink" title="向后插入"></a>向后插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span> &#123;</span><br><span class="line"></span><br><span class="line">Node* head;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createList</span><span class="params">(List&amp; lst, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">//生成链表时采用往后插入的方法，即每个新结点插入到链表尾部。</span></span><br><span class="line">lst.length = n;</span><br><span class="line">Node* _head = <span class="keyword">new</span> Node;</span><br><span class="line">_head-&gt;data = <span class="number">1</span>;</span><br><span class="line">lst.head = _head;</span><br><span class="line">Node* tail = _head;</span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (i; i &lt;= n; i++) &#123;</span><br><span class="line">Node* node = <span class="keyword">new</span> Node;</span><br><span class="line">node-&gt;data = i;</span><br><span class="line">tail-&gt;next = node;</span><br><span class="line">tail = tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h1><h2 id="漂亮的递归"><a href="#漂亮的递归" class="headerlink" title="漂亮的递归"></a>漂亮的递归</h2><p>【问题描述】键盘输入正整数 n，求出n与其反序数x之和并输出。例如，输入2038，n+x &#x3D; 2038 +8302 &#x3D;10340，输出应为10340。要求：编写函数实现数据转换成反序数值。【输入形式】输入一个整数； 【输出形式】输出一个整数； 【样例输入】2038 【样例输出】10340 【样例说明】不要任何输入输出的文字提示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> store = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">10</span>) <span class="keyword">return</span> store + n;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">store += n % <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reverse</span>(n / <span class="number">10</span>, store * <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n, reverse_num;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line">reverse_num = <span class="built_in">reverse</span>(n);</span><br><span class="line">std::cout &lt;&lt; n + reverse_num;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>写递归最关键的地方在于<strong>基本条件</strong>，基本条件出来了，递归的转折点也就出来了。</p></blockquote><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的旋转"><a href="#数组的旋转" class="headerlink" title="数组的旋转"></a>数组的旋转</h3><p><strong>【问题描述】</strong> 旋转是图像处理的基本操作，在这个问题中，你需要将一个图像逆时针旋转90度。 计算机中的图像表示可以用一个矩阵来表示，为了旋转一个图像，只需要将对应的矩阵旋转即可。 <strong>【输入格式】</strong> 输入的第一行包含两个整数n, m（1≤n, m≤10），分别表示图像矩阵的行数和列数。 接下来n行每行包含m个整数，表示输入的图像。 </p><p><strong>【输出格式】</strong> 输出m行，每行包含n个整数，表示原始矩阵逆时针旋转90度后的矩阵。每行后空格结束。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【样例输入】</span><br><span class="line">        2 3</span><br><span class="line">        1 5 3</span><br><span class="line">        3 2 4</span><br><span class="line">【样例输出】</span><br><span class="line">        3 4 </span><br><span class="line">        5 2 </span><br><span class="line">        1 3 </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> ls[<span class="number">10</span>][<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> ls2[<span class="number">10</span>][<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//初始化ls数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; ls[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数组旋转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            ls2[i][j] = ls[j][m - i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出旋转后的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cout &lt;&lt; ls2[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>也可以动态开辟:</p><p>&#x2F;&#x2F; 使用new运算符分配内存<br>int** ls &#x3D; new int* [n];<br>for (int i &#x3D; 0; i &lt; n; ++i) {<br>    ls[i] &#x3D; new int[m];<br>}<br>for (int i &#x3D; 0; i &lt; n; i++) {<br>    for (int j &#x3D; 0; j &lt; m; j++) {<br>        cin &gt;&gt; ls[i][j];<br>    }<br>}</p></blockquote><h3 id="求二维数组的鞍点"><a href="#求二维数组的鞍点" class="headerlink" title="求二维数组的鞍点"></a>求二维数组的鞍点</h3><p>【问题描述】找出一个二维数组（以三行四列的数组为例）中的鞍点，即该位置上的元素在该行上值最大，在该列上值最小（也可能没有鞍点）。</p><p>【输入形式】二维数组（以三行四列的数组为例）</p><p>【输出形式】如果有鞍点，输出鞍点的值及所在行列（例如[1][2]&#x3D;96 is Saddle Point），如果没有，输出没有鞍点（例如 No Saddle Point）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【样例输入】 </span><br><span class="line">  9 80 205 40</span><br><span class="line">  90 60 96 1</span><br><span class="line">  210 3 101 89</span><br><span class="line">【样例输出】</span><br><span class="line">  [1][2]=96 is Saddle Point</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ls[<span class="number">3</span>][<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> min = <span class="number">999</span>, max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">cin &gt;&gt; ls[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (ls[i][j] &gt; max) &#123;</span><br><span class="line">max = ls[i][j];</span><br><span class="line">col = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (ls[j][col] &lt; min) &#123;</span><br><span class="line">min = ls[j][col];</span><br><span class="line">row = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ls[row][col] == max) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">max = <span class="number">0</span>;</span><br><span class="line">min = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (min == max) cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; row &lt;&lt; <span class="string">&#x27;]&#x27;</span> &lt;&lt; <span class="string">&#x27;[&#x27;</span> &lt;&lt; col &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; min &lt;&lt; <span class="string">&quot; is Saddle Point&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;NO&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h3><p>【题目描述】<br>输入一个字符串（长度不超过255），请找出字符串中的所有的正整数（如-12，当作12），然后输出其中的素数。如果出现12.5，则看作12和5两个整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【样例输入】</span><br><span class="line"> How3.5many12prime-17number79inthestring.</span><br><span class="line">【样例输出】</span><br><span class="line"> 3 5 17 79</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; str.<span class="built_in">length</span>()) &#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (str[i] &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">num = num * <span class="number">10</span> + str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">is_prime</span>(num) &amp;&amp; num &gt; <span class="number">1</span>) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫笔记(三)—动态网站爬取</title>
      <link href="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-3-%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%88%AC%E5%8F%96/"/>
      <url>/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-3-%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%88%AC%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>这篇我们将学习网页加载数据的另一种方式——通过 <strong>API</strong>（Application Programming Interface，应用程序编程接口）加载数据，并利用 API 完成动态网页爬虫。</p><p>我们爬虫还分静态爬取和动态爬取？</p><p>因为一次性加载整个网站很慢，为了提升网页加载速度，有些网站将网站的骨架和内容拆分开，加载骨架后再通过多个请求获取内容，最终组成完整的网站。而有些老的网站或轻量级网站，仍然是一次性返回整个网站的内容，比如豆瓣。</p><p>像电影评论这样的信息是瞬息万变的，可能短短数小时内就多出几百、上千条。如果将每条评论的数据，都通过 HTML 代码的形式写进网页中，那么评论每发生一次变化，就要相应地改变代码，非常繁琐。</p><p>那这种实时改变的数据是怎样展现到我们面前的呢？这就是我们今天课程的重点——网页可以通过 API 获取数据，实时更新内容。<strong>API 即应用程序接口</strong>，它规定了网页与服务器之间可以交互什么数据、通过什么样的方式进行交互。</p><blockquote><p>Network面板介绍</p></blockquote><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-3-%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%88%AC%E5%8F%96/image-20231219233524200.png" alt="image-20231219233524200"></p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-3-%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%88%AC%E5%8F%96/image-20231220190956527.png" alt="image-20231220190956527"></p><h1 id="什么是XHR"><a href="#什么是XHR" class="headerlink" title="什么是XHR"></a>什么是XHR</h1><p>有些网站为了提升网页加载速度，会先加载骨架，再加载详细的内容。而加载详细内容的过程，就用到了 XHR 技术。</p><p>XHR 全称 <strong>XMLHttpRequest</strong>，是浏览器内置的对象。浏览器想要在不刷新网页前提下加载、更新局部内容时，必须通过 XHR 向存放数据的服务器发送请求。</p><p>也就是说XHR 类型请求里，就藏着我们需要的搜索结果。</p><p>我们以<a href="http://movie.mtime.com/251525/reviews">时光网</a>为例子,我们打开Network，清空，类型请求选择<code>XHR</code>.</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-3-%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%88%AC%E5%8F%96/image-20231219234652286.png" alt="image-20231219234652286"></p><p>我们点开comment开头的这条请求,然后点击<strong>预览(preview)</strong></p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-3-%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%88%AC%E5%8F%96/image-20231219234959741.png" alt="image-20231219234959741"></p><p>对照网页实际内容，我们可以确认影评的数据就是 <strong>content</strong> 中的信息。</p><p>我们接下来点击 <strong>标头(Headers)</strong> 里的 <strong>常规(General)</strong> 看看影评数据是如何获取到的</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-3-%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%88%AC%E5%8F%96/image-20231219235135276.png" alt="image-20231219235135276"></p><p>从图中我们可以看到，时光网规定了需要通过 <strong>GET</strong> 方法，向 <strong>Request URL</strong> 发送请求。点击第二页查看电影评论的行为，实际上是浏览器帮我们自动填充查询参数，向时光网获取短影评数据，参数详情为：</p><ul><li>id 为 251525 (<strong>movieId&#x3D;251525</strong>) ；</li><li>第 2 页内容 (<strong>pageIndex&#x3D;1</strong>)；</li><li>每页 20 条 (<strong>pageSize&#x3D;20</strong>)。</li></ul><p>像这种遵循某种规则向指定 URL 发送请求，从而获得相应数据的过程，就是 <strong>通过 API 获取数据</strong>。</p><p>另外，为了防止被网站反爬，我们还要在 标头(Headers) 中观察一下 <strong>请求头（Request Headers）</strong>，有两个参数要注意。</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-3-%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%88%AC%E5%8F%96/image-20231219235346281.png" alt="image-20231219235346281"></p><p><strong>user-agent</strong> 我们之前已经说过，用途是将爬虫伪装成浏览器；另外一个 <strong>referer</strong> 字段，字面意思是“发起者，发送人”，用来验证这个请求的发起方是否合法。也就是说，服务器要验证这个请求是由谁发出的，只接受从特写网页上发出该请求，比如这里就是时光网的网址。如果这个字段不加，可能会爬取失败。</p><p>既然找到了获取评论数据的真正链接，以及相关的请求头参数，接下来我们就可以试着通过爬虫来爬取数据了。我们仍然使用 <code>requests.get()</code> 方法获取刚才找到的 API 地址，但 <code>headers</code> 参数要加上 <code>referer</code> 的信息，假装是由时光网自身发起的请求，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;referer&#x27;</span>: <span class="string">&#x27;http://movie.mtime.com/&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">res = requests.get(<span class="string">&#x27;http://front-gateway.mtime.com/library/movie/comment.api?tt=1703000726720&amp;movieId=251525&amp;pageIndex=1&amp;pageSize=20&amp;orderType=1&#x27;</span>, headers=headers)</span><br><span class="line"><span class="built_in">print</span>(res.text)</span><br></pre></td></tr></table></figure><blockquote><p>上面代码中的链接中，<code>comment.api?</code> 后面的内容，是我们前面说过的 <strong>查询参数</strong>。这次的查询参数内容有些长，直接放在链接里有些乱。好在 <code>requests.get()</code> 方法提供了 <code>params</code> 参数，能让我们以字典的形式传递链接的查询参数，使代码看上去更加的整洁明了。</p><p>上一篇笔记文章提及的查询参数的链接<a href="%5BPython%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0(%E4%BA%8C">Python爬虫笔记(二)</a> | bai的小窝 (bailog.top)](<a href="https://www.bailog.top/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/#URL%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0">https://www.bailog.top/2023/12/19/Python-爬虫-爬虫基本知识速过-爬虫三步骤简讲/#URL查询参数</a>))</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">params = &#123;</span><br><span class="line">  <span class="string">&quot;tt&quot;</span>: <span class="string">&quot;1703000726720&quot;</span>,</span><br><span class="line">  <span class="string">&quot;movieId&quot;</span>: <span class="string">&quot;251525&quot;</span>,</span><br><span class="line">  <span class="string">&quot;pageIndex&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">  <span class="string">&quot;pageSize&quot;</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">  <span class="string">&quot;orderType&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = requests.get(</span><br><span class="line">  <span class="string">&#x27;http://front-gateway.mtime.com/library/movie/comment.api&#x27;</span>,</span><br><span class="line">  params=params,</span><br><span class="line">  headers=headers</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>五个参数中，<code>movieId</code> <code>pageIndex</code> <code>pageSize</code> 的意义我们可以根据字面意思猜到，应该分别代表 <strong>电影在时光网中的 ID</strong>，<strong>评论的第x页</strong> 和 <strong>每页评论数</strong>。</p><p>那剩下的 <code>orderType</code> 和 <code>tt</code> 是什么？</p><p><code>orderType</code> 字面意思是排序方式，而我们发现，短影评页的右上方的确是有这个选项的。值为 <strong>1</strong> 代表的应该就是按最热排序。</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-3-%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%88%AC%E5%8F%96/image-20231219235758771.png" alt="image-20231219235758771"></p><p>剩下的tt可能是 Unix 时间戳，依据有三个：</p><ul><li>以 15、16、17 开头，是长整数，与当下时间戳的开头值相符；</li><li>字母 t 本身也可能和 time（时间）有关；</li><li>多次尝试刷新网页，重复发起请求，发现 <code>tt</code> 的值每次都在变大，非常像时间的增长。</li></ul><blockquote><p>Unix 时间戳是指格林威治时间 1970 年 01 月 01 日 00 时 00 分 00 秒起至现在的总秒数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="built_in">print</span>(time.time())</span><br><span class="line"><span class="comment"># 输出1703001651.4214966</span></span><br></pre></td></tr></table></figure><p>两两比较，我们基本可以确定<code>tt</code>就是时间戳了</p><blockquote><p>我们可以在这个网站 (<a href="https://tool.lu/timestamp/">tool.lu&#x2F;timestamp&#x2F;</a>) 检查 <code>tt</code> 的值对应的北京时间，单位选毫秒</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-3-%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%88%AC%E5%8F%96/image-20231220000310452.png" alt="image-20231220000310452"></p></blockquote><p>因此我们可以将<code>params</code>修改为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">params = &#123;</span><br><span class="line">  <span class="comment"># 将当前时间戳转为毫秒后取整，作为 tt 的值</span></span><br><span class="line">  <span class="string">&quot;tt&quot;</span>: <span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">int</span>(time.time() * <span class="number">1000</span>)),</span><br><span class="line">  <span class="string">&quot;movieId&quot;</span>: <span class="string">&quot;251525&quot;</span>,</span><br><span class="line">  <span class="string">&quot;pageIndex&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">  <span class="string">&quot;pageSize&quot;</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">  <span class="string">&quot;orderType&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;code&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;count&quot;</span>: <span class="number">3307</span>,</span><br><span class="line">    <span class="string">&quot;hasMore&quot;</span>: true,</span><br><span class="line">    <span class="string">&quot;list&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;nickname&quot;</span>: <span class="string">&quot;瀛26000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;userImage&quot;</span>: <span class="string">&quot;https://img2.mtime.cn/u/285/2016285/7c677c7f-4503-42e9-a63f-683e9f97148c/128X128.jpg&quot;</span>,</span><br><span class="line">        <span class="string">&quot;rating&quot;</span>: <span class="string">&quot;8.5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: <span class="string">&quot;这是我看过的最有血有肉有人情味还紧跟时代潮流的一版哪吒了，没有金吒木吒只有哪吒，李靖没有让人讨厌的琵琶精小老婆，敖丙也不是奸淫掳掠无恶不作的龙二代，申公豹的口吃设计也承包了一部分笑点，太乙真人的火锅味&quot;</span>,</span><br><span class="line">...省略剩下的内容</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">...省略剩下的内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从打印结果上看，<code>res.text</code> 是多层级的字典吗？并不是，只是长得像字典的字符串罢了，我们可以验证一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(res.text))</span><br><span class="line"><span class="comment"># 输出：&lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>这种长得像字典的字符串，是一种名为 <strong>JSON</strong> 的数据格式。我们需要将其转换成真正的 <strong>字典&#x2F;列表</strong>，才能从中提取出评论数据。所以，接下来我们学习 <strong>JSON</strong> 来将其转换成字典&#x2F;列表。</p><h1 id="什么是-JSON"><a href="#什么是-JSON" class="headerlink" title="什么是 JSON"></a>什么是 JSON</h1><p><strong>JSON</strong>（JavaScript Object Notation）是一种轻量级的数据交换格式。 易于人阅读和编写，同时也易于机器解析和生成。</p><p><strong>JSON</strong> 建构于两种结构：<strong>键值对的集合</strong> 和 <strong>值的有序列表</strong>，分别对应 Python 里的字典和列表，这些都是常见的数据结构。大部分现代计算机语言都支持 <strong>JSON</strong>，所以 <strong>JSON</strong> 是在编程语言之间通用的数据格式。</p><p><strong>JSON</strong> 本质上就是一个字符串，只是该字符串符合特定的格式要求。也就是说，我们将字典、列表等用字符串的形式写出来就是 <strong>JSON</strong>，就像下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典</span></span><br><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;price&#x27;</span>: <span class="number">233</span>&#125;</span><br><span class="line"><span class="comment"># JSON</span></span><br><span class="line">json = <span class="string">&#x27;&#123;&quot;price&quot;: 233&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>]</span><br><span class="line"><span class="comment"># JSON</span></span><br><span class="line">json = <span class="string">&#x27;[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>Tips：Python 字符串使用单引号或双引号没有区别，但 <strong>JSON</strong> 中，字符串必须使用英文的双引号来包裹。</p></blockquote><p>而 <strong>JSON</strong> 是一种标准，规定了基本数据结构的写法，不同的编程语言拿到后解析成自己对应的数据结构即可。</p><h1 id="如何解析-JSON"><a href="#如何解析-JSON" class="headerlink" title="如何解析 JSON"></a>如何解析 JSON</h1><p>我们可以查看request库的官方文档[request库](<a href="https://requests.readthedocs.io/projects/cn/zh-cn/latest/">Requests: 让 HTTP 服务人类 — Requests 2.18.1 文档</a>)</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-3-%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%88%AC%E5%8F%96/image-20231220002141056.png" alt="image-20231220002141056"></p><p>通过调用 <strong>json()</strong> 方法即可对响应内容解码，当然内容必须得是 <strong>JSON</strong> 格式的，否则将会报错。转换后的结果是 Python 中对应的<strong>字典或列表</strong>，我们便可根据 Python 的基础知识提取我们需要的数据。不再需要通过 <strong>BeautifulSoup</strong> 对网页源代码解析，然后再提取数据了。</p><p>我们试着调用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;referer&#x27;</span>: <span class="string">&#x27;http://movie.mtime.com/&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">params = &#123;</span><br><span class="line">  <span class="comment"># 将当前时间戳转为毫秒后取整，作为 tt 的值</span></span><br><span class="line">  <span class="string">&quot;tt&quot;</span>: <span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">int</span>(time.time() * <span class="number">1000</span>)),</span><br><span class="line">  <span class="string">&quot;movieId&quot;</span>: <span class="string">&quot;251525&quot;</span>,</span><br><span class="line">  <span class="string">&quot;pageIndex&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">  <span class="string">&quot;pageSize&quot;</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">  <span class="string">&quot;orderType&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = requests.get(</span><br><span class="line">  <span class="string">&#x27;http://front-gateway.mtime.com/library/movie/comment.api&#x27;</span>,</span><br><span class="line">  params=params,</span><br><span class="line">  headers=headers)</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(res.json()))</span><br><span class="line"><span class="comment"># 输出：&lt;class &#x27;dict&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>res.json()</code> 方法的返回的是真正 <code>dict</code>（字典），这样我们就能从中提取数据了。根据之前说的，评论数据就在 <code>data</code> 下的 <code>list</code> 中，<code>list</code> 中有 0-19 的索引，每个编号展开都有 <code>nickname</code>，<code>content</code> 等信息，短影评就是 <code>content</code> 中的内容。</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-3-%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%88%AC%E5%8F%96/image-20231220002444013.png" alt="image-20231220002444013"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = res.json()</span><br><span class="line"><span class="built_in">print</span>(result[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;list&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;content&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 适合高中及以下年龄段观看，而且全场多处尬场</span></span><br></pre></td></tr></table></figure><p>最后如何爬取多页将交给你们自己研究</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-3-%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%88%AC%E5%8F%96/image-20231220002730535.png" alt="image-20231220002730535"></p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-3-%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%88%AC%E5%8F%96/image-20231220002918208.png" alt="image-20231220002918208"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫笔记(二)—爬虫三步骤简讲-静态网站爬取</title>
      <link href="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-2-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/"/>
      <url>/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-2-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫三步骤简讲"><a href="#爬虫三步骤简讲" class="headerlink" title="爬虫三步骤简讲"></a>爬虫三步骤简讲</h1><ul><li>获取数据</li><li>解析数据</li><li>提取数据</li></ul><h1 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h1><h2 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h2><p>安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple requests</span><br></pre></td></tr></table></figure><p>安装完成后，在命令行中输入 <code>pip show requests</code>,能看到 requests 库的版本、简介等信息，说明你已经安装成功啦。</p><p>用request库访问页面只需要一步:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">res = requests.get(<span class="string">&#x27;https://book.douban.com/top250/&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>上面第二行代码我们调用了 requests 库中的 <code>get()</code> 方法，让 Python 帮我们调用计算机网络服务，向传入的 URL 发送请求，并把收到的响应保存到变量 <code>res</code>（response 简写）中。</p></blockquote><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-2-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219162841082.png" alt="image-20231219162841082"></p><blockquote><p>我们将res打印出来的结果不是html代码，而是&lt;Response [xxx]&gt;响应状态.</p></blockquote><h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><p>HTTP 响应内容不单单包括客户端所请求的资源本身，还包含响应状态等信息。因此 requests 库选择将获取的响应打包为 <code>Response</code> 对象，方便我们通过类的 <strong>属性</strong> 或 <strong>方法</strong> 获取想要的内容。而当我们打印 <code>Response</code> 对象本身时，Python 会按照 requests 库约定好的方式，打印出类名（Response）和本次响应状态码。</p><blockquote><p>我们可以查询<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/418">MDN网页开发者手册</a>来看具体错误原因:服务器拒绝冲泡咖啡，因为它是茶壶.</p></blockquote><p>418,这一状态码起源于 1998 年愚人节玩笑，现在多被网站开发者用作彩蛋，也经常用于警告爬虫程序：小心点，你已经被我看穿啦!</p><p>因此，我们用爬虫访问对象时,需要在request.get()里面加上消息头(headers)</p><h2 id="消息头-headers"><a href="#消息头-headers" class="headerlink" title="消息头(headers)"></a>消息头(headers)</h2><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-2-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219163736947.png" alt="image-20231219163736947"></p><p>我们没有加消息头相当于告诉网站，我是爬虫。因此我们需要在请求的时候附加上消息头，我们只需要将需要附上的信息组织成 <strong>字典</strong> 的格式，再通过 <code>headers</code> 参数传递给 <code>get()</code> 方法，requests 库帮我们向服务器发送请求时，就会自动带上这些信息了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># 定制消息头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="comment"># 消息头中有一项附加信息 user-agent</span></span><br><span class="line">  <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 携带消息头向服务器发送请求</span></span><br><span class="line">res = requests.get(<span class="string">&#x27;https://book.douban.com/top250/&#x27;</span>, headers=headers)</span><br></pre></td></tr></table></figure><blockquote><p>消息头不止user-agent，我们再后面还会说到params查询参数请求(url地址?后面的内容)和proxies代理(http,https)。</p></blockquote><p>requests库将响应的内容转化为<strong>字符串</strong>类型，保存到 Response 对象的 <code>text</code> 属性中，我们能很轻松地通过 <code>.</code> 运算符访问到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(res.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="comment"># &lt;html lang=&quot;zh-cmn-Hans&quot; class=&quot;ua-mac ua-webkit book-new-nav&quot;&gt;</span></span><br><span class="line"><span class="comment"># &lt;head&gt;</span></span><br><span class="line"><span class="comment">#   &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span></span><br><span class="line"><span class="comment">#   &lt;title&gt;豆瓣读书 Top 250&lt;/title&gt;</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>我们可以发现响应内容为HTML源码，接下来我们将说说如何提取出所需信息。</p><h1 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h1><blockquote><p>对于我们这个例子,因为他是静态网站,我们将使用<strong>bs4</strong>库来解析数据;后面我们还会说到用API和json来获取解析</p></blockquote><p><strong>bs4</strong> 中的 4 是版本号，<strong>bs</strong> 是它名称缩写，全称叫 <strong>BeautifulSoup</strong>——取自刘易斯·卡罗尔在《爱丽丝梦游仙境》里的同名诗歌。正如诗歌所言，<strong>BeautifulSoup</strong> 尝试化平淡为神奇，通过将网页源代码解析成 <strong>BeautifulSoup 对象</strong>，把结构复杂的网页代码内部组织关系捋得清清楚楚。</p><p>安装:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple bs4</span><br></pre></td></tr></table></figure><h2 id="BeautifulSoup-对象"><a href="#BeautifulSoup-对象" class="headerlink" title="BeautifulSoup 对象"></a>BeautifulSoup 对象</h2><p>我们在IDE中用ctrl+左键可以进入库中阅读他的说明文档</p><p>BeautifulSoup 类作用:</p><ul><li>创建 <strong>BeautifulSoup 对象</strong> 时，它会把 HTML&#x2F;XML 文档解析成 <strong>树形结构</strong></li><li>BeautifulSoup 类继承自 Tag 类，因此 BeautifulSoup 类和 Tag 类有许多共用的方法。</li></ul><p>创建 <strong>BeautifulSoup</strong> 对象时需要传入两个参数：</p><ul><li>所需解析的 <strong>HTML 代码</strong>，即响应的文本内容（<code>res.text</code>）；</li><li>用于解析 HTML 代码的 <strong>解析器</strong>，课程内使用的是 Python 内置解析器 <code>html.parser</code>（parser：解析器）。</li></ul><p>我们获取豆瓣读书 Top 250 页面内容并解析成 BeautifulSoup 对象的过程写成代码就是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 库</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># 从 bs4 库中导入 BeautifulSoup</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定制消息头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 发送带消息头的请求</span></span><br><span class="line">res = requests.get(<span class="string">&#x27;https://book.douban.com/top250&#x27;</span>, headers=headers)</span><br><span class="line"><span class="comment"># 创建 BeautifulSoup 对象，解析响应的文本内容</span></span><br><span class="line">soup = BeautifulSoup(res.text, <span class="string">&#x27;html.parser&#x27;</span>)</span><br></pre></td></tr></table></figure><p>按照文档的说法，此时我们得到的 <code>soup</code> 变量已经是解析好的 <strong>树形结构</strong>。这棵树长什么样子呢？我们打印出 <code>soup</code> 变量的 <strong>数据类型</strong> 和 <strong>值</strong> 看看</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-2-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219165322498.png" alt="image-20231219165322498"></p><p>打印出来的类型是&lt;class ‘bs4.BeautifulSoup’&gt;，而其值与源代码一模一样。</p><p>其实，它们只是看上去一样，实际上却是不同的东西。</p><p><strong>BeautifulSoup 对象</strong> 内部结构像一棵倒着生长的树，树根在上面，枝叶在下面，每个节点都对应着 HTML 代码中的一个元素。顺着这棵 <strong>HTML 文档树</strong>，我们就能定位到某个或某群具有相同特征的元素，从而提取出元素文本内容——也就是我们所需的数据。</p><h2 id="HTML-文档树"><a href="#HTML-文档树" class="headerlink" title="HTML 文档树"></a>HTML 文档树</h2><p>举个例子:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>我的网页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"> <span class="selector-tag">body</span> &#123; <span class="attribute">background-color</span>: <span class="number">#101324</span>; <span class="attribute">color</span>: <span class="number">#ffffff</span>; <span class="attribute">font-family</span>: -apple-system, BlinkMacSystemFont, <span class="string">&#x27;Segoe UI&#x27;</span>, Roboto, <span class="string">&#x27;Helvetica Neue&#x27;</span>, Arial, <span class="string">&#x27;Noto Sans&#x27;</span>, sans-serif, <span class="string">&#x27;Apple Color Emoji&#x27;</span>, <span class="string">&#x27;Segoe UI Emoji&#x27;</span>, <span class="string">&#x27;Segoe UI Symbol&#x27;</span>, <span class="string">&#x27;Noto Color Emoji&#x27;</span>; &#125; <span class="selector-tag">a</span> &#123; <span class="attribute">color</span>: <span class="number">#1890ff</span>; &#125; <span class="selector-tag">code</span> &#123; <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.15</span>); <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">6px</span>; <span class="attribute">border-radius</span>: <span class="number">4px</span>; <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.87</span>); &#125; <span class="selector-tag">img</span> &#123; <span class="attribute">width</span>: <span class="number">100%</span>; &#125; </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Web 真好玩！<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>今天我在 <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.bailog.top/&quot;</span>&gt;</span>bai的小屋<span class="tag">&lt;/<span class="name">a</span>&gt;</span> 学到了这些内容：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>HTML 基本语法<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>HTML 文档结构<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Elements 面板 <span class="tag">&lt;<span class="name">code</span>&gt;</span>Edit text<span class="tag">&lt;/<span class="name">code</span>&gt;</span> 功能<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>其中常见的 HTML 元素有这些：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://media-image1.baydn.com/storage_media_image/svpyor/ff5185b0ab456965c9f89c7506ed0a9e.bff6930d34f5dca7819b5e571f421b9b.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该 HTML 文档根节点为 <strong>html 元素</strong>。它有两个子节点，分别是 <strong>head 元素</strong> 和 <strong>body 元素</strong>。再往内推，head 与 body 内也分别包含诸多元素。我们将这些元素按照 <strong>根节点 – 子节点 – 子节点的子节点……</strong> 顺序从上至下梳理出的图谱，就是 <strong>HTML 文档树</strong>。</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-2-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219165622772.png" alt="image-20231219165622772"></p><p>一棵文档树就像是这些元素的族谱：</p><ul><li>html 元素是所有其它元素的 <strong>祖先</strong>，反过来说，其它元素都是 html 的 <strong>后代</strong>；</li><li>head 元素和 body 元素的 <strong>父节点</strong> 是 html 元素，因此它们是 html 的 <strong>直接后代</strong>；</li><li>由于 head 和 body 父节点相同，所以它们互为 <strong>兄弟节点</strong>；</li></ul><blockquote><p>a 元素的父节点是 p 元素，p 元素的父节点是 body 元素，a 和 body 之间隔了一层“血缘关系”，所以 a 是 body 的 <strong>后代</strong> 而不是 <strong>直接后代</strong>。这点一定要注意</p></blockquote><p>我们解析得到的 BeautifulSoup 对象，本质上就是这样一棵 HTML 文档树。树中每个节点都被抽象为了 <strong>Tag 对象</strong>。还记得吗？BeautifulSoup 类是继承自 Tag 类的，所以 BeautifulSoup 对象不仅代表着整棵 HTML 文档树，还代表着根节点。</p><h1 id="提取数据"><a href="#提取数据" class="headerlink" title="提取数据"></a>提取数据</h1><p>根据<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/#id19">BeautifulSoup 官方中文文档</a>,我们可以看到 bs4 库中提供了多种遍历、检索文档树的方法。其中一个最常用也最强大灵活的一个方法是:通过<strong>CSS选择器</strong>提取</p><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><p>CSS 选择器是 CSS 语言中的一部分，能通过 HTML 元素的 <strong>类型</strong>、<strong>标识</strong> 和 <strong>关系</strong> 快速选择符合条件的 <strong>所有元素</strong>。由于它简单、好用，也被广泛应用于其它领域。绝大多数与 Web 打交道的语言、工具都支持通过 <strong>CSS 选择器</strong> 检索 HTML 元素，比如我们今天学习的 bs4 库，比如网页开发者工具。</p><ul><li>网页开发者工具:<br>按<code>Ctrl + F</code>打开搜索栏，在搜索栏输入div，表示检索此类型元素，此时开发者工具会将所有符合条件的内容用黄色底色标注出来。</li></ul><p><strong>类别</strong>:</p><ul><li><p><strong>基本选择器</strong>：通过元素的 <strong>类型</strong>、<strong>class 属性值</strong>、<strong>id 属性值</strong> 检索；</p></li><li><p><strong>组合选择器</strong>：通过元素和元素之间的 <strong>关系</strong> 检索，分为 <strong>直接后代组合器</strong>、<strong>后代组合器</strong> 和 <strong>兄弟组合器</strong>。</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-2-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219171814988.png" alt="image-20231219171814988"></p></li></ul><h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><p>例子:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;poem&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>静夜思<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;density&quot;</span>&gt;</span>唐<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="symbol">&amp;bull;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;author&quot;</span>&gt;</span>李白<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;first&quot;</span>&gt;</span>床前明月光，疑是地上霜。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;second&quot;</span>&gt;</span>举头望明月，低头思故乡。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"> <span class="selector-class">.poem</span> &#123;<span class="attribute">text-align</span>: center;&#125; <span class="selector-id">#title</span> &#123;<span class="attribute">font-size</span>: <span class="number">1.3rem</span>; <span class="attribute">font-weight</span>: bold;&#125; <span class="selector-class">.info</span> &#123;<span class="attribute">font-weight</span>: lighter;&#125; <span class="selector-class">.content</span> &#123;<span class="attribute">margin-left</span>: <span class="number">0.5rem</span>;&#125; </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="poem">  <p id="title">静夜思</p>  <div class="info">    <span id="density">唐</span>    <span>&bull;</span>    <span id="author">李白</span>  </div>  <div class="content">    <p id="first">床前明月光，疑是地上霜。</p>    <p id="second">举头望明月，低头思故乡。</p>  </div></div><style> .poem {text-align: center;} #title {font-size: 1.3rem; font-weight: bold;} .info {font-weight: lighter;} .content {margin-left: 0.5rem;} </style><p>我们抛去 style 元素不看，那么整体 HTML 文档树是这样的：</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-2-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219171103712.png" alt="image-20231219171103712"></p><p>可以看到，文档树中有三个 p 元素，id 为 <code>title</code> 的 p 元素用于描述唐诗标题，id 为 <code>first</code> 的 p 元素用于描述第一句诗，id 为 <code>second</code> 的用于描述第二句诗。CSS 选择器 <code>p</code> 会同时选中这三个元素：</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-2-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219171124251.png" alt="image-20231219171124251"></p><p>但如果我们想 <strong>精准</strong> 地提取出唐诗标题，这时该怎么做呢？</p><p>还记得我们上个笔记的内容吗？元素的 class 属性和 id 属性用于 <strong>标识元素</strong>。而标识的目的就是方便 CSS 选择器定位。</p><p>其中靠 class 属性值检索的选择器被称为 <strong>类选择器</strong>，需要写成 <code>.class_name</code>，表示检索所有 class 属性值为 <code>class_name</code> 的元素。靠 id 属性值检索的被称为 <strong>ID 选择器</strong>，写成 <code>#id_name</code>，表示检索所有 id 属性值为 <code>id_name</code> 的元素。</p><p>类选择器、ID 选择器与元素选择器一起并称为 <strong>基本选择器</strong>。</p><blockquote><p>如果我们想用CSS 选择器 <strong>精准定位</strong> 到唐诗标题所在 p 元素,我们可以用<code>#&#39;&#39;title&#39;&#39;</code>CSS选择器</p></blockquote><p>类选择器和 ID 选择器通常不会孤立出现，而是配合元素选择器一起使用，写成 <strong>元素名.类名</strong> 或 <strong>元素名#ID名</strong> 形式。例如唐诗标题所在 p 元素的完整选择器是 <code>p#title</code>。我们稍后爬取豆瓣网信息时就会使用这种写法。</p><p>了解如何提取唐诗标题后，我们又遇到新的问题：上下两句诗分布在两个 p 元素之中，我们又该同时定位到这两句诗呢？</p><h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><p>基本选择器无法满足我们需求时，我们可以转换思路——根据元素与其它元素之间的 <strong>关系</strong>，将若干个基本选择器组合起来形成 <strong>组合选择器</strong>，进一步提升检索精确度。</p><p>通过之前学习我们知道，元素与元素之间的关系可以分为 <strong>祖先 – 后代</strong>、<strong>祖先 – 直接后代</strong>、<strong>兄弟 – 兄弟</strong> 三类，因此两个元素之间的组合关系也分为三种：</p><ul><li><code>A B</code>：检索 A 元素 <strong>后代</strong> 中的所有 B 类型元素；</li><li><code>A &gt; B</code>：检索 A 元素 <strong>直接后代</strong> 中所有 B 类型元素；</li><li><code>A ~ B</code>：检索 A 元素 <strong>兄弟</strong> 中所有 B 类型元素。</li></ul><p>回顾《静夜思》文档树我们可以看到，根节点 div 元素后代中有许多 p 元素，标题所在 p 元素是根节点的 <strong>直接后代</strong>，上下两句诗所在 p 元素是根节点的 <strong>后代</strong>。所以当我们从根节点出发，编写选择器 <code>div.poem p</code>，会同时选中这三个 p 元素：</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-2-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219171620456.png" alt="image-20231219171620456"></p><p>而选择器 <code>div.poem &gt; p</code> 只会选中根节点的直接后代，即标题所在 p 元素：</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-2-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219171635740.png" alt="image-20231219171635740"></p><p>了解了什么是 <strong>组合选择器</strong>，我们就能同时定位上下两句诗啦。我们观察到，上下两句诗都是 p 元素，并且都是 <code>div.content</code> 的 <strong>直接后代</strong>，所以可以编写 <code>div.content &gt; p</code> 同时选中这两句诗：</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-2-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219171652356.png" alt="image-20231219171652356"></p><blockquote><p>由于此时 <code>div.content</code> 下没有其它元素，所以 <code>div.content p</code> 也能够定位到两句诗。CSS 选择器写法多种多样，只要能定位到所需元素即可。</p></blockquote><h3 id="实战例子"><a href="#实战例子" class="headerlink" title="实战例子"></a>实战例子</h3><p><a href="https://book.douban.com/top250?icn=index-book250-all">豆瓣读书top250</a>,中中提取出每本书的 <strong>书名</strong>、<strong>作者</strong> 和 <strong>出版社</strong> 信息。</p><p>我们可以先检查元素快速定位到源代码中的位置，然后进行解读:</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-2-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219172229454.png" alt="image-20231219172229454"></p><p>观察可知，我们可以用<code>div.class a</code>或者<code>div.class &gt; a</code>来获取书名</p><p>通过同样的方法，我们可以分析得出，作者、出版社等书籍信息都在 class 属性值为 <code>pl</code> 的 p 元素中。因此我们能通过选择器 <code>p.pl</code> 定位到它们。</p><h3 id="select-方法"><a href="#select-方法" class="headerlink" title="select()方法"></a>select()方法</h3><p><strong>BeautifulSoup 对象</strong> 有一个名为 <code>select()</code> 的方法。我们将定位的<code>CSS选择器</code>传进去，它会返回一个列表，列表中每个元素都是符合条件的检索结果。例如我想提取每本书书名信息所在元素，可以写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前面代码省略，soup 为解析好的 BeautifulSoup 对象</span></span><br><span class="line">book_name_tags = soup.select(<span class="string">&#x27;div.pl2 a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(book_name_tags)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># [&lt;a href=&quot;https://book.douban.com/subject/1007305/&quot; onclick=&quot;&amp;quot;moreurl(this,&#123;i:&#x27;0&#x27;&#125;)&amp;quot;&quot; title=&quot;红楼梦&quot;&gt;</span></span><br><span class="line"><span class="comment">#                 红楼梦                </span></span><br><span class="line"><span class="comment">#               &lt;/a&gt;, &lt;a href=&quot;https://book.douban.com/subject/4913064/&quot; onclick=&quot;&amp;quot;moreurl(this,&#123;i:&#x27;1&#x27;&#125;)&amp;quot;&quot; title=&quot;活着&quot;&gt;</span></span><br><span class="line"><span class="comment">#                 活着                </span></span><br><span class="line"><span class="comment">#               &lt;/a&gt;, &lt;a href=&quot;https://book.douban.com/subject/6082808/&quot; onclick=&quot;&amp;quot;moreurl(this,&#123;i:&#x27;2&#x27;&#125;)&amp;quot;&quot; title=&quot;百年孤独&quot;&gt;</span></span><br><span class="line"><span class="comment">#                 百年孤独</span></span><br><span class="line"><span class="comment">#               &lt;/a&gt;, ...]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(book_name_tags[<span class="number">0</span>]))</span><br><span class="line"><span class="comment"># 输出：&lt;class &#x27;bs4.element.Tag&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，所有书名信息所在元素都被我们提取出来了。并且通过打印 <code>book_name_tags</code> 列表第一个元素的数据类型我们发现，它是一个特殊的数据类型，<strong>Tag 类</strong>。正如我在介绍 BeautifulSoup 对象时说过的，BeautifulSoup 类继承自 Tag 类。我们通过 <code>select()</code> 方法获得的一个个节点，是一个个 <strong>Tag 对象</strong>。</p><h2 id="Tag对象"><a href="#Tag对象" class="headerlink" title="Tag对象"></a>Tag对象</h2><p>Tag常用的属性和方法:</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-2-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219172714327.png" alt="image-20231219172714327"></p><p>Tag 类也有 <code>select()</code> 方法——这是因为，BeautifulSoup 类中的 <code>select()</code> 方法就是继承自 Tag 类的。除此之外，我们还能通过 Tag 对象的 <code>text</code> 属性访问到该元素的 <strong>元素内容</strong>，通过 <strong>Tag对象[‘元素属性名称’]</strong> 形式访问到该元素的某个属性的值。</p><p>对于 <code>book_name_tags</code> 列表中第一个元素来说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">book = book_name_tags[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(book)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># &lt;a href=&quot;https://book.douban.com/subject/1007305/&quot; onclick=&quot;&amp;quot;moreurl(this,&#123;i:&#x27;0&#x27;&#125;)&amp;quot;&quot; title=&quot;红楼梦&quot;&gt;</span></span><br><span class="line"><span class="comment">#                 红楼梦                </span></span><br><span class="line"><span class="comment">#               &lt;/a&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以通过 <code>book.text</code> 获取元素内容，通过 <code>book[&#39;href&#39;]</code> 获取图书链接,<code>book[&#39;title&#39;]</code> 来获取书名。</p><p>同样的道理，我们可以编写代码提取出每本书作者、出版社信息所在元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前面代码省略，soup 为解析好的 BeautifulSoup 对象</span></span><br><span class="line">book_info_tags = soup.select(<span class="string">&#x27;p.pl&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(book_info_tags)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># [&lt;p class=&quot;pl&quot;&gt;[清] 曹雪芹 著 / 人民文学出版社 / 1996-12 / 59.70元&lt;/p&gt;, &lt;p class=&quot;pl&quot;&gt;余华 / 作家出版社 / 2012-8-1 / 20.00元&lt;/p&gt;, &lt;p class=&quot;pl&quot;&gt;[哥伦比亚] 加西亚·马尔克斯 / 范晔 / 南海出版公司 / 2011-6 / 39.50元&lt;/p&gt;, ...]</span></span><br></pre></td></tr></table></figure><p>可以看到，书籍信息存在于 p 元素的 <strong>文本内容</strong> 中，我们可以通过 <code>text</code> 属性获取。每条书籍信息则由若干项组成，依次是作者、译者（如果为外文作品）、出版社、出版年份、图书价格，每项中间用 <code>/</code> 分割。因此我们在提取图书作者、出版社信息时可分以下四步：</p><ol><li>遍历 <code>book_info_tags</code> 中每个元素；</li><li>对每个元素，通过 <code>text</code> 属性获取书籍信息，保存到 <code>info</code> 里；</li><li>按 <code>/</code> 分割 <code>info</code> 字符串，得到列表 <code>info_list</code>；</li><li><code>info_list</code> 中 <strong>第一项元素</strong> 是作者信息，<strong>倒数第三项元素</strong> 是出版社信息。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前面代码省略，soup 为解析好的 BeautifulSoup 对象</span></span><br><span class="line">book_info_tags = soup.select(<span class="string">&#x27;p.pl&#x27;</span>)</span><br><span class="line"><span class="comment"># 遍历所有书籍信息元素</span></span><br><span class="line"><span class="keyword">for</span> info_tag <span class="keyword">in</span> book_info_tags:</span><br><span class="line">  <span class="comment"># 获取书籍信息</span></span><br><span class="line">  info = info_tag.text</span><br><span class="line">  <span class="comment"># 按“ / ”分割字符串</span></span><br><span class="line">  info_list = info.split(<span class="string">&#x27; / &#x27;</span>)</span><br><span class="line">  <span class="comment"># 结果列表中第一项为作者信息</span></span><br><span class="line">  author = info_list[<span class="number">0</span>]</span><br><span class="line">  <span class="comment"># 倒数第三项为出版社信息</span></span><br><span class="line">  publisher = info_list[-<span class="number">3</span>]</span><br><span class="line">  <span class="built_in">print</span>(author, publisher)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># [清] 曹雪芹 著 人民文学出版社</span></span><br><span class="line"><span class="comment"># 余华 作家出版社</span></span><br><span class="line"><span class="comment"># [哥伦比亚] 加西亚·马尔克斯 南海出版公司</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>我们发现我们只提取了一页的数据，当我们在网站跳转页面的时候,可以发现，跳转后的 URL 相比于豆瓣读书 Top 250 首页 URL <strong><a href="https://book.douban.com/top250">https://book.douban.com/top250</a></strong>，后面多了串小尾巴 <strong>?start&#x3D;xx</strong>，并且随着页码的增加，小尾巴中数字部分也在增加。看起来这串小尾巴的值决定了页面中呈现的内容。</p><p>这部分以 <code>?</code> 开头的内容也是 URL 重要组成部分之一，被称为 <strong>查询参数</strong>，也叫 <strong>查询字符串</strong>。</p><h2 id="URL查询参数"><a href="#URL查询参数" class="headerlink" title="URL查询参数"></a>URL查询参数</h2><p><strong>查询参数</strong> 用于 <strong>过滤</strong>、<strong>组织</strong>、<strong>跟踪</strong> 网站上的信息，格式上以字符 <code>?</code> 开始，包含若干个由 <code>key=value</code> 形式 <strong>键值对</strong> 构成的参数。若 URL 携带多个查询参数，则参数与参数之间需要用 <code>&amp;</code> 相连，写成 <code>?key1=value1&amp;key2=value2&amp;...</code> 形式。</p><p>查询参数将整个站点的内容组织得井井有条。反向思考一下，我们也可以利用这一特点，在发送请求时附带上查询参数，从而自动地控制爬取哪一页的内容，就像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 豆瓣读书 Top 250 首页 URL</span></span><br><span class="line">base_url = <span class="string">&#x27;https://book.douban.com/top250/&#x27;</span></span><br><span class="line"><span class="comment"># 定制消息头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 定制查询参数</span></span><br><span class="line">params = &#123;</span><br><span class="line">  <span class="string">&#x27;start&#x27;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送带消息头、查询参数的请求</span></span><br><span class="line">res = requests.get(base_url, headers=headers, params=params)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># 输出：&lt;Response [200]&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>URL 携带的查询参数不仅能帮助过滤、组织数据，还能帮助网站跟踪用户信息。例如，我们打开百度，在搜索框中输入 <strong>python</strong> 并点击搜索，此时地址栏中 URL 为：</p><p><code>https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=python&amp;fenlei=256&amp;rsv_pq=f730835b0002005a&amp;rsv_t=6ad5qUqos2%2Fe4CWymVeklp9RMX%2FoN57Y5M3wUStajFsbCHW33MZ5kgZYICU&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=6&amp;rsv_sug1=6&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_btype=i&amp;prefixsug=python&amp;rsp=6&amp;inputT=1158&amp;rsv_sug4=1158</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">params = &#123;</span><br><span class="line">  <span class="string">&quot;ie&quot;</span>:<span class="string">&quot;utf-8&quot;</span>, <span class="comment"># InputEncoding，搜索关键字的编码</span></span><br><span class="line">  <span class="string">&quot;f&quot;</span>:<span class="string">&quot;8&quot;</span>, <span class="comment"># 搜索类型，8 为用户自主搜索，3 为下拉框推荐，1 为相关搜索</span></span><br><span class="line">  <span class="string">&quot;rsv_bp&quot;</span>:<span class="string">&quot;0&quot;</span>, <span class="comment"># 搜索位置，0 为从百度首页进入，1 为搜索结果顶部搜索，2 为搜索结果底部搜索</span></span><br><span class="line">  <span class="string">&quot;tn&quot;</span>:<span class="string">&quot;baidu&quot;</span>, <span class="comment"># 搜索来源标识，baidu 表示从百度首页搜索</span></span><br><span class="line">  <span class="string">&quot;wd&quot;</span>:<span class="string">&quot;python&quot;</span>, <span class="comment"># 搜索关键字</span></span><br><span class="line">  <span class="string">&quot;rqlang&quot;</span>:<span class="string">&quot;cn&quot;</span>, <span class="comment"># 用户所使用的语言，cn 表示中文</span></span><br><span class="line">  <span class="string">&quot;prefixsug&quot;</span>:<span class="string">&quot;python&quot;</span>, <span class="comment"># PrefixSuggestion，搜索前缀建议</span></span><br><span class="line">  <span class="string">&quot;rsp&quot;</span>:<span class="string">&quot;6&quot;</span>, <span class="comment"># 相关搜索词在所有推荐词中位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="反爬策略"><a href="#反爬策略" class="headerlink" title="反爬策略"></a>反爬策略</h1><h2 id="身份判别与限制"><a href="#身份判别与限制" class="headerlink" title="身份判别与限制"></a>身份判别与限制</h2><ul><li>判别访问网站的是人类还是机器（爬虫程序）；</li><li>判别该用户是否拥有访问权限。</li></ul><h2 id="IP识别与限制"><a href="#IP识别与限制" class="headerlink" title="IP识别与限制"></a>IP识别与限制</h2><p><strong>IP（Internet Protocol）</strong> 全称 <strong>互联网协议地址</strong>，意思是分配给用户上网使用的网际协议的设备的数字标签。每一个可联网设备在访问网络时，都会被上级设备分配一个 IP。例如你使用手机流量访问时，会被附近的信号基站分配一个 IP 地址；连接 Wi-Fi 访问网页时，同一无线网络下所有设备将会被分配到同一网段的 IP 地址。</p><p>不仅我们个人的设备拥有 IP，提供网络服务的服务器也有 IP。我们在发送请求时，需要携带本机 IP，向着目标机器 IP 发送内容；服务器在响应时，也会携带自己的 IP，向着我们的 IP 回应。这些步骤在整个网络通信环节中处于比较底层的位置，无论是浏览器还是 requests 库，都会帮我们自动完成。</p><p>前面说过，当我们爬取大量数据时，如果我们不加以节制地访问目标网站，会使网站超负荷运转，一些个人小网站没什么反爬虫措施可能因此瘫痪。而大网站一般会限制你的访问频率，因为正常人是不会在 1s 内访问几十次甚至上百次网站的。</p><p>因此网站通常会记录访问者 IP，一旦发现某一 IP 短时间内向站点发送了大量请求，就会限制该 IP 继续访问。对此，我们常常使用 <code>time.sleep()</code> 来降低访问的频率。这样一来，对方也就睁一只眼闭一只眼不理会我们的爬虫。</p><p>除了降低访问频率之外，我们也可以使用 <strong>代理</strong> 来解决 IP 限制问题。<strong>代理</strong> 的意思是通过别的 IP 访问网站。这样，在 IP 被封后我们可以换一个 IP 继续爬取数据，或者每次爬取数据时都换不同的 IP，避免同一个 IP 访问的频率过高，这样就能快速地大规模爬取数据了。</p><p>使用代理:</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-2-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219175040245.png" alt="image-20231219175040245"></p><p>和 <code>headers</code>、<code>params</code> 一样，我们也需要定义一个字典，将其传递给 <code>get()</code> 方法的 <code>proxies</code> 参数。<code>proxies</code> 字典中有两个键，<code>http</code> 和 <code>https</code>，分别代表两种网络协议，键对应的值就是用于代理的 IP 地址。</p><p>官方文档中给了代理的基本用法，但在爬取大量数据时我们需要很多的 IP 用于切换。因此，我们需要建立一个 IP 代理池（列表），每次从中随机选择一个传给 <code>proxies</code> 参数。我们来看一下如何实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 库</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># 从 bs4 库导入 BeautifulSoup</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将获取一页图书数据代码封装成函数 get_one_page_data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_one_page_data</span>(<span class="params">page, proxy</span>):</span><br><span class="line">  <span class="comment"># 豆瓣读书 Top 250 首页 URL</span></span><br><span class="line">  base_url = <span class="string">&#x27;https://book.douban.com/top250/&#x27;</span></span><br><span class="line">  <span class="comment"># 定制消息头，内容省略</span></span><br><span class="line">  headers = ...</span><br><span class="line">  <span class="comment"># 根据传入参数定制查询参数，内容省略</span></span><br><span class="line">  params = ...</span><br><span class="line">  <span class="comment"># 发送带消息头、查询参数、代理的请求</span></span><br><span class="line">  res = requests.get(</span><br><span class="line">    base_url, headers=headers, params=params, proxies=proxy</span><br><span class="line">  )</span><br><span class="line">  <span class="comment"># 解析成 BeautifulSoup 对象</span></span><br><span class="line">  soup = BeautifulSoup(res.text, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">  <span class="comment"># 提取出书名、作者、出版社信息并按行打印</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># IP 代理池（瞎写的并没有用）</span></span><br><span class="line">proxies_list = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;http&quot;</span>: <span class="string">&quot;http://10.10.1.10:3128&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https&quot;</span>: <span class="string">&quot;http://10.10.1.10:1080&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;http&quot;</span>: <span class="string">&quot;http://10.10.1.11:3128&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https&quot;</span>: <span class="string">&quot;http://10.10.1.11:1080&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;http&quot;</span>: <span class="string">&quot;http://10.10.1.12:3128&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https&quot;</span>: <span class="string">&quot;http://10.10.1.12:1080&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 循环 10 次，分别获取第 1～10 页数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">  <span class="comment"># 从 IP 代理池中随机选择一个</span></span><br><span class="line">  get_one_page_data(i, choice(proxies_list))</span><br></pre></td></tr></table></figure><h2 id="验证码限制"><a href="#验证码限制" class="headerlink" title="验证码限制"></a>验证码限制</h2><p>在处理验证码问题上，我们多采用 <strong>自动与手动相结合</strong> 的方式，让机器控制浏览器，遇到需要输入验证码的场合，等待我们手动输入，接着再完成后面的爬取工作。这部分内容需要用到 <strong>selenium 库</strong>。我们会在后面学习 selenium 库的用法，至于破解验证码的内容，暂时不会涉及。</p><h2 id="文件加密"><a href="#文件加密" class="headerlink" title="文件加密"></a>文件加密</h2><blockquote><p>我们已经知道了网页中的文字内容都在 HTML 元素的 <strong>文本内容</strong> 中，图片是一种文件资源，可以通过 URL 下载。而我们一直没有涉及到 <strong>音视频</strong> 等媒体资源，这是因为，多数音乐平台，如网易云、QQ 音乐，或者视频网站，如腾讯视频、Bilibili，它们都对音视频文件做了特殊的 <strong>加密</strong>。</p></blockquote><p><strong>流媒体传输技术</strong> 和 <strong>加密技术</strong>。</p><p><strong>流媒体传输技术</strong>将庞大的音视频文件编写为长长的 <strong>二进制文件流</strong>，再把它均匀地切分成若干块进行传输；接受到这些信息块的客户端，再按照顺序拼接起来，从而不至于前后错乱。</p><p>流媒体加密算法，其中使用范围最广的就是 <strong>HLS 算法</strong></p><h1 id="静态网站小结"><a href="#静态网站小结" class="headerlink" title="静态网站小结"></a>静态网站小结</h1><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-2-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231219173250832.png" alt="image-20231219173250832"></p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-2-%E7%88%AC%E8%99%AB%E4%B8%89%E6%AD%A5%E9%AA%A4%E7%AE%80%E8%AE%B2/image-20231220003145672.png" alt="image-20231220003145672"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫笔记(一)—基本知识</title>
      <link href="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-1-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-1-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器基础知识"><a href="#浏览器基础知识" class="headerlink" title="浏览器基础知识"></a>浏览器基础知识</h1><h2 id="网址-URL"><a href="#网址-URL" class="headerlink" title="网址(URL)"></a>网址(URL)</h2><p>学名: <strong>统一资源定位符</strong></p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li><p>网络协议类型:HTTP、HTTPS、FTP等</p></li><li><p>域名:如<a href="http://www.bailog.top/">www.bailog.top</a></p></li><li><p>资源在浏览器中的位置:有时以文件<strong>路径</strong>形式出现,有时以<strong>路由</strong>形式出现.</p><blockquote><p>比如我们一看到 URL <code>https://www.sample.com/编程/测试音频.mp3</code>，就知道这是在获取域名为 <code>sample.com</code> 的服务器中，编程文件夹下的 <strong>测试音频.mp3</strong> 文件。</p><p>比如扇贝编程首页的 URL 是 <code>https://www.bailog.top/archives/</code>，其中的 <code>/archives/</code> 是资源对应的路由，只有提供网络服务这一端知道资源到底在哪里。</p></blockquote></li><li><p>锚点:如<code>https://www.bailog.top/2023/12/14/Python-tree递归-tree递归/#总结</code>后面中的#总结，用于定位文章对应的内容。</p></li></ul><h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><p>浏览器只是一个“中转站”，并没有保存网站内容。我们浏览网页，是在通过浏览器，跟提供资源内容的 <strong>服务器</strong> 通信。它的实际过程是这样的：</p><ul><li>我们在浏览器输入 <strong>网址</strong>（URL）；</li><li>浏览器根据网址，调用我们设备的网络能力，找到域名对应的服务器，向服务器 <strong>请求</strong>（request）获取某某资源；</li><li>服务器收到请求后会作出 <strong>响应</strong>（response），在内部翻箱倒柜找出相应资源，把资源交给浏览器；</li><li>浏览器加载资源，把内容呈现到我们面前。</li><li><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-1-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231219000056624.png" alt="image-20231219000056624"></li></ul><blockquote><p>这也是“浏览器”名称的由来，即在自己的联网设备上 <strong>浏览</strong> 他人设备上的资源。在互联网领域，我们自己的设备叫做 <strong>客户端</strong>；他人设备，也就是提供内容的设备，叫做 <strong>服务器</strong>、<strong>服务端</strong>。浏览器每发送一次请求，服务器就会做出一次响应。如此一来一回，我们就在浏览器上看到了网页的内容。</p></blockquote><h2 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h2><h3 id="Network面板"><a href="#Network面板" class="headerlink" title="Network面板"></a>Network面板</h3><p>按F12调用,由四大块部分构成，我们重点关注三个部分：</p><ul><li><strong>功能区</strong>，这里我们重点关注类似 🚫 标志的 <strong>清除（clear）</strong> 按钮，以及 <strong>保留记录（Preserve log）</strong> 选项；</li><li><strong>筛选区</strong>，该功能区可以快速筛选出符合条件的请求，这里我们主要关注以 <strong>所有（All）</strong> 开始直到 <strong>其它（Other）</strong> 结束的类型标签，未来我们将用它来快速筛选指定类型请求；</li><li><strong>请求列表区</strong>，当开发者工具捕捉到发生在页面中的新请求时，会按请求发生顺序陈列在区域中。</li></ul><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-1-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231219000350515.png" alt="image-20231219000350515"></p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-1-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231219000512260.png" alt="image-20231219000512260"></p><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><p>反映本次响应的状态，分为五类:</p><ul><li>代码 <code>100</code>～<code>199</code>：<strong>信息响应</strong>，这是服务器在表明，“我收到你的请求了，不过处理起来有点麻烦，你接着发其它请求吧，我干完活了告诉你一声”；</li><li>代码 <code>200</code>～<code>299</code>：<strong>成功</strong>，表示服务器成功接收、理解、处理了请求；</li><li>代码 <code>300</code>～<code>399</code>：<strong>重定向</strong>，一般用于 URL 重定向，你可以理解为资源已经搬家了，服务器帮你把请求 URL 改成了资源所在的新地址；</li><li>代码 <code>400</code>～<code>499</code>：<strong>客户端错误</strong>，也就是我们请求获取资源的方式不对，比如 URL 输入错误，或者没有登录等等；</li><li>代码 <code>500</code>～<code>599</code>：<strong>服务器错误</strong>，表明服务器由于某些原因，现在无法作出响应。</li></ul><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-1-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231219152306544.png" alt="image-20231219152306544"></p><h2 id="爬虫工作原理"><a href="#爬虫工作原理" class="headerlink" title="爬虫工作原理:"></a>爬虫工作原理:</h2><p>爬虫实际上是充当了浏览器的功能，向服务器发送请求、获取服务器的响应。与使用浏览器浏览网页不同的是，爬虫程序无需将响应内容呈现出来，而是根据我们设定的规则去提取需要的数据，处理数据，最终将数据保存起来。</p><p>包含下面三个步骤:</p><ul><li><strong>第一步：获取数据</strong>，爬虫根据我们提供的 URL，向服务器发送请求获取响应内容</li><li><strong>第二步：处理数据</strong>，处理分为两步，一是解析响应内容，把它整理成 Python 中的数据格式，二是从中提取出所需数据；</li><li><strong>第三步：存储数据</strong>，将处理后的数据保存起来，便于后续的使用和分析等。</li></ul><h1 id="HTML基本语法"><a href="#HTML基本语法" class="headerlink" title="HTML基本语法"></a>HTML基本语法</h1><p><strong>HTML</strong> 全称 Hyper Text Markup Language，翻译过来是 <strong>超文本标记语言</strong>，是计算机语言的一种，由 <strong>元素</strong> 构成，用来结构化 Web 网页及其内容。</p><blockquote><p>比如，我有这么一段话：</p><p>Web 真好玩！</p><p>如果想让这段话显示在网页中，我们需要将它封装成一个 <strong>p（paragraph，段落）元素</strong>：</p><p><code>&lt;p&gt;Web 真好玩! &lt;/p&gt;</code></p></blockquote><p>可以看到，p 元素由三大部分组成：</p><ul><li><strong>开始标签</strong>：一对尖括号（即键盘上的小于号 <code>&lt;</code> 和大于号 <code>&gt;</code>）中间包裹着元素名称；</li><li><strong>元素内容</strong>：页面中用户可以看到的内容；</li><li><strong>结束标签</strong>：与开始标签类似，区别在于元素名称前有一个斜杠 <code>/</code>。</li></ul><h2 id="元素的属性"><a href="#元素的属性" class="headerlink" title="元素的属性"></a>元素的属性</h2><p><code>&lt;a href = &quot;https://www.bailog.top/&quot; target=&quot;_black&quot;&gt;bai的小窝&lt;a&gt;</code></p><blockquote><p>两个属性:</p><ul><li><code>href</code> 属性，值为 <code>https://web.shanbay.com/codetime/home/</code>，也就是扇贝编程首页 URL；</li><li><code>target</code> 属性，值为 <code>_blank</code>。</li></ul></blockquote><p>元素的属性属于额外信息，不会直接展示给我们用户，而是提供给浏览器、程序解析使用。每个元素可以设置什么样的属性，则是由元素类型决定的。比如 a 元素用于描述超链接，必须提供可跳转 URL，因此它具有 <code>href</code>（hypertext reference，超文本引用）属性。而没有这项功能的元素，比如 p 元素、h 系列元素等，也就不具有 <code>href</code> 属性。</p><blockquote><p>拓展：<code>target</code> 属性的值决定了当用户点击超链接时，跳转到指定 URL 的方式。<code>target</code> 属性默认值为 <code>_self</code>，表示在当前页面打开链接。课程中超链接 <code>target</code> 属性值为 <code>_blank</code>，表示会在浏览器新标签页打开。</p></blockquote><p>除了 <code>href</code> 这类特殊的属性，元素也有一些共同属性，最常见的就是 <code>class</code>、<code>id</code> 和 <code>style</code>。</p><p><code>class</code> 和 <code>id</code> 都是用来标识元素的。区别在于，<code>class</code> 用于标识某一类元素，在一份 HTML 文档中可以重复出现；而 <code>id</code> 用于标识具体的某一个元素，其值在整个 HTML 文档中是 <strong>唯一</strong> 的。</p><blockquote><p>你可以理解为：整个 HTML 文档是一所学校，<code>class</code> 是元素所在班级，<code>id</code> 是元素的学号。班级里可以有很多的人，但学号是全学校唯一的。</p></blockquote><p>元素标识的本职工作是方便 CSS、JavaScript 语言找到对应元素设置样式与交互逻辑。而我们的爬虫正可以利用这一点，借助 CSS 选择器定位到所需数据。</p><p><code>style</code> 属性则能够为元素设置样式，相当于在 HTML 中内嵌了一部分 CSS 代码。借助 style 属性，我们可以为 <strong>h1</strong> 元素加上一些样式，让它看起来和 <strong>p</strong> 元素差不多，也能够调整 <strong>p</strong> 元素的样式，让它看起来像个标题，就像这样：</p><p><code>&lt;h1 style=&quot;font-size: 1rem; font-weight: normal; margin-block-start: 1rem; margin-block-end: 1rem; margin: 0;&quot;&gt;加上样式后，一级标题看起来可以像段落正文&lt;/h1&gt;</code></p><h2 id="常见元素"><a href="#常见元素" class="headerlink" title="常见元素"></a>常见元素</h2><ul><li><p>HTML 中用 <strong>img（image）元素</strong> 来描述图片。img 元素有两个特殊属性，一个是 <code>src</code>（source）图片来源属性，值是图片资源对应的 URL；另一个是 <code>alt</code>（alternative text，用于替换的文本）属性。</p><p><code>&lt;img src = URL alt=&quot; &quot;&gt;</code></p><blockquote><p><code>alt</code> 属性功能比较特殊。当用户因为某些原因无法查看图片，比如网络连接速度慢、<code>src</code> 属性或属性值出现错误，或者用户正在使用屏幕阅读器时，浏览器会读取 <code>alt</code> 属性值，作为图片内容的替代信息展示给用户。并且 <code>alt</code> 的值可以为空，此时将由提供网页的服务器决定如何处理图片失效问题。</p></blockquote></li><li><p>空元素：有些元素并不需要提供文本内容，自然不需要元素内容。既然没有元素内容，索性连用于包裹内容的结束标签都不需要了。这类只有开始标签的元素叫做 <strong>空元素</strong></p></li></ul><blockquote><p>除了 img 元素，HTML 中还有许多空元素。它们有的是用于描述网页基本信息的，我们会在稍后章节中学习，有的则是服务于网页内容排版的，比如换行符 <strong>br（break）元素</strong>、水平分割线 <strong>hr（horizontal，水平的）元素</strong>。</p></blockquote><ul><li><p><code>&lt;br&gt;</code>元素:换行</p></li><li><p><code>&lt;hr&gt;</code>元素:水平分割线</p></li><li><p><code>&lt;ol&gt;</code>和<code>&lt;ul&gt;</code>元素:由最外层ol或ul元素以及内层li元素构成有序和无序列表。</p></li><li><p>表示空格:<code>&amp;amp;nbsp;</code></p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-1-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231219154503075.png" alt="image-20231219154503075"></p></li></ul><h2 id="HTML文档结构"><a href="#HTML文档结构" class="headerlink" title="HTML文档结构"></a>HTML文档结构</h2><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-1-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231219154918216.png" alt="image-20231219154918216"></p><p>我们从网页内容第一行看起。第一行的 <code>!&lt;DOCTYPE html&gt;</code> 表明该文件是 HTML 文档，便于浏览器正确解析，没有实际含义。<code>DOCTYPE</code> 之后的整个网页内容都包裹在 <strong>html 元素</strong> 中，这是约定俗成的格式。如此一来，网页内所有元素都是 html 元素的子元素，整个 HTML 文档像树一样开枝散叶，结构清晰明朗。因此，html 元素也被称为 <strong>根元素</strong>。</p><p>再往内部看，网页根元素最粗壮的两个分支，一个叫 <strong>head 元素</strong>，另一个叫 <strong>body 元素</strong>。它们分别是网页的 <strong>网页头</strong> 和 <strong>网页体</strong>。</p><p><img src="/2023/12/19/Python-%E7%88%AC%E8%99%AB-%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E9%80%9F%E8%BF%87-1-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231219154941949.png" alt="image-20231219154941949"></p><blockquote><ul><li>用 <strong>title 元素</strong> 设置网页标题，这个标题将显示在浏览器标签页上，也会作为收藏时的描述文字；</li><li>用 <strong>meta 元素</strong> 设置网页元信息，这些信息包括网页使用什么样的字符编码方式、样式、整体布局，还包含页面描述信息和面向搜索引擎的搜索关键字等等。</li><li>head 元素中还有许多 <strong>link 元素</strong> 和 <strong>script 元素</strong>，它们负责将 HTML 文档与对应的 CSS 样式、JavaScript 代码文件关联起来。仔细观察这些元素中的元素内容或 <code>href</code> 属性的值，就能够了解这个网页用到了哪些技术。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解计算机原理--第一章</title>
      <link href="/2023/12/14/%E8%AF%BB%E4%B8%80%E6%9C%AC%E5%A5%BD%E4%B9%A6-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-index/"/>
      <url>/2023/12/14/%E8%AF%BB%E4%B8%80%E6%9C%AC%E5%A5%BD%E4%B9%A6-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-index/</url>
      
        <content type="html"><![CDATA[<h1 id="二、信息的表示和表达"><a href="#二、信息的表示和表达" class="headerlink" title="二、信息的表示和表达"></a>二、信息的表示和表达</h1><h2 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h2><h3 id="2-1-1-十六进制表示法"><a href="#2-1-1-十六进制表示法" class="headerlink" title="2.1.1 十六进制表示法"></a>2.1.1 十六进制表示法</h3><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998390485614.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998390485614.png?x-oss-process=style/stylename</a>)</p><blockquote><p>转化为二进制需要从右到左每4分为一组转换(不足补0)</p></blockquote><h4 id="十进制和十六进制互选转换"><a href="#十进制和十六进制互选转换" class="headerlink" title="十进制和十六进制互选转换"></a>十进制和十六进制互选转换</h4><p>十进制除16倒取余<br>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998394198795.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998394198795.png?x-oss-process=style/stylename</a>)</p><h3 id="2-1-2-字数据大小"><a href="#2-1-2-字数据大小" class="headerlink" title="2.1.2 字数据大小"></a>2.1.2 字数据大小</h3><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998395609489.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998395609489.png?x-oss-process=style/stylename</a>)</p><blockquote><p>unsigned long、unsigned long int<br>都是同个意思</p></blockquote><h3 id="2-1-3-寻址和字节顺序"><a href="#2-1-3-寻址和字节顺序" class="headerlink" title="2.1.3 寻址和字节顺序"></a>2.1.3 寻址和字节顺序</h3><p>对于跨越多字节的程序对象，两个规则</p><ul><li>这个对象的地址是什么</li><li>字内存中如何排序这些字节</li></ul><h4 id="地址为所使用字节最小的地址"><a href="#地址为所使用字节最小的地址" class="headerlink" title="地址为所使用字节最小的地址"></a>地址为所使用字节最小的地址</h4><h4 id="排序方法有两个通用规则"><a href="#排序方法有两个通用规则" class="headerlink" title="排序方法有两个通用规则"></a>排序方法有两个通用规则</h4><ul><li>大端法:最高有效字节中最前面的方法</li><li>小端法:最低有效字节中最前面的方法<blockquote></blockquote>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998409476624.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998409476624.png?x-oss-process=style/stylename</a>)</li></ul><h3 id="2-1-4-表示字符串"><a href="#2-1-4-表示字符串" class="headerlink" title="2.1.4 表示字符串"></a>2.1.4 表示字符串</h3><p>字符串被编码为一个以null（值为0）字符结尾的字符数组，每个字符都由某个标准编码来表达，因此，文本数据比二进制数据具有更强的平台独立性</p><h3 id="2-1-5-表达代码"><a href="#2-1-5-表达代码" class="headerlink" title="2.1.5 表达代码"></a>2.1.5 表达代码</h3><p>不同机器类型使用不同的且不兼容的指令和编码方式，即使是完全一样的进程，运行中不同操作系统上也有不同的编码规则，因此二进制代码是不兼容的。</p><h3 id="2-1-6-布尔代数"><a href="#2-1-6-布尔代数" class="headerlink" title="2.1.6 布尔代数"></a>2.1.6 布尔代数</h3><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998567614189.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998567614189.png?x-oss-process=style/stylename</a>)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998568366125.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998568366125.png?x-oss-process=style/stylename</a>)</p><blockquote><p>布尔代数符合分配率<br>a&amp;(b|c) &#x3D; (a&amp;b)|(a&amp;c)<br>a|(b&amp;c) &#x3D; (a|b)&amp;(a|c)</p></blockquote><blockquote><p>布尔环<br>加分逆元(x+(-x) &#x3D; 0)<br>a^a &#x3D; 0<br>(a^b)^a &#x3D; b</p></blockquote><h3 id="2-1-7-位级运算"><a href="#2-1-7-位级运算" class="headerlink" title="2.1.7 位级运算"></a>2.1.7 位级运算</h3><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998569179935.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998569179935.png?x-oss-process=style/stylename</a>)</p><h4 id="掩码运算"><a href="#掩码运算" class="headerlink" title="掩码运算"></a>掩码运算</h4><p>掩码是一个位模式，表示一个字中选出的位的集合</p><blockquote><p>例子</p></blockquote><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998575552748.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998575552748.png?x-oss-process=style/stylename</a>)</p><h3 id="2-1-8-逻辑运算"><a href="#2-1-8-逻辑运算" class="headerlink" title="2.1.8 逻辑运算"></a>2.1.8 逻辑运算</h3><p>||、&amp;&amp;和！分别代表媒体逻辑中的OR、AND和NOT运算</p><h3 id="2-1-9移位运算"><a href="#2-1-9移位运算" class="headerlink" title="2.1.9移位运算"></a>2.1.9移位运算</h3><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998578307265.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998578307265.png?x-oss-process=style/stylename</a>)</p><ul><li>唯一例外是算术右移[10010101]的情况。<strong>因为操作数的最高位数1，填充的值就是1.</strong><blockquote><p>一般为算术右移<br>对于无符号数，右移必须是逻辑的<br>x&gt;&gt;j&gt;&gt;k等价于(x&lt;&lt;j)&lt;&lt;k<br>操作符的优先级中，加号的优先级比操作符的高</p></blockquote></li></ul><h2 id="2-2-整数表示"><a href="#2-2-整数表示" class="headerlink" title="2.2 整数表示"></a>2.2 整数表示</h2><p>编码整数的两种不同的方法：</p><ul><li>只能表示非负数</li><li>能够表示负数，0，正数</li></ul><blockquote><p>下文用到的数学术语</p></blockquote><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998582975352.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998582975352.png?x-oss-process=style/stylename</a>)</p><h3 id="2-2-1-整型数据类型"><a href="#2-2-1-整型数据类型" class="headerlink" title="2.2.1 整型数据类型"></a>2.2.1 整型数据类型</h3><h4 id="数据类型的典型取值范围"><a href="#数据类型的典型取值范围" class="headerlink" title="数据类型的典型取值范围"></a>数据类型的典型取值范围</h4><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998586485045.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998586485045.png?x-oss-process=style/stylename</a>)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998586665394.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998586665394.png?x-oss-process=style/stylename</a>)</p><blockquote><p>取值范围是不对称的——负数的范围比整数的范围大1</p></blockquote><blockquote><p>下表是C语言标准定义的每种数据类型必须能够表示的最小的取值范围。</p></blockquote><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998588029453.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998588029453.png?x-oss-process=style/stylename</a>)</p><h3 id="无符号的编码"><a href="#无符号的编码" class="headerlink" title="无符号的编码"></a>无符号的编码</h3><p>将位向量看作二进制表示的数，将获得了位向量的无符号表达</p><h4 id="无符号数编码的定义"><a href="#无符号数编码的定义" class="headerlink" title="无符号数编码的定义"></a>无符号数编码的定义</h4><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998590944911.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998590944911.png?x-oss-process=style/stylename</a>)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998591542514.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998591542514.png?x-oss-process=style/stylename</a>)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998592255921.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998592255921.png?x-oss-process=style/stylename</a>)</p><blockquote><p>B2Uw是一个双射，函数Ｂ2Uw将每个长度为w的位向量都映射位0～2^w - 1之间的一个唯一值；反过来,U2Bw在0～2^w - 1之间的每一个整数都可以映射为一个唯一的长度为w的位模式。</p></blockquote><h3 id="2-2-3-补码编码"><a href="#2-2-3-补码编码" class="headerlink" title="2.2.3 补码编码"></a>2.2.3 补码编码</h3><h4 id="补码编码的定义"><a href="#补码编码的定义" class="headerlink" title="补码编码的定义"></a>补码编码的定义</h4><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998595311062.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998595311062.png?x-oss-process=style/stylename</a>)<br>字的最高有效位解释为负权，也叫做符号位。</p><blockquote><p>符号位为1时值为负<br>符号位为0时值为非负</p></blockquote><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998597654820.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998597654820.png?x-oss-process=style/stylename</a>)</p><blockquote><p>B2Tw也是双射</p></blockquote><h4 id="可表示的整数的范围"><a href="#可表示的整数的范围" class="headerlink" title="可表示的整数的范围"></a>可表示的整数的范围</h4><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998599315139.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998599315139.png?x-oss-process=style/stylename</a>)</p><ul><li>补码范围不对称：｜TMin｜ &#x3D; |TMax| + 1<br>之所以不对称是因为一半的位模式表示负数，而另一半表示为非负数，因为0是非负数所以比负数多1</li><li>最大的无符号值刚好比补码的最大值的两倍大一点：UMaxw &#x3D; 2Tmxw + 1.<blockquote><p>c语言标准并没有要求用补码形式来表示用符号整数，但是几乎所有的机器都是这么做的。</p></blockquote></li></ul><blockquote><p>为来使代码具有最大可移植性，能够做所有可能的机器上运行，我们不应该假设任何可表示的数值类型，也不应该假设也符号数会使用何种特殊的表达方式。<br>许多程序的书写都是用补码来表示用符号数，并且具有图2-9和图2-10所示的典型的取值范围，这些程序能够值大量机器上移植</p></blockquote><p>staint.h中定义了一组数据类型：intN_t和uintN_t（对不同N值指定N位用符号和无符号整数）</p><blockquote><p>N：8、16、32和64</p></blockquote><p>这些数据类型对应着一组宏，定义了每个N对值对应对最小和最大值：INTN_MIN、INTN_MAX和UINTN_MAX</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998607174352.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998607174352.png?x-oss-process=style/stylename</a>)</p><h4 id="有符号的其他表示方法-反码和原码"><a href="#有符号的其他表示方法-反码和原码" class="headerlink" title="有符号的其他表示方法(反码和原码)"></a>有符号的其他表示方法(反码和原码)</h4><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998607836002.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998607836002.png?x-oss-process=style/stylename</a>)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998608162844.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998608162844.png?x-oss-process=style/stylename</a>)</p><p>![图2-15](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998608493945.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998608493945.png?x-oss-process=style/stylename</a>)</p><h3 id="2-2-4-有符号数和无符号数之间的转换"><a href="#2-2-4-有符号数和无符号数之间的转换" class="headerlink" title="2.2.4 有符号数和无符号数之间的转换"></a>2.2.4 有符号数和无符号数之间的转换</h3><p>从位级角度思考<br>转换<strong>数值变但是位模式不变</strong></p><h4 id="补码转换为无符号数"><a href="#补码转换为无符号数" class="headerlink" title="补码转换为无符号数"></a>补码转换为无符号数</h4><ul><li>原理<br>![公式2.5](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998611816561.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998611816561.png?x-oss-process=style/stylename</a>)</li><li>推导<br>![公式2.6](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998612864476.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998612864476.png?x-oss-process=style/stylename</a>)</li></ul><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998613857100.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998613857100.png?x-oss-process=style/stylename</a>)</p><h4 id="无符号数转换为补码"><a href="#无符号数转换为补码" class="headerlink" title="无符号数转换为补码"></a>无符号数转换为补码</h4><ul><li>原理</li></ul><p>![公式2.7](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998613713711.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16998613713711.png?x-oss-process=style/stylename</a>)</p><ul><li>推导</li></ul><p>![公式2.8](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999191653704.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999191653704.png?x-oss-process=style/stylename</a>)</p><p>![图2-17](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999191775362.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999191775362.png?x-oss-process=style/stylename</a>)</p><h3 id="2-2-5-C语言中有符号数与无符号数"><a href="#2-2-5-C语言中有符号数与无符号数" class="headerlink" title="2.2.5 Ｃ语言中有符号数与无符号数"></a>2.2.5 Ｃ语言中有符号数与无符号数</h3><p><strong>默认补码，要创建无符号常数，后缀加u&#x2F;U</strong><br>Ｃ语言运算中，如果一个运算数是有符号而另一个是无符号，Ｃ语言就会隐式将<strong>有符号</strong>强制转换为<strong>无符号数</strong>，并假设两个数都是非负的</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/">http://mwebpng.oss-cn-beijing.aliyuncs.com</a><u></u>&#x2F;2023&#x2F;12&#x2F;15&#x2F;16999196070225.png?x-oss-process&#x3D;style&#x2F;stylename)</p><p>![](<a href="http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999196160028.png?x-oss-process=style%14/stylename">http://mwebpng.oss-cn-beijing.aliyuncs.com/2023/12/15/16999196160028.png?x-oss-process=style/stylename</a>)</p><h3 id="2-2-6-扩展一个数的位表示"><a href="#2-2-6-扩展一个数的位表示" class="headerlink" title="2.2.6 扩展一个数的位表示"></a>2.2.6 扩展一个数的位表示</h3><h4 id="从较小类型转换到一个较大的类型-零扩展"><a href="#从较小类型转换到一个较大的类型-零扩展" class="headerlink" title="从较小类型转换到一个较大的类型(零扩展)"></a>从较小类型转换到一个较大的类型(零扩展)</h4><p>将无符号转换为另一个更大的数据类型</p><ul><li>零扩展：在表示的开头添加0</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读一本好书 </category>
          
          <category> 深入了解计算机原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读一本好书 </tag>
            
            <tag> 深入了解计算机原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tree递归</title>
      <link href="/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/"/>
      <url>/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>@<a href="%E9%97%AE%E9%A2%98">TOC</a><br>#Tree ADT<br><img src="/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/tree.jpg" alt="tree" title="tree"></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree</span>(<span class="params">label, branches=[]</span>):</span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches:</span><br><span class="line">        <span class="keyword">assert</span> is_tree(branch),<span class="string">&#x27;branches must be a tree&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> [label] + <span class="built_in">list</span>(branches)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">label</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">branches</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_tree</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(tree) != <span class="built_in">list</span> <span class="keyword">or</span> <span class="built_in">len</span>(tree) &lt;<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(tree):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_tree(branch):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_leaf</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> branches(tree)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>tree函数用于构造，label函数和branches函数用于选择，is_leaf和is_tree函数用于辅助</p></blockquote><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="fib-tree"><a href="#fib-tree" class="headerlink" title="fib_tree"></a>fib_tree</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib_tree</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left, right = fbi_tree(n-<span class="number">1</span>), fbi_tree(n-<span class="number">2</span>)</span><br><span class="line">        fib_n = label(left)+label(right)</span><br><span class="line">        <span class="keyword">return</span> tree(fib_n,left+right)</span><br></pre></td></tr></table></figure><blockquote><p>可见，基本情况是n &#x3D;&#x3D; 0 or n &#x3D;&#x3D;1<br>树递归的思想是从上到下，一旦到达基本情况变返回递归结果<br>这段函数从树顶端递归到0 or 1的情况，然后根据0和1的结果，逐层向上计算树节点的值</p></blockquote><h2 id="count-leaf"><a href="#count-leaf" class="headerlink" title="count_leaf"></a>count_leaf</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_leaves</span>(<span class="params">tree</span>):</span><br><span class="line">      <span class="keyword">if</span> is_leaf(tree):</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          branch_counts = [count_leaves(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(tree)]</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">sum</span>(branch_counts)</span><br></pre></td></tr></table></figure><blockquote><p>不断递归检查树枝是否为叶子，一旦是，便返回1并存储在数列中。最后用sum求树叶数</p></blockquote><h2 id="leaves"><a href="#leaves" class="headerlink" title="leaves"></a>leaves</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leaves</span>(<span class="params">tree</span>):</span><br><span class="line"><span class="keyword">if</span> is_leaf(tree):</span><br><span class="line"><span class="keyword">return</span> [label(tree)]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sum</span>([leaves(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(tree)],[])</span><br></pre></td></tr></table></figure><blockquote><p>分离树叶，不断递归检查树枝是否为树叶，若是，以数列形式存储在[ ]中，最后用sum消去一层[ ]<br>#为什么要用sum(<list>, [])？<br>因为当该分支只存在树叶时，leavers(b) for b in branches(tree)是以数列形式出现的，而若该分支同时存在树叶和树枝时，则返回单单数字(int).</list></p></blockquote><h2 id="increment-leaf"><a href="#increment-leaf" class="headerlink" title="increment_leaf:"></a>increment_leaf:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">increment_leaf</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> tree(label(t)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[increment_leaves(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br><span class="line"><span class="comment">#OR</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">increment</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">return</span> tree(label(t)+<span class="number">1</span>,[increment(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上面的increment只增加leaf<br>下面的increment增加所有节点</p></blockquote><h2 id="print-tree"><a href="#print-tree" class="headerlink" title="print_tree"></a>print_tree</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_tree</span>(<span class="params">t,indent = <span class="number">0</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>*indent + <span class="built_in">str</span>(label(t)))</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> branches(t):</span><br><span class="line">        print_tree(b, indent+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="print-path"><a href="#print-path" class="headerlink" title="print_path"></a>print_path</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_sums</span>(<span class="params">t, so_far</span>):</span><br><span class="line">    so_far = so_far + label(t)</span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="built_in">print</span>(so_far)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> branches(t):</span><br><span class="line">            print_sums(b, so_far)</span><br></pre></td></tr></table></figure><h2 id="count-paths"><a href="#count-paths" class="headerlink" title="count_paths"></a>count_paths</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_paths</span>(<span class="params">t, total</span>):</span><br><span class="line">    <span class="keyword">if</span> label(t) == total:</span><br><span class="line">        found = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        found = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> found + <span class="built_in">sum</span>([count_paths(b,total-label(t)) <span class="keyword">for</span> b <span class="keyword">in</span> branches(t)])</span><br></pre></td></tr></table></figure><blockquote><p>重点在于返回的count_paths(b,total-label(t)中的<code>total-label(t)</code><br>在递归过程中，total-label(t)不断更新到达下一分支时，满足条件的值。</p></blockquote><p><img src="/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/cp.png" alt="输出结果"></p><p><img src="/2023/12/14/Python-tree%E9%80%92%E5%BD%92-tree%E9%80%92%E5%BD%92/count_paths.png" alt="图示"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="berry-finder"><a href="#berry-finder" class="headerlink" title="berry_finder"></a>berry_finder</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">berry_finder</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns True if t contains a node with the value &#x27;berry&#x27; and </span></span><br><span class="line"><span class="string">    False otherwise.</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = tree(1, [tree(&#x27;berry&#x27;,[tree(&#x27;not berry&#x27;)])])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; berry_finder(t)</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;*** YOUR CODE HERE ***&quot;</span></span><br><span class="line">    <span class="keyword">if</span> label(t) == <span class="string">&#x27;berry&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t):</span><br><span class="line">        <span class="keyword">if</span> berry_finder(branch):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="replace-loki-at-leaf"><a href="#replace-loki-at-leaf" class="headerlink" title="replace_loki_at_leaf"></a>replace_loki_at_leaf</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">replace_loki_at_leaf</span>(<span class="params">t, lokis_replacement</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns a new tree where every leaf value equal to &quot;loki&quot; has</span></span><br><span class="line"><span class="string">    been replaced with lokis_replacement.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> label(t) == <span class="string">&#x27;loki&#x27;</span><span class="keyword">and</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> tree(lokis_replacement, [replace_loki_at_leaf(branch,lokis_replacement) <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t)])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[replace_loki_at_leaf(branch,lokis_replacement) <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Height"><a href="#Height" class="headerlink" title="Height"></a>Height</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Q5: Height</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the height of a tree.</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = tree(3, [tree(5, [tree(1)]), tree(2)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; height(t)</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;*** YOUR CODE HERE ***&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>([height(branch) <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t)])</span><br></pre></td></tr></table></figure><h2 id="find-path"><a href="#find-path" class="headerlink" title="find_path"></a>find_path</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_path</span>(<span class="params">t, x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t = tree(2, [tree(7, [tree(3), tree(6, [tree(5), tree(11)])] ), tree(15)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; find_path(t, 5)</span></span><br><span class="line"><span class="string">    [2, 7, 6, 5]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; find_path(t, 10)  # returns None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> label(t) == x:</span><br><span class="line">        <span class="keyword">return</span> [label(t)]</span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t):</span><br><span class="line">        path = find_path(branch, x)</span><br><span class="line">        <span class="keyword">if</span> path:</span><br><span class="line">            <span class="keyword">return</span> [label(t)] + path</span><br></pre></td></tr></table></figure><h2 id="sprout-leaves"><a href="#sprout-leaves" class="headerlink" title="sprout_leaves"></a>sprout_leaves</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sprout_leaves</span>(<span class="params">t, leaves</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Sprout new leaves containing the data in leaves at each leaf in</span></span><br><span class="line"><span class="string">    the original tree t and return the resulting tree.</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; t1 = tree(1, [tree(2), tree(3)])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(t1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">      3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; new1 = sprout_leaves(t1, [4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_tree(new1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">      2</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">      3</span></span><br><span class="line"><span class="string">        4</span></span><br><span class="line"><span class="string">        5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> is_leaf(t):</span><br><span class="line">        <span class="keyword">return</span> tree(label(t),[tree(leaf) <span class="keyword">for</span> leaf <span class="keyword">in</span> leaves])</span><br><span class="line">    <span class="keyword">return</span> tree(label(t),[sprout_leaves(branch,leaves) <span class="keyword">for</span> branch <span class="keyword">in</span> branches(t)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们可以发现，完成这些例子和练习的核心思想有：</p><ol><li>重构tree，且将branches部分用递归方法不断更新为我们需要的树枝。</li><li>利用 for语句和branches选择函数对函数进行递归。</li><li>而递归的关键就在于我们对基本情况的定义和对tree ADT的理解应用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CS61A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/"/>
      <url>/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>笔记来源网课教程：<a href="https://www.bilibili.com/video/BV1oD4y1h7S3">C++教程</a><br>10月·8号发布</p><h1 id="C-是怎么工作的"><a href="#C-是怎么工作的" class="headerlink" title="C++是怎么工作的"></a>C++是怎么工作的</h1><p>项目中的源文件传输给编译器，编译器将其转化成二进制的东西，可能转化成某种库，也可能是可执行的程序<br>opp编译成obj文件，然后通过linker将obj整合起来</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>编译前处理include后面的文件，该文件通常叫做“头文件”，我们之所以要包括iostream这个头文件，是因为我们需要一个被调用的函数的声明，例如<code>std::cout</code></p><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>程序的入口，它不一定需要返回值，默认返回0</p><h2 id><a href="#" class="headerlink" title="&lt;&lt;重载语句"></a>&lt;&lt;重载语句</h2><p>相当于一个函数而已，相当于print()<br><code>std::cout &lt;&lt; &quot;Hello World&quot;&lt;&lt; std::endl;</code><br>相当于<br><code>std::cout .print( &quot;Hello World&quot;).pint(std::endl); </code></p><h2 id="链接项目中的函数代码"><a href="#链接项目中的函数代码" class="headerlink" title="链接项目中的函数代码"></a>链接项目中的函数代码</h2><p><strong>Log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; </span><br><span class="line"><span class="comment">// 声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过linker将main.cpp中声明并使用的函数链接到某个项目文件中唯一的log函数中</p></blockquote><blockquote><p>声明只包含了函数，定义包含了函数和函数体</p></blockquote><h1 id="C-编译器的工作"><a href="#C-编译器的工作" class="headerlink" title="C++编译器的工作"></a>C++编译器的工作</h1><p>首先预处理,将所有代码转化成常量数据或指令。<br>将我们项目所有的cpp生成opj文件<br>cpp叫做<strong>翻译单元</strong></p><h2 id="include工作原理"><a href="#include工作原理" class="headerlink" title="#include工作原理"></a>#include工作原理</h2><p>在编译前将指定的文件粘贴并复制到当前cpp当中</p><p><strong>EndBrace.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; </span><br><span class="line"><span class="comment">// 声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&#x27;EndBrace.h&#x27;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>编译器的工作就是，将EndBrace中的所有代码copy进去当前cpp</p></blockquote><h2 id="查看预处理器实际上生成的文件"><a href="#查看预处理器实际上生成的文件" class="headerlink" title="查看预处理器实际上生成的文件"></a>查看预处理器实际上生成的文件</h2><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E9%A2%84%E5%A4%84%E7%90%86.png" alt="预处理器文件"><br>编译后会生成一个.i文件<br>里面含有预处理后的结果</p><h2 id="查看obj文件"><a href="#查看obj文件" class="headerlink" title="查看obj文件"></a>查看obj文件</h2><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E7%A8%8B%E5%BA%8F%E9%9B%86.png" alt="程序集"></p><p>将obj中的二进制文件转化为汇编代码(ASM文件) </p><blockquote><p>若在优化将速度调最大会忽略掉一些无用的操作</p></blockquote><h1 id="C-链接"><a href="#C-链接" class="headerlink" title="C++链接"></a>C++链接</h1><p>编译后的操作，链接的焦点是找到每个符号和函数在哪里然后连接在一起。<br><strong>编译可能不需要main函数，但是链接过程一定需要main函数</strong></p><blockquote><p>编译错误 错误类型是C开头，链接错误是LIN开头</p></blockquote><blockquote><p>不能存在两个相同的函数带着相同的参数，这样链接器不知道链接哪一个，从而产生错误。</p></blockquote><h2 id="易错处"><a href="#易错处" class="headerlink" title="易错处"></a>易错处</h2><p><strong>Log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 注意log函数名字已经被修改了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; </span><br><span class="line"><span class="comment">//声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//log(&quot;multiply&quot;);</span></span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">Multiply</span>(<span class="number">5</span>, <span class="number">8</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链接没有错误</p></blockquote><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; </span><br><span class="line"><span class="comment">//声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;multiply&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; Multiply(5, 8) &lt;&lt; std::endl;</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链接错误</p></blockquote><p><strong>为什么？</strong><br>虽然在这个文件中可能用不上Multiply函数，但在其他文件可能用得上，所以链接器确实需要链接它</p><h3 id="限制链接，函数只在当前翻译单元使用的方法"><a href="#限制链接，函数只在当前翻译单元使用的方法" class="headerlink" title="限制链接，函数只在当前翻译单元使用的方法"></a>限制链接，函数只在当前翻译单元使用的方法</h3><p>用<code>static</code>加在函数前</p><h2 id="产生链接错误的例子及修正"><a href="#产生链接错误的例子及修正" class="headerlink" title="产生链接错误的例子及修正"></a>产生链接错误的例子及修正</h2><h3 id="错误例子"><a href="#错误例子" class="headerlink" title="错误例子"></a>错误例子</h3><p><strong>log.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initlog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;Initialized log&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;multiply&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; Multiply(5, 8) &lt;&lt; std::endl;</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链接失败，log重复了</p></blockquote><p><strong>原因分析：</strong><br>两个头文件同时引入了两个log函数所以产生错误.</p><h3 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h3><ol><li><strong>log.h</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将log函数修改为静态函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>log.h</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>inlind的作用是获得我们实际的函数体并将函数调用替换为函数体。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>(<span class="string">&quot;Initialized log&quot;</span>);</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Initialized log&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><ol start="3"><li>将定义移到一个翻译单元</li></ol><p><strong>log.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initlog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;Initialized log&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-变量"><a href="#C-变量" class="headerlink" title="C++变量"></a>C++变量</h1><p>变量允许我们命名存储在内存中的数据并继续使用<br>当我们创造变量时，他被存储在内存中。</p><h2 id="不同变量类型的区别是内存大小"><a href="#不同变量类型的区别是内存大小" class="headerlink" title="不同变量类型的区别是内存大小"></a>不同变量类型的区别是内存大小</h2><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul><li>char : 1 byte (经常存储字符)</li><li>short : 2 byte</li><li>int : 4 byte</li><li>long : 4 byte</li><li>long long : 8 byte</li><li>float : 4 byte</li><li>double : 8 byte</li><li>bool : 1 byte<blockquote><p>float和double的区别可以是在数字后面加f(float)<br>1 是 Ture,0 是 False.</p></blockquote></li></ul><h3 id="查看数字大小"><a href="#查看数字大小" class="headerlink" title="查看数字大小"></a>查看数字大小</h3><p>sizeof(bool)</p><h1 id="C-函数"><a href="#C-函数" class="headerlink" title="C++函数"></a>C++函数</h1><p>最主要的是提高维护效率<br>避免复制重复<br>我们通常在头文件中写声明，在翻译单元或cpp文件中编写定义，原因就是<strong>链接错误中的修改方法3</strong></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><strong>Main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io_mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">multiply</span>(a, b);</span><br><span class="line">std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">io_mul</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">io_mul</span>(<span class="number">3</span>,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">io_mul</span>(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>io_mul的作用就是避免重复</p></blockquote><h1 id="C-头文件"><a href="#C-头文件" class="headerlink" title="C++头文件"></a>C++头文件</h1><p> 当我们跨文件调用函数的时候免不了声明，如果某个函数很常用那就要一直复制粘贴，很繁琐。<br> 而头文件就是塞入一堆声明，然后在其他cpp中include后，让预处理器帮忙复制粘贴。</p><h2 id="pragma-once"><a href="#pragma-once" class="headerlink" title="pragma once"></a>pragma once</h2><p>当我们创建了一个头文件，vs会自动帮我们填写<code>#pragma once</code><br>这个的作用是防止include多个头文件时，里面有重复的声明，导致编译失败。他只会复制一次声明</p><h2 id="ifndef"><a href="#ifndef" class="headerlink" title="ifndef"></a>ifndef</h2><p><strong>log.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nitLog</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>检查是否有个_LOG_H被定义了，如果没有就编译中包括以下代码,如果被定义了，那么这些都不会被包括进来 </p></blockquote><blockquote><p>如果通过了这初次检查，我们定义_LOG_H,如果下次用到的时候，就不会重复声明了</p></blockquote><h2 id="include两个不同形式"><a href="#include两个不同形式" class="headerlink" title="include两个不同形式"></a>include两个不同形式</h2><h3 id="形式"><a href="#形式" class="headerlink" title="&lt; &gt;形式"></a>&lt; &gt;形式</h3><p>告诉编译器去搜索包含路径的文件夹 </p><h3 id="“-“形式"><a href="#“-“形式" class="headerlink" title="“ “形式"></a>“ “形式</h3><p>告诉编译器就在当前文件夹，我们也可以用”..&#x2F;log.h”去返回到当前文件的上级目录</p><h2 id="区别c-标准库和c标准库"><a href="#区别c-标准库和c标准库" class="headerlink" title="区别c++标准库和c标准库"></a>区别c++标准库和c标准库</h2><p>关键在于有无.h扩展，c++文件通常没有。</p><h1 id="如何在vs中调试代码"><a href="#如何在vs中调试代码" class="headerlink" title="如何在vs中调试代码"></a>如何在vs中调试代码</h1><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>在断点处暂停程序</p><h3 id="读取内存"><a href="#读取内存" class="headerlink" title="读取内存"></a>读取内存</h3><p>程序中断后,内存数据实际上还在,查看内存对诊断问题.</p><h2 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h2><ol start="0"><li>确保模式是<strong>debug模式</strong></li><li><strong>设置断点</strong></li><li><strong>读内存</strong></li></ol><h3 id="按键介绍"><a href="#按键介绍" class="headerlink" title="按键介绍"></a>按键介绍</h3><ul><li>逐语句(F11)(step into):进入到当前这行代码上的函数里面</li><li>逐过程(F10)(step over):从当前函数跳到下一行代码</li><li>跳出(shift+F11)(step out):跳出当前函数，回到调用这个函数的位置</li></ul><h3 id="窗口介绍"><a href="#窗口介绍" class="headerlink" title="窗口介绍"></a>窗口介绍</h3><ul><li>自动、局部窗口 : 向你展示可能重要的全局或局部</li><li>监视1：观察变量(输入要观察的变量然后回车)</li></ul><blockquote><p>右键可以修改成查看16进制</p></blockquote><h3 id="内存视图"><a href="#内存视图" class="headerlink" title="内存视图"></a>内存视图</h3><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE.png" alt="内存视图"><br><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE_1.png" alt="内存视图浏览"></p><ul><li>最左侧为内存地址</li><li>中间是以16进制存储的实际值</li><li>最右边是以ACCII对值的解释</li></ul><h4 id="内存视图的使用"><a href="#内存视图的使用" class="headerlink" title="内存视图的使用"></a>内存视图的使用</h4><p>在地址一栏输入&amp;＋变量名即可</p><h1 id="VS的最佳设置"><a href="#VS的最佳设置" class="headerlink" title="VS的最佳设置"></a>VS的最佳设置</h1><h2 id="项目的设置"><a href="#项目的设置" class="headerlink" title="项目的设置"></a>项目的设置</h2><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E8%99%9A%E6%8B%9F%E7%BB%84%E7%BB%87.ong" alt="虚拟组织"></p><blockquote><p>这只是虚拟组织的文件夹，在文件资源管理器中并不存在。</p></blockquote><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E6%98%BE%E7%A4%BA%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt="显示所有文件"><br>我们可以点击<strong>显示所有文件</strong>这个按钮，这样子新添加文件夹的时候就实际的添加了文件夹，而非虚拟文件夹。</p><h2 id="文件夹的设置"><a href="#文件夹的设置" class="headerlink" title="文件夹的设置"></a>文件夹的设置</h2><p><img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E8%AE%BE%E7%BD%AE.png" alt="设置"><br><code>$(SolutionDir)bin\$(Platform)\$(Configuration)\</code></p><h1 id="C-条件与分值-if语句"><a href="#C-条件与分值-if语句" class="headerlink" title="C++条件与分值(if语句)"></a>C++条件与分值(if语句)</h1><p> 检查条件，然后跳转到内存的不同的地方,并从这里开始执行指令。</p><h2 id="内在指令"><a href="#内在指令" class="headerlink" title="内在指令"></a>内在指令</h2><p> <img src="/2023/12/14/CPP-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4-C-%E5%AD%A6%E4%B9%A0-%E5%9B%BD%E5%BA%86%E6%9C%9F%E9%97%B4/%E5%8F%8D%E6%B1%87%E7%BC%96.png" alt="反汇编"></p><blockquote><p>设置断点调试时，右键进入反汇编模式</p></blockquote><ul><li>mov : move</li><li>jne ：jump not equal</li><li>je ：jump equel</li></ul><blockquote><ol><li><p><code>mov dword ptr [a], 5</code>：这条指令将立即数5移动到名为<code>a</code>的整数变量。它将5存储到<code>a</code>的内存位置。</p></li><li><p><code>cmp dword ptr [a], 5</code>：这是一个比较指令，用于比较<code>a</code>的值与5的值。它将<code>a</code>的值与5进行比较，但不会更改任何寄存器的值。</p></li><li><p><code>jne main+34h (07FF6F0B823B4h)</code>：这是一个条件跳转指令。它检查前面的比较结果是否不等于（jne表示”jump if not<br>equal”）零，如果不等于零，则跳转到指定的地址，这里是<code>main+34h</code>。</p></li><li><p><code>mov dword ptr [rbp+0F4h], 1</code>：如果比较结果是相等的（即<code>a</code>等于5），则将立即数1移动到内存中的某个位置，该位置可能是一个标志变量，用于表示条件满足。</p></li><li><p><code>jmp main+3Eh (07FF6F0B823BEh)</code>：这是一个无条件跳转指令，它将程序跳转到指定的地址，这里是<code>main+3Eh</code>。</p></li><li><p><code>mov dword ptr [rbp+0F4h], 0</code>：这个指令是前面条件跳转的目标（如果比较结果不等于零），它将立即数0移动到内存中的某个位置，表示条件不满足。</p></li><li><p><code>movzx eax, byte ptr [rbp+0F4h]</code>：这条指令将内存中的一个字节（8位）加载到32位寄存器<code>eax</code>中，并将其零扩展（即高位填充0）。这可能是为了将条件满足与否的标志位加载到寄存器中。</p></li><li><p><code>mov byte ptr [comparisonResult], al</code>：这个指令将寄存器<code>al</code>中的字节值写入名为<code>comparisonResult</code>的布尔变量。这是将条件判断的结果保存到布尔变量中的操作。</p></li><li><p><code>movzx eax, byte ptr [comparisonResult]</code>：这是将布尔变量<code>comparisonResult</code>的值加载到寄存器<code>eax</code>中，以便进行进一步的条件判断。</p></li><li><p><code>test eax, eax</code>：这个指令将寄存器<code>eax</code>与自身进行按位与操作。它的目的是检查<code>eax</code>中的值是否为零。</p></li><li><p><code>je main+5Ch (07FF6F0B823DCh)</code>：这是一个条件跳转指令，如果前面的按位与操作结果等于零（即<code>eax</code>中的值为零），则跳转到指定的地址，这里是<code>main+5Ch</code>。</p></li><li><p><code>lea rcx, [string &quot;hello&quot; (07FF6F0B8BCA4h)]</code>：这个指令将字符串”hello”的地址加载到寄存器<code>rcx</code>中，准备调用一个名为<code>Log</code>的函数。</p></li><li><p><code>call Log (07FF6F0B8135Ch)</code>：这是一个函数调用指令，它调用名为<code>Log</code>的函数，并将<code>rcx</code>中的地址作为参数传递给该函数，用于记录”hello”。</p></li></ol></blockquote><h1 id="C-循环"><a href="#C-循环" class="headerlink" title="C++循环"></a>C++循环</h1><p>for and while 循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; a &lt; <span class="number">5</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line">pass</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>变量的声明,循环的条件(评估后的bool值),一次循环后的操作</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">.....</span><br><span class="line">i ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h1 id="C-控制流语句"><a href="#C-控制流语句" class="headerlink" title="C++控制流语句"></a>C++控制流语句</h1><p>控制流一般和循环一起使用</p><ul><li>continue :只能在循环使用</li><li>break : 能在循环和switch语句使用</li><li>return</li></ul><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>跳到循环的下一个迭代</p><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>跳出循环</p><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>返回值，终止语句</p><h1 id="C-指针"><a href="#C-指针" class="headerlink" title="C++指针"></a>C++指针</h1><p>指针是整数，一种存储内存地址的数字。对管理和操纵内存有很大用处.</p><h2 id="指针的引用和逆引用"><a href="#指针的引用和逆引用" class="headerlink" title="指针的引用和逆引用"></a>指针的引用和逆引用</h2><p>类型的意义在于逆引用指针时可以访问和修改变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;var;</span><br><span class="line">*ptr = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="申请内存和二次指针"><a href="#申请内存和二次指针" class="headerlink" title="申请内存和二次指针"></a>申请内存和二次指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>** ptr = &amp;buffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>pte地址的内存实际上是buffer的内存地址，只不过反了过来<br>比如如果pte的内存是b8 f1 02 00<br>那么buffer的内存地址就是00 02 f1 b8</p></blockquote><h1 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h1><p>(指针的扩展)<br>引用不用占用内存，但是指针是变量，会占用内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;</span><br><span class="line"><span class="comment">//ref 实际上不存在，编译后只会有变量a</span></span><br><span class="line"><span class="comment">//相当于a的别名</span></span><br><span class="line"> </span><br><span class="line"> std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用的作用"><a href="#引用的作用" class="headerlink" title="引用的作用"></a>引用的作用</h2><blockquote><p>运用指针的例子</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increment</span><span class="params">(<span class="type">int</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">(*value)++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">Increment</span>(&amp;a)；</span><br><span class="line"><span class="built_in">Log</span>(a);</span><br><span class="line"><span class="comment">//结果为 : 6</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运用引用的例子</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increment</span><span class="params">(<span class="type">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">Increment</span>(a);</span><br><span class="line"><span class="built_in">Log</span>(a);</span><br><span class="line"><span class="comment">//结果为 : 6</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在C++中，函数参数的默认传递方式是按值传递(pass by value)。这意味着当你调用一个函数时，传递给函数的是原始数据的副本，而不是原始数据本身。这是因为按值传递会创建原始数据的副本，以便函数可以在副本上执行操作，而不会影响原始数据。<br> 当你调用Increment(a)时，a的值被复制到Increment函数的局部变量value中，然后在函数内部对value进行递增操作。这个递增操作只会影响value的副本，而不会影响a的原始值。这就是为什么在main函数中a 的值仍然是5。</p></blockquote><p>那如果我用return a呢？</p><blockquote><p>如果你在 Increment 函数中返回 value，那么你需要在 main 函数中捕获这个返回值并将其分配给 a，才能使 a 的值增加。这是因为在 C++ 中，函数的返回值不会自动修改传递给它的参数。<br>a &#x3D; increment(a)</p></blockquote><p>简而言之，引用可以节约内存开销,避免重复复制。</p><h2 id="引用的注意"><a href="#引用的注意" class="headerlink" title="引用的注意"></a>引用的注意</h2><p>你不能改变它引用的东西<br>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;</span><br><span class="line">ref = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>* ref = &amp;a;</span><br><span class="line">*ref = <span class="number">2</span>;</span><br><span class="line">ref = &amp;b;</span><br><span class="line">*ref = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Log</span>(a);</span><br><span class="line"><span class="built_in">Log</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，错误例子中会运行成功，但是他并不是更改引用,ref这个引用还是引用的a</p></blockquote><h1 id="C-类"><a href="#C-类" class="headerlink" title="C++类"></a>C++类</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> xa, <span class="type">int</span> ya)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x += xa * speed;</span><br><span class="line">y += ya * speed;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void Move(Player&amp; player, int xa, int ya)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//player.x += xa * player.speed;</span></span><br><span class="line"><span class="comment">//player.y += xa * player.speed;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Player player;</span><br><span class="line">player.x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>花括号后面需要有分号<br>由类类型构成的变量称为<strong>对象</strong><br>新的对象变量称为<strong>实例</strong><br>类中的函数称为<strong>方法</strong></p></blockquote><blockquote><p>类中的属性是私有的，如果需要访问修改需要public类中的属性。</p></blockquote><h1 id="C-类与结构体对比"><a href="#C-类与结构体对比" class="headerlink" title="C++类与结构体对比"></a>C++类与结构体对比</h1><p>类默认是私有的，类外部调用时无法调用。<br>技术上说，没什么区别，但是使用情境不同。<br>struct and class</p><blockquote><p>弹幕：用结构体当数据容器，用类来写具备逻辑的功能对象.</p></blockquote><h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2><ol><li>默认的继承访问权 : class默认的是private,strcut默认的是public。</li><li>默认访问权限 : struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。</li><li>“class”这个关键字还用于定义模板参数，就像“typename”。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python—字符串,多态函数（接口），特殊方法名称[61A Fall 2023 Lecture 20——Inheritance]</title>
      <link href="/2023/12/14/Python-Python%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0-61A-Fall-2023-Lecture-20%E2%80%94%E2%80%94Inheritance-Python%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0-61A-Fall-2023-Lecture-20%E2%80%94%E2%80%94Inheritance/"/>
      <url>/2023/12/14/Python-Python%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0-61A-Fall-2023-Lecture-20%E2%80%94%E2%80%94Inheritance-Python%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0-61A-Fall-2023-Lecture-20%E2%80%94%E2%80%94Inheritance/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h1 id="字符串表示形式"><a href="#字符串表示形式" class="headerlink" title="字符串表示形式"></a>字符串表示形式</h1><h2 id="str"><a href="#str" class="headerlink" title="str()"></a>str()</h2><p>方便阅读</p><h2 id="repr"><a href="#repr" class="headerlink" title="repr()"></a>repr()</h2><p>方便调试</p><ul><li>repr 返回对象的官方表示形式</li><li>print 用于打印可读性好的字符串</li><li>str 返回对象的非正式表示</li><li>eval 用于执行字符串表示的代码。</li><li>在字符串示例中，由于字符串中包含引号和全角逗号，因此在 repr 和 str 的输出中会反映这些差异，但 eval 用于执行这些字符串时，它们被正确处理。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half= Fraction(<span class="number">1</span>，<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>halfFraction(<span class="number">1</span>，<span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt;&gt; <span class="built_in">repr</span>(half)</span><br><span class="line"><span class="string">&#x27;Fraction(1，2)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(half)</span><br><span class="line"><span class="number">1</span>/<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(half)</span><br><span class="line"><span class="string">&#x27;1/2&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">repr</span>(half))</span><br><span class="line">Fraction(<span class="number">1</span>，<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">str</span>(half))</span><br><span class="line">05</span><br></pre></td></tr></table></figure><blockquote><p>repr(half) 返回对象的”official”字符串表示形式，它是 Fraction(1，2)，它是有效的Python表达式，可以用于重建相同的对象。<br>print(half) 打印对象时，print 使用对象的 str 方法，所以它输出 ‘1&#x2F;2’，这是用户友好的字符串表示。<br>str(half) 返回对象的”informal”字符串表示形式，这里返回 ‘1&#x2F;2’。<br>eval(repr(half)) 使用 eval 函数来执行 repr(half) 返回的字符串，这将返回一个新的 Fraction 对象，即 Fraction(1，2)。<br>eval(str(half)) 使用 eval 函数来执行 str(half) 返回的字符串，这将返回浮点数 0.5，因为 eval 解释它为数学表达式。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&quot;Hello, World&quot;</span></span><br><span class="line">&gt;&gt;&gt;s</span><br><span class="line"><span class="string">&#x27;Hello，World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">repr</span>(s))</span><br><span class="line"><span class="string">&#x27;Hello，World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s)</span><br><span class="line">Hello，World</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">str</span>(s))</span><br><span class="line">Hello，World</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(s)</span><br><span class="line"><span class="string">&#x27;Hello，World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(s)</span><br><span class="line"><span class="string">&quot;&#x27;Hello,World&#x27;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">repr</span>(s))</span><br><span class="line"><span class="string">&#x27;Hello，World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(<span class="built_in">repr</span>(<span class="built_in">repr</span>(s)))</span><br><span class="line"><span class="string">&#x27;\&#x27;&quot;\\\&#x27;Hello,world\\\&#x27;&quot;\&#x27;&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">eval</span>(<span class="built_in">eval</span>(<span class="built_in">repr</span>(<span class="built_in">repr</span>(<span class="built_in">repr</span>(s)))))))</span><br><span class="line"><span class="string">&#x27;Hello, World&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h1><h2 id="f’-’"><a href="#f’-’" class="headerlink" title="f’{}’"></a>f’{}’</h2><p>花括号里的为Python表达式 会自动计算<br>你也可以用str()或repr()</p><h1 id="多态函数"><a href="#多态函数" class="headerlink" title="多态函数"></a>多态函数</h1><p>使用于许多不同类型数据的函数<br>str和repr函数就是例子</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="repr-1"><a href="#repr-1" class="headerlink" title="repr"></a>repr</h3><p>调用一个零参数方法，相应地称为__repr__</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>half.__repr__()</span><br><span class="line"><span class="string">&#x27;Fraction(1, 2)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="str-1"><a href="#str-1" class="headerlink" title="str"></a>str</h3><p>调用一个零参数方法，相应地称为_str_</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half.__str__()</span><br><span class="line"><span class="string">&#x27;1/2&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用print()时实际上就是调用了__str__()</p></blockquote><h2 id="repr和str的实现"><a href="#repr和str的实现" class="headerlink" title="repr和str的实现"></a>repr和str的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repr</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">type</span>(x).__repr__(x)</span><br></pre></td></tr></table></figure><p>通过查找为你提供的参数类型来设法跳过实例属性或忽略他们</p><blockquote><p>是一个类属性，也是一个函数，但是这个函数不是绑定方法，因为它是在type类中查找的</p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>对象属性是消息传递的一种形式，它允许不同的数据类型以不同的方式响应同一消息。</li></ul><blockquote><p>对象通过发送消息(通常是方法调用)来与其他对象进行交互。对象的属性可以是对象的状态或数据。</p></blockquote><ul><li>从不同类引出类似行为的一组共享消息是一种强大的抽象方法。</li></ul><blockquote><p>不同的类可以实现相同的接口或共享相同的消息。</p></blockquote><ul><li>接口是一组共享属性名称，以及它们的行为规范。在复数的情况下，实现算术所需的接口由四个属性组成： real 、 imag 、 magnitude 和 angle 。<blockquote><p>这是一个具体的示例，说明了接口的用途。如果多个类需要实现某种算术操作（例如复数的加法或乘法），可以定义一个接口，其中包含所需的属性名称和方法，以确保这些类都具有相同的接口，从而可以执行相似的操作。</p></blockquote></li></ul><p>消息传递：对象通过查找彼此的属性（传递消息）进行交互<br>属性查找规则允许不同的数据类型响应相同的消息<br>从不同对象类中引出类似行为的共享消息（属性名）是一种强大的<strong>抽象方法</strong></p><p><strong>实现返回python可解释和人类可读字符串的方法</strong>的<strong>类</strong>实现了用于<strong>生成字符串表示的接口</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ratio</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n , d</span>):</span><br><span class="line">        self.numer = n</span><br><span class="line">        self.denom = d</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Ratio(&#123;0&#125;, &#123;1&#125;)&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;0&#125;/&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half = Ratio(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(half)</span><br><span class="line"><span class="number">1</span>/<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>half</span><br><span class="line">Ratio(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p>个人对接口的理解：有一些具有相同行为的类，我们定义了一个接口，使得我们不需要知道传入这些类中的数据类型便知道这些类都有一种可以计算某个结果的方法。这样子不管什么数据类型都可以计算出我们需要的预期结果。[这是抽象接口]</p></blockquote><blockquote><p>Python存在两种接口 一个是面对对象用于继承的抽象接口，一个是用于封装类显露出来的动态接口[下面Ratio类的add方法是一种接口，是动态接口]</p></blockquote><h1 id="特殊方法名称"><a href="#特殊方法名称" class="headerlink" title="特殊方法名称"></a>特殊方法名称</h1><p>总是有__在前面和后面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;zero, one, two = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one + two</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(zero), <span class="built_in">bool</span>(one)</span><br><span class="line">(<span class="literal">False</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt;zero, one, two = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one.__add__(two)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zero.__bool__(), one.__bool__()</span><br><span class="line">(<span class="literal">False</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><blockquote><p>内置语法和内置函数 与 实际执行工作的特殊方法名称中间存在对应关系</p></blockquote><p>这是使用接口来允许用户定义的对象与Python中内置系统进行交互的另一个示例。<br>我们举例类的时候可以覆盖特殊方法来建立我们想要的互动结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ratio</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n , d</span>):</span><br><span class="line">        self.numer = n</span><br><span class="line">        self.denom = d</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Ratio(&#123;0&#125;, &#123;1&#125;)&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;0&#125;/&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, <span class="built_in">int</span>):</span><br><span class="line">            n = self.numer + self.denom * other</span><br><span class="line">            d = self.denom</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(other, Ratio):</span><br><span class="line">            n = self.numer * other.denom + self.denom * other.numer</span><br><span class="line">            d = self.denom * other.denom</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(other, <span class="built_in">float</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">float</span>(self) + other</span><br><span class="line">        g = gcd(n, d)</span><br><span class="line">        <span class="keyword">return</span> Ratio(n//g, d//g)</span><br><span class="line">    __radd__ = __add__</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__float__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.numer/self.denom</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">n, d</span>):</span><br><span class="line">    <span class="keyword">while</span> n != d:</span><br><span class="line">        n, d = <span class="built_in">min</span>(n, d), <span class="built_in">abs</span>(n - d)</span><br><span class="line">    <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure><ul><li>类型分类：用了条件语句对传入的other数据类型进行判断从而提供不同的执行方法</li><li>类型强制：将一种类型的对象转换为另一种类型，以便能够将其与其他值组合。</li></ul><blockquote><p>这是让两个类进行交互时而使用的两种策略</p></blockquote><blockquote><p>__add__函数相当于是一个隐形接口，我们不需要知道传入的数据是不是浮点数、整数还是什么，都可以将他们加起来 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> CS自学笔记 </category>
          
          <category> CS61A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CS61A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是我的第一篇文章</title>
      <link href="/2023/12/14/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F/"/>
      <url>/2023/12/14/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2><p><a href="https://www.bilibili.com/video/BV1G84y1B7NH/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&vd_source=700c4afe7cf00e2775dbed3e27760082">(博客教程视频)</a></p><p><a href="https://www.fomal.cc/posts/e593433d.html">(博客教程网站)</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1G84y1B7NH/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&vd_source=700c4afe7cf00e2775dbed3e27760082">(博客教程视频)</a></p><p><a href="https://www.fomal.cc/posts/e593433d.html">(博客教程网站)</a></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }  /* 小冰分类分类磁铁黑夜模式适配 *//* 一般状态 */[data-theme="dark"] .magnet_link_context {  background: #1e1e1e;  color: antiquewhite;}/* 鼠标悬浮状态 */[data-theme="dark"] .magnet_link_context:hover {  background: #3ecdf1;  color: #f2f2f2;}/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
